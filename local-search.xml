<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TypeScript泛型详解</title>
    <link href="/posts/56997/"/>
    <url>/posts/56997/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript泛型详解"><a href="#TypeScript泛型详解" class="headerlink" title="TypeScript泛型详解"></a>TypeScript泛型详解</h1><p>TypeScript 的泛型功能是其最强大的特性之一，能够让你编写既灵活又安全的代码。泛型允许你在定义函数、类、接口等时使用占位符来表示类型，从而在实际使用时指定具体类型，使得类型检查更为严格，同时避免了重复代码的编写。</p><p>本文将结合 TypeScript 官方文档，详细解析泛型的概念、用法以及常见应用场景，并举例说明如何正确书写和调用泛型。</p><hr><h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h2><p>泛型可以理解为一个占位符，它允许你在定义函数或类时<strong>不指定类型</strong>，而在使用时指定类型，达到类型复用的目的。这样，我们可以为同一函数或类提供多种不同类型，而不需要为每种类型分别编写不同的实现。</p><h2 id="2-泛型的基本语法"><a href="#2-泛型的基本语法" class="headerlink" title="2. 泛型的基本语法"></a>2. 泛型的基本语法</h2><p>泛型的语法很简单，通常使用尖括号（<code>&lt; &gt;</code>）来表示类型参数。类型参数一般使用大写字母来表示，如 <code>T</code>、<code>K</code>、<code>V</code> 等。你可以将类型参数放在函数、类或接口的名称后面。</p><h3 id="2-1-泛型函数"><a href="#2-1-泛型函数" class="headerlink" title="2.1 泛型函数"></a>2.1 泛型函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code> 是泛型类型参数，可以代表任何类型。</li><li><code>arg: T</code> 表示函数参数 <code>arg</code> 的类型是 <code>T</code>。</li><li><code>: T</code> 表示函数的返回值类型也是 <code>T</code>，这使得输入与输出类型一致。</li></ul><p><strong>调用泛型函数</strong></p><p>调用时，你可以通过显式指定类型来替代泛型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> result1 = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello, TypeScript&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);  <span class="hljs-comment">// 输出: Hello, TypeScript</span><br><br><span class="hljs-keyword">let</span> result2 = identity&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);  <span class="hljs-comment">// 输出: 100</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>identity&lt;string&gt;(&quot;Hello, TypeScript&quot;)</code> 表示将泛型 <code>T</code> 替换为 <code>string</code>，而 <code>identity&lt;number&gt;(100)</code> 则将 <code>T</code> 替换为 <code>number</code>。</p><h3 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h3><p>你也可以为接口定义泛型，泛型接口常用于处理集合、容器等类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">value</span>: T;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">box1</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; = &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">box2</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; = &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> &#125;;<br></code></pre></td></tr></table></figure><p>在这里，<code>Box&lt;T&gt;</code> 接口定义了一个泛型接口，<code>value</code> 的类型是 <code>T</code>，你可以在实例化接口时指定 <code>T</code> 为具体类型。</p><h3 id="2-3-泛型类"><a href="#2-3-泛型类" class="headerlink" title="2.3 泛型类"></a>2.3 泛型类</h3><p>泛型类类似于泛型接口，允许类在实例化时使用不同的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">value</span>: T;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: T</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br><br>  <span class="hljs-title function_">getValue</span>(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> stringContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringContainer.<span class="hljs-title function_">getValue</span>());  <span class="hljs-comment">// 输出: Hello</span><br><br><span class="hljs-keyword">let</span> numberContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberContainer.<span class="hljs-title function_">getValue</span>());  <span class="hljs-comment">// 输出: 123</span><br></code></pre></td></tr></table></figure><p>在此例中，<code>Container&lt;T&gt;</code> 是一个泛型类，它的构造函数和方法都依赖于类型参数 <code>T</code>。</p><hr><h2 id="3-泛型的优势"><a href="#3-泛型的优势" class="headerlink" title="3. 泛型的优势"></a>3. 泛型的优势</h2><ol><li><strong>类型安全：</strong> 泛型提供了更精确的类型检查，使得在编译阶段就能发现潜在的类型错误。</li><li><strong>代码复用：</strong> 泛型使得相同的代码能够处理多种不同类型，而不需要重复编写不同的函数或类。</li><li><strong>灵活性：</strong> 泛型类型可以在函数或类使用时动态指定，灵活应对不同的业务需求。</li></ol><hr><h2 id="4-约束泛型类型"><a href="#4-约束泛型类型" class="headerlink" title="4. 约束泛型类型"></a>4. 约束泛型类型</h2><p>泛型的类型参数是可以约束的，即你可以要求泛型类型满足某些条件或具有某些特性。为此，TypeScript 提供了 <code>extends</code> 关键字来约束泛型类型。</p><h3 id="4-1-约束泛型类型的语法"><a href="#4-1-约束泛型类型的语法" class="headerlink" title="4.1 约束泛型类型的语法"></a>4.1 约束泛型类型的语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> logLength&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> &#125;&gt;(<span class="hljs-attr">arg</span>: T): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>T extends &#123; length: number &#125;</code> 表示泛型 <code>T</code> 必须具有 <code>length</code> 属性（即，<code>T</code> 必须是一个具有 <code>length</code> 属性的类型）。这样可以确保 <code>logLength</code> 函数只接受有 <code>length</code> 属性的类型。</p><h5 id="调用时"><a href="#调用时" class="headerlink" title="调用时"></a><strong>调用时</strong></h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">logLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>));  <span class="hljs-comment">// 输出: 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">logLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><p>这个函数可以接受任何具有 <code>length</code> 属性的类型，例如字符串和数组。</p><hr><h2 id="5-泛型的默认类型"><a href="#5-泛型的默认类型" class="headerlink" title="5. 泛型的默认类型"></a>5. 泛型的默认类型</h2><p>在 TypeScript 中，泛型类型参数可以有默认类型。如果没有传入具体类型，则使用默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> createPair&lt;T = <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">value</span>: T): [T, T] &#123;<br>  <span class="hljs-keyword">return</span> [value, value];<br>&#125;<br><br><span class="hljs-keyword">let</span> pair1 = <span class="hljs-title function_">createPair</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair1);  <span class="hljs-comment">// 输出: [&quot;Hello&quot;, &quot;Hello&quot;]</span><br><br><span class="hljs-keyword">let</span> pair2 = <span class="hljs-title function_">createPair</span>(<span class="hljs-number">42</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair2);  <span class="hljs-comment">// 输出: [42, 42]</span><br></code></pre></td></tr></table></figure><p>在此例中，<code>T = string</code> 表示如果调用时没有指定类型，<code>T</code> 默认为 <code>string</code>。因此，<code>createPair</code> 函数可以接受任何类型，但默认使用 <code>string</code> 类型。</p><hr><h2 id="6-泛型与联合类型"><a href="#6-泛型与联合类型" class="headerlink" title="6. 泛型与联合类型"></a>6. 泛型与联合类型</h2><p>泛型和联合类型可以结合使用，这样可以让一个函数同时支持多种类型的参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> wrap&lt;T&gt;(<span class="hljs-attr">value</span>: T | <span class="hljs-built_in">string</span>): T &#123;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">let</span> wrappedString = <span class="hljs-title function_">wrap</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> wrappedNumber = <span class="hljs-title function_">wrap</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>在这里，<code>value</code> 参数可以是 <code>T</code> 类型或者 <code>string</code> 类型。调用时传入的参数可以是 <code>string</code> 或者任何类型。</p><hr><h2 id="7-泛型与类型推断"><a href="#7-泛型与类型推断" class="headerlink" title="7. 泛型与类型推断"></a>7. 泛型与类型推断</h2><p>TypeScript 会根据传入的参数类型来自动推断泛型类型。在很多情况下，我们不需要显式指定泛型类型，TypeScript 会根据传入的值自动推断出类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 自动推断 T 为 string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: Hello</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们没有显式指定 <code>T</code> 类型，TypeScript 自动推断 <code>T</code> 为 <code>string</code>，并保证类型安全。</p><hr><h2 id="8-高级泛型应用"><a href="#8-高级泛型应用" class="headerlink" title="8. 高级泛型应用"></a>8. 高级泛型应用</h2><h3 id="8-1-泛型与条件类型"><a href="#8-1-泛型与条件类型" class="headerlink" title="8.1 泛型与条件类型"></a>8.1 泛型与条件类型</h3><p>TypeScript 也支持泛型与条件类型结合使用，从而在类型层面做出更复杂的判断和转换。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">MyType</span>&lt;<span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// a 的类型是 number</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">MyType</span>&lt;<span class="hljs-built_in">number</span>&gt;;  <span class="hljs-comment">// b 的类型是 boolean</span><br></code></pre></td></tr></table></figure><h3 id="8-2-泛型与映射类型"><a href="#8-2-泛型与映射类型" class="headerlink" title="8.2 泛型与映射类型"></a>8.2 泛型与映射类型</h3><p>映射类型允许你基于现有类型构造新的类型。与泛型结合使用，可以帮助你更灵活地定义对象的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionsFlags</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;<br>  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]: <span class="hljs-built_in">boolean</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FeatureFlags</span> = &#123;<br>  <span class="hljs-attr">darkMode</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">newUserProfile</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FeatureOptions</span> = <span class="hljs-title class_">OptionsFlags</span>&lt;<span class="hljs-title class_">FeatureFlags</span>&gt;;<br><span class="hljs-comment">// 结果：&#123; darkMode: boolean; newUserProfile: boolean; &#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>泛型使得 TypeScript 在保持类型安全的同时，增强了代码的灵活性和可复用性。它通过占位符 <code>T</code> 等形式，允许你在函数、类或接口的定义中不指定具体类型，最终在使用时动态地指定类型。</p><p>本文详细介绍了泛型的基本语法、常见应用场景、约束和高级用法。理解泛型的工作原理，并熟练掌握它的使用，将使你能编写出更加健壮和可维护的代码。</p><p>如果你还没有深入理解泛型，请尝试在你的项目中使用它们，逐步积累经验，你将发现泛型能够显著提高你的代码质量和开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探秘JavaScript内部机制:从this到事件循环</title>
    <link href="/posts/56251/"/>
    <url>/posts/56251/</url>
    
    <content type="html"><![CDATA[<h1 id="探秘JavaScript内部机制-从this到事件循环"><a href="#探秘JavaScript内部机制-从this到事件循环" class="headerlink" title="探秘JavaScript内部机制:从this到事件循环"></a>探秘JavaScript内部机制:从this到事件循环</h1><p>JavaScript 是一种高级编程语言，拥有灵活的语法和丰富的特性。虽然我们在日常开发中大多集中在语言的高级语法和 API 上，但要深入理解 JavaScript 的行为，必须掌握它的底层机制。本文将详细介绍 JavaScript 中的一些关键底层机制，包括 <code>this</code>、<code>arguments</code>、<code>prototype</code>、<code>new</code>、闭包、事件循环等，并且探讨更多的内部实现细节。</p><h2 id="1-this：函数上下文中的指针"><a href="#1-this：函数上下文中的指针" class="headerlink" title="1. this：函数上下文中的指针"></a>1. <strong><code>this</code>：函数上下文中的指针</strong></h2><p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，用于指向当前执行上下文中的对象。它的值在函数调用时是动态确定的，取决于函数的调用方式。</p><h3 id="1-1-this-的基本规则"><a href="#1-1-this-的基本规则" class="headerlink" title="1.1 this 的基本规则"></a>1.1 <code>this</code> 的基本规则</h3><ul><li><p><strong>普通函数调用</strong>：<code>this</code> 指向全局对象，在浏览器中是 <code>window</code>，在 Node.js 中是 <code>global</code>。严格模式下 <code>this</code> 为 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 在浏览器中是 window 或 undefined（严格模式）</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>方法调用</strong>：当函数作为对象的方法被调用时，<code>this</code> 指向该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 &quot;Alice&quot;</span><br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// this 指向 obj</span><br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数调用</strong>：当函数作为构造函数被调用时，<code>this</code> 指向新创建的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 &quot;Bob&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>**箭头函数中的 <code>this</code>**：箭头函数不会有自己的 <code>this</code>，它会从外部函数的上下文中继承 <code>this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 undefined，因为箭头函数继承了外部 `this`</span><br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出 undefined</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-this-的动态绑定"><a href="#1-2-this-的动态绑定" class="headerlink" title="1.2 this 的动态绑定"></a>1.2 <code>this</code> 的动态绑定</h3><p><code>this</code> 是动态绑定的，可以通过 <code>call</code>、<code>apply</code> 和 <code>bind</code> 改变它的指向。</p><p>在 JavaScript 中，<code>call</code>、<code>apply</code> 和 <code>bind</code> 是三个常用于控制函数上下文（即改变 <code>this</code> 的指向）的方法。这三个方法都与函数的调用方式和上下文绑定密切相关。掌握这三个方法对于处理 <code>this</code> 的指向问题至关重要。</p><h4 id="1-2-1-call-方法"><a href="#1-2-1-call-方法" class="headerlink" title="1.2.1. call 方法"></a>1.2.1. <strong><code>call</code> 方法</strong></h4><p><code>call</code> 方法可以显式地改变函数中 <code>this</code> 的指向。它接受一个参数，作为函数执行时的 <code>this</code> 指向。除此之外，<code>call</code> 方法还可以传入一系列参数，这些参数会作为普通参数传递给目标函数。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：在函数执行时，<code>this</code> 指向的对象。可以是任何类型的值，包括 <code>null</code> 和 <code>undefined</code>。</li><li><code>arg1, arg2, ...</code>：要传递给函数的参数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);  <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 30 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>greet.call(person, &#39;Alice&#39;, 30)</code> 显式地将 <code>this</code> 绑定到了 <code>person</code> 对象上。</p><p><strong>特点：</strong></p><ul><li><code>call</code> 立即调用函数，并且可以显式传入参数。</li><li>在调用时，<code>this</code> 会绑定到第一个参数上。</li></ul><hr><h4 id="1-2-2-apply-方法"><a href="#1-2-2-apply-方法" class="headerlink" title="1.2.2. apply 方法"></a>1.2.2. <strong><code>apply</code> 方法</strong></h4><p><code>apply</code> 方法的作用与 <code>call</code> 方法类似，也是用于显式绑定 <code>this</code>。不同之处在于，<code>apply</code> 方法接受的是一个数组或类数组对象作为第二个参数，而不是一系列的独立参数。这意味着 <code>apply</code> 适用于动态传递参数列表的场景。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">apply</span>(thisArg, [argsArray])<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：在函数执行时，<code>this</code> 指向的对象。</li><li><code>argsArray</code>：一个数组或类数组对象，包含传递给函数的参数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>]);  <span class="hljs-comment">// 输出：Hello, my name is Bob and I am 25 years old.</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>greet.apply(person, [&#39;Bob&#39;, 25])</code> 的调用方式与 <code>call</code> 类似，不同的是我们使用了数组来传递参数。</p><p><strong>特点：</strong></p><ul><li><code>apply</code> 方法也立即调用函数，<code>this</code> 会绑定到第一个参数。</li><li>参数以数组的形式传递，因此适用于参数数量不固定或参数动态生成的场景。</li></ul><hr><h4 id="1-2-3-bind-方法"><a href="#1-2-3-bind-方法" class="headerlink" title="1.2.3. bind 方法"></a>1.2.3. <strong><code>bind</code> 方法</strong></h4><p>与 <code>call</code> 和 <code>apply</code> 方法不同，<code>bind</code> 方法不会立即执行函数，而是返回一个新的函数。在返回的新函数中，<code>this</code> 会被永久性地绑定到指定的对象，而这个函数可以在之后的任何时刻调用。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newFunc = <span class="hljs-keyword">function</span>.<span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：要绑定到函数上的 <code>this</code> 值。</li><li><code>arg1, arg2, ...</code>：可选的参数，这些参数会在调用 <code>newFunc</code> 时被传递给原函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Charlie&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> boundGreet = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><span class="hljs-title function_">boundGreet</span>(<span class="hljs-number">35</span>);  <span class="hljs-comment">// 输出：Hello, my name is Charlie and I am 35 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>greet.bind(person, &#39;Charlie&#39;)</code> 创建了一个新的函数 <code>boundGreet</code>，这个函数会始终将 <code>this</code> 绑定到 <code>person</code> 对象，并且固定传递 <code>&#39;Charlie&#39;</code> 作为第一个参数。之后，调用 <code>boundGreet(35)</code> 时，<code>this</code> 已经是 <code>person</code>，并且 <code>35</code> 被作为 <code>age</code> 参数传入。</p><p><strong>特点：</strong></p><ul><li><code>bind</code> 返回一个新函数，<strong>不会立即执行</strong>。</li><li>返回的函数在调用时，<code>this</code> 会永久绑定到指定对象。</li><li>可以部分应用（预设部分参数），这使得 <code>bind</code> 在某些情况下非常有用，尤其是在事件处理和回调函数中。</li></ul><hr><h4 id="1-2-4-call、apply-和-bind-的区别"><a href="#1-2-4-call、apply-和-bind-的区别" class="headerlink" title="1.2.4. call、apply 和 bind 的区别"></a>1.2.4. <strong><code>call</code>、<code>apply</code> 和 <code>bind</code> 的区别</strong></h4><table><thead><tr><th>特性</th><th><code>call</code></th><th><code>apply</code></th><th><code>bind</code></th></tr></thead><tbody><tr><td><strong>调用方式</strong></td><td>立即调用</td><td>立即调用</td><td>返回一个新函数</td></tr><tr><td><strong>参数传递方式</strong></td><td>依次传递参数</td><td>传递一个数组</td><td>预设参数并返回一个新函数</td></tr><tr><td><strong>返回值</strong></td><td>没有返回值</td><td>没有返回值</td><td>返回一个新函数</td></tr><tr><td><strong>使用场景</strong></td><td>需要立即调用函数并传递参数</td><td>参数以数组的形式传递时</td><td>需要绑定 <code>this</code> 并在未来某个时刻调用</td></tr></tbody></table><hr><h4 id="1-2-5-实际应用示例"><a href="#1-2-5-实际应用示例" class="headerlink" title="1.2.5. 实际应用示例"></a>1.2.5. <strong>实际应用示例</strong></h4><h5 id="1-call-和-apply-适用于函数重用"><a href="#1-call-和-apply-适用于函数重用" class="headerlink" title="1. call 和 apply 适用于函数重用"></a>1. <code>call</code> 和 <code>apply</code> 适用于函数重用</h5><p><code>call</code> 和 <code>apply</code> 允许你将一个函数的上下文从一个对象转换到另一个对象。例如，可以使用它们来扩展已有函数的功能，或者为某个特定的对象调用其他对象的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br>greet.<span class="hljs-title function_">call</span>(person1);  <span class="hljs-comment">// 输出 &quot;Hello, my name is John&quot;</span><br>greet.<span class="hljs-title function_">call</span>(person2);  <span class="hljs-comment">// 输出 &quot;Hello, my name is Jane&quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-bind-适用于事件处理和回调函数"><a href="#2-bind-适用于事件处理和回调函数" class="headerlink" title="2. bind 适用于事件处理和回调函数"></a>2. <code>bind</code> 适用于事件处理和回调函数</h5><p><code>bind</code> 在事件处理和回调函数中非常有用，因为它可以确保 <code>this</code> 在异步执行时仍然指向正确的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ClickMe&#x27;</span>,<br>  <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用bind确保`this`指向obj</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, obj.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(obj));<br></code></pre></td></tr></table></figure><h5 id="3-bind-和部分应用"><a href="#3-bind-和部分应用" class="headerlink" title="3. bind 和部分应用"></a>3. <strong><code>bind</code> 和部分应用</strong></h5><p><code>bind</code> 还可以用于部分应用（即提前指定部分参数），这使得它在构建一些通用函数时非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">const</span> addFive = add.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 预设第一个参数为5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addFive</span>(<span class="hljs-number">10</span>));  <span class="hljs-comment">// 输出 15</span><br></code></pre></td></tr></table></figure><hr><h4 id="1-2-6-总结"><a href="#1-2-6-总结" class="headerlink" title="1.2.6. 总结"></a>1.2.6. <strong>总结</strong></h4><ul><li><strong><code>call</code></strong> 和 <strong><code>apply</code></strong> 都是用于临时改变函数执行时的上下文 (<code>this</code>)，但是它们在传参方式上有所不同：<code>call</code> 接受单独的参数，而 <code>apply</code> 接受一个数组作为参数。</li><li><strong><code>bind</code></strong> 通过返回一个新函数，允许你永久地绑定 <code>this</code>，并在未来某个时刻调用该函数。它也可以用于预设部分参数。</li></ul><p>理解这三个方法的使用场景和区别，能够帮助你在 JavaScript 编程中更好地控制函数的上下文绑定，避免由于 <code>this</code> 指向错误而导致的 bug。</p><h2 id="2-arguments：动态参数对象"><a href="#2-arguments：动态参数对象" class="headerlink" title="2. arguments：动态参数对象"></a>2. <strong><code>arguments</code>：动态参数对象</strong></h2><p><code>arguments</code> 是一个类似数组的对象，它包含了传递给函数的所有参数。在 JavaScript 的函数中，<code>arguments</code> 会自动创建，它的 <code>length</code> 属性可以获取传递的参数个数。需要注意的是，<code>arguments</code> 不是一个真正的数组，它不拥有数组方法，如 <code>map</code>、<code>forEach</code> 等。</p><h3 id="2-1-使用-arguments"><a href="#2-1-使用-arguments" class="headerlink" title="2.1 使用 arguments"></a>2.1 使用 <code>arguments</code></h3><p><code>arguments</code> 对象非常适合用来处理不确定数量的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    total += <span class="hljs-variable language_">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h3 id="2-2-箭头函数和-arguments"><a href="#2-2-箭头函数和-arguments" class="headerlink" title="2.2 箭头函数和 arguments"></a>2.2 箭头函数和 <code>arguments</code></h3><p>箭头函数没有自己的 <code>arguments</code> 对象，而是从外部的上下文中继承 <code>arguments</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>  <span class="hljs-title function_">arrowFunc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 继承外部函数 arguments</span><br>&#125;<br><br><span class="hljs-title function_">outer</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 输出: [3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-使用-ES6-的扩展运算符"><a href="#2-3-使用-ES6-的扩展运算符" class="headerlink" title="2.3 使用 ES6 的扩展运算符"></a>2.3 使用 ES6 的扩展运算符</h3><p>ES6 引入了扩展运算符（<code>...</code>），我们可以用它代替 <code>arguments</code>，并且可以在函数内部像数组一样处理参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h2 id="3-prototype：原型和继承机制"><a href="#3-prototype：原型和继承机制" class="headerlink" title="3. prototype：原型和继承机制"></a>3. <strong><code>prototype</code>：原型和继承机制</strong></h2><p>JavaScript 是基于原型的编程语言。每个对象都通过 <code>prototype</code> 属性与其他对象建立联系，形成原型链。这种原型链决定了对象属性和方法的继承方式。</p><h3 id="3-1-原型链"><a href="#3-1-原型链" class="headerlink" title="3.1 原型链"></a>3.1 原型链</h3><p>每个函数都有一个 <code>prototype</code> 属性，指向一个对象，该对象就是该函数的原型。对象的原型也是对象，并且它也有原型，这样就形成了一条“原型链”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>alice.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure><h3 id="3-2-原型链的查找机制"><a href="#3-2-原型链的查找机制" class="headerlink" title="3.2 原型链的查找机制"></a>3.2 原型链的查找机制</h3><p>当访问一个对象的属性时，如果该对象本身没有该属性，JavaScript 会通过原型链查找该属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">toString</span>());  <span class="hljs-comment">// 输出: [object Object]</span><br></code></pre></td></tr></table></figure><p>这里，<code>obj</code> 没有 <code>toString</code> 方法，但由于 <code>Object.prototype</code> 中有这个方法，所以 <code>obj</code> 继承了它。</p><h3 id="3-3-prototype-与-proto-的区别"><a href="#3-3-prototype-与-proto-的区别" class="headerlink" title="3.3 prototype 与 __proto__ 的区别"></a>3.3 <code>prototype</code> 与 <code>__proto__</code> 的区别</h3><ul><li><code>prototype</code> 是函数对象的属性，指向该函数的原型对象。</li><li><code>__proto__</code> 是每个实例对象的属性，指向该实例的构造函数的原型对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><h2 id="4-闭包：访问外部函数变量"><a href="#4-闭包：访问外部函数变量" class="headerlink" title="4. 闭包：访问外部函数变量"></a>4. <strong>闭包：访问外部函数变量</strong></h2><p>闭包是 JavaScript 的一项重要特性，它允许函数记住并访问其外部函数的作用域。即使外部函数已经执行结束，闭包依然能访问外部函数的变量。</p><h3 id="4-1-闭包的工作原理"><a href="#4-1-闭包的工作原理" class="headerlink" title="4.1 闭包的工作原理"></a>4.1 闭包的工作原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">counter</span>();  <span class="hljs-comment">// 输出 1</span><br><span class="hljs-title function_">counter</span>();  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>inner</code> 函数是一个闭包，它访问并修改 <code>outer</code> 函数的局部变量 <code>count</code>。</p><h3 id="4-2-闭包的用途"><a href="#4-2-闭包的用途" class="headerlink" title="4.2 闭包的用途"></a>4.2 闭包的用途</h3><ul><li><strong>数据封装</strong>：闭包可以用来封装私有数据，不让外部直接访问。</li><li><strong>回调函数和事件处理器</strong>：闭包常用于处理异步操作、回调函数等。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>      count--;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br>counter.<span class="hljs-title function_">increment</span>();  <span class="hljs-comment">// 输出 1</span><br>counter.<span class="hljs-title function_">increment</span>();  <span class="hljs-comment">// 输出 2</span><br>counter.<span class="hljs-title function_">decrement</span>();  <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h2 id="5-new-操作符：实例化对象"><a href="#5-new-操作符：实例化对象" class="headerlink" title="5. new 操作符：实例化对象"></a>5. <strong><code>new</code> 操作符：实例化对象</strong></h2><p><code>new</code> 是 JavaScript 中用于创建实例的关键字，它不仅可以创建一个新的对象，还会自动执行构造函数中的操作。</p><h3 id="5-1-new-操作符的工作流程"><a href="#5-1-new-操作符的工作流程" class="headerlink" title="5.1 new 操作符的工作流程"></a>5.1 <code>new</code> 操作符的工作流程</h3><ul><li>创建一个新对象。</li><li>将新对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code> 属性。</li><li>执行构造函数，并将 <code>this</code> 绑定到新对象。</li><li>返回新对象（如果构造函数没有显式返回对象，则返回新创建的对象）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bob <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><h2 id="6-事件循环：JavaScript-的异步执行"><a href="#6-事件循环：JavaScript-的异步执行" class="headerlink" title="6. 事件循环：JavaScript 的异步执行"></a>6. <strong>事件循环：JavaScript 的异步执行</strong></h2><p>JavaScript 是单线程的，但它有一个强大的机制来处理异步操作，称为事件循环（Event Loop）。事件循环允许 JavaScript 执行非阻塞操作，例如 I&#x2F;O 操作、定时器、事件监听等。</p><h3 id="6-1-事件循环的流程"><a href="#6-1-事件循环的流程" class="headerlink" title="6.1 事件循环的流程"></a>6.1 事件循环的流程</h3><ol><li>执行栈（Call Stack）：当前正在执行的代码。</li><li>消息队列（Message Queue）：存储待执行的异步任务（如回调函数、事件等）。</li><li>事件循环：不断查看执行栈是否为空，如果为空，则将消息队列中的任务移入执行栈。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middle&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Start</span><br><span class="hljs-comment">// End</span><br><span class="hljs-comment">// Middle</span><br></code></pre></td></tr></table></figure><p>这里，尽管 <code>setTimeout</code> 的延迟时间是 <code>0</code>，但是它依然被放入消息队列，等待主线程执行完当前代码后再执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 的底层机制提供了许多强大的功能，帮助我们高效地管理函数、对象、继承、异步操作等方面的复杂性。理解这些底层机制，能够让我们更好地掌握语言，写出高效、可维护的代码。</p><ul><li>**<code>this</code>**：动态上下文指向，取决于函数的调用方式。</li><li>**<code>arguments</code>**：函数内部的参数对象，提供不定数量参数的访问。</li><li>**<code>prototype</code>**：原型链实现继承机制。</li><li><strong>闭包</strong>：函数可以“记住”外部函数的变量，常用于数据封装和回调。</li><li>**<code>new</code>**：实例化对象，自动设置原型并执行构造函数。</li><li><strong>事件循环</strong>：JavaScript 的异步执行机制，确保代码的非阻塞性执行。</li></ul><p>在实际开发中，掌握这些底层机制将帮助你编写更加高效、灵活、可维护的代码，同时避免一些常见的陷阱。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-fluid免费部署评论功能</title>
    <link href="/posts/6873/"/>
    <url>/posts/6873/</url>
    
    <content type="html"><![CDATA[<h1 id="giscus"><a href="#giscus" class="headerlink" title="giscus"></a>giscus</h1><p>giscus是一个由 GitHub Discussions 驱动的评论系统，部署方便，无跟踪，无广告，永久免费。<br>无需数据库。全部数据均储存在 GitHub Discussions 中。</p><h2 id="1-安装giscus-app"><a href="#1-安装giscus-app" class="headerlink" title="1.安装giscus app"></a>1.安装<a href="https://github.com/apps/giscus">giscus app</a></h2><p>首先，要在你的github中安装<a href="https://github.com/apps/giscus">giscus app</a><br>点击”install”即可<br><img src="/posts/6873/202301120806.webp"><br><img src="/posts/6873/202301120806.webp"></p><p>然后如图依次点击”Only select repositories”和”Select repositories”,并选择你存储评论的仓库(<strong>即部署hexo的仓库，如本仓库yonghengshikong&#x2F;yonghengshikong.github.io</strong>)。<br>点击”install”安装<br><img src="/posts/6873/202301120808.webp"><br><img src="/posts/6873/202301120808.webp"></p><h2 id="2-配置仓库允许评论"><a href="#2-配置仓库允许评论" class="headerlink" title="2.配置仓库允许评论"></a>2.配置仓库允许评论</h2><p>打开hexo仓库的设置页面，选择常规设置，勾选允许评论</p><p><img src="/posts/6873/5.png"></p><p><img src="/posts/6873/6.png"></p><h2 id="3-进入giscus关联仓库"><a href="#3-进入giscus关联仓库" class="headerlink" title="3.进入giscus关联仓库"></a>3.进入giscus关联仓库</h2><p><strong>打开<a href="https://giscus.app/">giscus官网</a>，进一步配置</strong></p><p><img src="/posts/6873/2.png"></p><p><img src="/posts/6873/3.png"></p><p><img src="/posts/6873/4.png" alt="giscus配置数据"></p><h2 id="4-在config-yml中配置"><a href="#4-在config-yml中配置" class="headerlink" title="4.在config.yml中配置"></a>4.在config.yml中配置</h2><p><strong>启动评论，类型设置为giscus</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>  <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">giscus</span><br></code></pre></td></tr></table></figure><p>根据前面的giscus配置数据来填写以下信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Giscus</span><br><span class="hljs-comment"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class="hljs-comment"># Based on GitHub Discussions, similar to Utterances</span><br><span class="hljs-comment"># See: https://giscus.app/</span><br><span class="hljs-attr">giscus:</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">yonghengshikong/yonghengshikong.github.io</span><br>  <span class="hljs-attr">repo-id:</span> <span class="hljs-string">***********</span><br>  <span class="hljs-attr">category:</span> <span class="hljs-string">General</span><br>  <span class="hljs-attr">category-id:</span> <span class="hljs-string">***************</span><br>  <span class="hljs-attr">theme-light:</span> <span class="hljs-string">light</span><br>  <span class="hljs-attr">theme-dark:</span> <span class="hljs-string">dark</span><br>  <span class="hljs-attr">mapping:</span> <span class="hljs-string">title</span><br>  <span class="hljs-attr">reactions-enabled:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">emit-metadata:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">input-position:</span> <span class="hljs-string">bottom</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h2 id="5-最终效果如下"><a href="#5-最终效果如下" class="headerlink" title="5.最终效果如下"></a>5.最终效果如下</h2><p><img src="/posts/6873/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析TypeScript装饰器</title>
    <link href="/posts/52923/"/>
    <url>/posts/52923/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-TypeScript-装饰器"><a href="#深入理解-TypeScript-装饰器" class="headerlink" title="深入理解 TypeScript 装饰器"></a>深入理解 TypeScript 装饰器</h1><p>TypeScript 中的装饰器是一个非常强大且灵活的特性，它允许开发者通过注解和修改类、方法、属性、参数的行为，使得代码更加优雅、模块化和可扩展。本文将从装饰器的类型、参数、返回值、实现机制、用法和应用场景等方面进行详细解析，并通过丰富的示例代码帮助开发者更好地理解和掌握装饰器的使用。</p><h2 id="1-开启装饰器支持"><a href="#1-开启装饰器支持" class="headerlink" title="1. 开启装饰器支持"></a>1. 开启装饰器支持</h2><p>在 TypeScript 中，装饰器是一个实验性特性。为了使用装饰器，需要在 <code>tsconfig.json</code> 配置文件中启用 <code>experimentalDecorators</code> 选项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-装饰器类型概览"><a href="#2-装饰器类型概览" class="headerlink" title="2. 装饰器类型概览"></a>2. 装饰器类型概览</h2><p>TypeScript 支持以下四种主要的装饰器类型：</p><ol><li><strong>类装饰器（Class Decorator）</strong></li><li><strong>方法装饰器（Method Decorator）</strong></li><li><strong>属性装饰器（Property Decorator）</strong></li><li><strong>参数装饰器（Parameter Decorator）</strong></li></ol><p>每种装饰器的参数不同，具体参数说明和使用场景在下面的章节中将详细介绍。</p><h2 id="3-装饰器的基本语法与使用"><a href="#3-装饰器的基本语法与使用" class="headerlink" title="3. 装饰器的基本语法与使用"></a>3. 装饰器的基本语法与使用</h2><h3 id="3-1-类装饰器"><a href="#3-1-类装饰器" class="headerlink" title="3.1 类装饰器"></a>3.1 类装饰器</h3><h4 id="3-1-1-基础实现"><a href="#3-1-1-基础实现" class="headerlink" title="3.1.1 基础实现"></a>3.1.1 基础实现</h4><p>类装饰器是最基本的装饰器，通常用于修改类的行为或替换构造函数。它接受一个参数——构造函数，并且返回一个新的构造函数或修改过的构造函数。</p><p><strong>参数：</strong></p><ul><li><strong>target</strong>：类的构造函数。该构造函数是类的实例化方法，可以在装饰器中被替换或修改。</li></ul><p><strong>返回值：</strong></p><ul><li>可以返回一个新的类构造函数，用来替换原始类的构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-meta">@logClass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MyClass instance created.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Class MyClass has been decorated.</span><br><span class="hljs-comment">// MyClass instance created.</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-装饰器传参的基本实现-装饰器工厂"><a href="#3-1-2-装饰器传参的基本实现-装饰器工厂" class="headerlink" title="3.1.2  装饰器传参的基本实现(装饰器工厂)"></a>3.1.2  装饰器传参的基本实现(装饰器工厂)</h4><p>通过这种方式，你可以在装饰器中使用传入的参数来执行特定的逻辑。我们通过一个简单的示例来演示这个过程：</p><p><strong>示例：为类装饰器传递参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 返回的实际装饰器函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;message&#125;</span>: Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@logClass</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyClass instance created.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>logClass</code> 是一个工厂函数，接收一个 <code>message</code> 参数。</li><li>在 <code>logClass</code> 内部，我们返回一个实际的装饰器函数（<code>target =&gt; &#123; ... &#125;</code>）。</li><li>返回的装饰器函数会接收到类的构造函数作为 <code>target</code> 参数，这样你就可以在装饰器中使用这个类的构造函数，或者执行其他操作。</li><li>这个装饰器在 <code>@logClass(&quot;Hello&quot;)</code> 中使用时，传入了 <code>&quot;Hello&quot;</code> 这个参数，最终输出的内容会包括这个参数。</li></ol><p><strong>输出结果：</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Hello: Class MyClass has been decorated.<br>MyClass<span class="hljs-built_in"> instance </span>created.<br></code></pre></td></tr></table></figure><h4 id="3-2-3-进一步的装饰器参数应用"><a href="#3-2-3-进一步的装饰器参数应用" class="headerlink" title="3.2.3  进一步的装饰器参数应用"></a>3.2.3  进一步的装饰器参数应用</h4><p>你还可以传递更多参数，并在装饰器中执行更复杂的逻辑。以下是一个扩展的示例，演示如何为类装饰器传递多个参数，并执行类属性和方法的修改。</p><p><strong>示例：带多个参数的类装饰器</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span>, level: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;message&#125;</span> [Level: <span class="hljs-subst">$&#123;level&#125;</span>]: Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@logClass</span>(<span class="hljs-string">&quot;Logging&quot;</span>, <span class="hljs-string">&quot;INFO&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyClass instance created.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Logging [Level: INFO]: Class MyClass has been decorated.<br>MyClass<span class="hljs-built_in"> instance </span>created.<br></code></pre></td></tr></table></figure><h4 id="3-2-4-装饰器组合"><a href="#3-2-4-装饰器组合" class="headerlink" title="3.2.4 装饰器组合"></a>3.2.4 装饰器组合</h4><p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p><ul><li>书写在同一行上：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@f</span> <span class="hljs-meta">@g</span> x<br></code></pre></td></tr></table></figure><ul><li>书写在多行上：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@f</span><br><span class="hljs-meta">@g</span><br>x<br></code></pre></td></tr></table></figure><p>当多个装饰器应用于一个声明上，它们求值方式与<a href="http://en.wikipedia.org/wiki/Function_composition">复合函数</a>相似。在这个模型下，当复合<em>f</em>和<em>g</em>时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于<em>f</em>(<em>g</em>(<em>x</em>))。</p><p>同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ol><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用。</li></ol><p>如果我们使用<strong>装饰器工厂</strong>的话，可以通过下面的例子来观察它们求值的顺序：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;f(): evaluated&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;f(): called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;g(): evaluated&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;g(): called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-meta">@f</span>()<br>    <span class="hljs-meta">@g</span>()<br>    <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在控制台里会打印出如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">f(): evaluated<br>g(): evaluated<br>g(): called<br>f(): called<br></code></pre></td></tr></table></figure><h3 id="3-2-方法装饰器"><a href="#3-2-方法装饰器" class="headerlink" title="3.2 方法装饰器"></a>3.2 方法装饰器</h3><p>方法装饰器用于类的方法，它接受三个参数：</p><ol><li><strong>target</strong>：方法所在类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：方法的名称（<code>string</code> 类型）。</li><li><strong>descriptor</strong>：方法的属性描述符（<code>PropertyDescriptor</code> 类型）。</li></ol><p><strong>参数：</strong></p><ul><li><strong>target</strong>：类的原型（即类的实例对象），如果是静态方法，则为构造函数。</li><li><strong>propertyKey</strong>：方法名称，<code>string</code> 类型。</li><li><strong>descriptor</strong>：该方法的属性描述符（<code>PropertyDescriptor</code>），包含了 <code>value</code>、<code>writable</code>、<code>enumerable</code> 和 <code>configurable</code> 等字段。</li></ul><p><strong>PropertyDescriptor 字段：</strong></p><ul><li><strong>value</strong>：方法本身的实现（即函数）。</li><li><strong>writable</strong>：布尔值，指示方法是否可以被修改。</li><li><strong>enumerable</strong>：布尔值，指示方法是否可枚举。</li><li><strong>configurable</strong>：布尔值，指示方法是否可配置。</li></ul><p>可以通过 <code>descriptor</code> 修改方法的执行行为，如修改其值或禁用它。</p><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;<br>  <br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> was called with arguments:`</span>, args);<br>    <span class="hljs-keyword">return</span> originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Method greet was called with arguments: [ &#x27;Alice&#x27; ]</span><br><span class="hljs-comment">// Hello, Alice</span><br></code></pre></td></tr></table></figure><h3 id="3-3-属性装饰器"><a href="#3-3-属性装饰器" class="headerlink" title="3.3 属性装饰器"></a>3.3 属性装饰器</h3><p>属性装饰器用于类的属性，它只能接收两个参数：</p><ol><li><strong>target</strong>：类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：属性名（<code>string</code> 类型）。</li></ol><p>属性装饰器通常用于为属性添加元数据或进行相关处理，但不能直接修改属性值。如果需要修改属性值，应使用 getter 或 setter。</p><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Property <span class="hljs-subst">$&#123;propertyKey&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logProperty</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-参数装饰器"><a href="#3-4-参数装饰器" class="headerlink" title="3.4 参数装饰器"></a>3.4 参数装饰器</h3><p>参数装饰器用于方法参数，它接受三个参数：</p><ol><li><strong>target</strong>：方法所在类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：方法名称（<code>string</code> 类型）。</li><li><strong>parameterIndex</strong>：参数在方法中的索引（<code>number</code> 类型）。</li></ol><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logParameter</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, parameterIndex: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Parameter at index <span class="hljs-subst">$&#123;parameterIndex&#125;</span> in method <span class="hljs-subst">$&#123;propertyKey&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-meta">@logParameter</span> name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Parameter at index 0 in method greet has been decorated.</span><br><span class="hljs-comment">// Hello, Alice</span><br></code></pre></td></tr></table></figure><h2 id="4-装饰器的参数解析"><a href="#4-装饰器的参数解析" class="headerlink" title="4. 装饰器的参数解析"></a>4. 装饰器的参数解析</h2><h3 id="4-1-PropertyDescriptor-详解"><a href="#4-1-PropertyDescriptor-详解" class="headerlink" title="4.1 PropertyDescriptor 详解"></a>4.1 <code>PropertyDescriptor</code> 详解</h3><p><code>PropertyDescriptor</code> 是一个描述对象属性的元数据对象。在 JavaScript 中，<code>PropertyDescriptor</code> 被用于定义对象的属性行为，包括属性是否可写、是否可枚举、是否可配置等。</p><p>在 TypeScript 的装饰器中，<code>PropertyDescriptor</code> 被广泛用于描述方法和属性的行为。通过修改 <code>PropertyDescriptor</code>，我们可以对方法或属性的访问行为进行定制，从而增强类的功能。</p><p><code>**PropertyDescriptor**</code> 主要有以下几个字段：</p><ol><li>value<ul><li><strong>类型</strong>：<code>any</code></li><li><strong>说明</strong>：该字段保存了属性或方法的实际值。对于属性，它是该属性的值；对于方法，它是方法本身（即函数）。我们可以通过修改 <code>value</code> 字段来改变方法或属性的行为。</li></ul></li><li>writable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示属性是否是可写的。如果为 <code>false</code>，则该属性不可修改。对于方法装饰器，这个字段表示方法是否可以被替换。</li></ul></li><li>enumerable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示属性或方法是否可枚举。如果为 <code>false</code>，则该属性不会在 <code>for...in</code> 循环中被列举出来。</li></ul></li><li>configurable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示是否可以删除该属性或修改该属性的描述符。如果为 <code>false</code>，则无法删除或修改该属性的描述符。</li></ul></li><li>get<ul><li><strong>类型</strong>：<code>Function | undefined</code></li><li><strong>说明</strong>：该字段仅在属性是访问器属性（getter）时存在。它保存一个函数，用于获取该属性的值。可以通过修改 <code>get</code> 来修改属性的读取行为。</li></ul></li><li>set<ul><li><strong>类型</strong>：<code>Function | undefined</code></li><li><strong>说明</strong>：该字段仅在属性是访问器属性（setter）时存在。它保存一个函数，用于设置该属性的值。可以通过修改 <code>set</code> 来修改属性的写入行为。</li></ul></li></ol><h4 id="4-1-1-修改属性的可写性和可枚举性"><a href="#4-1-1-修改属性的可写性和可枚举性" class="headerlink" title="4.1.1 修改属性的可写性和可枚举性"></a>4.1.1 修改属性的可写性和可枚举性</h4><p>属性装饰器是通过 <code>PropertyDescriptor</code> 来修改属性的行为。例如，假设我们想让某个属性成为只读属性，并且不希望它在 <code>for...in</code> 循环中出现，可以通过 <code>PropertyDescriptor</code> 来实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 使属性只读</span><br>  descriptor.<span class="hljs-property">enumerable</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 使属性不可枚举</span><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@readonly</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jane&#x27;</span>;  <span class="hljs-comment">// 错误：name 属性是只读的</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj));  <span class="hljs-comment">// 输出：[]</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>readonly</code> 装饰器修改了 <code>name</code> 属性，使它变为只读属性且不可枚举。通过设置 <code>descriptor.writable</code> 和 <code>descriptor.enumerable</code>，我们可以控制属性的行为。</p><h4 id="4-1-2-修改方法的实现"><a href="#4-1-2-修改方法的实现" class="headerlink" title="4.1.2 修改方法的实现"></a>4.1.2 修改方法的实现</h4><p>方法装饰器也可以通过 <code>PropertyDescriptor</code> 来修改方法的实现。例如，我们可以在方法执行前后增加日志记录：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;  <span class="hljs-comment">// 保存原始方法</span><br><br>  <span class="hljs-comment">// 修改方法实现，增加日志功能</span><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;key&#125;</span> called with arguments: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(args)&#125;</span>`</span>);<br>    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);  <span class="hljs-comment">// 调用原始方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;key&#125;</span> returned: <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 输出：Method add called with arguments: [1,2] 和 Method add returned: 3</span><br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// 输出：Method greet called with arguments: [&quot;Alice&quot;] 和 Method greet returned: Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>logMethod</code> 装饰器通过修改 <code>descriptor.value</code>，将原始的方法实现替换为带有日志记录功能的新方法。每次调用方法时，都会打印出调用参数和返回值。</p><h4 id="4-1-3-控制属性的访问器行为"><a href="#4-1-3-控制属性的访问器行为" class="headerlink" title="4.1.3 控制属性的访问器行为"></a>4.1.3 控制属性的访问器行为</h4><p>当属性是访问器属性（getter 或 setter）时，<code>PropertyDescriptor</code> 中的 <code>get</code> 和 <code>set</code> 字段将包含访问器的实现。通过修改这些字段，可以定制属性的读取和写入逻辑。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalGetter = descriptor.<span class="hljs-property">get</span>;  <span class="hljs-comment">// 保存原始 getter</span><br><br>  descriptor.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Accessing <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> originalGetter?.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = age;<br>  &#125;<br><br>  <span class="hljs-meta">@validate</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">age</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Age cannot be negative&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">25</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 输出：Accessing age 和 25</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>validate</code> 装饰器在 <code>getter</code> 被调用时添加了日志功能。通过修改 <code>descriptor.get</code>，我们可以在读取属性时执行额外的逻辑。</p><p><code>PropertyDescriptor</code> 是 TypeScript 装饰器中非常重要的一个参数，它允许开发者对属性和方法的行为进行细粒度的控制。通过 <code>PropertyDescriptor</code>，我们可以：</p><ul><li>控制属性的可写性（<code>writable</code>）</li><li>控制属性是否可枚举（<code>enumerable</code>）</li><li>控制属性是否可配置（<code>configurable</code>）</li><li>修改方法的实现（<code>value</code>）</li><li>修改属性的访问器（<code>get</code> 和 <code>set</code>）</li></ul><p>通过灵活地使用 <code>PropertyDescriptor</code>，我们可以增强类和对象的功能，实现日志记录、缓存、权限控制等功能。掌握 <code>PropertyDescriptor</code> 的使用，可以让我们更好地在 TypeScript 中实现装饰器模式，提升代码的灵活性和可维护性。</p><h3 id="4-2-装饰器的用处"><a href="#4-2-装饰器的用处" class="headerlink" title="4.2 装饰器的用处"></a>4.2 装饰器的用处</h3><p>装饰器提供了一种灵活的方式来修改类、方法、属性或参数的行为。它在以下场景中非常有用：</p><ol><li><strong>依赖注入</strong>：使用装饰器动态地为类或方法注入依赖对象。</li><li><strong>权限控制</strong>：控制方法的访问权限，比如基于用户角色或权限进行限制。</li><li><strong>日志记录</strong>：自动记录方法的调用，参数和返回值，帮助调试和性能监控。</li><li><strong>性能优化</strong>：通过缓存、延迟加载等技术优化方法的执行效率。</li><li><strong>事件监听</strong>：自动为类或方法注册事件监听器。</li></ol><h3 id="4-3-使用装饰器的场景示例"><a href="#4-3-使用装饰器的场景示例" class="headerlink" title="4.3 使用装饰器的场景示例"></a>4.3 使用装饰器的场景示例</h3><p><strong>示例 1：依赖注入</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">service: <span class="hljs-built_in">any</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>    target[propertyKey] = service;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerService</span> &#123;<br>  <span class="hljs-title function_">log</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@inject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerService</span>())<br>  <span class="hljs-attr">logger</span>: <span class="hljs-title class_">LoggerService</span>;<br><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出：Hello, world!</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：性能监控</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">monitorPerformance</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;<br><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> took <span class="hljs-subst">$&#123;end - start&#125;</span>ms to execute`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@monitorPerformance</span><br>  <span class="hljs-title function_">longRunningTask</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 模拟长时间的任务</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e8</span>; i++) &#123;&#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">longRunningTask</span>();  <span class="hljs-comment">// 输出：Method longRunningTask took XXXms to execute</span><br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>装饰器是 TypeScript 提供的一个强大特性，通过注解类、方法、属性或参数来改变它们的行为。在这篇文章中，我们详细探讨了装饰器的语法、参数、用途以及一些常见的应用场景。掌握装饰器的使用方法，能够让你在项目中写出更加优雅、简洁和可扩展的代码。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript14新特性详解</title>
    <link href="/posts/37339/"/>
    <url>/posts/37339/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2023（ES14）新特性详解"><a href="#ECMAScript-2023（ES14）新特性详解" class="headerlink" title="ECMAScript 2023（ES14）新特性详解"></a>ECMAScript 2023（ES14）新特性详解</h1><p>ECMAScript 2023（也称为 ES14）引入了一些重要的新特性，旨在提高 JavaScript 的功能和开发者的体验。以下是 ES14 的主要新特性：</p><h2 id="1-Array-prototype-toSorted"><a href="#1-Array-prototype-toSorted" class="headerlink" title="1. Array.prototype.toSorted()"></a>1. <code>Array.prototype.toSorted()</code></h2><p><code>Array.prototype.toSorted()</code> 方法返回一个新的数组，包含原数组的所有元素，但以指定的排序顺序排列。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toSorted</span>(compareFunction);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>compareFunction</code>（可选）：用于排序的函数，定义了排序顺序。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含按指定顺序排序的元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sortedNumbers = numbers.<span class="hljs-title function_">toSorted</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedNumbers); <span class="hljs-comment">// 输出: [1, 1, 3, 4, 5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 原数组仍为: [3, 1, 4, 1, 5]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Array-prototype-toReversed"><a href="#2-Array-prototype-toReversed" class="headerlink" title="2. Array.prototype.toReversed()"></a>2. <code>Array.prototype.toReversed()</code></h2><p><code>Array.prototype.toReversed()</code> 方法返回一个新的数组，包含原数组的所有元素，但顺序是反向的。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toReversed</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含原数组的元素按反向顺序排列。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> reversedArray = array.<span class="hljs-title function_">toReversed</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedArray); <span class="hljs-comment">// 输出: [3, 2, 1]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// 原数组仍为: [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Array-prototype-toSpliced"><a href="#3-Array-prototype-toSpliced" class="headerlink" title="3. Array.prototype.toSpliced()"></a>3. <code>Array.prototype.toSpliced()</code></h2><p><code>Array.prototype.toSpliced()</code> 方法返回一个新的数组，包含原数组的元素，但在指定位置删除了指定数量的元素。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toSpliced</span>(start, deleteCount, ...items);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>start</code>: 开始删除的索引。</li><li><code>deleteCount</code>: 要删除的元素数量。</li><li><code>...items</code>（可选）：要添加的新元素。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含删除了指定元素的原数组元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>const splicedArray = <span class="hljs-built_in">array</span>.toSpliced(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(splicedArray); <span class="hljs-comment">// 输出: [1, &#x27;a&#x27;, &#x27;b&#x27;, 4]</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">array</span>); <span class="hljs-comment">// 原数组仍为: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Symbol-symbols"><a href="#4-Symbol-symbols" class="headerlink" title="4. Symbol.symbols"></a>4. <code>Symbol.symbols</code></h2><p><code>Symbol.symbols</code> 是一种新的内置 <code>Symbol</code>，它允许开发者标记不可修改的字段。这个新特性可以帮助实现更严格的类型和字段管理。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> immutableField = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;immutable&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>    [immutableField]: <span class="hljs-string">&#x27;This field cannot be changed&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[immutableField]); <span class="hljs-comment">// 输出: This field cannot be changed</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-WeakRefs-和-FinalizationRegistry"><a href="#5-WeakRefs-和-FinalizationRegistry" class="headerlink" title="5. WeakRefs 和 FinalizationRegistry"></a>5. <code>WeakRefs</code> 和 <code>FinalizationRegistry</code></h2><p>在 ES14 中，<code>WeakRef</code> 和 <code>FinalizationRegistry</code> 的支持得到了增强，使得开发者可以更好地管理内存和对象的生命周期。这对于实现内存敏感的功能非常有用。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> registry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function">(<span class="hljs-params">heldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Resource <span class="hljs-subst">$&#123;heldValue&#125;</span> is garbage collected`</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> resource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&#x27;Resource 1&#x27;</span>);<br><span class="hljs-keyword">const</span> weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(resource);<br><br>registry.<span class="hljs-title function_">register</span>(resource, resource.<span class="hljs-property">name</span>);<br><br>resource = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 解除对资源的引用，触发垃圾回收</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2023（ES14）引入了多项新特性，使得 JavaScript 更加灵活和高效。新方法如 <code>toSorted</code>、<code>toReversed</code> 和 <code>toSpliced</code> 提供了不修改原数组的情况下进行操作的能力，而 <code>Symbol.symbols</code> 和对 <code>WeakRefs</code> 的改进则增强了对内存管理的控制。这些改进不仅提升了开发者的体验，也为 JavaScript 的未来发展提供了更多可能性。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript13新特性详解</title>
    <link href="/posts/41881/"/>
    <url>/posts/41881/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2022（ES13）新特性详解"><a href="#ECMAScript-2022（ES13）新特性详解" class="headerlink" title="ECMAScript 2022（ES13）新特性详解"></a>ECMAScript 2022（ES13）新特性详解</h1><p>ECMAScript 2022（也称为 ES13）是 ECMAScript 的又一个小版本更新，主要引入了一些新特性来增强语言的表达力和性能。以下是 ES13 的主要新特性，包括详细的 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-at"><a href="#1-Array-prototype-at" class="headerlink" title="1. Array.prototype.at()"></a>1. <code>Array.prototype.at()</code></h2><p><code>Array.prototype.at()</code> 方法允许通过给定的索引获取数组中元素的值，可以接受负数索引，从而方便地访问数组末尾的元素。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">at</span>(index)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>index</code>: 要获取的元素的索引。可以是正数（从开头开始）或负数（从结尾开始）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回数组中指定索引的元素；如果索引超出范围，则返回 <code>undefined</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// 50</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">2</span>)); <span class="hljs-comment">// 40</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Object-hasOwn"><a href="#2-Object-hasOwn" class="headerlink" title="2. Object.hasOwn()"></a>2. <code>Object.hasOwn()</code></h2><p><code>Object.hasOwn()</code> 方法提供了一种简洁的方式来判断对象是否具有某个自身属性，类似于 <code>Object.prototype.hasOwnProperty()</code>，但语法更简洁。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, prop)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要检查的对象。</li><li><code>prop</code>: 要检查的属性名（字符串）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>如果对象具有该自身属性，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;gender&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-类字段和私有字段"><a href="#3-类字段和私有字段" class="headerlink" title="3. 类字段和私有字段"></a>3. 类字段和私有字段</h2><p>在 ES13 中，类支持声明公共字段和私有字段。这使得定义类属性更加简洁和清晰。</p><h3 id="3-1-公共字段"><a href="#3-1-公共字段" class="headerlink" title="3.1 公共字段"></a>3.1 公共字段</h3><p>可以在类中直接声明公共字段。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    myField = value;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br>    age = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-私有字段"><a href="#3-2-私有字段" class="headerlink" title="3.2 私有字段"></a>3.2 私有字段</h3><p>私有字段以 <code>#</code> 开头，仅能在类的内部访问。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    #myPrivateField;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    #ssn = <span class="hljs-string">&#x27;123-45-6789&#x27;</span>; <span class="hljs-comment">// 私有字段</span><br>    <br>    <span class="hljs-title function_">getSSN</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#ssn; <span class="hljs-comment">// 可以访问私有字段</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getSSN</span>()); <span class="hljs-comment">// 123-45-6789</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.#ssn); <span class="hljs-comment">// SyntaxError: Private field &#x27;#ssn&#x27; must be declared in an enclosing class</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2022（ES13）引入的新特性如 <code>Array.prototype.at()</code>、<code>Object.hasOwn()</code>、类字段和私有字段等，极大地增强了 JavaScript 的语法和可用性，使得编写和维护代码变得更加简洁。了解这些新特性可以帮助开发者更有效地利用 JavaScript，提升开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript12新特性详解</title>
    <link href="/posts/13144/"/>
    <url>/posts/13144/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2021（ES12）新特性详解"><a href="#ECMAScript-2021（ES12）新特性详解" class="headerlink" title="ECMAScript 2021（ES12）新特性详解"></a>ECMAScript 2021（ES12）新特性详解</h1><p>ECMAScript 2021（也称为 ES12）引入了一系列新特性，进一步增强了 JavaScript 的功能和灵活性。主要的新特性包括 <strong>String.prototype.replaceAll</strong>、<strong>Promise.any</strong>、<strong>WeakRefs</strong>、<strong>逻辑赋值运算符</strong>、<strong>数字分隔符</strong>、<strong>Promise.allSettled()</strong> 以及 <strong>Array.prototype.at</strong>。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-String-prototype-replaceAll"><a href="#1-String-prototype-replaceAll" class="headerlink" title="1. String.prototype.replaceAll"></a>1. String.prototype.replaceAll</h2><p><code>String.prototype.replaceAll()</code> 方法用于返回一个新字符串，其中所有匹配的子字符串都被替换为指定的替换字符串。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">replaceAll</span>(search, replacement)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>search</code>：要替换的子字符串，可以是一个字符串或正则表达式（不使用全局标志）。</li><li><code>replacement</code>：替换成的字符串。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新字符串，其中所有匹配的子字符串都被替换。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;I like cats. Cats are great!&#x27;</span>;<br><span class="hljs-keyword">const</span> newStr = str.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;cats&#x27;</span>, <span class="hljs-string">&#x27;dogs&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr); <span class="hljs-comment">// &#x27;I like dogs. Dogs are great!&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a>2. Promise.any</h2><p><code>Promise.any()</code> 方法接受一个可迭代的 Promise 对象，并返回一个 Promise，该 Promise 在其中一个输入 Promise 成功时解析，或在所有输入 Promise 都失败时被拒绝。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(promises)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>promises</code>：一个可迭代的 Promise 对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 Promise，当其中一个 Promise 成功时解析为该 Promise 的值；如果所有 Promise 都失败，则返回一个 AggregateError。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error 1&#x27;</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error 2&#x27;</span>);<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Success&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &#x27;Success&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Logical-Assignment-Operators"><a href="#3-Logical-Assignment-Operators" class="headerlink" title="3. Logical Assignment Operators"></a>3. Logical Assignment Operators</h2><p>逻辑赋值运算符结合了逻辑运算和赋值操作，简化了常见的逻辑赋值模式。</p><ul><li><p><strong>语法</strong>:</p><ul><li><code>x ||= y</code> （逻辑或赋值）</li><li><code>x &amp;&amp;= y</code> （逻辑与赋值）</li><li><code>x ??= y</code> （空值合并赋值）</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br><br>a ||= b; <span class="hljs-comment">// 如果 a 为 falsy，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span>;<br>c &amp;&amp;= b; <span class="hljs-comment">// 如果 c 为 truthy，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">let</span> d = <span class="hljs-literal">undefined</span>;<br>d ??= b; <span class="hljs-comment">// 如果 d 为 null 或 undefined，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Numeric-Separators"><a href="#4-Numeric-Separators" class="headerlink" title="4. Numeric Separators"></a>4. Numeric Separators</h2><p>数字分隔符（<code>_</code>）允许在数字中使用下划线作为分隔符，以提高数字的可读性。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> billion = <span class="hljs-number">1_000_000_000</span>;<br><span class="hljs-keyword">const</span> hex = <span class="hljs-number">0xFF_FF_FF</span>;<br><span class="hljs-keyword">const</span> binary = <span class="hljs-number">0b1010_1011_1100_1100</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(billion); <span class="hljs-comment">// 1000000000</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hex); <span class="hljs-comment">// 16777215</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binary); <span class="hljs-comment">// 43980</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-WeakRefs"><a href="#5-WeakRefs" class="headerlink" title="5. WeakRefs"></a>5. WeakRefs</h2><p><code>WeakRef</code> 允许你持有对对象的弱引用，这样可以防止引用的对象被垃圾回收。这对实现缓存或其他内存管理方案非常有用。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Weak Reference&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakRef.<span class="hljs-title function_">deref</span>()); <span class="hljs-comment">// &#123; name: &#x27;Weak Reference&#x27; &#125;</span><br><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 允许 obj 被垃圾回收</span><br><br><span class="hljs-comment">// 由于是弱引用，obj 可能会被回收</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakRef.<span class="hljs-title function_">deref</span>()); <span class="hljs-comment">// 可能输出 undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2021（ES12）引入的新特性，如 <code>String.prototype.replaceAll</code>、<code>Promise.any</code>、逻辑赋值运算符、数字分隔符、<code>WeakRefs</code> ，为 JavaScript 的开发提供了更高的灵活性和便利性。这些新特性使得开发者在处理字符串、异步操作、数字表示和数组访问方面变得更加高效。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript11新特性详解</title>
    <link href="/posts/49688/"/>
    <url>/posts/49688/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2020（ES11）新特性详解"><a href="#ECMAScript-2020（ES11）新特性详解" class="headerlink" title="ECMAScript 2020（ES11）新特性详解"></a>ECMAScript 2020（ES11）新特性详解</h1><p>ECMAScript 2020（也称为 ES11）引入了一系列新特性，进一步增强了 JavaScript 的功能和灵活性。主要的新特性包括 <strong>Optional Chaining</strong>、<strong>Nullish Coalescing Operator</strong>、<strong>BigInt</strong>、<strong>Promise.allSettled()<strong>、</strong>globalThis</strong>、<strong>module <code>import.meta</code><strong>、</strong>String.prototype.matchAll</strong> 和 <strong>WeakRefs</strong>。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-Optional-Chaining"><a href="#1-Optional-Chaining" class="headerlink" title="1. Optional Chaining"></a>1. Optional Chaining</h2><p>可选链（Optional Chaining）运算符（<code>?.</code>）使得访问深层嵌套对象的属性变得更安全，避免了因为访问 <code>undefined</code> 或 <code>null</code> 属性而抛出错误。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj?.<span class="hljs-property">prop</span><br>obj?.[expr]<br>obj?.<span class="hljs-title function_">method</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>如果所访问的值存在，则返回该值；如果不存在（为 <code>null</code> 或 <code>undefined</code>），则返回 <code>undefined</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Wonderland&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">address</span>?.<span class="hljs-property">city</span>); <span class="hljs-comment">// &#x27;Wonderland&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">address</span>?.<span class="hljs-property">zip</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">getName</span>?.()); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Nullish-Coalescing-Operator"><a href="#2-Nullish-Coalescing-Operator" class="headerlink" title="2. Nullish Coalescing Operator"></a>2. Nullish Coalescing Operator</h2><p>空值合并运算符（Nullish Coalescing Operator，<code>??</code>）用于返回其右侧操作数的值，当且仅当其左侧操作数为 <code>null</code> 或 <code>undefined</code> 时。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">value1 ?? value2<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回 <code>value1</code>，如果 <code>value1</code> 不是 <code>null</code> 或 <code>undefined</code>；否则返回 <code>value2</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;default string&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// &#x27;default string&#x27;</span><br><br><span class="hljs-keyword">const</span> bar = <span class="hljs-number">0</span> ?? <span class="hljs-number">42</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// 0</span><br><br><span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;&#x27;</span> ?? <span class="hljs-string">&#x27;default string&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-BigInt"><a href="#3-BigInt" class="headerlink" title="3. BigInt"></a>3. BigInt</h2><p>BigInt 提供了一种表示大于 <code>Number.MAX_SAFE_INTEGER</code> 的整数的新数据类型，适用于需要高精度整数计算的场景。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigIntValue = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789012345678901234567890</span>);<br><span class="hljs-keyword">const</span> bigIntValue2 = <span class="hljs-number">123456789012345678901234567890n</span>; <span class="hljs-comment">// 使用 n 后缀</span><br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 BigInt 类型的整数。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigInt1 = <span class="hljs-number">123456789012345678901234567890n</span>;<br><span class="hljs-keyword">const</span> bigInt2 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">12345678901234567890</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigInt1 + bigInt2); <span class="hljs-comment">// 12345678901234567891234567890n</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigInt1 &gt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Promise-allSettled"><a href="#4-Promise-allSettled" class="headerlink" title="4. Promise.allSettled()"></a>4. Promise.allSettled()</h2><p><code>Promise.allSettled()</code> 方法返回一个 Promise，解析为一个对象数组，表示所有给定 Promise 的最终结果（每个 Promise 的状态要么是 fulfilled 要么是 rejected）。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>promises</code>：一个可迭代的 Promise 对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 Promise，当所有给定的 Promise 处理结束后，解析为一个对象数组，每个对象的形状为 <code>&#123; status, value, reason &#125;</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> &#123;<br>    results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">status</span>);<br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Result:&#x27;</span>, result.<span class="hljs-property">value</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, result.<span class="hljs-property">reason</span>);<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-globalThis"><a href="#5-globalThis" class="headerlink" title="5. globalThis"></a>5. globalThis</h2><p><code>globalThis</code> 提供了一个统一的方式来访问全局对象，无论是在浏览器环境还是 Node.js 环境中。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis); <span class="hljs-comment">// 在浏览器中输出 window 对象，在 Node.js 中输出 global 对象</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6-module-import-meta"><a href="#6-module-import-meta" class="headerlink" title="6. module import.meta"></a>6. module <code>import.meta</code></h2><p><code>import.meta</code> 是一个包含模块元数据的对象，主要用于模块内部的信息。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>); <span class="hljs-comment">// 输出当前模块的 URL</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7. String.prototype.matchAll"></a>7. String.prototype.matchAll</h2><p><code>String.prototype.matchAll()</code> 方法返回一个可迭代的匹配对象，包含所有与正则表达式匹配的结果。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">matchAll</span>(regexp)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>regexp</code>：一个正则表达式对象（必须是带有 <code>g</code> 标志的）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个可迭代的对象，每个元素是一个包含匹配结果的数组。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;test1test2test3&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/test(\d)/g</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> str.<span class="hljs-title function_">matchAll</span>(regex)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Matched: <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span>, Group: <span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>]&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Matched: test1, Group: 1</span><br><span class="hljs-comment">// Matched: test2, Group: 2</span><br><span class="hljs-comment">// Matched: test3, Group: 3</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2020（ES11）引入的新特性，如 Optional Chaining、Nullish Coalescing Operator、BigInt、Promise.allSettled()、globalThis、module <code>import.meta</code>、String.prototype.matchAll，为 JavaScript 的开发提供了更高的灵活性和便利性。这些新特性使得开发者在处理数据、管理异步操作和优化内存方面变得更加高效。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript10新特性详解</title>
    <link href="/posts/21209/"/>
    <url>/posts/21209/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2019（ES10）新特性详解"><a href="#ECMAScript-2019（ES10）新特性详解" class="headerlink" title="ECMAScript 2019（ES10）新特性详解"></a>ECMAScript 2019（ES10）新特性详解</h1><p>ECMAScript 2019（也称为 ES10）引入了一些实用的新特性，增强了 JavaScript 的功能和可用性。主要的新特性包括 <strong>Array.prototype.flat()<strong>、</strong>Array.prototype.flatMap()<strong>、</strong>Object.fromEntries()<strong>、</strong>String.prototype.trimStart()</strong> 和 **String.prototype.trimEnd()**。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-flat"><a href="#1-Array-prototype-flat" class="headerlink" title="1. Array.prototype.flat()"></a>1. Array.prototype.flat()</h2><p><code>Array.prototype.flat()</code> 方法用于将嵌套的数组“拉平”，将多维数组转换为一维数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">flat</span>([depth])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>depth</code>（可选）：一个整数，表示要拉平的嵌套数组的深度。默认值为 <code>1</code>。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新数组，包含拉平后的元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>()); <span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Array-prototype-flatMap"><a href="#2-Array-prototype-flatMap" class="headerlink" title="2. Array.prototype.flatMap()"></a>2. Array.prototype.flatMap()</h2><p><code>Array.prototype.flatMap()</code> 方法首先映射每个元素，然后将结果扁平化为一个新数组。它是 <code>map()</code> 和 <code>flat()</code> 的组合。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">flatMap</span>(<span class="hljs-title function_">callback</span>(currentValue[, index[, array]])[, thisArg])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="hljs">callback<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>    ：用于生成数组的函数，接受以下参数：<br><br>    - `currentValue`：当前处理的元素。<br>    - `index`（可选）：当前处理元素的索引。<br>    - `array`（可选）：调用 `flatMap` 的数组。<br><br>  - `thisArg`（可选）：执行 `callback` 函数时，用作 `this` 的值。<br><br><span class="hljs-title">- **返回值**:</span><br><br>  - 返回一个新数组，包含通过 `callback` 处理的每个元素，并拉平一层。<br><br><span class="hljs-title">- **用法示例**:</span><br><br>  ```javascript<br>  const array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-comment">;</span><br>  <br>  const result = array.flatMap(x =&gt; [x, x * <span class="hljs-number">2</span>])<span class="hljs-comment">;</span><br>  console.log(result)<span class="hljs-comment">; // [1, 2, 2, 4, 3, 6, 4, 8]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="3-Object-fromEntries"><a href="#3-Object-fromEntries" class="headerlink" title="3. Object.fromEntries()"></a>3. Object.fromEntries()</h2><p><code>Object.fromEntries()</code> 方法将一个键值对的列表转换为一个对象。这可以用于将 Map 或其他包含键值对的数据结构转换为对象。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(iterable)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>iterable</code>：一个可迭代对象，其中每个元素都是一个长度为 2 的数组，表示键值对。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新对象，包含转换后的键值对。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>],<br>    [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>]<br>]);<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(entries);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; name: &#x27;John&#x27;, age: 30 &#125;</span><br><br><span class="hljs-keyword">const</span> array = [[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>], [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>]];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(array)); <span class="hljs-comment">// &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-String-prototype-trimStart"><a href="#4-String-prototype-trimStart" class="headerlink" title="4. String.prototype.trimStart()"></a>4. String.prototype.trimStart()</h2><p><code>String.prototype.trimStart()</code> 方法用于删除字符串开头的空白字符（空格、制表符等）。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">trimStart</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的字符串，去除了开头的空白字符。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;   Hello, World!   &#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimStart</span>()); <span class="hljs-comment">// &#x27;Hello, World!   &#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-String-prototype-trimEnd"><a href="#5-String-prototype-trimEnd" class="headerlink" title="5. String.prototype.trimEnd()"></a>5. String.prototype.trimEnd()</h2><p><code>String.prototype.trimEnd()</code> 方法用于删除字符串结尾的空白字符。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">trimEnd</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的字符串，去除了结尾的空白字符。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;   Hello, World!   &#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimEnd</span>()); <span class="hljs-comment">// &#x27;   Hello, World!&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2019（ES10）引入的这些新特性，如 <code>Array.prototype.flat()</code>、<code>Array.prototype.flatMap()</code>、<code>Object.fromEntries()</code>、<code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code>，显著提高了 JavaScript 的功能和可读性。它们使得处理数组、对象和字符串变得更加方便和直观，帮助开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript9新特性详解</title>
    <link href="/posts/29004/"/>
    <url>/posts/29004/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2018（ES9）新特性详解"><a href="#ECMAScript-2018（ES9）新特性详解" class="headerlink" title="ECMAScript 2018（ES9）新特性详解"></a>ECMAScript 2018（ES9）新特性详解</h1><p>ECMAScript 2018（也称为 ES9）引入了一些新的特性和改进，使得 JavaScript 更加强大和灵活。下面将详细介绍 ES9 的主要新特性，包括：<strong>异步迭代器（Async Iterators）</strong>、<strong>Promise.prototype.finally()<strong>、</strong>扩展对象（Spread Properties）</strong> 和 <strong>正则表达式的改进</strong>。每个特性都会包含 API 说明、参数、返回值及用法示例。</p><h1 id="1-异步迭代器（Async-Iterators）"><a href="#1-异步迭代器（Async-Iterators）" class="headerlink" title="1. 异步迭代器（Async Iterators）"></a>1. 异步迭代器（Async Iterators）</h1><p>异步迭代器允许你在处理异步数据时使用 <code>for await...of</code> 循环。这样可以方便地处理异步操作，尤其是在处理网络请求、文件读取等场景中。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> asyncIterable) &#123;<br>    <span class="hljs-comment">// 处理每个 item</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>没有返回值。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 模拟异步操作</span><br>        <span class="hljs-keyword">yield</span> item;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processAsyncData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-title function_">asyncGenerator</span>()) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出 &#x27;a&#x27;，&#x27;b&#x27;，&#x27;c&#x27; 每隔 1 秒</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processAsyncData</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-1-示例剖析"><a href="#1-1-示例剖析" class="headerlink" title="1.1 示例剖析"></a>1.1 <strong>示例剖析</strong></h2><h3 id="1-异步生成器函数"><a href="#1-异步生成器函数" class="headerlink" title="1. 异步生成器函数"></a>1. 异步生成器函数</h3><p>首先，异步生成器是一个函数，可以使用 <code>async function*</code> 声明。异步生成器的特点是可以使用 <code>await</code> 关键字，并且使用 <code>yield</code> 返回多个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 模拟异步操作</span><br>        <span class="hljs-keyword">yield</span> item; <span class="hljs-comment">// 暂停执行并返回当前 item</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong><code>async function\*</code></strong>: 声明一个异步生成器函数。</li><li><strong><code>yield</code></strong>: 用于暂停函数的执行，并返回一个值给调用者。</li><li><strong><code>await</code></strong>: 可以在异步生成器中使用，以等待异步操作完成。</li></ul><h3 id="2-异步迭代器"><a href="#2-异步迭代器" class="headerlink" title="2. 异步迭代器"></a>2. 异步迭代器</h3><p>当你调用异步生成器函数（如 <code>asyncGenerator()</code>）时，它返回一个异步迭代器。这个迭代器可以通过 <code>next()</code> 方法逐步获取值。</p><ul><li><strong><code>next()</code> 方法</strong>: 返回一个 Promise，该 Promise 的 <code>value</code> 属性是生成器 <code>yield</code> 返回的值，<code>done</code> 属性指示生成器是否已完成。</li></ul><h3 id="3-for-await-of-语句"><a href="#3-for-await-of-语句" class="headerlink" title="3. for await...of 语句"></a>3. <code>for await...of</code> 语句</h3><p><code>for await...of</code> 是一个用于遍历异步迭代器的语句。它可以处理异步操作，使得代码更易于阅读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processAsyncData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-title function_">asyncGenerator</span>()) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 每隔 1 秒输出 &#x27;a&#x27;，&#x27;b&#x27;，&#x27;c&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong>自动调用 <code>next()</code></strong>: 在循环中，<code>for await...of</code> 会自动调用异步生成器的 <code>next()</code> 方法，获取生成器的下一个值。</li><li><strong>异步等待</strong>: 在调用 <code>next()</code> 时，如果生成器还未到达下一个 <code>yield</code>，则会等待直到异步操作完成，获取到值后继续执行循环。</li><li><strong>停止条件</strong>: 当生成器完成（即没有更多的值可以 <code>yield</code>），<code>done</code> 会变为 <code>true</code>，循环会自动停止。</li></ul><h3 id="4-详细流程"><a href="#4-详细流程" class="headerlink" title="4. 详细流程"></a>4. 详细流程</h3><p>让我们详细分析执行 <code>processAsyncData</code> 的流程：</p><ol><li><strong>调用 <code>asyncGenerator()</code></strong>: 这会创建一个异步生成器对象，准备生成值。</li><li><strong>进入 <code>for await...of</code> 循环</strong>: 这时，循环开始，准备处理从异步生成器获取的值。</li><li><strong>第一次迭代</strong>:<ul><li><code>next()</code> 被自动调用。</li><li>在 <code>asyncGenerator</code> 中，执行到第一个 <code>await</code>，即 <code>await new Promise(...)</code>，此时会暂停执行。</li><li>等待 1 秒后，Promise 被解决，执行到 <code>yield item</code>，返回 <code>&#39;a&#39;</code>。</li><li><code>for await...of</code> 接收到这个值，赋值给 <code>value</code>，并执行 <code>console.log(value)</code>，输出 <code>&#39;a&#39;</code>。</li></ul></li><li><strong>第二次迭代</strong>:<ul><li>再次自动调用 <code>next()</code>。</li><li>同样地，执行到 <code>await</code>，暂停 1 秒后返回 <code>&#39;b&#39;</code>，并输出。</li></ul></li><li><strong>第三次迭代</strong>:<ul><li>继续执行，返回 <code>&#39;c&#39;</code>。</li></ul></li><li><strong>结束</strong>:<ul><li>当没有更多的值可 <code>yield</code> 时，异步生成器完成，<code>next()</code> 返回一个 <code>done</code> 为 <code>true</code> 的对象，循环结束。</li></ul></li></ol><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><code>async function*</code> 创建异步生成器，可以在其中使用 <code>await</code> 和 <code>yield</code>。</li><li><code>for await...of</code> 语句用于遍历异步生成器，自动处理 <code>next()</code> 调用和异步等待。</li><li>这使得异步操作的控制流更为简单和清晰，避免了手动处理 Promise 的复杂性。</li></ul><h1 id="2-Promise-prototype-finally"><a href="#2-Promise-prototype-finally" class="headerlink" title="2. Promise.prototype.finally()"></a>2. Promise.prototype.finally()</h1><p><code>Promise.prototype.finally()</code> 方法为 Promise 提供了一个清理功能，允许你在 Promise 解决或拒绝后执行一段代码。这对于进行一些清理操作（例如关闭加载指示器）非常有用。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise.<span class="hljs-title function_">finally</span>(onFinally);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>onFinally</code>: 一个可选的回调函数，在 Promise 解决或拒绝后执行。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的 Promise，其结果与原 Promise 相同。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据获取成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 输出: 数据获取成功</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;发生错误:&#x27;</span>, error);<br>    &#125;)<br>    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;清理操作&#x27;</span>); <span class="hljs-comment">// 不论成功或失败都会执行</span><br>    &#125;);<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-扩展对象（Spread-Properties）"><a href="#3-扩展对象（Spread-Properties）" class="headerlink" title="3. 扩展对象（Spread Properties）"></a>3. 扩展对象（Spread Properties）</h1><p>扩展对象语法允许我们使用扩展运算符（<code>...</code>）在对象字面量中复制属性。这使得对象的合并和克隆更加简洁。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newObject = &#123; ...obj1, ...obj2 &#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj1</code>, <code>obj2</code>: 要合并的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新对象，包含所有合并后的属性。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">4</span> &#125;;<br><span class="hljs-keyword">const</span> merged = &#123; ...obj1, ...obj2 &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(merged); <span class="hljs-comment">// 输出: &#123; a: 1, b: 3, c: 4 &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="4-正则表达式的改进"><a href="#4-正则表达式的改进" class="headerlink" title="4. 正则表达式的改进"></a>4. 正则表达式的改进</h1><p>ES9 对正则表达式进行了增强，新增了两个主要功能：<strong>命名捕获组</strong>和<strong>s（dotAll）标志</strong>。</p><h2 id="4-1-命名捕获组"><a href="#4-1-命名捕获组" class="headerlink" title="4.1 命名捕获组"></a>4.1 命名捕获组</h2><p>使用命名捕获组可以更容易地从正则表达式中提取信息。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?&lt;name&gt;pattern)/</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>捕获组的命名可以通过 <code>groups</code> 属性访问。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?&lt;firstName&gt;\w+) (?&lt;lastName&gt;\w+)/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;John Doe&#x27;</span>;<br><span class="hljs-keyword">const</span> result = regex.<span class="hljs-title function_">exec</span>(str);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">groups</span>.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// 输出: John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">groups</span>.<span class="hljs-property">lastName</span>); <span class="hljs-comment">// 输出: Doe</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-2-s（dotAll）标志"><a href="#4-2-s（dotAll）标志" class="headerlink" title="4.2 s（dotAll）标志"></a>4.2 s（dotAll）标志</h2><p><code>s</code> 标志使得点号 <code>.</code> 可以匹配换行符，这对于多行字符串的匹配非常有用。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/.*?/</span>s; <span class="hljs-comment">// 点号可以匹配换行符</span><br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> text = <span class="hljs-string">`Hello\nWorld`</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/Hello.*World/</span>s;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(text)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ECMAScript 2018（ES9）引入的这些新特性，极大地增强了 JavaScript 处理异步操作、对象合并、正则表达式等方面的能力。它们使得代码更加简洁和易于维护，帮助开发者更高效地完成任务。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript8新特性详解</title>
    <link href="/posts/57741/"/>
    <url>/posts/57741/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2017（ES8）新特性详解"><a href="#ECMAScript-2017（ES8）新特性详解" class="headerlink" title="ECMAScript 2017（ES8）新特性详解"></a>ECMAScript 2017（ES8）新特性详解</h1><p>ECMAScript 2017（也称为 ES8）引入了多个新的特性，其中最主要的有：**<code>async/await</code>** 语法、**<code>Object.entries()</code>** 和 <strong><code>Object.values()</code></strong> 方法、以及 <strong><code>String.prototype.padStart()</code></strong> 和 <strong><code>String.prototype.padEnd()</code></strong> 方法。下面将详细介绍这些新特性。</p><h1 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async&#x2F;await"></a>1. async&#x2F;await</h1><p><code>async/await</code> 语法用于简化基于 Promise 的异步编程，使异步代码的写法更接近同步代码的风格。</p><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p><code>async/await</code> 是 ECMAScript 2017（ES8）引入的一种语法，用于简化基于 Promise 的异步编程。它使得异步代码的书写方式更接近于同步代码，从而提高了代码的可读性和可维护性。</p><h2 id="1-2-async-函数"><a href="#1-2-async-函数" class="headerlink" title="1.2 async 函数"></a>1.2 async 函数</h2><ul><li><strong>定义</strong>: 使用 <code>async</code> 关键字定义的函数被称为异步函数，返回一个 Promise 对象。</li><li><strong>返回值</strong>: 如果异步函数内部有 <code>return</code> 语句，则该值会被包装成一个 resolved 的 Promise。如果没有 <code>return</code> 语句，则默认返回一个 resolved 状态的 Promise，值为 <code>undefined</code>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 实际上返回的是 Promise.resolve(42)</span><br>&#125;<br><br><span class="hljs-title function_">example</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h2 id="1-3-await-表达式"><a href="#1-3-await-表达式" class="headerlink" title="1.3 await 表达式"></a>1.3 await 表达式</h2><ul><li><strong>定义</strong>: <code>await</code> 关键字用于等待一个 Promise 的结果，它只能在 <code>async</code> 函数内部使用。</li><li><strong>功能</strong>: <code>await</code> 会暂停 <code>async</code> 函数的执行，直到 Promise 被解决（resolved）或拒绝（rejected）。当 Promise 被解决时，<code>await</code> 表达式返回该 Promise 的结果；当 Promise 被拒绝时，<code>await</code> 表达式会抛出错误。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)); <span class="hljs-comment">// 打印获取到的数据</span><br></code></pre></td></tr></table></figure><h2 id="1-4-错误处理"><a href="#1-4-错误处理" class="headerlink" title="1.4 错误处理"></a>1.4 错误处理</h2><p>在使用 <code>async/await</code> 时，可以使用 <code>try/catch</code> 语句块来处理错误。<code>await</code> 抛出的任何错误都可以在 <code>catch</code> 中捕获。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchDataWithErrorHandling</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>);<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取数据时出错:&#x27;</span>, error);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchDataWithErrorHandling</span>();<br></code></pre></td></tr></table></figure><h2 id="1-5-串行与并行处理"><a href="#1-5-串行与并行处理" class="headerlink" title="1.5 串行与并行处理"></a>1.5 串行与并行处理</h2><ul><li><p><strong>串行处理</strong>: 如果多个异步操作之间存在依赖关系，可以逐个使用 <code>await</code> 进行串行处理。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">serialExecution</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataFromAPI1</span>();<br>    <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataFromAPI2</span>(result1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>并行处理</strong>: 对于没有依赖关系的多个异步操作，可以使用 <code>Promise.all()</code> 来实现并行处理。这样可以提高性能。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parallelExecution</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">fetchDataFromAPI1</span>();<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">fetchDataFromAPI2</span>();<br>    <span class="hljs-keyword">const</span> [result1, result2] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1, result2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h2><ul><li><code>async/await</code> 是一种简化异步编程的语法，使得异步代码看起来像同步代码。</li><li><code>async</code> 关键字用于定义异步函数，返回一个 Promise。</li><li><code>await</code> 关键字用于等待 Promise 的结果，暂停函数的执行。</li><li>错误可以通过 <code>try/catch</code> 进行处理。</li><li>支持串行和并行处理，可以提高代码的性能和可读性。</li></ul><h1 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2. Object.entries()"></a>2. Object.entries()</h1><p><code>Object.entries()</code> 方法返回一个给定对象自身可枚举属性的键值对数组。该数组中的每个元素都是一个数组，其中包含两个元素：属性名和属性值。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要查询的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个数组，数组的每个元素是一个包含对象自身可枚举属性的键值对数组。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">const</span> entries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries); <br><span class="hljs-comment">// [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="3-Object-values"><a href="#3-Object-values" class="headerlink" title="3. Object.values()"></a>3. Object.values()</h1><p><code>Object.values()</code> 方法返回一个给定对象自身可枚举属性值的数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要查询的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个数组，数组中的元素是对象自身可枚举属性的值。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">const</span> values = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="4-String-prototype-padStart"><a href="#4-String-prototype-padStart" class="headerlink" title="4. String.prototype.padStart()"></a>4. String.prototype.padStart()</h1><p><code>String.prototype.padStart()</code> 方法用于在当前字符串的开头填充指定的字符，以达到给定的总长度。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">padStart</span>(targetLength [, padString])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>targetLength</code>: 返回的字符串所需的长度。</li><li><code>padString</code>（可选）: 填充字符串，默认为空格。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回填充后的字符串。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;5&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">// &#x27;05&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// &#x27;12312&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-String-prototype-padEnd"><a href="#5-String-prototype-padEnd" class="headerlink" title="5. String.prototype.padEnd()"></a>5. String.prototype.padEnd()</h1><p><code>String.prototype.padEnd()</code> 方法用于在当前字符串的结尾填充指定的字符，以达到给定的总长度。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">padEnd</span>(targetLength [, padString])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>targetLength</code>: 返回的字符串所需的长度。</li><li><code>padString</code>（可选）: 填充字符串，默认为空格。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回填充后的字符串。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;5&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">// &#x27;50&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// &#x27;5abc&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ECMAScript 2017（ES8）引入的新特性如 <code>async/await</code> 语法、<code>Object.entries()</code>、<code>Object.values()</code>、<code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code>，极大地增强了 JavaScript 的可用性和可读性。这些特性使得异步编程、对象操作和字符串处理变得更加简洁高效，有助于开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript7新特性详解</title>
    <link href="/posts/5576/"/>
    <url>/posts/5576/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2016（ES7）新特性详解"><a href="#ECMAScript-2016（ES7）新特性详解" class="headerlink" title="ECMAScript 2016（ES7）新特性详解"></a>ECMAScript 2016（ES7）新特性详解</h1><p>ECMAScript 2016（也称为 ES7）是 ECMAScript 的一个小版本更新，主要引入了两个新特性：**<code>Array.prototype.includes()</code>** 和 <strong>指数运算符（<code>\**</code>）</strong>。下面将详细介绍这两个新特性，包含 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a>1. Array.prototype.includes()</h2><p><code>Array.prototype.includes()</code> 方法用于判断数组是否包含特定的元素，返回一个布尔值。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">includes</span>(valueToFind[, fromIndex])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li>valueToFind: 要查找的值，可以是任何数据类型。</li><li>fromIndex: （可选）从该索引开始搜索。默认值为 <code>0</code>。如果为负值，则表示从数组末尾开始查找。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>如果数组包含 <code>valueToFind</code>，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-title class_">NaN</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-指数运算符（Exponentiation-Operator）"><a href="#2-指数运算符（Exponentiation-Operator）" class="headerlink" title="2. 指数运算符（Exponentiation Operator）"></a>2. 指数运算符（Exponentiation Operator）</h2><p>指数运算符（<code>**</code>）提供了一种简洁的方式来进行幂运算，相比于 <code>Math.pow()</code>，语法更为直观。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">base ** exponent<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li>base: 基数，可以是任何数字或表达式。</li><li>exponent: 指数，可以是任何数字（包括负数、零或小数）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回 <code>base</code> 的 <code>exponent</code> 次幂。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>); <span class="hljs-comment">// 8</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 9</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span> ** <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)); <span class="hljs-comment">// 512</span><br><br><span class="hljs-keyword">let</span> base = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> exponent = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(base ** exponent); <span class="hljs-comment">// 125</span><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((a + b) ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2016（ES7）引入的两个新特性，<code>Array.prototype.includes()</code> 和 指数运算符（<code>**</code>），提升了 JavaScript 的可用性和可读性。这些新特性使得数组包含检查和数学运算变得更加简洁，帮助开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript从基础到进阶</title>
    <link href="/posts/26356/"/>
    <url>/posts/26356/</url>
    
    <content type="html"><![CDATA[<h1 id="全面掌握-TypeScript：从基础到进阶"><a href="#全面掌握-TypeScript：从基础到进阶" class="headerlink" title="全面掌握 TypeScript：从基础到进阶"></a>全面掌握 TypeScript：从基础到进阶</h1><p>TypeScript 是 JavaScript 的一个超集，它增加了静态类型检查和最新的 ES 功能，帮助我们构建更可维护、更健壮的代码。本文将深入探讨 TypeScript 的所有关键知识点，从基础语法到高级用法。</p><hr><h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><p>TypeScript 是由 Microsoft 开发的编程语言，它增加了静态类型，支持最新的 ECMAScript 标准，拥有更好的代码提示和重构能力，特别适合中大型项目开发。</p><hr><h2 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="2. 安装与配置"></a>2. 安装与配置</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g typescript<br></code></pre></td></tr></table></figure><h3 id="创建-tsconfig-json"><a href="#创建-tsconfig-json" class="headerlink" title="创建 tsconfig.json"></a>创建 <code>tsconfig.json</code></h3><p>可以使用 <code>tsc --init</code> 命令生成项目的配置文件 <code>tsconfig.json</code>，在其中设置编译选项和路径。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-基本类型"><a href="#3-基本类型" class="headerlink" title="3. 基本类型"></a>3. 基本类型</h2><p>TypeScript 提供了多种基本数据类型，与 JavaScript 相似，同时增加了静态类型检查。</p><h3 id="基本类型示例"><a href="#基本类型示例" class="headerlink" title="基本类型示例"></a>基本类型示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;John Doe&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">42</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;  <span class="hljs-comment">// `any` 可以被赋值为任何类型</span><br></code></pre></td></tr></table></figure><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li><code>null</code> 和 <code>undefined</code> 也是 TypeScript 中的基本类型。</li><li><code>void</code> 表示函数没有返回值。</li><li><code>never</code> 表示不可能存在的类型，通常用于抛出错误的函数。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-接口（Interfaces）"><a href="#4-接口（Interfaces）" class="headerlink" title="4. 接口（Interfaces）"></a>4. 接口（Interfaces）</h2><p>接口用于定义对象的结构，确保类或对象符合某些规则。</p><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">john</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="可选属性和只读属性"><a href="#可选属性和只读属性" class="headerlink" title="可选属性和只读属性"></a>可选属性和只读属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可选属性</span><br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 只读属性</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-类（Classes）"><a href="#5-类（Classes）" class="headerlink" title="5. 类（Classes）"></a>5. 类（Classes）</h2><p>TypeScript 的类提供了面向对象的特性，比如继承、访问控制修饰符等。</p><h3 id="基本类的定义"><a href="#基本类的定义" class="headerlink" title="基本类的定义"></a>基本类的定义</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> speaks`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承与访问修饰符"><a href="#继承与访问修饰符" class="headerlink" title="继承与访问修饰符"></a>继承与访问修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-函数（Functions）"><a href="#6-函数（Functions）" class="headerlink" title="6. 函数（Functions）"></a>6. 函数（Functions）</h2><h3 id="函数参数类型与返回类型"><a href="#函数参数类型与返回类型" class="headerlink" title="函数参数类型与返回类型"></a>函数参数类型与返回类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Hello&quot;</span></span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">timestamp: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">year: <span class="hljs-built_in">number</span>, month: <span class="hljs-built_in">number</span>, day: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">yearOrTimestamp: <span class="hljs-built_in">number</span>, month?: <span class="hljs-built_in">number</span>, day?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span> &#123;<br>  <span class="hljs-keyword">if</span> (month !== <span class="hljs-literal">undefined</span> &amp;&amp; day !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(yearOrTimestamp, month - <span class="hljs-number">1</span>, day);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(yearOrTimestamp);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-泛型（Generics）"><a href="#7-泛型（Generics）" class="headerlink" title="7. 泛型（Generics）"></a>7. 泛型（Generics）</h2><p>泛型用于创建复用性更高的代码，适用于类、接口和函数。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> &#125;&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-类型推断与类型兼容性"><a href="#8-类型推断与类型兼容性" class="headerlink" title="8. 类型推断与类型兼容性"></a>8. 类型推断与类型兼容性</h2><p>TypeScript 可以推断变量类型，也支持类型之间的兼容性检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// TypeScript 会自动推断 `str` 为 `string`</span><br></code></pre></td></tr></table></figure><hr><h2 id="9-高级类型"><a href="#9-高级类型" class="headerlink" title="9. 高级类型"></a>9. 高级类型</h2><h3 id="交叉类型和联合类型"><a href="#交叉类型和联合类型" class="headerlink" title="交叉类型和联合类型"></a>交叉类型和联合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fish</span> = &#123; <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Bird</span> = &#123; <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FishOrBird</span> = <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span>;<br></code></pre></td></tr></table></figure><h3 id="映射类型与条件类型"><a href="#映射类型与条件类型" class="headerlink" title="映射类型与条件类型"></a>映射类型与条件类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="10-模块与命名空间"><a href="#10-模块与命名空间" class="headerlink" title="10. 模块与命名空间"></a>10. 模块与命名空间</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>TypeScript 支持模块化，通过 <code>import</code> 和 <code>export</code> 来导入和导出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// math.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Shapes</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> radius: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shapes</span>.<span class="hljs-title class_">Circle</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="11-装饰器（Decorators）"><a href="#11-装饰器（Decorators）" class="headerlink" title="11. 装饰器（Decorators）"></a>11. 装饰器（Decorators）</h2><p>装饰器用于增强类或类成员的行为，常用于依赖注入和日志记录等功能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Log</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> called`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-meta">@Log</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="12-TypeScript-工具与配置"><a href="#12-TypeScript-工具与配置" class="headerlink" title="12. TypeScript 工具与配置"></a>12. TypeScript 工具与配置</h2><h3 id="使用-tsconfig-json-配置项目"><a href="#使用-tsconfig-json-配置项目" class="headerlink" title="使用 tsconfig.json 配置项目"></a>使用 tsconfig.json 配置项目</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="13-TypeScript-实践：最佳实践与代码规范"><a href="#13-TypeScript-实践：最佳实践与代码规范" class="headerlink" title="13. TypeScript 实践：最佳实践与代码规范"></a>13. TypeScript 实践：最佳实践与代码规范</h2><ul><li><strong>使用严格模式</strong>：启用 <code>strict</code> 以确保代码的类型安全。</li><li><strong>避免使用 <code>any</code> 类型</strong>：<code>any</code> 会削弱类型检查，尽量使用具体类型。</li><li><strong>保持函数纯粹</strong>：在编写函数时，避免不必要的副作用。</li><li><strong>定义清晰的接口</strong>：使用接口来定义数据结构，使代码更具可读性。</li></ul><hr><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>TypeScript 是一门非常强大且实用的语言。通过掌握 TypeScript，您可以编写更加高效、健壮的 JavaScript 代码，并大幅提高团队开发效率。希望本文能为您全面了解 TypeScript 提供帮助！</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocos-Creator中SpriteFrame和Texture的区别</title>
    <link href="/posts/32972/"/>
    <url>/posts/32972/</url>
    
    <content type="html"><![CDATA[<h2 id="Cocos-Creator-中-SpriteFrame-和-Texture-的区别及其在-UI-开发中的重要性"><a href="#Cocos-Creator-中-SpriteFrame-和-Texture-的区别及其在-UI-开发中的重要性" class="headerlink" title="Cocos Creator 中 SpriteFrame 和 Texture 的区别及其在 UI 开发中的重要性"></a>Cocos Creator 中 SpriteFrame 和 Texture 的区别及其在 UI 开发中的重要性</h2><p>在 Cocos Creator 的开发过程中，理解 <code>SpriteFrame</code> 和 <code>Texture</code> 之间的区别是至关重要的，特别是在 UI 开发中。本文将详细讨论这两者的定义、特性及其在实际开发中的应用，尤其是 <code>SpriteFrame</code> 在性能和资源管理方面的优势。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>Texture</strong>：<code>Texture</code> 是 GPU 渲染所使用的基本图像数据，包含了颜色信息和其他绘制相关的数据。开发者通常直接与纹理打交道，并需要手动管理内存，包括加载和卸载纹理。</p><p><strong>SpriteFrame</strong>：<code>SpriteFrame</code> 是 Cocos Creator 中对 <code>Texture</code> 的一种封装，包含了对 <code>Texture</code> 的引用以及一些额外的信息（如锚点、变换等）。<code>SpriteFrame</code> 更加适合用于 <code>Sprite</code> 组件，因为它在使用时提供了更多的灵活性。</p><h3 id="2-渲染流程"><a href="#2-渲染流程" class="headerlink" title="2. 渲染流程"></a>2. 渲染流程</h3><p>理解 Cocos Creator 中的渲染流程有助于更好地使用 <code>SpriteFrame</code> 和 <code>Texture</code>。一般来说，渲染流程如下：</p><ol><li><strong>加载资源</strong>：当加载 <code>SpriteFrame</code> 时，Cocos Creator 会自动处理纹理的加载。如果使用 <code>Texture</code>，开发者需要手动加载和释放纹理。</li><li><strong>渲染准备</strong>：<code>SpriteFrame</code> 包含的纹理会被添加到渲染队列中，Cocos Creator 会根据需要自动调整纹理的状态。</li><li><strong>渲染</strong>：渲染引擎将使用 <code>SpriteFrame</code> 中的纹理进行绘制，绘制时会考虑锚点、缩放等属性。</li><li><strong>资源管理</strong>：当 <code>SpriteFrame</code> 不再使用时，Cocos Creator 会自动卸载不再需要的纹理，避免内存泄漏。而使用 <code>Texture</code> 时，开发者必须手动卸载纹理。</li></ol><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h3><h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><ul><li>使用 <code>Texture</code> 时，开发者需要手动管理纹理的加载和卸载，这可能会导致内存浪费和潜在的内存泄漏。</li><li>使用 <code>SpriteFrame</code> 时，Cocos Creator 会自动处理纹理的生命周期，开发者不需要担心手动释放资源。</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li><strong>合批渲染</strong>：当使用 <code>SpriteFrame</code> 并且多个 <code>Sprite</code> 共享同一张图集时，可以实现合批渲染（Batching）。合批渲染允许 Cocos Creator 在单个绘制调用中渲染多个精灵，显著提高渲染性能。由于减少了 CPU 与 GPU 之间的交互次数，这种方式能够显著提升渲染效率，从而降低绘制调用的开销。</li><li><strong>自动管理</strong>：Cocos Creator 在使用 <code>SpriteFrame</code> 时，会自动处理纹理的加载和卸载，从而优化内存使用和渲染性能。相比之下，直接使用 <code>Texture</code> 可能需要手动管理纹理，这容易导致性能下降。</li></ul><h3 id="4-UI-开发中的应用"><a href="#4-UI-开发中的应用" class="headerlink" title="4. UI 开发中的应用"></a>4. UI 开发中的应用</h3><p>在 UI 开发中，通常使用 <code>SpriteFrame</code>，原因如下：</p><ul><li><strong>便捷性</strong>：<code>SpriteFrame</code> 提供了额外的属性和方法，方便开发者进行 UI 相关的操作，如设置锚点和调整图像的显示。</li><li><strong>性能</strong>：<code>SpriteFrame</code> 在渲染时会更高效，因为 Cocos Creator 能够在后台自动处理纹理的管理，减少了手动操作带来的复杂性和潜在的错误。此外，合批渲染的优势使得多个 UI 元素在同一帧中被渲染时更加高效。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><h4 id="SpriteFrame-的应用场景："><a href="#SpriteFrame-的应用场景：" class="headerlink" title="SpriteFrame 的应用场景："></a>SpriteFrame 的应用场景：</h4><ul><li><strong>UI 元素</strong>：用于按钮、图标、背景等 UI 元素的渲染，因其便捷性和性能优化。</li><li><strong>动画精灵</strong>：在角色动画中，使用 <code>SpriteFrame</code> 可以方便地处理精灵的切换。</li><li><strong>图集使用</strong>：使用 <code>SpriteFrame</code> 时，可以很方便地使用图集，并实现合批渲染，提升渲染效率。</li></ul><h4 id="Texture-的应用场景："><a href="#Texture-的应用场景：" class="headerlink" title="Texture 的应用场景："></a>Texture 的应用场景：</h4><ul><li><strong>特殊效果</strong>：用于一些特殊的渲染效果或 Shader，需要直接对纹理数据进行操作的场景。</li><li><strong>不频繁更新的纹理</strong>：如果纹理较为静态，不需要频繁更新，也可以考虑直接使用 <code>Texture</code>，以避免额外的封装开销。</li><li><strong>大纹理或视频</strong>：某些大纹理或视频流可能直接需要使用 <code>Texture</code> 来满足性能需求。</li></ul><h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><h4 id="使用-SpriteFrame"><a href="#使用-SpriteFrame" class="headerlink" title="使用 SpriteFrame"></a>使用 SpriteFrame</h4><p>以下是一个使用 <code>SpriteFrame</code> 加载和设置的代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cc.<span class="hljs-title class_">Class</span>(&#123;<br>    <span class="hljs-attr">extends</span>: cc.<span class="hljs-property">Component</span>,<br><br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">spriteFrame</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">SpriteFrame</span>,<br>        &#125;,<br>        <span class="hljs-attr">sprite</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Sprite</span>,<br>        &#125;,<br>    &#125;,<br><br>    <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 加载 SpriteFrame</span><br>        cc.<span class="hljs-property">loader</span>.<span class="hljs-title function_">loadRes</span>(<span class="hljs-string">&quot;path/to/your/image&quot;</span>, cc.<span class="hljs-property">SpriteFrame</span>, <span class="hljs-function">(<span class="hljs-params">err, spriteFrame</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (err) &#123;<br>                cc.<span class="hljs-title function_">error</span>(err);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteFrame</span> = spriteFrame; <span class="hljs-comment">// 保存 SpriteFrame</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sprite</span>.<span class="hljs-property">spriteFrame</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteFrame</span>; <span class="hljs-comment">// 设置为 Sprite 的 SpriteFrame</span><br>        &#125;);<br>    &#125;,<br><br>    <span class="hljs-comment">// onDestroy 方法不再需要手动释放资源</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="使用-Texture"><a href="#使用-Texture" class="headerlink" title="使用 Texture"></a>使用 Texture</h4><p>如果直接使用 <code>Texture</code>，手动管理的示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cc.<span class="hljs-title class_">Class</span>(&#123;<br>    <span class="hljs-attr">extends</span>: cc.<span class="hljs-property">Component</span>,<br><br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">texture</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Texture2D</span>,<br>        &#125;,<br>        <span class="hljs-attr">sprite</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Sprite</span>,<br>        &#125;,<br>    &#125;,<br><br>    <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 加载 Texture</span><br>        cc.<span class="hljs-property">loader</span>.<span class="hljs-title function_">loadRes</span>(<span class="hljs-string">&quot;path/to/your/image&quot;</span>, cc.<span class="hljs-property">Texture2D</span>, <span class="hljs-function">(<span class="hljs-params">err, texture</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (err) &#123;<br>                cc.<span class="hljs-title function_">error</span>(err);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span> = texture; <span class="hljs-comment">// 保存 Texture</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sprite</span>.<span class="hljs-property">spriteFrame</span> = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">SpriteFrame</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>); <span class="hljs-comment">// 将 Texture 转换为 SpriteFrame</span><br>        &#125;);<br>    &#125;,<br><br>    <span class="hljs-title function_">onDestroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 手动卸载纹理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>.<span class="hljs-title function_">destroy</span>();<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 防止悬空引用</span><br>        &#125;<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h3><p>综上所述，<code>SpriteFrame</code> 和 <code>Texture</code> 是 Cocos Creator 中非常重要的概念。对于 UI 开发来说，优先选择使用 <code>SpriteFrame</code>，可以更好地管理资源，提高开发效率，并优化性能。理解这两者的区别将有助于开发者在实际项目中作出更明智的选择。在实际开发中，考虑合批渲染和资源管理的便利性，可以使项目更加高效和稳定。通过合批渲染，多个 UI 元素能够在同一绘制调用中被渲染，极大提高了渲染性能。</p><p>希望这次的修改能满足您的需求！如果还有其他问题或需要进一步的调整，请随时告诉我。</p>]]></content>
    
    
    <categories>
      
      <category>Cocos Creator</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos Creator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十、NodeJs mongoDB详解</title>
    <link href="/posts/59814/"/>
    <url>/posts/59814/</url>
    
    <content type="html"><![CDATA[<h1 id="十、NodeJs-mongoDB®详解"><a href="#十、NodeJs-mongoDB®详解" class="headerlink" title="十、NodeJs mongoDB®详解"></a>十、NodeJs mongoDB®详解</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>MongoDB 是一个面向文档的 NoSQL 数据库，以高性能、高可用性和自动扩展著称。它使用 BSON（一种类似 JSON 的二进制格式）存储数据，使得数据结构更加灵活。MongoDB 不使用关系型数据库的表结构，而是使用集合（Collection）和文档（Document），通过键值对存储数据，适用于大数据和实时数据处理等需求。</p><p>官方地址 <a href="https://www.mongodb.com/">https://www.mongodb.com/</a></p><p>MongoDB 设计的特点：</p><ul><li><strong>文档存储</strong>：数据以文档（Document）形式存储，灵活且易于扩展。</li><li><strong>Schema-less</strong>：允许文档结构随需求调整，方便处理非结构化和半结构化数据。</li><li><strong>分布式架构</strong>：支持自动分片（Sharding）和高可用性，适合扩展到大量节点。</li><li><strong>强大查询语言</strong>：支持聚合、筛选、排序、投影等多样查询方式。</li></ul><h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><ul><li><p><strong>数据库 (Database)</strong><br>MongoDB 的数据库相当于关系型数据库中的数据库，里面包含多个集合（表）。每个 MongoDB 实例可以创建多个数据库，每个数据库有独立的权限控制。</p></li><li><p><strong>集合 (Collection)</strong><br>集合类似于关系数据库中的表，但不强制要求文档的 Schema 相同，因此可以在同一集合中存储不同结构的文档。集合在数据库中，使用时需指定数据库。</p></li><li><p><strong>文档 (Document)</strong><br>文档是 MongoDB 中的基本数据单元，相当于关系数据库中的一行记录。每个文档是一个 BSON 格式的对象，结构类似于 JSON。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;001&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skills&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Python&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;JavaScript&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>_id</code> 字段是每个文档的唯一标识，如果不指定，MongoDB 会自动生成。</p></li><li><p><strong>字段 (Field)</strong><br>字段是文档中的键值对，类似于关系数据库中的列。一个文档可以包含多个字段，并且字段类型可以不同，例如字符串、数值、数组、嵌套文档等。</p></li><li><p><strong>索引 (Index)</strong><br>MongoDB 支持为集合创建索引，常见的是单字段索引、复合索引和文本索引等。索引提高查询速度，但会占用额外空间。</p></li><li><p><strong>副本集 (Replica Set)</strong><br>MongoDB 中的一组节点，负责数据的冗余备份。副本集中包含一个主节点和多个从节点，主节点负责写操作，从节点同步数据，确保高可用性。</p></li><li><p><strong>分片 (Sharding)</strong><br>MongoDB 的水平分片策略，将数据分散到不同的分片中，使系统具备良好的扩展性。</p></li></ul><p><img src="/posts/59814/915718a948758c68.png"></p><h1 id="三、下载安装与启动"><a href="#三、下载安装与启动" class="headerlink" title="三、下载安装与启动"></a>三、下载安装与启动</h1><h2 id="1-Windows-系统"><a href="#1-Windows-系统" class="headerlink" title="1. Windows 系统"></a>1. Windows 系统</h2><h3 id="1-1-下载-MongoDB"><a href="#1-1-下载-MongoDB" class="headerlink" title="1.1 下载 MongoDB"></a>1.1 下载 MongoDB</h3><ol><li>前往 <a href="https://www.mongodb.com/try/download/community">MongoDB 官方下载页面</a>。</li><li>选择 <strong>Windows</strong> 操作系统和 <strong>版本</strong>（一般选择最新稳定版）。</li><li>下载 <code>.msi</code> 安装包。</li></ol><h3 id="1-2-安装-MongoDB"><a href="#1-2-安装-MongoDB" class="headerlink" title="1.2 安装 MongoDB"></a>1.2 安装 MongoDB</h3><ol><li>双击下载的 <code>.msi</code> 文件启动安装。</li><li>选择 <strong>Complete（完全安装）</strong>。</li><li>勾选 <strong>Install MongoDB as a Service</strong>，以便 MongoDB 随系统启动。</li><li>继续安装，完成后 MongoDB 将安装在 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;</code>。</li></ol><h3 id="1-3-配置-MongoDB"><a href="#1-3-配置-MongoDB" class="headerlink" title="1.3 配置 MongoDB"></a>1.3 配置 MongoDB</h3><ol><li><p>打开 <strong>命令提示符</strong>，输入以下命令来创建 MongoDB 数据目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md C:\data\db<br></code></pre></td></tr></table></figure><p>如果需要更改路径，可以在配置文件中设置。</p></li><li><p>将 MongoDB 可执行文件添加到系统路径，进入系统环境变量配置并添加 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;\bin</code> 到 <code>PATH</code>。</p></li><li><p>在命令提示符中输入以下命令启动 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongod<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="2-macOS-系统"><a href="#2-macOS-系统" class="headerlink" title="2. macOS 系统"></a>2. macOS 系统</h2><h3 id="2-1-使用-Homebrew-安装-MongoDB"><a href="#2-1-使用-Homebrew-安装-MongoDB" class="headerlink" title="2.1 使用 Homebrew 安装 MongoDB"></a>2.1 使用 Homebrew 安装 MongoDB</h3><ol><li><p>打开 <strong>终端</strong>，更新 Homebrew：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew update<br></code></pre></td></tr></table></figure></li><li><p>安装 MongoDB 社区版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew tap mongodb/brew<br>brew install mongodb-community@6.0<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-启动-MongoDB"><a href="#2-2-启动-MongoDB" class="headerlink" title="2.2 启动 MongoDB"></a>2.2 启动 MongoDB</h3><ol><li><p>使用以下命令启动 MongoDB 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew services start mongodb/brew/mongodb-community<br></code></pre></td></tr></table></figure></li><li><p>要停止服务，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew services stop mongodb/brew/mongodb-community<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="3-Linux-系统（以-Ubuntu-为例）"><a href="#3-Linux-系统（以-Ubuntu-为例）" class="headerlink" title="3. Linux 系统（以 Ubuntu 为例）"></a>3. Linux 系统（以 Ubuntu 为例）</h3><h4 id="3-1-添加-MongoDB-源"><a href="#3-1-添加-MongoDB-源" class="headerlink" title="3.1 添加 MongoDB 源"></a>3.1 添加 MongoDB 源</h4><ol><li><p>导入 MongoDB 公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -<br></code></pre></td></tr></table></figure></li><li><p>添加 MongoDB 源到系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/6.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list<br></code></pre></td></tr></table></figure></li><li><p>更新系统包索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-2-安装-MongoDB"><a href="#3-2-安装-MongoDB" class="headerlink" title="3.2 安装 MongoDB"></a>3.2 安装 MongoDB</h4><p>安装 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install -y mongodb-org<br></code></pre></td></tr></table></figure><h4 id="3-3-启动-MongoDB-服务"><a href="#3-3-启动-MongoDB-服务" class="headerlink" title="3.3 启动 MongoDB 服务"></a>3.3 启动 MongoDB 服务</h4><ol><li><p>启动 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start mongod<br></code></pre></td></tr></table></figure></li><li><p>设置 MongoDB 开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable mongod<br></code></pre></td></tr></table></figure></li><li><p>检查 MongoDB 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status mongod<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-验证-MongoDB-安装"><a href="#4-验证-MongoDB-安装" class="headerlink" title="4. 验证 MongoDB 安装"></a>4. 验证 MongoDB 安装</h3><p>无论在哪个系统上安装 MongoDB，可以通过以下命令来连接 MongoDB 服务器，验证安装是否成功：</p><ol><li><p>启动 <strong>MongoDB Shell</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongo<br></code></pre></td></tr></table></figure></li><li><p>连接成功后，MongoDB Shell 会显示一个提示符，输入以下命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">show dbs<br></code></pre></td></tr></table></figure><p>如果列出可用数据库，则说明 MongoDB 已正确安装。</p></li></ol><hr><h3 id="5-基本配置文件"><a href="#5-基本配置文件" class="headerlink" title="5. 基本配置文件"></a>5. 基本配置文件</h3><p>可以在 <code>/etc/mongod.conf</code>（Linux）或 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;\bin\mongod.cfg</code>（Windows）中修改 MongoDB 的配置文件。以下是一个简单配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># mongod.conf</span><br><br><span class="hljs-comment"># 数据存储位置</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">dbPath:</span> <span class="hljs-string">/var/lib/mongodb</span><br><br><span class="hljs-comment"># 日志文件</span><br><span class="hljs-attr">systemLog:</span><br>  <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/mongodb/mongod.log</span><br>  <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 绑定地址</span><br><span class="hljs-attr">net:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br>  <span class="hljs-attr">bindIp:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>配置完成后，可以重启 MongoDB 以应用新配置。</p><h1 id="四、基本操作命令"><a href="#四、基本操作命令" class="headerlink" title="四、基本操作命令"></a>四、基本操作命令</h1><h2 id="1-数据库操作命令"><a href="#1-数据库操作命令" class="headerlink" title="1.数据库操作命令"></a>1.数据库操作命令</h2><h3 id="1-1-显示所有数据库"><a href="#1-1-显示所有数据库" class="headerlink" title="1.1 显示所有数据库"></a>1.1 显示所有数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show dbs<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：列出当前 MongoDB 实例中的所有数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show dbs<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-切换-创建数据库"><a href="#1-2-切换-创建数据库" class="headerlink" title="1.2 切换&#x2F;创建数据库"></a>1.2 切换&#x2F;创建数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use &lt;database_name&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：切换到指定数据库，如果该数据库不存在则创建一个新数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use myDatabase<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-删除数据库"><a href="#1-3-删除数据库" class="headerlink" title="1.3 删除数据库"></a>1.3 删除数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropDatabase</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：删除当前使用的数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use myDatabase<br>db.<span class="hljs-title function_">dropDatabase</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="2-集合操作命令"><a href="#2-集合操作命令" class="headerlink" title="2.集合操作命令"></a>2.集合操作命令</h2><h3 id="2-1-显示集合"><a href="#2-1-显示集合" class="headerlink" title="2.1 显示集合"></a>2.1 显示集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show collections<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：列出当前数据库中的所有集合。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show collections<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-创建集合"><a href="#2-2-创建集合" class="headerlink" title="2.2 创建集合"></a>2.2 创建集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createCollection</span>(name, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>name</code>：集合名称。</li><li><code>options</code>：可选参数，如 <code>capped</code>（是否固定大小）、<code>size</code>（指定集合大小）等。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createCollection</span>(<span class="hljs-string">&quot;logs&quot;</span>, &#123; <span class="hljs-attr">capped</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">5242880</span> &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-删除集合"><a href="#2-3-删除集合" class="headerlink" title="2.3 删除集合"></a>2.3 删除集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">drop</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：删除指定集合。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">logs</span>.<span class="hljs-title function_">drop</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-文档操作命令"><a href="#3-文档操作命令" class="headerlink" title="3.文档操作命令"></a>3.文档操作命令</h2><h3 id="3-1-插入文档"><a href="#3-1-插入文档" class="headerlink" title="3.1 插入文档"></a>3.1 插入文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">insertOne</span>(<span class="hljs-variable language_">document</span>)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">insertMany</span>(documents)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>document</code>：插入的单个文档。</li><li><code>documents</code>：插入的多个文档组成的数组。</li></ul></li><li><p>示例</p><p>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertMany</span>([&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> &#125;])<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-查找文档"><a href="#3-2-查找文档" class="headerlink" title="3.2 查找文档"></a>3.2 查找文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">find</span>(query, projection)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>query</code>：可选参数，筛选条件。</li><li><code>projection</code>：可选参数，指定返回的字段（1 表示返回，0 表示不返回）。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gte</span>: <span class="hljs-number">25</span> &#125; &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">0</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><p>查询所有信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">pretty</span>()<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-更新文档"><a href="#3-3-更新文档" class="headerlink" title="3.3 更新文档"></a>3.3 更新文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateOne</span>(filter, update, options)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateMany</span>(filter, update, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>filter</code>：指定更新的文档筛选条件。</li><li><code>update</code>：更新操作。</li><li><code>options</code>：可选参数，<code>upsert</code> 表示是否在不存在时插入新文档。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125; &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">updateMany</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">30</span> &#125; &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-删除文档"><a href="#3-4-删除文档" class="headerlink" title="3.4 删除文档"></a>3.4 删除文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">deleteOne</span>(filter)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">deleteMany</span>(filter)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>filter</code>：指定删除的文档条件。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">deleteMany</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">30</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-查询操作符"><a href="#4-查询操作符" class="headerlink" title="4.查询操作符"></a>4.查询操作符</h2><h3 id="4-1-比较操作符"><a href="#4-1-比较操作符" class="headerlink" title="4.1 比较操作符"></a>4.1 比较操作符</h3><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>$eq</code></td><td>等于</td></tr><tr><td><code>$ne</code></td><td>不等于</td></tr><tr><td><code>$gt</code></td><td>大于</td></tr><tr><td><code>$gte</code></td><td>大于等于</td></tr><tr><td><code>$lt</code></td><td>小于</td></tr><tr><td><code>$lte</code></td><td>小于等于</td></tr></tbody></table><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gte</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">$lte</span>: <span class="hljs-number">35</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-逻辑操作符"><a href="#4-2-逻辑操作符" class="headerlink" title="4.2 逻辑操作符"></a>4.2 逻辑操作符</h3><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>$and</code></td><td>逻辑与</td></tr><tr><td><code>$or</code></td><td>逻辑或</td></tr><tr><td><code>$not</code></td><td>逻辑非</td></tr></tbody></table><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">$or</span>: [&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">20</span> &#125; &#125;, &#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">30</span> &#125; &#125;] &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="索引操作命令"><a href="#索引操作命令" class="headerlink" title="索引操作命令"></a>索引操作命令</h2><h3 id="5-1-创建索引"><a href="#5-1-创建索引" class="headerlink" title="5.1 创建索引"></a>5.1 创建索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">createIndex</span>(&#123; <span class="hljs-attr">field</span>: <span class="hljs-number">1</span> &#125;, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>field</code>：要索引的字段和排序（1 为升序，-1 为降序）。</li><li><code>options</code>：可选参数，如 <code>unique</code> 是否唯一索引。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">createIndex</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-查看索引"><a href="#5-2-查看索引" class="headerlink" title="5.2 查看索引"></a>5.2 查看索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">getIndexes</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：查看当前集合中的所有索引。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">getIndexes</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="6-聚合操作命令"><a href="#6-聚合操作命令" class="headerlink" title="6.聚合操作命令"></a>6.聚合操作命令</h2><h3 id="6-1-聚合查询"><a href="#6-1-聚合查询" class="headerlink" title="6.1 聚合查询"></a>6.1 聚合查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">aggregate</span>(pipeline)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>pipeline</code>：包含多个聚合阶段的数组。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">orders</span>.<span class="hljs-title function_">aggregate</span>([<br>    &#123; <span class="hljs-attr">$match</span>: &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;shipped&quot;</span> &#125; &#125;,<br>    &#123; <span class="hljs-attr">$group</span>: &#123; <span class="hljs-attr">_id</span>: <span class="hljs-string">&quot;$customer&quot;</span>, <span class="hljs-attr">total</span>: &#123; <span class="hljs-attr">$sum</span>: <span class="hljs-string">&quot;$amount&quot;</span> &#125; &#125; &#125;,<br>    &#123; <span class="hljs-attr">$sort</span>: &#123; <span class="hljs-attr">total</span>: -<span class="hljs-number">1</span> &#125; &#125;<br>])<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-用户和权限管理命令"><a href="#7-用户和权限管理命令" class="headerlink" title="7.用户和权限管理命令"></a>7.用户和权限管理命令</h2><h3 id="7-1-创建用户"><a href="#7-1-创建用户" class="headerlink" title="7.1 创建用户"></a>7.1 创建用户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createUser</span>(&#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>    <span class="hljs-attr">pwd</span>: <span class="hljs-string">&quot;password&quot;</span>,<br>    <span class="hljs-attr">roles</span>: [&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;role_name&quot;</span>, <span class="hljs-attr">db</span>: <span class="hljs-string">&quot;database_name&quot;</span> &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createUser</span>(&#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-attr">pwd</span>: <span class="hljs-string">&quot;password123&quot;</span>,<br>    <span class="hljs-attr">roles</span>: [&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;readWrite&quot;</span>, <span class="hljs-attr">db</span>: <span class="hljs-string">&quot;myDatabase&quot;</span> &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-2-删除用户"><a href="#7-2-删除用户" class="headerlink" title="7.2 删除用户"></a>7.2 删除用户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropUser</span>(<span class="hljs-string">&quot;username&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropUser</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="8-备份和恢复命令"><a href="#8-备份和恢复命令" class="headerlink" title="8.备份和恢复命令"></a>8.备份和恢复命令</h2><h3 id="8-1-备份数据库"><a href="#8-1-备份数据库" class="headerlink" title="8.1 备份数据库"></a>8.1 备份数据库</h3><p>在命令行使用 <code>mongodump</code> 命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mongodump --db myDatabase --out /backup/path<br></code></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将 <code>myDatabase</code> 数据库导出到指定路径。</li></ul><h3 id="8-2-恢复数据库"><a href="#8-2-恢复数据库" class="headerlink" title="8.2 恢复数据库"></a>8.2 恢复数据库</h3><p>在命令行使用 <code>mongorestore</code> 命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mongorestore --db myDatabase /backup/path/myDatabase<br></code></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将备份的数据库文件恢复到 MongoDB。</li></ul><h2 id="9-总结所有的操作符"><a href="#9-总结所有的操作符" class="headerlink" title="9.总结所有的操作符"></a>9.总结所有的操作符</h2><table><thead><tr><th>操作符</th><th>分类</th><th>说明</th></tr></thead><tbody><tr><td><strong>$set</strong></td><td>更新操作</td><td>将字段设置为指定的值。如果字段不存在，则创建该字段。</td></tr><tr><td><strong>$unset</strong></td><td>更新操作</td><td>删除指定的字段。</td></tr><tr><td><strong>$inc</strong></td><td>更新操作</td><td>将字段的值增加指定的数值（支持正数或负数）。</td></tr><tr><td><strong>$mul</strong></td><td>更新操作</td><td>将字段的值乘以指定的数值。</td></tr><tr><td><strong>$rename</strong></td><td>更新操作</td><td>重命名字段。</td></tr><tr><td><strong>$min</strong></td><td>更新操作</td><td>如果指定的值小于当前字段值，则将字段更新为指定的值。</td></tr><tr><td><strong>$max</strong></td><td>更新操作</td><td>如果指定的值大于当前字段值，则将字段更新为指定的值。</td></tr><tr><td><strong>$currentDate</strong></td><td>更新操作</td><td>将字段更新为当前日期。支持 Date 或 Timestamp 类型。</td></tr><tr><td><strong>$addToSet</strong></td><td>数组操作</td><td>如果值不在数组中，则添加到数组中（类似于去重的功能）。</td></tr><tr><td><strong>$pop</strong></td><td>数组操作</td><td>从数组中移除第一个或最后一个元素。</td></tr><tr><td><strong>$pull</strong></td><td>数组操作</td><td>从数组中删除所有匹配的元素。</td></tr><tr><td><strong>$push</strong></td><td>数组操作</td><td>将一个或多个值添加到数组的末尾。</td></tr><tr><td><strong>$each</strong></td><td>数组操作</td><td>与 <code>$push</code> 结合使用，用于一次插入多个值。</td></tr><tr><td><strong>$slice</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，限制数组的最大长度。</td></tr><tr><td><strong>$sort</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，对数组中的元素进行排序。</td></tr><tr><td><strong>$position</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，指定元素插入数组的位置。</td></tr><tr><td><strong>$pullAll</strong></td><td>数组操作</td><td>从数组中删除与指定值完全匹配的所有元素。</td></tr><tr><td><strong>$elemMatch</strong></td><td>查询操作</td><td>用于查询数组中符合指定条件的元素。</td></tr><tr><td><strong>$in</strong></td><td>查询操作</td><td>匹配字段的值在给定数组中的文档。</td></tr><tr><td><strong>$nin</strong></td><td>查询操作</td><td>匹配字段的值不在给定数组中的文档。</td></tr><tr><td><strong>$and</strong></td><td>逻辑操作</td><td>满足所有条件的文档。</td></tr><tr><td><strong>$or</strong></td><td>逻辑操作</td><td>满足至少一个条件的文档。</td></tr><tr><td><strong>$not</strong></td><td>逻辑操作</td><td>否定表达式，用于匹配与指定条件不符的文档。</td></tr><tr><td><strong>$nor</strong></td><td>逻辑操作</td><td>不满足任意一个条件的文档。</td></tr><tr><td><strong>$gt</strong></td><td>比较操作</td><td>匹配字段的值大于指定值的文档。</td></tr><tr><td><strong>$gte</strong></td><td>比较操作</td><td>匹配字段的值大于或等于指定值的文档。</td></tr><tr><td><strong>$lt</strong></td><td>比较操作</td><td>匹配字段的值小于指定值的文档。</td></tr><tr><td><strong>$lte</strong></td><td>比较操作</td><td>匹配字段的值小于或等于指定值的文档。</td></tr><tr><td><strong>$eq</strong></td><td>比较操作</td><td>匹配字段的值等于指定值的文档。</td></tr><tr><td><strong>$ne</strong></td><td>比较操作</td><td>匹配字段的值不等于指定值的文档。</td></tr><tr><td><strong>$exists</strong></td><td>查询操作</td><td>匹配包含或不包含指定字段的文档。</td></tr><tr><td><strong>$type</strong></td><td>查询操作</td><td>匹配指定字段类型的文档。</td></tr><tr><td><strong>$size</strong></td><td>查询操作</td><td>匹配数组长度等于指定值的文档。</td></tr><tr><td><strong>$regex</strong></td><td>查询操作</td><td>使用正则表达式匹配字段值。</td></tr><tr><td><strong>$text</strong></td><td>查询操作</td><td>进行全文索引查询。</td></tr><tr><td><strong>$where</strong></td><td>查询操作</td><td>使用 JavaScript 表达式匹配文档。</td></tr><tr><td><strong>$geoWithin</strong></td><td>地理位置查询</td><td>匹配位于指定地理形状内的点。</td></tr><tr><td><strong>$geoIntersects</strong></td><td>地理位置查询</td><td>匹配与指定的地理形状相交的点。</td></tr><tr><td><strong>$near</strong></td><td>地理位置查询</td><td>查找距离某点附近的点。</td></tr><tr><td><strong>$nearSphere</strong></td><td>地理位置查询</td><td>查找球体距离某点附近的点。</td></tr><tr><td><strong>$mod</strong></td><td>查询操作</td><td>匹配字段的值是指定除数的余数的文档。</td></tr></tbody></table><p>这些操作符在 MongoDB 中具有不同的用途，可以组合使用来实现复杂的查询和更新操作。例如，通过结合 <code>$set</code>、<code>$push</code> 和 <code>$pull</code> 可以在一个操作中更新多个字段并同时操作数组内容。这种灵活性使得 MongoDB 非常适用于文档更新和复杂查询的场景。</p><h1 id="五、-MongoDB-的锁机制"><a href="#五、-MongoDB-的锁机制" class="headerlink" title="五、 MongoDB 的锁机制"></a>五、 MongoDB 的锁机制</h1><h2 id="1-MongoDB-的锁机制"><a href="#1-MongoDB-的锁机制" class="headerlink" title="1.MongoDB 的锁机制"></a>1.MongoDB 的锁机制</h2><p>在分布式数据库中，数据一致性与并发控制是两个重要的问题。MongoDB 作为一个广泛使用的 NoSQL 数据库，提供了一些机制来确保数据的原子性和一致性。</p><h3 id="1-1-文档级锁"><a href="#1-1-文档级锁" class="headerlink" title="1.1 文档级锁"></a>1.1 文档级锁</h3><p>MongoDB 使用文档级锁（Document-Level Locking）来管理对数据的并发访问。这意味着在对单个文档进行操作时，MongoDB 会为该文档加锁，而允许其他文档同时被访问。这种机制显著提高了并发性能，特别是在高并发场景下。</p><ul><li><strong>原子性</strong>：MongoDB 中对单个文档的操作是原子性的。也就是说，对于同一文档的更新操作，要么完全成功，要么完全失败，不会出现部分更新的情况。</li></ul><h3 id="1-2-多文档操作的非原子性"><a href="#1-2-多文档操作的非原子性" class="headerlink" title="1.2 多文档操作的非原子性"></a>1.2 多文档操作的非原子性</h3><p>尽管单文档操作是原子性的，但当执行多文档操作（例如 <code>updateMany</code>）时，整体操作并不是原子性的。每个文档的修改是原子性的，但多个文档的操作整体上可能会由于某些文档更新失败而导致状态不一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateMany</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;pending&#x27;</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;complete&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，如果有一个文档在更新时因其他进程修改而失败，那么剩余的文档仍然会被更新，导致状态不一致。</p><h2 id="2-事务支持"><a href="#2-事务支持" class="headerlink" title="2. 事务支持"></a>2. 事务支持</h2><p>MongoDB 4.0 及以上版本支持多文档事务，这样可以确保多个操作作为一个整体要么完全成功，要么完全失败。事务的使用可以避免因部分操作成功而导致的数据不一致问题。</p><h3 id="2-1-事务的原理"><a href="#2-1-事务的原理" class="headerlink" title="2.1 事务的原理"></a>2.1 事务的原理</h3><p>在使用事务时，MongoDB 会在开始事务时锁定相应的文档，确保在事务未提交前，其他操作不能对这些文档进行修改。只有在成功提交事务后，修改才会生效。</p><h3 id="2-2-使用示例"><a href="#2-2-使用示例" class="headerlink" title="2.2 使用示例"></a>2.2 使用示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> session = client.<span class="hljs-title function_">startSession</span>();<br><br>session.<span class="hljs-title function_">startTransaction</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> collection1.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125; &#125;, &#123; session &#125;);<br>    <span class="hljs-keyword">await</span> collection2.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">_id</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125; &#125;, &#123; session &#125;);<br>    <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">commitTransaction</span>();<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">abortTransaction</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Transaction aborted due to error:&#x27;</span>, error);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    session.<span class="hljs-title function_">endSession</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果 <code>collection1</code> 或 <code>collection2</code> 的更新失败，事务将被中止，并且任何已经进行的更改都会被撤销。</p><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h2><p>在某些情况下，使用乐观锁可以有效解决并发修改的问题。乐观锁的思路是在更新时验证文档的版本号或修改时间戳，确保在更新时文档没有被其他进程修改。</p><h3 id="3-1-实现乐观锁的示例"><a href="#3-1-实现乐观锁的示例" class="headerlink" title="3.1 实现乐观锁的示例"></a>3.1 实现乐观锁的示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> collection.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">_id</span>: documentId &#125;);<br><span class="hljs-keyword">if</span> (result.<span class="hljs-property">version</span> === currentVersion) &#123;<br>    <span class="hljs-keyword">await</span> collection.<span class="hljs-title function_">updateOne</span>(<br>        &#123; <span class="hljs-attr">_id</span>: documentId &#125;,<br>        &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: newValue, <span class="hljs-attr">version</span>: currentVersion + <span class="hljs-number">1</span> &#125; &#125;<br>    );<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Document was modified by another process&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，只有在文档的版本号与当前版本一致时才进行更新，这样可以避免数据覆盖的问题。</p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>MongoDB 的锁机制和事务支持为开发者提供了强大的工具来处理并发数据操作的问题。了解这些机制不仅有助于提高应用程序的性能，还能确保数据的一致性。在高并发环境下，合理使用事务和乐观锁可以有效避免数据冲突和不一致问题。</p><p>对于开发者而言，掌握这些知识是构建健壮且可靠的 MongoDB 应用程序的重要基础。</p><h1 id="六、Mongoose"><a href="#六、Mongoose" class="headerlink" title="六、Mongoose"></a>六、Mongoose</h1><h2 id="1-Mongoose-简介"><a href="#1-Mongoose-简介" class="headerlink" title="1. Mongoose 简介"></a>1. Mongoose 简介</h2><p>Mongoose 是 MongoDB 官方推荐的 Node.js ODM 库，它允许我们通过 JavaScript 定义 MongoDB 数据的 Schema，提供了数据验证、模型管理和数据操作功能。</p><hr><h2 id="2-安装-Mongoose"><a href="#2-安装-Mongoose" class="headerlink" title="2. 安装 Mongoose"></a>2. 安装 Mongoose</h2><p>在 Node.js 项目中，可以使用 npm 或 yarn 安装 Mongoose：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install mongoose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br>yarn add mongoose<br></code></pre></td></tr></table></figure><hr><h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3. 连接数据库"></a>3. 连接数据库</h2><p>使用 <code>mongoose.connect</code> 方法连接 MongoDB 数据库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/mydatabase&#x27;</span>, &#123;<br>  <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span>,<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接成功&#x27;</span>))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;连接失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>uri</code></td><td>String</td><td>数据库 URI，例如 <code>mongodb://localhost:27017/dbname</code></td></tr><tr><td><code>options</code></td><td>Object</td><td>连接配置项，<code>useNewUrlParser</code> 和 <code>useUnifiedTopology</code> 为常见项</td></tr><tr><td><code>useNewUrlParser</code></td><td>Boolean</td><td>使用新的 URL 解析器，避免警告</td></tr><tr><td><code>useUnifiedTopology</code></td><td>Boolean</td><td>启用新的 MongoDB 驱动引擎</td></tr></tbody></table><hr><h2 id="4-定义-Schema-和-Model"><a href="#4-定义-Schema-和-Model" class="headerlink" title="4. 定义 Schema 和 Model"></a>4. 定义 Schema 和 Model</h2><p><strong>Schema 常用类型</strong></p><p><strong>Mongoose 支持多种数据类型。常见类型如下</strong>：</p><table><thead><tr><th>类型</th><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>required</code></td><td>是否必填</td><td><code>required: true</code></td></tr><tr><td></td><td><code>minlength</code></td><td>最小长度</td><td><code>minlength: 2</code></td></tr><tr><td></td><td><code>maxlength</code></td><td>最大长度</td><td><code>maxlength: 100</code></td></tr><tr><td></td><td><code>trim</code></td><td>去掉两侧空格</td><td><code>trim: true</code></td></tr><tr><td></td><td><code>uppercase</code></td><td>转换为大写</td><td><code>uppercase: true</code></td></tr><tr><td></td><td><code>lowercase</code></td><td>转换为小写</td><td><code>lowercase: true</code></td></tr><tr><td></td><td><code>enum</code></td><td>允许的枚举值</td><td><code>enum: [&#39;ADMIN&#39;, &#39;USER&#39;, &#39;GUEST&#39;]</code></td></tr><tr><td><code>Number</code></td><td><code>min</code></td><td>最小值</td><td><code>min: 0</code></td></tr><tr><td></td><td><code>max</code></td><td>最大值</td><td><code>max: 120</code></td></tr><tr><td></td><td><code>default</code></td><td>默认值</td><td><code>default: 18</code></td></tr><tr><td><code>Date</code></td><td><code>default</code></td><td>默认日期（可用 <code>Date.now</code>）</td><td><code>default: Date.now</code></td></tr><tr><td><code>Boolean</code></td><td><code>default</code></td><td>布尔型默认值</td><td><code>default: true</code></td></tr><tr><td><code>Buffer</code></td><td></td><td>用于存储二进制数据</td><td></td></tr><tr><td><code>Mixed</code></td><td><code>default</code></td><td>可以存储任意数据</td><td><code>default: &#123; role: &#39;user&#39; &#125;</code></td></tr><tr><td><code>ObjectId</code></td><td><code>ref</code></td><td>关联到另一集合</td><td><code>ref: &#39;User&#39;</code></td></tr><tr><td><code>Array</code></td><td><code>default</code></td><td>数组的默认值</td><td><code>default: []</code></td></tr><tr><td><code>Map</code></td><td><code>of</code></td><td>指定 Map 值的类型</td><td><code>of: String</code></td></tr><tr><td>嵌套对象</td><td></td><td>定义嵌套对象结构</td><td><code>&#123; street: String, city: String &#125;</code></td></tr></tbody></table><p><strong>定义 Schema 示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-comment">// 字符串类型示例</span><br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minlength</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">maxlength</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">trim</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 移除字符串两侧空格</span><br>    <span class="hljs-attr">uppercase</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 将字符串转换为大写</span><br>    <span class="hljs-attr">lowercase</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 保持小写</span><br>    <span class="hljs-attr">enum</span>: [<span class="hljs-string">&#x27;ADMIN&#x27;</span>, <span class="hljs-string">&#x27;USER&#x27;</span>, <span class="hljs-string">&#x27;GUEST&#x27;</span>],  <span class="hljs-comment">// 枚举限定值</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 数值类型示例</span><br>  <span class="hljs-attr">age</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>: <span class="hljs-number">120</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">18</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 日期类型示例</span><br>  <span class="hljs-attr">birthdate</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>,  <span class="hljs-comment">// 默认当前时间</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 布尔类型示例</span><br>  <span class="hljs-attr">isActive</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 二进制数据类型示例</span><br>  <span class="hljs-attr">profilePicture</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Buffer</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 混合类型示例，允许任意类型数据</span><br>  <span class="hljs-attr">metadata</span>: &#123;<br>    <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">Mixed</span>,<br>    <span class="hljs-attr">default</span>: &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span> &#125;,<br>  &#125;,<br><br>  <span class="hljs-comment">// ObjectId 类型示例</span><br>  <span class="hljs-attr">parentUser</span>: &#123;<br>    <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,<br>    <span class="hljs-attr">ref</span>: <span class="hljs-string">&#x27;User&#x27;</span>,  <span class="hljs-comment">// 关联另一个集合</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 数组类型示例</span><br>  <span class="hljs-attr">hobbies</span>: &#123;<br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>],  <span class="hljs-comment">// 字符串数组</span><br>    <span class="hljs-attr">default</span>: [],<br>  &#125;,<br><br>  <span class="hljs-comment">// Map 类型示例</span><br>  <span class="hljs-attr">socialLinks</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Map</span>,<br>    <span class="hljs-attr">of</span>: <span class="hljs-title class_">String</span>,  <span class="hljs-comment">// 每个键的值为字符串类型</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 嵌套对象示例</span><br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">street</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    <span class="hljs-attr">city</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span> &#125;,<br>    <span class="hljs-attr">zip</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">match</span>: <span class="hljs-regexp">/^[0-9]&#123;5&#125;$/</span> &#125;,  <span class="hljs-comment">// 正则匹配5位数字</span><br>  &#125;,<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>Model 定义与使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><hr><h2 id="5-CRUD-操作"><a href="#5-CRUD-操作" class="headerlink" title="5. CRUD 操作"></a>5. CRUD 操作</h2><p>Mongoose 提供了一系列方法用于增删改查。以下是常用 CRUD 方法的参数说明和示例：</p><h3 id="1-创建文档-create"><a href="#1-创建文档-create" class="headerlink" title="1.创建文档 - create()"></a>1.创建文档 - <code>create()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建成功:&#x27;</span>, doc))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;创建失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>doc</code></td><td>Object</td><td>要插入的文档</td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><h3 id="2-查询文档-find"><a href="#2-查询文档-find" class="headerlink" title="2.查询文档 - find()"></a>2.查询文档 - <code>find()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">18</span> &#125; &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询结果:&#x27;</span>, users))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;查询失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查询条件，例如 <code>&#123; age: 25 &#125;</code></td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><h3 id="3-更新文档-updateOne"><a href="#3-更新文档-updateOne" class="headerlink" title="3.更新文档 - updateOne()"></a>3.更新文档 - <code>updateOne()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;, &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新成功:&#x27;</span>, result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;更新失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查找条件，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code></td></tr><tr><td><code>update</code></td><td>Object</td><td>更新内容，例如 <code>&#123; age: 26 &#125;</code></td></tr><tr><td><code>options</code></td><td>Object</td><td>可选，配置项，<code>upsert</code> 等</td></tr></tbody></table><h3 id="4-删除文档-deleteOne"><a href="#4-删除文档-deleteOne" class="headerlink" title="4.删除文档 - deleteOne()"></a>4.删除文档 - <code>deleteOne()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功:&#x27;</span>, result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;删除失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查找条件，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code></td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><hr><h2 id="6-条件运算符"><a href="#6-条件运算符" class="headerlink" title="6. 条件运算符"></a>6. 条件运算符</h2><p>Mongoose 支持丰富的查询条件运算符，用于复杂的数据查询。常见的条件运算符如下：</p><table><thead><tr><th>条件运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>$eq</code></td><td>等于某个值</td><td><code>&#123; age: &#123; $eq: 18 &#125; &#125;</code></td></tr><tr><td><code>$ne</code></td><td>不等于某个值</td><td><code>&#123; age: &#123; $ne: 18 &#125; &#125;</code></td></tr><tr><td><code>$gt</code></td><td>大于某个值</td><td><code>&#123; age: &#123; $gt: 18 &#125; &#125;</code></td></tr><tr><td><code>$gte</code></td><td>大于等于某个值</td><td><code>&#123; age: &#123; $gte: 18 &#125; &#125;</code></td></tr><tr><td><code>$lt</code></td><td>小于某个值</td><td><code>&#123; age: &#123; $lt: 18 &#125; &#125;</code></td></tr><tr><td><code>$lte</code></td><td>小于等于某个值</td><td><code>&#123; age: &#123; $lte: 18 &#125; &#125;</code></td></tr><tr><td><code>$in</code></td><td>在某个集合中</td><td><code>&#123; age: &#123; $in: [18, 20, 25] &#125; &#125;</code></td></tr><tr><td><code>$nin</code></td><td>不在某个集合中</td><td><code>&#123; age: &#123; $nin: [18, 20, 25] &#125; &#125;</code></td></tr><tr><td><code>$or</code></td><td>满足任一条件</td><td><code>&#123; $or: [&#123; age: 18 &#125;, &#123; name: &#39;John&#39; &#125;] &#125;</code></td></tr><tr><td><code>$and</code></td><td>满足所有条件</td><td><code>&#123; $and: [&#123; age: &#123; $gte: 18 &#125; &#125;, &#123; age: &#123; $lt: 25 &#125; &#125;] &#125;</code></td></tr><tr><td><code>$exists</code></td><td>字段是否存在</td><td><code>&#123; email: &#123; $exists: true &#125; &#125;</code></td></tr><tr><td><code>$regex</code></td><td>匹配正则表达式</td><td><code>&#123; name: &#123; $regex: /^J/i &#125; &#125;</code></td></tr></tbody></table><p><strong>示例：查找年龄大于 18 且爱好包含 “reading” 的用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123;<br>  <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">18</span> &#125;,<br>  <span class="hljs-attr">hobbies</span>: &#123; <span class="hljs-attr">$in</span>: [<span class="hljs-string">&#x27;reading&#x27;</span>] &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(users));<br></code></pre></td></tr></table></figure><hr><h2 id="7-索引和聚合"><a href="#7-索引和聚合" class="headerlink" title="7. 索引和聚合"></a>7. 索引和聚合</h2><h3 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h3><p> Mongoose 支持为字段创建索引以加速查询。常见索引类型有唯一索引、复合索引和文本索引。</p><p><strong>优点</strong>：</p><p><strong>查询性能</strong>：在复杂的查询中使用其他字段（例如用户名、电子邮件等）作为筛选条件，MongoDB 如果没有针对这些字段建立索引，就必须扫描整个集合，导致性能下降。为频繁查询的字段创建索引可以显著提升效率。</p><p><strong>复合查询</strong>：例如，在查询中需要组合多个字段，如按 <code>name</code> 和 <code>age</code> 共同筛选用户，这种情况下可以创建复合索引 <code>&#123; name: 1, age: 1 &#125;</code> 来加速联合查询。</p><p><strong>唯一约束</strong>：业务需求可能要求某些字段具有唯一性（如电子邮件或用户名），可通过 <code>unique</code> 索引来确保。</p><p><strong>排序需求</strong>：如果某字段常用于排序，创建索引能优化排序操作。默认 <code>_id</code> 索引只能对 <code>_id</code> 字段排序，如果我们想按 <code>createdAt</code> 排序，就需要为 <code>createdAt</code> 字段创建索引。</p><p><strong>全文搜索</strong>：MongoDB 提供了文本索引来支持复杂的全文检索，适用于字段内容较长或频繁进行模糊查询的情况。</p><table><thead><tr><th>索引类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>单字段索引</td><td>为单个字段创建索引</td><td><code>&#123; name: 1 &#125;</code></td></tr><tr><td>复合索引</td><td>为多个字段组合创建索引</td><td><code>&#123; name: 1, age: -1 &#125;</code></td></tr><tr><td>唯一索引</td><td>保证字段值的唯一性</td><td><code>&#123; email: &#123; unique: true &#125; &#125;</code></td></tr><tr><td>文本索引</td><td>支持全文搜索</td><td><code>&#123; description: &#39;text&#39; &#125;</code></td></tr><tr><td>稀疏索引</td><td>忽略 <code>null</code> 和缺失的字段</td><td><code>&#123; phone: &#123; sparse: true &#125; &#125;</code></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">email</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;,  <span class="hljs-comment">// 唯一索引</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-title class_">Number</span>,<br>&#125;);<br><br>userSchema.<span class="hljs-title function_">index</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">age</span>: -<span class="hljs-number">1</span> &#125;);  <span class="hljs-comment">// 复合索引</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><h3 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h3><p> Mongoose 提供的聚合框架可以对数据进行复杂的统计分析，常用的聚合管道操作符包括 <code>$match</code>、<code>$group</code>、<code>$sort</code>、<code>$limit</code> 等。</p><table><thead><tr><th>操作符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>$match</code></td><td>筛选符合条件的文档</td><td><code>&#123; age: &#123; $gt: 18 &#125; &#125;</code></td></tr><tr><td><code>$group</code></td><td>分组统计</td><td><code>&#123; _id: &quot;$hobbies&quot;, total: &#123; $sum: 1 &#125; &#125;</code></td></tr><tr><td><code>$sort</code></td><td>排序</td><td><code>&#123; age: -1 &#125;</code></td></tr><tr><td><code>$limit</code></td><td>限制结果数量</td><td><code>5</code></td></tr><tr><td><code>$project</code></td><td>控制输出字段</td><td><code>&#123; name: 1, age: 1 &#125;</code></td></tr></tbody></table><p><strong>示例：按爱好分组并统计每个爱好的人数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">aggregate</span>([<br>  &#123; <span class="hljs-attr">$unwind</span>: <span class="hljs-string">&quot;$hobbies&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">$group</span>: &#123; <span class="hljs-attr">_id</span>: <span class="hljs-string">&quot;$hobbies&quot;</span>, <span class="hljs-attr">count</span>: &#123; <span class="hljs-attr">$sum</span>: <span class="hljs-number">1</span> &#125; &#125; &#125;,<br>  &#123; <span class="hljs-attr">$sort</span>: &#123; <span class="hljs-attr">count</span>: -<span class="hljs-number">1</span> &#125; &#125;,<br>  &#123; <span class="hljs-attr">$limit</span>: <span class="hljs-number">5</span> &#125;<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));<br></code></pre></td></tr></table></figure><hr><h2 id="8-验证和钩子"><a href="#8-验证和钩子" class="headerlink" title="8. 验证和钩子"></a>8. 验证和钩子</h2><h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>Mongoose 提供了内置的字段验证功能，可以通过参数如 <code>required</code>、<code>minlength</code>、<code>maxlength</code>、<code>match</code> 等来实现基础验证，还可以自定义验证。</p><p>以下是一个详细的表格，列出了 Mongoose 中常见的验证类型及其参数说明和示例：</p><table><thead><tr><th>验证类型</th><th>参数</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>必填</strong></td><td><code>required</code></td><td>确保字段必须存在</td><td><code>&#123; required: true &#125;</code></td></tr><tr><td><strong>最小长度</strong></td><td><code>minlength</code></td><td>限制字符串的最小长度</td><td><code>&#123; minlength: 5 &#125;</code></td></tr><tr><td><strong>最大长度</strong></td><td><code>maxlength</code></td><td>限制字符串的最大长度</td><td><code>&#123; maxlength: 100 &#125;</code></td></tr><tr><td><strong>正则匹配</strong></td><td><code>match</code></td><td>字符串必须匹配指定的正则表达式</td><td><code>&#123; match: /^[a-z]+$/ &#125;</code></td></tr><tr><td><strong>数值最小值</strong></td><td><code>min</code></td><td>限制数值的最小值</td><td><code>&#123; min: 18 &#125;</code></td></tr><tr><td><strong>数值最大值</strong></td><td><code>max</code></td><td>限制数值的最大值</td><td><code>&#123; max: 65 &#125;</code></td></tr><tr><td><strong>自定义验证</strong></td><td><code>validate</code></td><td>使用自定义函数验证</td><td><code>&#123; validate: customValidatorFn &#125;</code></td></tr><tr><td><strong>唯一值</strong></td><td><code>unique</code></td><td>确保字段在集合中唯一</td><td><code>&#123; unique: true &#125;</code></td></tr><tr><td><strong>默认值</strong></td><td><code>default</code></td><td>设置字段的默认值</td><td><code>&#123; default: &#39;未设置&#39; &#125;</code></td></tr><tr><td><strong>枚举值</strong></td><td><code>enum</code></td><td>限制字段的值为预定义的一组值</td><td><code>&#123; enum: [&#39;user&#39;, &#39;admin&#39;, &#39;guest&#39;] &#125;</code></td></tr><tr><td><strong>数值类型</strong></td><td><code>type</code></td><td>指定字段的数据类型</td><td><code>&#123; type: Number &#125;</code></td></tr><tr><td><strong>日期类型</strong></td><td><code>type</code></td><td>指定字段为日期类型</td><td><code>&#123; type: Date &#125;</code></td></tr><tr><td><strong>数组类型</strong></td><td><code>type</code></td><td>指定字段为数组类型</td><td><code>&#123; type: [String] &#125;</code></td></tr><tr><td><strong>对象类型</strong></td><td><code>type</code></td><td>指定字段为对象类型</td><td><code>&#123; type: Object &#125;</code></td></tr></tbody></table><p><strong>示例：完整的 Mongoose 模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">username</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">minlength</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">maxlength</span>: <span class="hljs-number">15</span>,<br>    <span class="hljs-attr">validate</span>: &#123;<br>      <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9]&#123;2,14&#125;$/</span>.<span class="hljs-title function_">test</span>(v);<br>      &#125;,<br>      <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;props.value&#125;</span> 不是一个有效的用户名！`</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">email</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">match</span>: <span class="hljs-regexp">/.+\@.+\..+/</span> <br>  &#125;,<br>  <span class="hljs-attr">age</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <br>    <span class="hljs-attr">max</span>: <span class="hljs-number">120</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">18</span> <br>  &#125;,<br>  <span class="hljs-attr">role</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">enum</span>: [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;moderator&#x27;</span>], <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> <br>  &#125;,<br>  <span class="hljs-attr">hobbies</span>: &#123; <br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>], <span class="hljs-comment">// 数组类型</span><br>    <span class="hljs-attr">default</span>: [] <br>  &#125;,<br>  <span class="hljs-attr">createdAt</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>, <br>    <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> <br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;testuser&#x27;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>  <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&#x27;reading&#x27;</span>, <span class="hljs-string">&#x27;gaming&#x27;</span>]<br>&#125;);<br><br>user.<span class="hljs-title function_">save</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户保存成功！&#x27;</span>))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;保存用户时出错：&#x27;</span>, err.<span class="hljs-property">errors</span>));<br></code></pre></td></tr></table></figure><p>这个模式使用了各种验证类型来确保用户数据的有效性，展示了如何在 Mongoose 中使用这些验证规则。</p><p><strong>validate参数说明</strong></p><ol><li><strong>validator</strong>:<ul><li><strong>类型</strong>: <code>Function</code></li><li><strong>描述</strong>: 自定义验证函数，接受一个参数 <code>v</code>（要验证的值）。返回 <code>true</code> 表示验证通过，返回 <code>false</code> 表示验证失败。</li></ul></li><li><strong>message</strong>:<ul><li><strong>类型</strong>: <code>String | Function</code></li><li><strong>描述</strong>: 当验证失败时，返回的错误信息。可以使用字符串，也可以使用一个函数，函数接受一个参数 <code>props</code>，其中包含被验证的值（<code>props.value</code>）、字段路径（<code>props.path</code>）、模型实例等信息。</li></ul></li></ol><p><strong>自定义验证的注意事项</strong></p><ul><li>如果在模式中为字段设置了 <code>required: true</code>，则该字段的值必须存在，验证会在保存文档之前进行。</li><li>自定义验证在保存时会触发，如果自定义验证失败，Mongoose 将抛出一个错误，包含所有验证失败的字段信息。</li><li>使用自定义验证时，确保验证逻辑高效，以免在大量数据操作时影响性能。</li></ul><h3 id="2-钩子"><a href="#2-钩子" class="headerlink" title="2.钩子"></a>2.钩子</h3><p>Mongoose 钩子（中间件）支持在文档保存、更新、删除等操作前后执行自定义逻辑。钩子分为两类：<strong>文档中间件</strong> 和 <strong>查询中间件</strong>。</p><p><strong>文档中间件</strong></p><table><thead><tr><th>钩子</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>save</code></td><td>在文档保存之前或之后触发</td><td><code>schema.pre(&#39;save&#39;, fn)</code></td></tr><tr><td><code>remove</code></td><td>在文档删除之前或之后触发</td><td><code>schema.pre(&#39;remove&#39;, fn)</code></td></tr></tbody></table><p><strong>查询中间件</strong></p><table><thead><tr><th>钩子</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>find</code></td><td>在 <code>find</code> 查询前或后触发</td><td><code>schema.pre(&#39;find&#39;, fn)</code></td></tr><tr><td><code>findOne</code></td><td>在 <code>findOne</code> 查询前或后触发</td><td><code>schema.pre(&#39;findOne&#39;, fn)</code></td></tr><tr><td><code>updateOne</code></td><td>在 <code>updateOne</code> 查询前或后触发</td><td><code>schema.pre(&#39;updateOne&#39;, fn)</code></td></tr></tbody></table><p><strong>示例：<code>pre-save</code> 钩子自动记录文档的创建时间</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">userSchema.<span class="hljs-title function_">pre</span>(<span class="hljs-string">&#x27;save&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isNew</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  &#125;<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="9-正则匹配"><a href="#9-正则匹配" class="headerlink" title="9. 正则匹配"></a>9. 正则匹配</h2><p>下面是几种等效的不同写法：</p><h3 id="1-使用-RegExp-构造函数"><a href="#1-使用-RegExp-构造函数" class="headerlink" title="1.使用 RegExp 构造函数"></a>1.使用 <code>RegExp</code> 构造函数</h3><p>使用 JavaScript 的 <code>RegExp</code> 构造函数可以更加动态地传递正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;imissyou&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure><p>如果你需要忽略大小写，可以在正则表达式中添加修饰符，例如 <code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure><h3 id="2-使用-regex-运算符"><a href="#2-使用-regex-运算符" class="headerlink" title="2. 使用 $regex 运算符"></a>2. 使用 <code>$regex</code> 运算符</h3><p>MongoDB 提供了 <code>$regex</code> 运算符用于匹配正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>同样，你可以使用 <code>$options</code> 来指定正则表达式选项，例如忽略大小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-attr">$options</span>: <span class="hljs-string">&#x27;i&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><h3 id="3-使用嵌套的-regex-和-options-选项"><a href="#3-使用嵌套的-regex-和-options-选项" class="headerlink" title="3. 使用嵌套的 $regex 和 $options 选项"></a>3. 使用嵌套的 <code>$regex</code> 和 <code>$options</code> 选项</h3><p>如果你需要多个选项，比如忽略大小写或者多行模式，你可以使用 <code>$options</code> 来同时启用多个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-attr">$options</span>: <span class="hljs-string">&#x27;im&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-动态生成正则表达式"><a href="#4-动态生成正则表达式" class="headerlink" title="4. 动态生成正则表达式"></a>4. 动态生成正则表达式</h3><p>如果正则表达式是动态生成的，可以结合 JavaScript 变量来创建查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pattern = <span class="hljs-string">&#x27;imissyou&#x27;</span>;<br><span class="hljs-keyword">let</span> caseInsensitive = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果需要忽略大小写</span><br><br><span class="hljs-keyword">let</span> query = &#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(pattern, caseInsensitive ? <span class="hljs-string">&#x27;i&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>) &#125;;<br>db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(query);<br></code></pre></td></tr></table></figure><h3 id="5-查询匹配前缀、后缀或包含"><a href="#5-查询匹配前缀、后缀或包含" class="headerlink" title="5. 查询匹配前缀、后缀或包含"></a>5. 查询匹配前缀、后缀或包含</h3><p>使用正则表达式匹配字符串的开头、结尾或中间部分：</p><ul><li><strong>匹配以 <code>imissyou</code> 开头：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^imissyou/</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>匹配以 <code>imissyou</code> 结尾：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/imissyou$/</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>匹配包含 <code>imissyou</code> 且忽略大小写：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/imissyou/i</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="10-个性化读取"><a href="#10-个性化读取" class="headerlink" title="10. 个性化读取"></a>10. 个性化读取</h2><h3 id="1-字段筛选"><a href="#1-字段筛选" class="headerlink" title="1. 字段筛选"></a>1. 字段筛选</h3><p><strong>只读取部分数据，0:不要的字段，1:要的字段</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//0:不要的字段</span><br><span class="hljs-comment">//1:要的字段</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">select</span>(&#123;<span class="hljs-attr">_id</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">title</span>:<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-数据排序"><a href="#2-数据排序" class="headerlink" title="2. 数据排序"></a>2. 数据排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//sort 排序</span><br><span class="hljs-comment">//1:升序</span><br><span class="hljs-comment">//-1:倒序</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">sort</span>(&#123;<span class="hljs-attr">hot</span>:<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-数据截取"><a href="#3-数据截取" class="headerlink" title="3. 数据截取"></a>3. 数据截取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//skip 跳过 limit 限定</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">skip</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">limit</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="七、图形化管理工具"><a href="#七、图形化管理工具" class="headerlink" title="七、图形化管理工具"></a>七、图形化管理工具</h1><p>我们可以使用图形化的管理工具来对Mongodb进行交互，这里演示两个图形化工具</p><ul><li><strong>Robo 3T 免费 <a href="https://github.com/Studio3T/robomongo/releases">https://github.com/Studio3T/robomongo/releases</a></strong></li><li><strong>Navicat 收费 <a href="https://www.navicat.com.cn/">https://www.navicat.com.cn/</a></strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九、NodeJs express框架</title>
    <link href="/posts/21819/"/>
    <url>/posts/21819/</url>
    
    <content type="html"><![CDATA[<h1 id="九、NodeJs-express框架"><a href="#九、NodeJs-express框架" class="headerlink" title="九、NodeJs express框架"></a>九、NodeJs express框架</h1><h1 id="一、express介绍"><a href="#一、express介绍" class="headerlink" title="一、express介绍"></a>一、express介绍</h1><p><strong>express 是一个基于 Node.js 平台的极简、灵活的WEB应用开发框架，官方网址：<a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></strong></p><p>简单来说，express是一个封装好的工具包，封装了很多功能，便于我们开发WEB应用（HTTP服务）</p><h1 id="二、express使用"><a href="#二、express使用" class="headerlink" title="二、express使用"></a>二、express使用</h1><h2 id="2-1-express-下载"><a href="#2-1-express-下载" class="headerlink" title="2.1 express 下载"></a>2.1 express 下载</h2><p>express 本身是一个npm包，所以可以通过npm安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br>npm i express<br></code></pre></td></tr></table></figure><h2 id="2-2-express-初体验"><a href="#2-2-express-初体验" class="headerlink" title="2.2 express 初体验"></a>2.2 express 初体验</h2><p>大家可以按照这个步骤进行操作：</p><h3 id="1．创建JS文件，键入如下代码"><a href="#1．创建JS文件，键入如下代码" class="headerlink" title="1．创建JS文件，键入如下代码"></a>1．创建JS文件，键入如下代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//2. 创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//3. 创建路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello express server&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//4. 监听端口 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2．命令行下执行该脚本"><a href="#2．命令行下执行该脚本" class="headerlink" title="2．命令行下执行该脚本"></a>2．命令行下执行该脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">node &lt;文件名&gt;<br><span class="hljs-comment"># 或者</span><br>nodemon &lt;文件名&gt;<br></code></pre></td></tr></table></figure><h1 id="三、express-路由"><a href="#三、express-路由" class="headerlink" title="三、express 路由"></a>三、express 路由</h1><h2 id="3-1-什么是路由"><a href="#3-1-什么是路由" class="headerlink" title="3.1 什么是路由"></a>3.1 什么是路由</h2><p>官方定义：<strong>路由确定了应用程序如何响应客户端对特定端点的请求</strong></p><h2 id="3-2-路由的使用"><a href="#3-2-路由的使用" class="headerlink" title="3.2 路由的使用"></a>3.2 路由的使用</h2><p>一个路由的组成有请求方法，路径和 回调函数组成</p><p>express中提供了一系列方法，可以很方便的使用路由，使用格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.&lt;method&gt;(path，callback)<br></code></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//创建 get 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;网站首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//首页路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我才是真正的首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//创建 post 路由</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//匹配所有的请求方法</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;1 秒钟为您找到相关结果约 100,000,000 个&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//自定义 404 路由</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//监听端口 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-3-获取请求参数"><a href="#3-3-获取请求参数" class="headerlink" title="3.3 获取请求参数"></a>3.3 获取请求参数</h2><p>express 框架封装了一些API来方便获取请求报文中的数据，并且兼容原生HTTP模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//获取请求的路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//1. 获取报文的方式与原生 HTTP 获取方式是兼容的</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">method</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">httpVersion</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>);<br>    <span class="hljs-comment">//2. express 独有的获取报文的方式</span><br>    <span class="hljs-comment">//获取查询字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>); <span class="hljs-comment">// 『相对重要』</span><br>    <span class="hljs-comment">// 获取指定的请求头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;host&#x27;</span>));<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求报文的获取&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;启动成功....&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-4-获取路由参数"><a href="#3-4-获取路由参数" class="headerlink" title="3.4 获取路由参数"></a>3.4 获取路由参数</h2><p>路由参数指的是URL 路径中的参数（数据）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品详情, 商品 id 为&#x27;</span> + req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="四、express响应设置"><a href="#四、express响应设置" class="headerlink" title="四、express响应设置"></a>四、express响应设置</h1><p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取请求的路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/response&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//1. express 中设置响应的方式兼容 HTTP 模块的方式</span><br>    res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>    res.<span class="hljs-property">statusMessage</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>);<br>    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;响应体&#x27;</span>);<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br>    <span class="hljs-comment">//2. express 的响应方法</span><br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>); <span class="hljs-comment">//设置响应状态码</span><br>    res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-string">&#x27;yyy&#x27;</span>);<span class="hljs-comment">//设置响应头</span><br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;中文响应不乱码&#x27;</span>);<span class="hljs-comment">//设置响应体</span><br>    <span class="hljs-comment">//连贯操作</span><br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-string">&#x27;yyy&#x27;</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;你好朋友&#x27;</span>)<br>    <span class="hljs-comment">//3. 其他响应</span><br>    res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;http://atguigu.com&#x27;</span>)<span class="hljs-comment">//重定向</span><br>    res.<span class="hljs-title function_">download</span>(<span class="hljs-string">&#x27;./package.json&#x27;</span>);<span class="hljs-comment">//下载响应</span><br>    res.<span class="hljs-title function_">json</span>();<span class="hljs-comment">//响应 JSON</span><br>    res.<span class="hljs-title function_">sendFile</span>(__dirname + <span class="hljs-string">&#x27;/home.html&#x27;</span>) <span class="hljs-comment">//响应文件内容</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="五、express-中间件"><a href="#五、express-中间件" class="headerlink" title="五、express 中间件"></a>五、express 中间件</h1><h2 id="5-1-什么是中间件"><a href="#5-1-什么是中间件" class="headerlink" title="5.1 什么是中间件"></a>5.1 什么是中间件</h2><p><strong>中间件（Middleware）本质是一个回调函数</strong></p><p><strong>中间件函数 可以像路由回调一样访问 请求对象（request），响应对象（response）</strong></p><h2 id="5-2-中间件的作用"><a href="#5-2-中间件的作用" class="headerlink" title="5.2 中间件的作用"></a>5.2 中间件的作用</h2><p>中间件的作用就是使用函数封装公共操作，简化代码</p><h2 id="5-3-中间件的类型"><a href="#5-3-中间件的类型" class="headerlink" title="5.3 中间件的类型"></a>5.3 中间件的类型</h2><ul><li><p>全局中间件</p></li><li><p>路由中间件</p></li></ul><h3 id="5-3-1-定义全局中间件"><a href="#5-3-1-定义全局中间件" class="headerlink" title="5.3.1 定义全局中间件"></a>5.3.1 定义全局中间件</h3><p>每一个请求到达服务端之后 都会执行全局中间件函数</p><p>声明中间件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> recordMiddleware = <span class="hljs-keyword">function</span>(<span class="hljs-params">request,response,next</span>)&#123;<br>    <span class="hljs-comment">//实现功能代码</span><br>    <span class="hljs-comment">//.....</span><br>    <span class="hljs-comment">//执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next)</span><br>    <span class="hljs-title function_">next</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts/21819/3c76d3f4ddfdb7f6.png"></p><p><strong>应用中间件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(recordMiddleware);<br></code></pre></td></tr></table></figure><p>声明时可以直接将匿名函数传递给 use</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第一个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-3-2-多个全局中间件"><a href="#5-3-2-多个全局中间件" class="headerlink" title="5.3.2 多个全局中间件"></a>5.3.2 多个全局中间件</h3><p>express 允许使用 app.use() 定义多个全局中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第一个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第二个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="5-3-3-定义路由中间件"><a href="#5-3-3-定义路由中间件" class="headerlink" title="5.3.3 定义路由中间件"></a>5.3.3 定义路由中间件</h3><p>如果只需要对某一些路由进行功能封装，则就需要路由中间件</p><p>调用格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/路径&#x27;</span>,<span class="hljs-string">`中间件函数`</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    <br>&#125;);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/路径&#x27;</span>,<span class="hljs-string">`中间件函数1`</span>,<span class="hljs-string">`中间件函数2`</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    <br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="5-4-静态资源中间件"><a href="#5-4-静态资源中间件" class="headerlink" title="5.4 静态资源中间件"></a>5.4 静态资源中间件</h2><p>express 内置处理静态资源的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入express框架</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public&#x27;</span>)); <span class="hljs-comment">//当然这个目录中都是一些静态资源</span><br><span class="hljs-comment">//如果访问的内容经常变化，还是需要设置路由</span><br><span class="hljs-comment">//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，</span><br><span class="hljs-comment">//则谁书写在前，优先执行谁</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    respsonse.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>index．html文件为默认打开的资源</li><li>如果静态资源与路由规则同时匹配，谁先匹配谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ol><h2 id="5-5-获取请求体数据-body-parser"><a href="#5-5-获取请求体数据-body-parser" class="headerlink" title="5.5 获取请求体数据 body-parser"></a>5.5 获取请求体数据 body-parser</h2><p>express 可以使用 body-parser 包处理请求体</p><p><strong>第一步：安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i body-parser<br></code></pre></td></tr></table></figure><p><strong>第二步：导入body-parser包</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>第三步：获取中间件函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//处理 querystring 格式的请求体</span><br><span class="hljs-keyword">let</span> urlParser = bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123;<span class="hljs-attr">extended</span>:<span class="hljs-literal">false</span>&#125;));<br><span class="hljs-comment">//处理 JSON 格式的请求体</span><br><span class="hljs-keyword">let</span> jsonParser = bodyParser.<span class="hljs-title function_">json</span>();<br></code></pre></td></tr></table></figure><p><strong>第四步：设置路由中间件，然后使用 request.body 来获取请求体数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, urlParser, <span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//获取请求体数据</span><br><span class="hljs-comment">//console.log(request.body);</span><br><span class="hljs-comment">//用户名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">body</span>.<span class="hljs-property">username</span>);<br><span class="hljs-comment">//密码</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">body</span>.<span class="hljs-property">userpass</span>);<br>response.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;获取请求体数据&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>获取到的请求体数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Object: null prototype] &#123; username: <span class="hljs-string">&#x27;admin&#x27;</span>, userpass: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="六、-Router"><a href="#六、-Router" class="headerlink" title="六、 Router"></a>六、 Router</h1><h2 id="6-1-什么是-Router"><a href="#6-1-什么是-Router" class="headerlink" title="6.1 什么是 Router"></a>6.1 什么是 Router</h2><p>express 中的Router是一个完整的中间件和路由系统，可以看做是一个小型的app对象。</p><h2 id="6-2-Router作用"><a href="#6-2-Router作用" class="headerlink" title="6.2 Router作用"></a>6.2 Router作用</h2><p>对路由进行模块化，更好的管理路由</p><h2 id="6-3-Router使用"><a href="#6-3-Router使用" class="headerlink" title="6.3 Router使用"></a>6.3 Router使用</h2><p>创建独立的 JS 文件（homeRouter.js）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//2. 创建路由器对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-comment">//3. 在 router 对象身上添加路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;)<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/cart&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;购物车&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//4. 暴露</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>主文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//5.引入子路由文件</span><br><span class="hljs-keyword">const</span> homeRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/homeRouter&#x27;</span>);<br><span class="hljs-comment">//6.设置和使用中间件</span><br>app.<span class="hljs-title function_">use</span>(homeRouter);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><h1 id="七、EJS模板引擎"><a href="#七、EJS模板引擎" class="headerlink" title="七、EJS模板引擎"></a>七、EJS模板引擎</h1><p>EJS（Embedded JavaScript）是一个轻量级的模板引擎，它允许我们在 HTML 中嵌入 JavaScript 代码。通过 EJS，我们可以在服务器端渲染动态内容，生成 HTML 文件。EJS 的语法非常简单直观，适合用于 Express.js 等基于 Node.js 的 Web 框架。</p><h2 id="7-1-EJS-的安装与使用"><a href="#7-1-EJS-的安装与使用" class="headerlink" title="7.1 EJS 的安装与使用"></a>7.1 EJS 的安装与使用</h2><h3 id="7-1-1-安装-EJS"><a href="#7-1-1-安装-EJS" class="headerlink" title="7.1.1 安装 EJS"></a>7.1.1 安装 EJS</h3><p>EJS 是一个 npm 包，可以通过 npm 进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install ejs<br></code></pre></td></tr></table></figure><h3 id="7-1-2-在-Express-中使用-EJS"><a href="#7-1-2-在-Express-中使用-EJS" class="headerlink" title="7.1.2 在 Express 中使用 EJS"></a>7.1.2 在 Express 中使用 EJS</h3><p>我们可以通过如下步骤将 EJS 集成到 Express 项目中：</p><ol><li><strong>引入 EJS</strong>：在项目中设置视图引擎为 EJS。</li><li><strong>创建视图文件</strong>：编写 <code>.ejs</code> 模板文件。</li><li><strong>渲染视图</strong>：通过路由函数返回渲染后的 HTML。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 设置视图引擎为 EJS</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br><span class="hljs-comment">// 路由渲染视图</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hello EJS&#x27;</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码中，<code>res.render</code> 方法会去 <code>views</code> 文件夹中寻找 <code>index.ejs</code> 文件，并将 <code>title</code> 和 <code>user</code> 变量传递给模板进行渲染。</p><h2 id="7-2-EJS-基本语法"><a href="#7-2-EJS-基本语法" class="headerlink" title="7.2 EJS 基本语法"></a>7.2 EJS 基本语法</h2><h3 id="7-2-1-输出变量"><a href="#7-2-1-输出变量" class="headerlink" title="7.2.1 输出变量"></a>7.2.1 输出变量</h3><p>EJS 中最常用的功能就是在 HTML 文件中输出变量。通过 <code>&lt;%= %&gt;</code> 来输出变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;<br>&lt;p&gt;Welcome, &lt;%= user %&gt;!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>假设传递的数据为 <code>&#123; title: &#39;Hello EJS&#39;, user: &#39;John Doe&#39; &#125;</code>，那么渲染后的 HTML 结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello EJS<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome, John Doe!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-执行-JavaScript-代码"><a href="#7-2-2-执行-JavaScript-代码" class="headerlink" title="7.2.2 执行 JavaScript 代码"></a>7.2.2 执行 JavaScript 代码</h3><p>在 EJS 模板中，可以通过 <code>&lt;% %&gt;</code> 语法执行 JavaScript 代码，但不会输出结果。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;ul&gt;<br>    &lt;% for(let i = 0; i &lt; 3; i++) &#123; %&gt;<br>        &lt;li&gt;Item &lt;%= i + 1 %&gt;&lt;/li&gt;<br>    &lt;% &#125; %&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>渲染后的结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-3-条件语句"><a href="#7-2-3-条件语句" class="headerlink" title="7.2.3 条件语句"></a>7.2.3 条件语句</h3><p>可以在 EJS 中编写 if、else 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;% if (user === &#x27;John Doe&#x27;) &#123; %&gt;<br>    &lt;p&gt;Hello, John Doe!&lt;/p&gt;<br>&lt;% &#125; else &#123; %&gt;<br>    &lt;p&gt;Hello, guest!&lt;/p&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><h3 id="7-2-4-转义-HTML"><a href="#7-2-4-转义-HTML" class="headerlink" title="7.2.4 转义 HTML"></a>7.2.4 转义 HTML</h3><p>在输出变量时，如果使用 <code>&lt;%- %&gt;</code>，EJS 会对内容进行 HTML 转义。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- &quot;&lt;div&gt;Hello World&lt;/div&gt;&quot; %&gt;<br></code></pre></td></tr></table></figure><p>渲染后直接显示 <code>&lt;div&gt;Hello World&lt;/div&gt;</code> 作为 HTML 标签，而不是输出标签字符串。</p><h3 id="7-2-5-注释"><a href="#7-2-5-注释" class="headerlink" title="7.2.5 注释"></a>7.2.5 注释</h3><p>EJS 支持在模板中添加注释，使用 <code>&lt;%# %&gt;</code> 进行注释，注释不会显示在渲染后的 HTML 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%# This is a comment %&gt;<br></code></pre></td></tr></table></figure><h2 id="7-3-EJS-高级用法"><a href="#7-3-EJS-高级用法" class="headerlink" title="7.3 EJS 高级用法"></a>7.3 EJS 高级用法</h2><h3 id="7-3-1-模板继承"><a href="#7-3-1-模板继承" class="headerlink" title="7.3.1 模板继承"></a>7.3.1 模板继承</h3><p>EJS 支持通过 <code>include</code> 来引入其他模板文件。通过这种方式，我们可以复用公共部分的模板，如头部和尾部：</p><p><strong>头部模板 (header.ejs)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header Section<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>尾部模板 (footer.ejs)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Footer Section<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>主模板 (index.ejs)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- include(&#x27;header&#x27;) %&gt;<br><br>&lt;p&gt;Content of the page goes here.&lt;/p&gt;<br><br>&lt;%- include(&#x27;footer&#x27;) %&gt;<br></code></pre></td></tr></table></figure><p>EJS 会把 <code>header.ejs</code> 和 <code>footer.ejs</code> 中的内容包含进主模板中，最终渲染的页面结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header Section<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content of the page goes here.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Footer Section<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-2-传递参数给-include"><a href="#7-3-2-传递参数给-include" class="headerlink" title="7.3.2 传递参数给 include"></a>7.3.2 传递参数给 include</h3><p>我们可以给 <code>include</code> 的模板传递参数，例如传递不同的数据给包含的模板：</p><p><strong>navbar.ejs</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;nav&gt;<br>    &lt;ul&gt;<br>        &lt;% for(let link of links) &#123; %&gt;<br>            &lt;li&gt;&lt;a href=&quot;&lt;%= link.href %&gt;&quot;&gt;&lt;%= link.text %&gt;&lt;/a&gt;&lt;/li&gt;<br>        &lt;% &#125; %&gt;<br>    &lt;/ul&gt;<br>&lt;/nav&gt;<br></code></pre></td></tr></table></figure><p><strong>主模板</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- include(&#x27;navbar&#x27;, &#123; links: [&#123;href: &#x27;/home&#x27;, text: &#x27;Home&#x27;&#125;, &#123;href: &#x27;/about&#x27;, text: &#x27;About&#x27;&#125;] &#125;) %&gt;<br><br>&lt;p&gt;Main content goes here&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Main content goes here<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-3-循环输出动态内容"><a href="#7-3-3-循环输出动态内容" class="headerlink" title="7.3.3 循环输出动态内容"></a>7.3.3 循环输出动态内容</h3><p>EJS 支持在模板中循环输出动态内容，这在处理列表数据时非常有用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;ul&gt;<br>    &lt;% items.forEach(function(item) &#123; %&gt;<br>        &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;<br>    &lt;% &#125;); %&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>假设传递的 <code>items</code> 为 <code>[&#39;Apple&#39;, &#39;Banana&#39;, &#39;Orange&#39;]</code>，最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Apple<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Banana<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Orange<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-4-表单处理"><a href="#7-3-4-表单处理" class="headerlink" title="7.3.4 表单处理"></a>7.3.4 表单处理</h3><p>EJS 中可以嵌入表单，并且处理表单提交的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/submit&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>Username:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在服务器端处理表单提交：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/submit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; username, password &#125; = req.<span class="hljs-property">body</span>;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`Username: <span class="hljs-subst">$&#123;username&#125;</span>, Password: <span class="hljs-subst">$&#123;password&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-4-EJS-与其他模板引擎对比"><a href="#7-4-EJS-与其他模板引擎对比" class="headerlink" title="7.4 EJS 与其他模板引擎对比"></a>7.4 EJS 与其他模板引擎对比</h2><h3 id="7-4-1-与-Pug-的对比"><a href="#7-4-1-与-Pug-的对比" class="headerlink" title="7.4.1 与 Pug 的对比"></a>7.4.1 与 Pug 的对比</h3><p>Pug 是另一个流行的模板引擎，它通过缩进来组织 HTML 结构，代码简洁，但语法相对复杂，而 EJS 更贴近 HTML 的写法，容易上手。</p><h3 id="7-4-2-与-Handlebars-的对比"><a href="#7-4-2-与-Handlebars-的对比" class="headerlink" title="7.4.2 与 Handlebars 的对比"></a>7.4.2 与 Handlebars 的对比</h3><p>Handlebars 使用双花括号 <code>&#123;&#123;&#125;&#125;</code> 来嵌入数据，支持逻辑较少，主打简单与纯粹，EJS 则支持更多的 JavaScript 逻辑，功能更强大。</p><h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><p>EJS 是一个简洁、强大且易于使用的模板引擎，适用于 Node.js 中的服务器端渲染。通过灵活使用 EJS 的语法和功能，可以快速开发出高效的 Web 应用。</p><p><strong>常见优点：</strong></p><ul><li>语法简单易懂，接近原生 HTML。</li><li>支持嵌入任意 JavaScript 代码。</li><li>可以与 Express 等框架无缝结合。</li></ul><p><strong>使用场景：</strong></p><ul><li>动态网页生成。</li><li>服务器端渲染。</li><li>基于模板的前后端交互。</li></ul><p>通过对 EJS 的理解和灵活使用，我们可以更加高效地构建 Web 应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八、NodeJs 模块系统</title>
    <link href="/posts/56695/"/>
    <url>/posts/56695/</url>
    
    <content type="html"><![CDATA[<h1 id="八、NodeJs-模块系统"><a href="#八、NodeJs-模块系统" class="headerlink" title="八、NodeJs 模块系统"></a>八、NodeJs 模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展。</p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>在 Node.js 中，引入一个模块非常简单，如下我们创建一个 <strong>main.js</strong> 文件并引入 hello 模块，代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>);<br>hello.<span class="hljs-title function_">world</span>();<br></code></pre></td></tr></table></figure><p>以上实例中，代码 require(‘.&#x2F;hello’) 引入了当前目录下的 hello.js 文件（.&#x2F; 为当前目录，node.js 默认后缀为 js）。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p><p>接下来我们就来创建 hello.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">world</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘.&#x2F;hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p><p>有时候我们只是想把一个对象封装到模块中，格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//hello.js </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">var</span> name; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thyName</span>) &#123; <br>        name = thyName; <br>    &#125;; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name); <br>    &#125;; <br>&#125;; <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Hello</span>;<br></code></pre></td></tr></table></figure><p>这样就可以直接获得这个对象了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>); <br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>(); <br>hello.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;BYVoid&#x27;</span>); <br>hello.<span class="hljs-title function_">sayHello</span>(); <br></code></pre></td></tr></table></figure><p>模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.world &#x3D; function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p><hr><h2 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><br>...<br><br>http.<span class="hljs-title function_">createServer</span>(...);<br></code></pre></td></tr></table></figure><p>Node.js 中自带了一个叫做 <strong>http</strong> 的模块，在我们的代码中请求它并把返回值赋给一个本地变量。</p><p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p><p>Node.js 的 require 方法中的文件查找策略如下：</p><p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p><p><img src="/posts/56695/nodejs-require.jpg"></p><h3 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h3><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p><h3 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载"></a>从原生模块加载</h3><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http&#x2F;http.js&#x2F;http.node&#x2F;http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p><p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p><h3 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h3><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p><p>require方法接受以下几种参数的传递：</p><ul><li>http、fs、path等，原生模块。</li><li>.&#x2F;mod或..&#x2F;mod，相对路径的文件模块。</li><li>&#x2F;pathtomodule&#x2F;mod，绝对路径的文件模块。</li><li>mod，非原生模块的文件模块。</li></ul><p>在路径 Y 下执行 require(X) 语句执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果 X 是内置模块<br>   a. 返回内置模块<br>   b. 停止执行<br>2. 如果 X 以 <span class="hljs-string">&#x27;/&#x27;</span> 开头<br>   a. 设置 Y 为文件根路径<br>3. 如果 X 以 <span class="hljs-string">&#x27;./&#x27;</span> 或 <span class="hljs-string">&#x27;/&#x27;</span> or <span class="hljs-string">&#x27;../&#x27;</span> 开头<br>   a. LOAD_AS_FILE(Y + X)<br>   b. LOAD_AS_DIRECTORY(Y + X)<br>4. LOAD_NODE_MODULES(X, <span class="hljs-built_in">dirname</span>(Y))<br>5. 抛出异常 <span class="hljs-string">&quot;not found&quot;</span><br><br>LOAD_AS_FILE(X)<br>1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。<br>3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。<br>4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。<br><br>LOAD_INDEX(X)<br>1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。<br>3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。<br><br>LOAD_AS_DIRECTORY(X)<br>1. 如果 X/package.json 是一个文件,<br>   a. 解析 X/package.json, 并查找 <span class="hljs-string">&quot;main&quot;</span> 字段。<br>   b. <span class="hljs-built_in">let</span> M = X + (json main 字段)<br>   c. LOAD_AS_FILE(M)<br>   d. LOAD_INDEX(M)<br>2. LOAD_INDEX(X)<br><br>LOAD_NODE_MODULES(X, START)<br>1. <span class="hljs-built_in">let</span> DIRS=NODE_MODULES_PATHS(START)<br>2. <span class="hljs-keyword">for</span> each DIR <span class="hljs-keyword">in</span> DIRS:<br>   a. LOAD_AS_FILE(DIR/X)<br>   b. LOAD_AS_DIRECTORY(DIR/X)<br><br>NODE_MODULES_PATHS(START)<br>1. <span class="hljs-built_in">let</span> PARTS = path <span class="hljs-built_in">split</span>(START)<br>2. <span class="hljs-built_in">let</span> I = count of PARTS - 1<br>3. <span class="hljs-built_in">let</span> DIRS = []<br>4. <span class="hljs-keyword">while</span> I &gt;= 0,<br>   a. <span class="hljs-keyword">if</span> PARTS[I] = <span class="hljs-string">&quot;node_modules&quot;</span> CONTINUE<br>   b. DIR = path <span class="hljs-built_in">join</span>(PARTS[0 .. I] + <span class="hljs-string">&quot;node_modules&quot;</span>)<br>   c. DIRS = DIRS + DIR<br>   d. <span class="hljs-built_in">let</span> I = I - 1<br>5. <span class="hljs-built_in">return</span> DIRS<br></code></pre></td></tr></table></figure><blockquote><p><strong>exports 和 module.exports 的使用</strong></p><p>如果要对外暴露属性或方法，就用 <strong>exports</strong> 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 <strong>module.exports</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七、NodeJs HTTP协议</title>
    <link href="/posts/5656/"/>
    <url>/posts/5656/</url>
    
    <content type="html"><![CDATA[<h1 id="七、NodeJs-HTTP协议"><a href="#七、NodeJs-HTTP协议" class="headerlink" title="七、NodeJs HTTP协议"></a>七、NodeJs HTTP协议</h1><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>HTTP（hypertext transport protocol）协议；中文叫超文本传输协议</p><p>是一种基于TCP&#x2F;IP的应用层通信协议</p><p>这个协议详细规定了 浏览器 和万维网 服务器 之间互相通信的规则。</p><p>协议中主要规定了两个方面的内容</p><ul><li><p>客户端:用来向服务器发送数据，可以被称之为请求报文</p></li><li><p>服务端:向客户端返回数据，可以被称之为响应报文</p></li></ul><p>报文:可以简单理解为就是一堆字符串</p><h1 id="二、请求报文的组成"><a href="#二、请求报文的组成" class="headerlink" title="二、请求报文的组成"></a>二、请求报文的组成</h1><ul><li><p>请求行</p></li><li><p>请求头</p></li><li><p>空行</p></li><li><p>请求体</p></li></ul><h1 id="三、HTTP的请求行"><a href="#三、HTTP的请求行" class="headerlink" title="三、HTTP的请求行"></a>三、HTTP的请求行</h1><ul><li><p>请求方法（get、post、put、delete等）</p></li><li><p>请求URL（统一资源定位器）</p></li></ul><p>例如:<a href="http://www.baidu.com/index.html?a%EF%BC%9D100&b%EF%BC%9D200#logo">http://www.baidu.com:80/index.html?a＝100&amp;b＝200#logo</a></p><ul><li><p>http: 协议（https、ftp、ssh等）</p></li><li><p><a href="http://www.baidu.com/">www.baidu.com</a>         域名</p></li><li><p>80                                端口号</p></li><li><p>&#x2F;index.html                路径</p></li><li><p>a&#x3D;1008.b&#x3D;200           查询字符串</p></li><li><p>#logo                           哈希（锚点链接）</p></li></ul><p>HTTP协议版本号</p><h1 id="四、HTTP请求头"><a href="#四、HTTP请求头" class="headerlink" title="四、HTTP请求头"></a>四、HTTP请求头</h1><p>格式:『头名:头值』</p><p>常见的请求头有:</p><table><thead><tr><th>请求头</th><th>解释</th></tr></thead><tbody><tr><td>Host</td><td>主机名</td></tr><tr><td>Connection</td><td>连接的设置keep-alive（保持连接）；close（关闭连接）</td></tr><tr><td>Cache-Control</td><td>缓存控制 max-age＝0 （没有缓存）</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>将网页中的http请求转化为https请求（很少用）老网站升级</td></tr><tr><td>User-Agent</td><td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自哪个客户端，一般在PC端和手机端的区分</td></tr><tr><td>Accept</td><td>设置浏览器接收的数据类型</td></tr><tr><td>Accept-Encoding</td><td>设置接收的压缩方式</td></tr><tr><td>Accept-Language</td><td>设置接收的语言q＝0.7为喜好系数，满分为1</td></tr><tr><td>Cookie</td><td>后面单独讲</td></tr></tbody></table><h1 id="五、HTTP的请求体"><a href="#五、HTTP的请求体" class="headerlink" title="五、HTTP的请求体"></a>五、HTTP的请求体</h1><p>请求体内容的格式是非常灵活的，</p><p>（可以是空）⇒GET请求，</p><p>（也可以是字符串，还可以是JSON)⇒POST请求</p><p>例如:</p><ul><li><p>字符串:keywords&#x3D;手机8price&#x3D;2000</p></li><li><p>JSON:｛＂keywords＂:＂手机＂，＂price＂:2000｝</p></li></ul><h1 id="六、响应报文的组成"><a href="#六、响应报文的组成" class="headerlink" title="六、响应报文的组成"></a>六、响应报文的组成</h1><ul><li><strong>响应行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure><ul><li><p>HTTP&#x2F;1.1:HTTP协议版本号</p></li><li><p>200:响应状态码 404 Not Found 500 Internal Server Error 还有一些状态码，参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p></li><li><p>OK:响应状态描述</p></li></ul><p><span style="background:#e5eecc">响应状态码和响应字符串关系是–对应的。</span></p><ul><li><strong>响应头</strong></li></ul><table border="1"><tr><td colspan="1" rowspan="1">Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据Connection 链接设置</td></tr><tr><td colspan="1" rowspan="1">Content-Type:text/html;charset=utf-8 设置响应体的数据类型以及字符集，响应体为html，字符集utf-8</td></tr><tr><td colspan="1" rowspan="1">Content-Length:响应体的长度，单位为字节</td></tr></table><ul><li><p><strong>空行</strong></p></li><li><p><strong>响应体</strong></p></li></ul><p><strong>响应体内容的类型是非常灵活的，常见的类型有HTML、CSS、JS、图片、JSON</strong></p><h1 id="七、创建HTTP服务"><a href="#七、创建HTTP服务" class="headerlink" title="七、创建HTTP服务"></a>七、创建HTTP服务</h1><p>使用nodejs 创建 HTTP服务</p><h2 id="7-1-操作步骤"><a href="#7-1-操作步骤" class="headerlink" title="7.1 操作步骤"></a>7.1 操作步骤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//2. 创建服务对象 create 创建 server 服务</span><br><span class="hljs-comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据</span><br><span class="hljs-comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello HTTP server&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//3. 监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口 9000 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>http.createServer 里的回调函数的执行时机: 当接收到 HTTP 请求的时候，就会执行</strong></p><h2 id="7-2-测试"><a href="#7-2-测试" class="headerlink" title="7.2 测试"></a>7.2 测试</h2><p>浏览器请求对应端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://127.0.0.1:9000<br></code></pre></td></tr></table></figure><h2 id="7-3-注意事项"><a href="#7-3-注意事项" class="headerlink" title="7.3 注意事项"></a>7.3 注意事项</h2><h3 id="1-命令行-ctrl＋c停止服务"><a href="#1-命令行-ctrl＋c停止服务" class="headerlink" title="1.命令行 ctrl＋c停止服务"></a>1.命令行 <strong>ctrl＋c</strong>停止服务</h3><h3 id="2-当服务启动后，更新代码-必须重启服务才能生效"><a href="#2-当服务启动后，更新代码-必须重启服务才能生效" class="headerlink" title="2.当服务启动后，更新代码 必须重启服务才能生效"></a>2.当服务启动后，更新代码 必须重启服务才能生效</h3><h3 id="3-响应内容中文乱码的解决办法"><a href="#3-响应内容中文乱码的解决办法" class="headerlink" title="3.响应内容中文乱码的解决办法"></a>3.响应内容中文乱码的解决办法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-端口号被占用"><a href="#4-端口号被占用" class="headerlink" title="4.端口号被占用"></a>4.端口号被占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: listen EADDRINUSE: address already <span class="hljs-keyword">in</span> use :::9000<br></code></pre></td></tr></table></figure><p>1）关闭当前正在运行监听端口的服务（使用较多）</p><p>2）修改其他端口号</p><p>5.HTTP协议默认端口是80。HTTPS协议的默认端口是443，HTTP服务开发常用端口有3000，8080,8090,9000等</p><p><strong>如果端口被其他程序占用，可以使用资源监视器 找到占用端口的程序，然后使用 任务管理器 关闭对应的程序</strong></p><h1 id="八、浏览器查看HTTP报文"><a href="#八、浏览器查看HTTP报文" class="headerlink" title="八、浏览器查看HTTP报文"></a>八、浏览器查看HTTP报文</h1><p><strong>点击步骤</strong></p><p><img src="/posts/5656/image-20241014173924293.png"></p><h2 id="8-1查看请求行与请求头"><a href="#8-1查看请求行与请求头" class="headerlink" title="8.1查看请求行与请求头"></a>8.1查看请求行与请求头</h2><h2 id><a href="#" class="headerlink" title></a><img src="/posts/5656/image-20241014174034947.png"></h2><h2 id="8-2查看请求体"><a href="#8-2查看请求体" class="headerlink" title="8.2查看请求体"></a>8.2查看请求体</h2><p><img src="/posts/5656/image-20241014174143907.png"></p><h2 id="8-3查看URL查询字符串"><a href="#8-3查看URL查询字符串" class="headerlink" title="8.3查看URL查询字符串"></a>8.3查看URL查询字符串</h2><p><img src="/posts/5656/image-20241014174204151.png"></p><h2 id="8-4查看响应行与响应头"><a href="#8-4查看响应行与响应头" class="headerlink" title="8.4查看响应行与响应头"></a>8.4查看响应行与响应头</h2><p><img src="/posts/5656/image-20241014174335095.png"></p><h2 id="8-5查看响应体"><a href="#8-5查看响应体" class="headerlink" title="8.5查看响应体"></a>8.5查看响应体</h2><p><img src="/posts/5656/image-20241014174400437.png"></p><h1 id="九、获取HTTP请求报文"><a href="#九、获取HTTP请求报文" class="headerlink" title="九、获取HTTP请求报文"></a>九、获取HTTP请求报文</h1><p>想要获取请求的数据，需要通过request 对象</p><table><thead><tr><th>含义</th><th>语法</th><th>重点掌握</th></tr></thead><tbody><tr><td>请求方法</td><td>request.method</td><td>*</td></tr><tr><td>请求版本</td><td>request.httpVersion</td><td></td></tr><tr><td>请求路径</td><td>request.url</td><td>*</td></tr><tr><td>URL 路径</td><td>require(‘url’).parse(request.url).pathname</td><td>*</td></tr><tr><td>URL查询字符串</td><td>require(‘url’).parse(request.url, true).query</td><td>*</td></tr><tr><td>请求头</td><td>request.headers</td><td>*</td></tr><tr><td>请求体</td><td>request.on(‘data, function(chunk){}); request.on(‘end’, function(){});</td><td></td></tr></tbody></table><p><strong>注意事项:</strong></p><p>1.request.url只能获取路径以及查询字符串，无法获取URL中的域名以及协议的内容</p><p>2.request.headers将请求信息转化成一个对象，并将属性名都转化成了『小写』</p><p>3.关于路径:如果访问网站的时候，只填写了IP地址或者是域名信息，此时请求的路径为『&#x2F;』</p><p>4.关于favicon.ico:这个请求是属于浏览器自动发送的请求</p><h2 id="9-1-搭建HTTP服务"><a href="#9-1-搭建HTTP服务" class="headerlink" title="9.1 搭建HTTP服务"></a>9.1 搭建HTTP服务</h2><p>按照以下要求搭建HTTP服务</p><table><thead><tr><th>请求类型（方法）</th><th>请求地址</th><th>响应体结果</th></tr></thead><tbody><tr><td>get</td><td>&#x2F;login</td><td>登录页面</td></tr><tr><td>get</td><td>&#x2F;reg</td><td>注册页面</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、引入http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-comment">//2、建立服务</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request; <span class="hljs-comment">//对象的解构赋值</span><br>    <span class="hljs-comment">//设置响应头信息</span><br>    <span class="hljs-comment">//解决中文乱码</span><br>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/register&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;注册页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;登录页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//3、监听端口</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="十、设置HTTP响应报文"><a href="#十、设置HTTP响应报文" class="headerlink" title="十、设置HTTP响应报文"></a>十、设置HTTP响应报文</h1><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage（用的非常少）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader（＇头名，＇头值）</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’) response.end(‘xxx’)</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//write 和 end 的两种使用情况:</span><br><span class="hljs-comment">//1. write 和 end 的结合使用 响应体相对分散</span><br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">//每一个请求，在处理的时候必须要执行 end 方法的</span><br><span class="hljs-comment">//2. 单独使用 end 方法 响应体相对集中</span><br>response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="10-1-示例"><a href="#10-1-示例" class="headerlink" title="10.1 示例"></a>10.1 示例</h2><p>搭建HTTP服务，响应一个4行3列的表格，并且要求表格有 隔行换色效果，且点击单元格能 高亮显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="hljs-string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="hljs-string">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="hljs-string">    &lt;style&gt;</span><br><span class="hljs-string">    td&#123;</span><br><span class="hljs-string">    padding: 20px 40px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(odd)&#123;</span><br><span class="hljs-string">    background: #aef;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(even)&#123;</span><br><span class="hljs-string">    background: #fcb;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table, td&#123;</span><br><span class="hljs-string">    border-collapse: collapse;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &lt;/style&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;/table&gt;</span><br><span class="hljs-string">    &lt;script&gt;</span><br><span class="hljs-string">    //获取所有的 td</span><br><span class="hljs-string">    let tds = document.querySelectorAll(&#x27;td&#x27;);</span><br><span class="hljs-string">    //遍历</span><br><span class="hljs-string">    tds.forEach(item =&gt; &#123;</span><br><span class="hljs-string">    item.onclick = function()&#123;</span><br><span class="hljs-string">    this.style.background = &#x27;#222&#x27;;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">`</span>); <span class="hljs-comment">//设置响应体</span><br>&#125;);<br><span class="hljs-comment">//监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动....&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="十一、网页资源的基本加载过程"><a href="#十一、网页资源的基本加载过程" class="headerlink" title="十一、网页资源的基本加载过程"></a>十一、网页资源的基本加载过程</h1><p><img src="/posts/5656/image-20241014175420098.png"></p><p>网页资源的加载都是循序渐进的，首先获取HTML的内容，然后解析HTML在发送其他资源的请求，如CSS， Javascript，图片等。理解了这个内容对于后续的学习与成长有非常大的帮助</p><h1 id="十二、静态资源服务"><a href="#十二、静态资源服务" class="headerlink" title="十二、静态资源服务"></a>十二、静态资源服务</h1><p>静态资源是指内容长时间不发生改变的资源，例如图片，视频，cSS文件，JS文件，HTML文件，字体文件等</p><p>动态资源是指内容经常更新的资源，例如百度首页，网易首页，京东搜索列表页面等</p><h2 id="12-1-网站根目录或静态资源目录"><a href="#12-1-网站根目录或静态资源目录" class="headerlink" title="12.1 网站根目录或静态资源目录"></a>12.1 网站根目录或静态资源目录</h2><p>HTTP服务在哪个文件夹中寻找静态资源，那个文件夹就是静态资源目录，也称之为 网站根目录</p><p>思考:vscode 中使用live-server访问HTML时，它启动的服务中网站根目录是谁？</p><h2 id="12-2-网页中的URL"><a href="#12-2-网页中的URL" class="headerlink" title="12.2 网页中的URL"></a>12.2 网页中的URL</h2><p>网页中的URL主要分为两大类:相对路径与绝对路径</p><h3 id="12-2-1-绝对路径"><a href="#12-2-1-绝对路径" class="headerlink" title="12.2.1 绝对路径"></a>12.2.1 绝对路径</h3><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><table><thead><tr><th>形式</th><th>特点</th></tr></thead><tbody><tr><td><a href="http://atguigu.com/web">http://atguigu.com/web</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td>&#x2F;&#x2F;atguigu.com&#x2F;web</td><td>与页面URL的协议拼接形成完整URL再发送请求。大型网站用的比较多</td></tr><tr><td>&#x2F;web</td><td>与页面URL的协议、主机名、端口拼接形成完整URL再发送请求。中小型网站</td></tr></tbody></table><h3 id="12-2-2-相对路径"><a href="#12-2-2-相对路径" class="headerlink" title="12.2.2 相对路径"></a>12.2.2 相对路径</h3><p>相对路径在发送请求时，需要与当前页面URL路径进行计算，得到完整URL后，再发送请求，学习阶段用的较多</p><p>例如当前网页url为<a href="http://www.atguigu.com/course/h5.html">http://www.atguigu.com/course/h5.html</a></p><table><thead><tr><th>形式</th><th>最终的URL</th></tr></thead><tbody><tr><td>.&#x2F;css&#x2F;app.css</td><td><a href="http://www.atguigu.com/course/css/app.css">http://www.atguigu.com/course/css/app.css</a></td></tr><tr><td>js&#x2F;app.js</td><td><a href="http://www.atguigu.com/course/js/app.js">http://www.atguigu.com/course/js/app.js</a></td></tr><tr><td>..&#x2F;img&#x2F;logo.png</td><td><a href="http://www.atguigu.com/img/logo.png">http://www.atguigu.com/img/logo.png</a></td></tr><tr><td>..&#x2F;..&#x2F;mp4&#x2F;show.mp4</td><td><a href="http://www.atguigu.com/mp4/show.mp4">http://www.atguigu.com/mp4/show.mp4</a></td></tr></tbody></table><h3 id="12-2-3-网页中使用URL的场景小结"><a href="#12-2-3-网页中使用URL的场景小结" class="headerlink" title="12.2.3 网页中使用URL的场景小结"></a>12.2.3 网页中使用URL的场景小结</h3><p>包括但不限于如下场景:</p><ul><li><p>a标签href</p></li><li><p>link标签 href</p></li><li><p>script标签src</p></li><li><p>img标签 src</p></li><li><p>video audio 标签 src</p></li><li><p>form中的action</p></li><li><p>AJAX请求中的URL</p></li></ul><h2 id="12-3-设置资源类型（mime类型）"><a href="#12-3-设置资源类型（mime类型）" class="headerlink" title="12.3 设置资源类型（mime类型）"></a>12.3 设置资源类型（mime类型）</h2><p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。</p><p><code>mime 类型结构:［type］/［subType］</code></p><p><code>例如:text/html text/css image/jpeg image/png application/json</code></p><p>HTTP服务可以设置响应头Content-Type 来表明响应体的MIME类型，浏览器会根据该类型决定如何处理资源</p><p>下面是常见文件对应的mime类型</p><ul><li><p>html:’text&#x2F;html’,</p></li><li><p>css:’text&#x2F;css’,</p></li><li><p>js: ‘text&#x2F;javascript’,</p></li><li><p>png: ‘image&#x2F;png’,</p></li><li><p>jpg: ‘image&#x2F;jpeg’,</p></li><li><p>gif: ‘image&#x2F;gif’,</p></li><li><p>mp4: ‘video&#x2F;mp4’,</p></li><li><p>mp3: ‘audio&#x2F;mpeg’,</p></li><li><p>json: ‘application&#x2F;json’</p></li></ul><p>对于未知的资源类型，可以选择 application&#x2F;octet-stream类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的下载效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//判断请求方式以及请求路径</span><br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/index.html&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/css/app.css&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/css/app.css&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/js/app.js&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/js/app.js&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//404响应</span><br>        response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>很明显上面的代码，当只要有一个请求路径就需要进行判断，显然这种方式不够完美，那么我们需要封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//文件夹路径</span><br>    <span class="hljs-keyword">let</span> rootDir = __dirname + <span class="hljs-string">&#x27;/public&#x27;</span>;<br>    <span class="hljs-comment">//拼接文件路径</span><br>    <span class="hljs-keyword">let</span> filePath = rootDir + url;<br>    <span class="hljs-comment">//读取文件内容</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断</span><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-comment">//如果出现错误，响应404状态码</span><br>            response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>            response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//响应文件内容</span><br>            response.<span class="hljs-title function_">end</span>(data);<br>        &#125;<br>    &#125;)<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="12-4-GET和POST请求场景小结"><a href="#12-4-GET和POST请求场景小结" class="headerlink" title="12.4 GET和POST请求场景小结"></a>12.4 GET和POST请求场景小结</h2><h3 id="12-4-1-GET-请求的情况"><a href="#12-4-1-GET-请求的情况" class="headerlink" title="12.4.1 GET 请求的情况:"></a>12.4.1 <strong>GET 请求的情况:</strong></h3><p>在地址栏直接输入url访问</p><ul><li><p>点击a链接</p></li><li><p>link标签引入css</p></li><li><p>script 标签引入js</p></li><li><p>img标签引入图片</p></li><li><p>form标签中的method为get（不区分大小写）</p></li><li><p>ajax中的get请求</p></li></ul><h3 id="12-4-2-POST-请求的情况"><a href="#12-4-2-POST-请求的情况" class="headerlink" title="12.4.2 POST 请求的情况:"></a>12.4.2 <strong>POST 请求的情况:</strong></h3><ul><li><p>form标签中的method为post（不区分大小写）</p></li><li><p>AJAX的post请求</p></li></ul><h2 id="十三、GET和POST请求的区别"><a href="#十三、GET和POST请求的区别" class="headerlink" title="十三、GET和POST请求的区别"></a>十三、GET和POST请求的区别</h2><p>GET和POST是HTTP协议请求的两种方式。</p><ul><li><p>GET主要用来获取数据，POST主要用来提交数据</p></li><li><p>GET带参数请求是将参数缀到URL之后，在地址栏中输入url访问网站就是GET请求，POST带参数请求是将参数放到请求体中</p></li><li><p>POST 请求相对GET安全一些，因为在浏览器中参数会暴露在地址栏</p></li><li><p>GET请求大小有限制，一般为2K，而POST 请求则没有大小限制</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、NodeJs path模块</title>
    <link href="/posts/5760/"/>
    <url>/posts/5760/</url>
    
    <content type="html"><![CDATA[<h1 id="六、NodeJs-path模块"><a href="#六、NodeJs-path模块" class="headerlink" title="六、NodeJs path模块"></a>六、NodeJs path模块</h1><p>path 模块提供了操作路径的功能，我们将介绍如下几个较为常用的几个 API：</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>path.resolve</td><td>拼接规范的绝对路径 常用</td></tr><tr><td>path.sep</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse</td><td>解析路径并返回对象</td></tr><tr><td>path.basename</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname</td><td>获取路径的目录名</td></tr><tr><td>path.extname</td><td>获得路径的扩展名</td></tr></tbody></table><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">//获取路径分隔符</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-property">sep</span>);<br><br><span class="hljs-comment">//拼接绝对路径</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;test&#x27;</span>));<br><br><span class="hljs-comment">//解析路径</span><br><br><span class="hljs-keyword">let</span> pathname = <span class="hljs-string">&#x27;D:/program file/nodejs/node.exe&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">parse</span>(pathname));<br><br><span class="hljs-comment">//获取路径基础名称</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(pathname))<br><br><span class="hljs-comment">//获取路径的目录名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">dirname</span>(pathname));<br><br><span class="hljs-comment">//获取路径的扩展名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(pathname));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、NodeJs fs模块</title>
    <link href="/posts/3454/"/>
    <url>/posts/3454/</url>
    
    <content type="html"><![CDATA[<h1 id="五、NodeJs-fs模块"><a href="#五、NodeJs-fs模块" class="headerlink" title="五、NodeJs fs模块"></a>五、NodeJs fs模块</h1><p>fs 全称为 file system，称之为文件系统，是 Node.js 中的内置模块，可以对计算机中的磁盘进行操作。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile &#x2F; appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h1 id="一、文件写入"><a href="#一、文件写入" class="headerlink" title="一、文件写入"></a>一、文件写入</h1><p>文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果</p><h2 id="1-1-writeFile-异步写入"><a href="#1-1-writeFile-异步写入" class="headerlink" title="1-1. writeFile 异步写入"></a>1-1. writeFile 异步写入</h2><p>语法： </p><p><strong>fs.writeFile(file, data[, options], callback)</strong></p><p>参数说明：</p><ul><li><p>file 文件名</p></li><li><p>data 待写入的数据</p></li><li><p>options 选项设置（可选）</p></li><li><p>callback 写入回调</p></li></ul><p>返回值： undefined</p><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// require 是 Node.js 环境中的&#x27;全局&#x27;变量，用来导入模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">//将 『三人行，必有我师焉。』 写入到当前文件夹下的『座右铭.txt』文件中</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)；<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-2-writeFileSync-同步写入"><a href="#1-2-writeFileSync-同步写入" class="headerlink" title="1-2. writeFileSync 同步写入"></a>1-2. writeFileSync 同步写入</h2><p> 语法: </p><p><strong>fs.writeFileSync(file, data[, options])</strong></p><p> 参数与 fs.writeFile 大体一致，只是没有 callback 参数</p><p> 返回值：undefined</p><p> <strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>    fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p> Node.js 中的磁盘操作是由其他线程完成的，结果的处理有两种模式：</p><p> 同步处理 JavaScript 主线程会等待其他线程的执行结果，然后再继续执行主线程的代码，</p><p> 效率较低</p><p> 异步处理 JavaScript 主线程不会等待其他线程的执行结果，直接执行后续的主线程代码，</p><p>效率较好</p><h2 id="1-3-appendFile-appendFileSync-追加写入"><a href="#1-3-appendFile-appendFileSync-追加写入" class="headerlink" title="1-3. appendFile &#x2F; appendFileSync 追加写入"></a>1-3. appendFile &#x2F; appendFileSync 追加写入</h2><p> appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同</p><p> 语法:</p><ul><li><p><strong>fs.appendFile(file, data[, options], callback)</strong></p></li><li><p><strong>fs.appendFileSync(file, data[, options])</strong></p></li></ul><p> 返回值： 二者都为 undefined</p><p> 实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;择其善者而从之，其不善者而改之。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;追加成功&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">appendFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;\r\n温故而知新, 可以为师矣&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-4-createWriteStream-流式写入"><a href="#1-4-createWriteStream-流式写入" class="headerlink" title="1-4. createWriteStream 流式写入"></a>1-4. createWriteStream 流式写入</h2><p> 语法：</p><p> <strong>fs.createWriteStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>返回值：Object</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ws = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;天光云影共徘徊\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;问渠那得清如许\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;为有源头活水来\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure><p> 程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p> 流式写入方式适用于大文件写入或者频繁写入的场景, writeFile 适合于写入频率较低的场景</p><h2 id="1-5-写入文件的场景"><a href="#1-5-写入文件的场景" class="headerlink" title="1-5 写入文件的场景"></a>1-5 写入文件的场景</h2><p> 文件写入在计算机中是一个非常常见的操作，下面的场景都用到了文件写入</p><ul><li><p>下载文件</p></li><li><p>安装软件</p></li><li><p>保存程序日志，如 Git</p></li><li><p>编辑器保存文件</p></li><li><p>视频录制</p></li></ul><p> 当需要持久化保存数据的时候，应该想到文件写入</p><h1 id="二、文件读取"><a href="#二、文件读取" class="headerlink" title="二、文件读取"></a>二、文件读取</h1><p> 文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h2 id="2-1-readFile-异步读取"><a href="#2-1-readFile-异步读取" class="headerlink" title="2-1 readFile 异步读取"></a>2-1 readFile 异步读取</h2><p> 语法：<strong>fs.readFile(path[, options], callback)</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li><li><p>callback 回调函数</p></li></ul><p> 返回值： undefined</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="2-2-readFileSync-同步读取"><a href="#2-2-readFileSync-同步读取" class="headerlink" title="2-2 readFileSync 同步读取"></a>2-2 readFileSync 同步读取</h2><p> 语法：<strong>fs.readFileSync(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li></ul><p> 返回值： string | Buffer</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>);<br><span class="hljs-keyword">let</span> data2 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="2-3-createReadStream-流式读取"><a href="#2-3-createReadStream-流式读取" class="headerlink" title="2-3 createReadStream 流式读取"></a>2-3 createReadStream 流式读取</h2><p> 语法：<strong>fs.createReadStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li></ul><p> 返回值： Object</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建读取流对象</span><br><span class="hljs-keyword">let</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br><span class="hljs-comment">//每次取出 64k 数据后执行一次 data 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;);<br><span class="hljs-comment">//读取完毕后, 执行 end 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-4-读取文件应用场景"><a href="#2-4-读取文件应用场景" class="headerlink" title="2-4 读取文件应用场景"></a>2-4 读取文件应用场景</h2><ul><li><p>电脑开机</p></li><li><p>程序运行</p></li><li><p>编辑器打开文件</p></li><li><p>查看图片</p></li><li><p>播放视频</p></li><li><p>播放音乐</p></li><li><p>Git 查看日志</p></li><li><p>上传文件</p></li><li><p>查看聊天记录</p></li></ul><h1 id="三、文件移动与重命名"><a href="#三、文件移动与重命名" class="headerlink" title="三、文件移动与重命名"></a>三、文件移动与重命名</h1><p> 在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名文件或文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rename(oldPath, newPath, callback)</strong></p></li><li><p><strong>fs.renameSync(oldPath, newPath)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>oldPath 文件当前的路径</p></li><li><p>newPath 文件新的路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><p> &#x2F;&#x2F;创建读取流对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/观书有感.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;移动完成&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">renameSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/我的座右铭.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="四、文件删除"><a href="#四、文件删除" class="headerlink" title="四、文件删除"></a>四、文件删除</h1><p> 在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件</p><p> 语法：</p><ul><li><p><strong>fs.unlink(path, callback)</strong></p></li><li><p><strong>fs.unlinkSync(path)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br>fs.<span class="hljs-title function_">unlinkSync</span>(<span class="hljs-string">&#x27;./test2.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="五、文件夹操作"><a href="#五、文件夹操作" class="headerlink" title="五、文件夹操作"></a>五、文件夹操作</h1><p> 借助 Node.js 的能力，我们可以对文件夹进行创建 、读取、 删除等操作</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir &#x2F; mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir &#x2F; readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir &#x2F; rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h2 id="5-1-mkdir-创建文件夹"><a href="#5-1-mkdir-创建文件夹" class="headerlink" title="5-1 mkdir 创建文件夹"></a>5-1 mkdir 创建文件夹</h2><p> 在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹</p><p> 语法：</p><ul><li><p><strong>fs.mkdir(path[, options], callback)</strong></p></li><li><p><strong>fs.mkdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归异步创建</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./1/2/3&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归同步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-string">&#x27;./x/y/z&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p> &#x2F;&#x2F;异步创建文件夹</p><h2 id="5-2-readdir-读取文件夹"><a href="#5-2-readdir-读取文件夹" class="headerlink" title="5-2 readdir 读取文件夹"></a>5-2 readdir 读取文件夹</h2><p> 在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹</p><p> 语法：</p><ul><li><p><strong>fs.readdir(path[, options], callback)</strong></p></li><li><p><strong>fs.readdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步读取</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步读取</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h2 id="5-3-rmdir-删除文件夹"><a href="#5-3-rmdir-删除文件夹" class="headerlink" title="5-3 rmdir 删除文件夹"></a>5-3 rmdir 删除文件夹</h2><p> 在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rmdir(path[, options], callback)</strong></p></li><li><p><strong>fs.rmdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//异步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./1&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归删除&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//同步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdirSync</span>(<span class="hljs-string">&#x27;./x&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><h1 id="六、查看资源状态"><a href="#六、查看资源状态" class="headerlink" title="六、查看资源状态"></a>六、查看资源状态</h1><p> 在 Node.js 中，我们可以使用 stat 或 statSync 来查看资源的详细信息</p><p> 语法：</p><ul><li><p><strong>fs.stat(path[, options], callback)</strong></p></li><li><p><strong>fs.statSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步获取状态</span><br>fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步获取状态</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">statSync</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><p> 结果值对象结构：</p><ul><li><p>size 文件体积</p></li><li><p>birthtime 创建时间</p></li><li><p>mtime 最后修改时间</p></li><li><p>isFile 检测是否为文件</p></li><li><p>isDirectory 检测是否为文件夹</p></li></ul><p> ….</p><h1 id="七、相对路径问题"><a href="#七、相对路径问题" class="headerlink" title="七、相对路径问题"></a>七、相对路径问题</h1><p> fs 模块对资源进行操作时，路径的写法有两种：</p><p> <strong>相对路径</strong></p><ul><li><p>.&#x2F;座右铭.txt 当前目录下的座右铭.txt</p></li><li><p>座右铭.txt 等效于上面的写法</p></li><li><p>..&#x2F;座右铭.txt 当前目录的上一级目录中的座右铭.txt</p></li></ul><p> <strong>绝对路径</strong></p><ul><li><p>D:&#x2F;Program Files windows 系统下的绝对路径</p></li><li><p>&#x2F;usr&#x2F;bin Linux 系统下的绝对路径</p></li></ul><p> 相对路径中所谓的当前目录，指的是命令行的工作目录，而并非是文件的所在目录</p><p> 所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG</p><h1 id="八、-dirname"><a href="#八、-dirname" class="headerlink" title="八、__dirname"></a>八、__dirname</h1><p> __dirname 与 require 类似，都是 Node.js 环境中的’全局’变量</p><p> __dirname 保存着当前文件所在目录的绝对路径，可以使用 __dirname 与文件名拼接成绝对路径</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><p> <em>使用 fs 模块的时候，尽量使用 __dirname 将路径转化为绝对路径，这样可以避免相对路径产生的Bug</em></p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、NodeJs Stream(流)</title>
    <link href="/posts/6344/"/>
    <url>/posts/6344/</url>
    
    <content type="html"><![CDATA[<h1 id="四、NodeJs-Stream-流"><a href="#四、NodeJs-Stream-流" class="headerlink" title="四、NodeJs Stream(流)"></a>四、NodeJs Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p><p>Node.js，Stream 有四种流类型：</p><ul><li><strong>Readable</strong> - 可读操作。</li><li><strong>Writable</strong> - 可写操作。</li><li><strong>Duplex</strong> - 可读可写操作.</li><li><strong>Transform</strong> - 操作被写入数据，然后读出结果。</li></ul><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><ul><li><strong>data</strong> - 当有数据可读时触发。</li><li><strong>end</strong> - 没有更多的数据可读时触发。</li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul><p>本教程会为大家介绍常用的流操作。</p><hr><h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-comment">// 创建可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 设置编码为 utf8。</span><br>readerStream.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 处理流事件 --&gt; data, end, and error</span><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) &#123;<br>   data += chunk;<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;菜鸟教程官网地址：www.runoob.com&#x27;</span>;<br><br><span class="hljs-comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 使用 utf8 编码写入数据</span><br>writerStream.<span class="hljs-title function_">write</span>(data,<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 标记文件末尾</span><br>writerStream.<span class="hljs-title function_">end</span>();<br><br><span class="hljs-comment">// 处理流事件 --&gt; finish、error</span><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入完成。&quot;</span>);<br>&#125;);<br><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br>写入完成。<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p><p><img src="/posts/6344/bVcla61.png"></p><p>如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。</p><p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p><p>设置 input.txt 文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br><span class="hljs-comment">// 创建一个可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个可写流</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 管道读写操作</span><br><span class="hljs-comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br>readerStream.<span class="hljs-title function_">pipe</span>(writerStream);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><hr><h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p><p>接下来我们就是用管道和链式来压缩和解压文件。</p><p>创建 compress.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 压缩 input.txt 文件为 input.txt.gz</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件压缩完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node compress.js <br>文件压缩完成。<br></code></pre></td></tr></table></figure><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p><p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 解压 input.txt.gz 文件为 input.txt</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGunzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件解压完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node decompress.js <br>文件解压完成。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、NodeJs Buffer(缓冲区)</title>
    <link href="/posts/16461/"/>
    <url>/posts/16461/</url>
    
    <content type="html"><![CDATA[<h1 id="三、NodeJs-Buffer-缓冲区"><a href="#三、NodeJs-Buffer-缓冲区" class="headerlink" title="三、NodeJs Buffer(缓冲区)"></a>三、NodeJs Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p><p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I&#x2F;O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><blockquote><p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 <strong>Buffer.from()</strong> 接口去创建Buffer对象。</p></blockquote><hr><h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br><br><span class="hljs-comment">// 输出 72756e6f6f62</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>));<br><br><span class="hljs-comment">// 输出 cnVub29i</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;base64&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Node.js 目前支持的字符编码包括：</strong></p><ul><li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li><li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li><li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li><li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li><li><strong>base64</strong> - Base64 编码。</li><li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li><li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li><li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li></ul><hr><h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p><ul><li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li><li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li><li><strong>Buffer.allocUnsafeSlow(size)</strong></li><li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li><li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li><li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li><li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="hljs-comment">// 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="hljs-comment">// 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="hljs-comment">// 因此需要使用 fill() 或 write() 重写。</span><br><span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf6 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>, <span class="hljs-string">&#x27;latin1&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>写入 Node 缓冲区的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">write</span>(string[, offset[, length]][, encoding])<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>string</strong> - 写入缓冲区的字符串。</li><li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li><li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li></ul><p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">256</span>);<br>len = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;www.runoob.com&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入字节数 : &quot;</span>+  len);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span> main.js<br>写入字节数 : 14<br></code></pre></td></tr></table></figure><hr><h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>读取 Node 缓冲区数据的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toString</span>([encoding[, start[, end]]])<br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li><li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li><li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">26</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) &#123;<br>  buf[i] = i + <span class="hljs-number">97</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>));       <span class="hljs-comment">// 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));   <span class="hljs-comment">//使用 &#x27;ascii&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));    <span class="hljs-comment">// 使用 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-literal">undefined</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)); <span class="hljs-comment">// 使用默认的 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>abcdefghijklmnopqrstuvwxyz<br>abcde<br>abcde<br>abcde<br></code></pre></td></tr></table></figure><hr><h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toJSON</span>()<br></code></pre></td></tr></table></figure><p>当字符串化一个 Buffer 实例时，<a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a> 会隐式地调用该 **toJSON()**。</p><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回 JSON 对象。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>]);<br><span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(buf);<br><br><span class="hljs-comment">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);<br><br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> value &amp;&amp; value.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;Buffer&#x27;</span> ?<br>    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(value.<span class="hljs-property">data</span>) :<br>    value;<br>&#125;);<br><br><span class="hljs-comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Buffer&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>:[1,2,3,4,5]&#125;<br>&lt;Buffer 01 02 03 04 05&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区合并的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(list[, totalLength])<br></code></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li><li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buffer1,buffer2]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer3 内容: &quot;</span> + buffer3.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer3 内容: 菜鸟教程www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">compare</span>(otherBuffer);<br></code></pre></td></tr></table></figure><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</li></ul><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个数字，表示 <strong>buf</strong> 在 <strong>otherBuffer</strong> 之前，之后或相同。</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>);<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>);<br><span class="hljs-keyword">var</span> result = buffer1.<span class="hljs-title function_">compare</span>(buffer2);<br><br><span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之前&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 与 &quot;</span> + buffer2 + <span class="hljs-string">&quot;相同&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之后&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ABC在ABCD之前<br></code></pre></td></tr></table></figure><hr><h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区拷贝语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">copy</span>(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])<br></code></pre></td></tr></table></figure><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</li><li><strong>targetStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>没有返回值。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abcdefghijkl&#x27;</span>);<br><span class="hljs-keyword">var</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);<br><br><span class="hljs-comment">//将 buf2 插入到 buf1 指定位置上</span><br>buf2.<span class="hljs-title function_">copy</span>(buf1, <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">abRUNOOBijkl<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">slice</span>([start[, end]])<br></code></pre></td></tr></table></figure><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>start</strong> - 数字, 可选, 默认: 0</li><li><strong>end</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>);<br><span class="hljs-comment">// 剪切缓冲区</span><br><span class="hljs-keyword">var</span> buffer2 = buffer1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer2 content: &quot;</span> + buffer2.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer2 content: ru<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区长度计算语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h3><p>返回 Buffer 对象所占据的内存长度。</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>);<br><span class="hljs-comment">//  缓冲区长度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer length: &quot;</span> + buffer.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer length: 14<br></code></pre></td></tr></table></figure><hr><h2 id="方法参考手册"><a href="#方法参考手册" class="headerlink" title="方法参考手册"></a>方法参考手册</h2><p>以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>new Buffer(size)</strong> 分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。废弃的: 使用 Buffer.alloc() 代替（或 Buffer.allocUnsafe()）。</td></tr><tr><td align="left">2</td><td align="left"><strong>new Buffer(buffer)</strong> 拷贝参数 buffer 的数据到 Buffer 实例。废弃的: 使用 Buffer.from(buffer) 代替。</td></tr><tr><td align="left">3</td><td align="left"><strong>new Buffer(str[, encoding])</strong> 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 废弃的: 使用 Buffer.from(string[, encoding]) 代替。</td></tr><tr><td align="left">4</td><td align="left"><strong>buf.length</strong> 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td></tr><tr><td align="left">5</td><td align="left"><strong>buf.write(string[, offset[, length]][, encoding])</strong> 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</td></tr><tr><td align="left">6</td><td align="left"><strong>buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如： <code>const buf = Buffer.allocUnsafe(6); buf.writeUIntLE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer ab 90 78 56 34 12&gt; console.log(buf);</code>noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">7</td><td align="left"><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。<code>const buf = Buffer.allocUnsafe(6); buf.writeUIntBE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer 12 34 56 78 90 ab&gt; console.log(buf);</code></td></tr><tr><td align="left">8</td><td align="left"><strong>buf.writeIntLE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">9</td><td align="left"><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">10</td><td align="left"><strong>buf.readUIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">11</td><td align="left"><strong>buf.readUIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">12</td><td align="left"><strong>buf.readIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">13</td><td align="left"><strong>buf.readIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">14</td><td align="left"><strong>buf.toString([encoding[, start[, end]]])</strong> 根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</td></tr><tr><td align="left">15</td><td align="left"><strong>buf.toJSON()</strong> 将 Buffer 实例转换为 JSON 对象。</td></tr><tr><td align="left">16</td><td align="left"><strong>buf[index]</strong> 获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td></tr><tr><td align="left">17</td><td align="left"><strong>buf.equals(otherBuffer)</strong> 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td></tr><tr><td align="left">18</td><td align="left"><strong>buf.compare(otherBuffer)</strong> 比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td></tr><tr><td align="left">19</td><td align="left"><strong>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</strong> buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td></tr><tr><td align="left">20</td><td align="left"><strong>buf.slice([start[, end]])</strong> 剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td></tr><tr><td align="left">21</td><td align="left"><strong>buf.readUInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">22</td><td align="left"><strong>buf.readUInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">23</td><td align="left"><strong>buf.readUInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">24</td><td align="left"><strong>buf.readUInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">25</td><td align="left"><strong>buf.readUInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">26</td><td align="left"><strong>buf.readInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">27</td><td align="left"><strong>buf.readInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">28</td><td align="left"><strong>buf.readInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">29</td><td align="left"><strong>buf.readInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">30</td><td align="left"><strong>buf.readInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">31</td><td align="left"><strong>buf.readFloatLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">32</td><td align="left"><strong>buf.readFloatBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">33</td><td align="left"><strong>buf.readDoubleLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">34</td><td align="left"><strong>buf.readDoubleBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">35</td><td align="left"><strong>buf.writeUInt8(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td></tr><tr><td align="left">36</td><td align="left"><strong>buf.writeUInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">37</td><td align="left"><strong>buf.writeUInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">38</td><td align="left"><strong>buf.writeUInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">39</td><td align="left"><strong>buf.writeUInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">40</td><td align="left"><strong>buf.writeInt8(value, offset[, noAssert])</strong></td></tr><tr><td align="left">41</td><td align="left"><strong>buf.writeInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">42</td><td align="left"><strong>buf.writeInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">43</td><td align="left"><strong>buf.writeInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">44</td><td align="left"><strong>buf.writeInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">45</td><td align="left"><strong>buf.writeFloatLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">46</td><td align="left"><strong>buf.writeFloatBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">47</td><td align="left"><strong>buf.writeDoubleLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">48</td><td align="left"><strong>buf.writeDoubleBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">49</td><td align="left"><strong>buf.fill(value[, offset][, end])</strong> 使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、NodeJs EventEmitter</title>
    <link href="/posts/42651/"/>
    <url>/posts/42651/</url>
    
    <content type="html"><![CDATA[<h1 id="二、NodeJs-EventEmitter"><a href="#二、NodeJs-EventEmitter" class="headerlink" title="二、NodeJs EventEmitter"></a>二、NodeJs EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>2 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br>1 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">node.js:201 <br>throw e; // process.nextTick error, or <span class="hljs-string">&#x27;error&#x27;</span> event on first tick <br>^ <br>Error: Uncaught, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at EventEmitter.emit (events.js:50:15) <br>at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) <br>at Module._compile (module.js:441:26) <br>at Object..js (module.js:459:10) <br>at Module.load (module.js:348:31) <br>at Function._load (module.js:308:12) <br>at Array.0 (module.js:479:10) <br>at EventEmitter._tickCallback (node.js:192:40) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、NodeJs 事件循环</title>
    <link href="/posts/17687/"/>
    <url>/posts/17687/</url>
    
    <content type="html"><![CDATA[<h1 id="一、NodeJs-事件循环"><a href="#一、NodeJs-事件循环" class="headerlink" title="一、NodeJs 事件循环"></a>一、NodeJs 事件循环</h1><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p><p>Node.js 几乎每一个 API 都是支持回调函数的。</p><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p><hr><h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><p><img src="/posts/17687/event_loop.jpg"></p><p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>以下程序绑定事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定事件及事件的处理程序</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, eventHandler);<br></code></pre></td></tr></table></figure><p>我们可以通过程序触发事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 触发事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建 main.js 文件，代码如下所示：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>&#x2F;&#x2F; 引入 events 模块 var events &#x3D; require(‘events’); &#x2F;&#x2F; 创建 eventEmitter 对象 var eventEmitter &#x3D; new events.EventEmitter();  &#x2F;&#x2F; 创建事件处理程序 var connectHandler &#x3D; function connected() {   console.log(‘连接成功。’);     &#x2F;&#x2F; 触发 data_received 事件    eventEmitter.emit(‘data_received’); }  &#x2F;&#x2F; 绑定 connection 事件处理程序 eventEmitter.on(‘connection’, connectHandler);  &#x2F;&#x2F; 使用匿名函数绑定 data_received 事件 eventEmitter.on(‘data_received’, function(){   console.log(‘数据接收成功。’); });  &#x2F;&#x2F; 触发 connection 事件  eventEmitter.emit(‘connection’);  console.log(“程序执行完毕。”);</p><p>接下来让我们执行以上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>连接成功。<br>数据接收成功。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p><p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>   <span class="hljs-keyword">if</span> (err)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p><p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p><p>执行以上代码，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>Error: ENOENT, open <span class="hljs-string">&#x27;input.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs基础</title>
    <link href="/posts/31322/"/>
    <url>/posts/31322/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Node-js是什么"><a href="#一、Node-js是什么" class="headerlink" title="一、Node.js是什么"></a>一、Node.js是什么</h1><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p><h3 id="1、特性"><a href="#1、特性" class="headerlink" title="1、特性"></a>1、特性</h3><p>Node.js 可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p><ul><li>文件的读写 (File System)</li><li>进程的管理 (Process)</li><li>网络通信 (HTTP&#x2F;HTTPS)</li><li>……</li></ul><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><h4 id="2-1-浏览器安全级别的限制"><a href="#2-1-浏览器安全级别的限制" class="headerlink" title="2.1 浏览器安全级别的限制"></a>2.1 浏览器安全级别的限制</h4><p><strong>Ajax测试</strong></p><p>浏览器访问存在跨域问题，所以以下的get请求无法成功！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#x27;</span>, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">send</span>()</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>浏览器预览</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">browser-sync start --server --files **/* --directory<br></code></pre></td></tr></table></figure><h4 id="2-2-文件的读写-File-System"><a href="#2-2-文件的读写-File-System" class="headerlink" title="2.2 文件的读写 (File System)"></a>2.2 文件的读写 (File System)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./ajax.png&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-3-进程的管理（Process）"><a href="#2-3-进程的管理（Process）" class="headerlink" title="2.3 进程的管理（Process）"></a>2.3 进程的管理（Process）</h4><p><strong>NodeJs可以通过process来获取执行命令中传入的参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(argv)<br>&#125;<br><br><span class="hljs-title function_">main</span>(process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node 2.3-process.js argv1 argv2<br></code></pre></td></tr></table></figure><h4 id="2-4-网络通信（HTTP-HTTPS）"><a href="#2-4-网络通信（HTTP-HTTPS）" class="headerlink" title="2.4 网络通信（HTTP&#x2F;HTTPS）"></a>2.4 网络通信（HTTP&#x2F;HTTPS）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span><br>  &#125;)<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;hello nodejs&quot;</span>)<br>  res.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h1 id="二、Node-相关工具"><a href="#二、Node-相关工具" class="headerlink" title="二、Node 相关工具"></a>二、Node 相关工具</h1><h3 id="1、NVM-Node-Version-Manager"><a href="#1、NVM-Node-Version-Manager" class="headerlink" title="1、NVM: Node Version Manager"></a>1、NVM: Node Version Manager</h3><p><strong>1.1 Mac 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/nvm-sh/nvm/blob/master/README.md<br></code></pre></td></tr></table></figure><p><strong>1.2 Windows 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm-windows<br>nodist<br></code></pre></td></tr></table></figure><h3 id="2、NPM-Node-Package-Manager"><a href="#2、NPM-Node-Package-Manager" class="headerlink" title="2、NPM: Node Package Manager"></a>2、NPM: Node Package Manager</h3><h4 id="2-1-全局安装package"><a href="#2-1-全局安装package" class="headerlink" title="2.1 全局安装package"></a>2.1 全局安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install forever --global (-g)<br>$ forever<br>$ npm uninstall forever --global<br>$ forever<br></code></pre></td></tr></table></figure><p><strong>全局安装包的目录</strong></p><ul><li>Mac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Users/felix/.nvm/versions/node/nvm各个版本/bin/<br></code></pre></td></tr></table></figure></li><li>Windows<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\你的用户名\AppData\Roaming\npm\node_modules<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-本地安装package"><a href="#2-2-本地安装package" class="headerlink" title="2.2 本地安装package"></a>2.2 本地安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/desktop<br>$ <span class="hljs-built_in">mkdir</span> gp-project<br>$ <span class="hljs-built_in">cd</span> gp-project<br>$ npm install underscore<br>$ npm list (<span class="hljs-built_in">ls</span>)<br></code></pre></td></tr></table></figure><h4 id="2-3-package-json初始化"><a href="#2-3-package-json初始化" class="headerlink" title="2.3 package.json初始化"></a>2.3 package.json初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm init -y<br>$ <span class="hljs-built_in">ls</span><br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-4-使用package-json"><a href="#2-4-使用package-json" class="headerlink" title="2.4 使用package.json"></a>2.4 使用package.json</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install underscore --save<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ npm install lodash --save-dev<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ <span class="hljs-built_in">rm</span> -rf node_modules<br>$ <span class="hljs-built_in">ls</span><br>$ npm install<br>$ npm uninstall underscore --save<br>$ npm list | grep underscore<br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-5-安装指定版本的包"><a href="#2-5-安装指定版本的包" class="headerlink" title="2.5 安装指定版本的包"></a>2.5 安装指定版本的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm list<br>$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.8.0<br>$ npm list<br>$ npm uninstall underscore<br>$ npm list<br></code></pre></td></tr></table></figure><h4 id="2-6-更新本地安装的包"><a href="#2-6-更新本地安装的包" class="headerlink" title="2.6 更新本地安装的包"></a>2.6 更新本地安装的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.4.4 --save-dev<br>$ npm list | grep gulp<br>$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本<br>$ npm list | grep gulp<br>$ npm update<br></code></pre></td></tr></table></figure><h4 id="2-7-清除缓存"><a href="#2-7-清除缓存" class="headerlink" title="2.7 清除缓存"></a>2.7 清除缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h4 id="2-8-上传自己的包"><a href="#2-8-上传自己的包" class="headerlink" title="2.8 上传自己的包"></a>2.8 上传自己的包</h4><h6 id="2-8-1-编写模块"><a href="#2-8-1-编写模块" class="headerlink" title="2.8.1 编写模块"></a>2.8.1 编写模块</h6><p>保存为index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span>; <br>&#125; <br></code></pre></td></tr></table></figure><h6 id="2-8-2-初始化包描述文件"><a href="#2-8-2-初始化包描述文件" class="headerlink" title="2.8.2 初始化包描述文件"></a>2.8.2 初始化包描述文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init <br></code></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19-npm&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.1&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19 self module&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make test&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Git&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git+https://github.com/lurongtao/gp19-npm.git&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>    <span class="hljs-string">&quot;demo&quot;</span> <br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Felixlu&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm/issues&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm#readme&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><h6 id="2-8-3-注册npm仓库账号"><a href="#2-8-3-注册npm仓库账号" class="headerlink" title="2.8.3 注册npm仓库账号"></a>2.8.3 注册npm仓库账号</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://www.npmjs.com 上面的账号<br>felix_lurt/qqmko09ijn<br>$ npm adduser<br></code></pre></td></tr></table></figure><h6 id="2-8-4-上传包"><a href="#2-8-4-上传包" class="headerlink" title="2.8.4 上传包"></a>2.8.4 上传包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm publish<br></code></pre></td></tr></table></figure><p>坑：403 Forbidden</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看npm源：npm config get registry<br>切换npm源方法一：npm config <span class="hljs-built_in">set</span> registry http://registry.npmjs.org<br>切换npm源方法二：nrm use npm<br></code></pre></td></tr></table></figure><h6 id="2-8-5-安装包"><a href="#2-8-5-安装包" class="headerlink" title="2.8.5 安装包"></a>2.8.5 安装包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install gp19-npm<br></code></pre></td></tr></table></figure><h6 id="2-8-6-卸载包"><a href="#2-8-6-卸载包" class="headerlink" title="2.8.6 卸载包"></a>2.8.6 卸载包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看当前项目引用了哪些包 ：<br>npm <span class="hljs-built_in">ls</span><br>卸载包：<br>npm unpublish --force<br></code></pre></td></tr></table></figure><h6 id="2-8-7-使用引入包"><a href="#2-8-7-使用引入包" class="headerlink" title="2.8.7 使用引入包"></a>2.8.7 使用引入包</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gp19-npm&#x27;</span>)<br>hello.<span class="hljs-title function_">sayHello</span>()<br></code></pre></td></tr></table></figure><h4 id="2-9-npm-脚本"><a href="#2-9-npm-脚本" class="headerlink" title="2.9 npm 脚本"></a>2.9 npm 脚本</h4><p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。</p><p><strong>一、什么是 npm 脚本？</strong></p><p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node build.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>二、执行顺序</strong></p><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><p>script1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br></code></pre></td></tr></table></figure><p>script2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y)<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script1.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;script2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script2.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果是并行执行（即同时的平行执行），可以使用 <code>&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp; npm run script2<br></code></pre></td></tr></table></figure><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用 <code>&amp;&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp;&amp; npm run script2<br></code></pre></td></tr></table></figure><p><strong>三、简写形式</strong></p><p>常用的 npm 脚本简写形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm start 是 npm run start<br></code></pre></td></tr></table></figure><p><strong>四、变量</strong></p><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p><p>首先，通过 <code>npm_package_</code> 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。</p><blockquote><p>注意：一定要在 npm 脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到值的</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.2.5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node view.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回 1.2.5。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// view.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>); <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>); <span class="hljs-comment">// 1.2.5</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用$npm_package_name 和 $npm_package_version 取到这两个值。</p><p>npm_package_前缀也支持嵌套的package.json字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>scripts<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_package_repository_type&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。</p><p>下面是另外一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_scripts_install 变量的值等于 foo.js。</p><p>然后，npm 脚本还可以通过 npm_config_ 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_config_tag&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>注意，package.json 里面的 config 对象，可以被环境变量覆盖。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;config&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;port&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;start&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node server.js&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_config_port 变量返回的是 8080。这个值可以用下面的方法覆盖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> foo:port 80<br></code></pre></td></tr></table></figure><p>最后，env命令可以列出所有环境变量。</p><p>“env”: “env”</p><h4 id="2-10-npm-安装-git-上发布的包"><a href="#2-10-npm-安装-git-上发布的包" class="headerlink" title="2.10 npm 安装 git 上发布的包"></a>2.10 npm 安装 git 上发布的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这样适合安装公司内部的git服务器上的项目</span><br>npm install git+https://git@github.com:lurongtao/gp-project.git<br><br><span class="hljs-comment"># 或者以ssh的方式</span><br>npm install git+ssh://git@github.com:lurongtao/gp-project.git<br></code></pre></td></tr></table></figure><h4 id="2-11-cross-env-使用"><a href="#2-11-cross-env-使用" class="headerlink" title="2.11 cross-env 使用"></a>2.11 cross-env 使用</h4><h5 id="2-11-1-cross-env是什么"><a href="#2-11-1-cross-env是什么" class="headerlink" title="2.11.1 cross-env是什么"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p><h5 id="2-11-2-出现原因"><a href="#2-11-2-出现原因" class="headerlink" title="2.11.2 出现原因"></a>2.11.2 出现原因</h5><p>当您使用 NODE_ENV&#x3D;production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows 不支持 NODE_ENV&#x3D;production 的设置方式。</p><h5 id="2-11-3-解决"><a href="#2-11-3-解决" class="headerlink" title="2.11.3 解决"></a>2.11.3 解决</h5><p>cross-env 使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包(cross-env)能够提供一个设置环境变量的 scripts，让你能够以 Unix 方式设置环境变量，然后在 Windows 上也能兼容运行。</p><h5 id="2-11-4-安装"><a href="#2-11-4-安装" class="headerlink" title="2.11.4 安装"></a>2.11.4 安装</h5><p>npm install –save-dev cross-env</p><h5 id="2-11-5-使用"><a href="#2-11-5-使用" class="headerlink" title="2.11.5 使用"></a>2.11.5 使用</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>NODE_ENV环境变量将由 cross-env 设置<br>打印 process.env.NODE_ENV &#x3D;&#x3D;&#x3D; ‘production’</p><h3 id="3、NRM-npm-registry-manager"><a href="#3、NRM-npm-registry-manager" class="headerlink" title="3、NRM: npm registry manager"></a>3、NRM: npm registry manager</h3><h4 id="3-1-手工切换源"><a href="#3-1-手工切换源" class="headerlink" title="3.1 手工切换源"></a>3.1 手工切换源</h4><h5 id="3-1-1-查看当前源"><a href="#3-1-1-查看当前源" class="headerlink" title="3.1.1 查看当前源"></a>3.1.1 查看当前源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h5 id="3-1-2-切换淘宝源"><a href="#3-1-2-切换淘宝源" class="headerlink" title="3.1.2 切换淘宝源"></a>3.1.2 切换淘宝源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h4 id="3-2-NRM-管理源"><a href="#3-2-NRM-管理源" class="headerlink" title="3.2 NRM 管理源"></a>3.2 NRM 管理源</h4><p>NRM (npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h5 id="3-2-1-安装-nrm"><a href="#3-2-1-安装-nrm" class="headerlink" title="3.2.1 安装 nrm"></a>3.2.1 安装 nrm</h5><p>在命令行执行命令，npm install -g nrm，全局安装nrm。</p><h5 id="3-2-2-使用-nrm"><a href="#3-2-2-使用-nrm" class="headerlink" title="3.2.2 使用 nrm"></a>3.2.2 使用 nrm</h5><p>执行命令 nrm ls 查看可选的源。<br>其中，带*的是当前使用的源，上面的输出表明当前源是官方源。</p><h5 id="3-2-3-切换-nrm"><a href="#3-2-3-切换-nrm" class="headerlink" title="3.2.3 切换 nrm"></a>3.2.3 切换 nrm</h5><p>如果要切换到taobao源，执行命令nrm use taobao。</p><h5 id="3-2-4-测试速度"><a href="#3-2-4-测试速度" class="headerlink" title="3.2.4 测试速度"></a>3.2.4 测试速度</h5><p>你还可以通过 nrm test 测试相应源的响应时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nrm <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="4、NPX-npm-package-extention"><a href="#4、NPX-npm-package-extention" class="headerlink" title="4、NPX: npm package extention"></a>4、NPX: npm package extention</h3><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g npx<br></code></pre></td></tr></table></figure><h4 id="4-1-调用项目安装的模块"><a href="#4-1-调用项目安装的模块" class="headerlink" title="4.1 调用项目安装的模块"></a>4.1 调用项目安装的模块</h4><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -D mocha<br></code></pre></td></tr></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 项目的根目录下执行</span><br>$ <span class="hljs-keyword">node</span><span class="hljs-title">-modules</span>/.bin/mocha --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx mocha <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于 <span class="hljs-built_in">ls</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npx <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。</p><h4 id="4-2-避免全局安装模块"><a href="#4-2-避免全局安装模块" class="headerlink" title="4.2 避免全局安装模块"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app 这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">npx</span> <span class="hljs-built_in">create-react-app</span> <span class="hljs-string">my-react-app</span><br></code></pre></td></tr></table></figure><p>上面代码运行时，npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ npx http-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="4-3-–no-install-参数和-–ignore-existing-参数"><a href="#4-3-–no-install-参数和-–ignore-existing-参数" class="headerlink" title="4.3 –no-install 参数和 –ignore-existing 参数"></a>4.3 –no-install 参数和 –ignore-existing 参数</h4><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> npx --<span class="hljs-keyword">no</span>-install http-server<br></code></pre></td></tr></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx <span class="hljs-comment">--ignore-existing http-server</span><br></code></pre></td></tr></table></figure><h1 id="三、模块-包-与-CommonJS"><a href="#三、模块-包-与-CommonJS" class="headerlink" title="三、模块&#x2F;包 与 CommonJS"></a>三、模块&#x2F;包 与 CommonJS</h1><h3 id="1、模块-包分类"><a href="#1、模块-包分类" class="headerlink" title="1、模块&#x2F;包分类"></a>1、模块&#x2F;包分类</h3><p>Node.js 有三类模块，即内置的模块、第三方的模块、自定义的模块。</p><h4 id="1-1-内置的模块"><a href="#1-1-内置的模块" class="headerlink" title="1.1 内置的模块"></a>1.1 内置的模块</h4><p>Node.js 内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> extname = path.<span class="hljs-title function_">extname</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(extname)<br></code></pre></td></tr></table></figure><h4 id="1-2-第三方的Node-js模块"><a href="#1-2-第三方的Node-js模块" class="headerlink" title="1.2 第三方的Node.js模块"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> chalk<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chalk&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">blue</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="1-3-自定义的Node-js模块"><a href="#1-3-自定义的Node-js模块" class="headerlink" title="1.3 自定义的Node.js模块"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p><p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p><h5 id="1-3-1-模块定义、接口暴露和引用接口"><a href="#1-3-1-模块定义、接口暴露和引用接口" class="headerlink" title="1.3.1 模块定义、接口暴露和引用接口"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能 抽离成为一个单独的 js  文件 作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。</p><p>m1.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;gp19&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayName</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module 1&#x27;</span>)<br><br><span class="hljs-comment">// 接口暴露方法一：</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br><br><span class="hljs-comment">// 接口暴露方法二：</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">say</span> = sayName<br><br><span class="hljs-comment">// 错误！</span><br><span class="hljs-built_in">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br></code></pre></td></tr></table></figure><p>main.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./m1&#x27;</span>)<br>m1.<span class="hljs-title function_">say</span>()<br></code></pre></td></tr></table></figure><h5 id="1-3-2-模块的循环引用"><a href="#1-3-2-模块的循环引用" class="headerlink" title="1.3.2 模块的循环引用"></a>1.3.2 模块的循环引用</h5><p>由于 exports 使用方式方式不对，会在两个不同 js 循环引用的情况下，导致其中一个 js 无法获取另外一个 js 的方法，从而导致执行报错。如：</p><ul><li>a.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in a, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>b.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b starting&#x27;</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in b, a.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;main starting&#x27;</span>)<br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in main, a.done = %j, b.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>, b.<span class="hljs-property">done</span>)<br></code></pre></td></tr></table></figure><p>main.js 首先会 load a.js, 此时执行到const b &#x3D; require(‘.&#x2F;b.js’);的时候，程序会转去loadb.js, 在b.js中执行到const a &#x3D; require(‘.&#x2F;a.js’); 为了防止无限循环，将a.jsexports的未完成副本返回到b.js模块。然后b.js完成加载，并将其导出对象提供给a.js模块。</p><p>我们知道nodeJs的对每个js文件进行了一层包装称为module，module中有一个属性exports，当调用require(‘a.js’)的时候其实返回的是module.exports对象，module.exports初始化为一个{}空的object，所以在上面的例子中，执行到b.js中const a &#x3D; require(‘.&#x2F;a.js’);时不会load新的a module, 而是将已经load但是还未完成的a module的exports属性返回给b module，所以b.js拿到的是a module的exports对象，即：{done:false}, 虽然在a.js中exports.done被修改成了true，但是由于此时a.js未load完成，所以在b.js输出的a module的属性done为false，而在main.js中输出的a module的属性done为true. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。 </p><h1 id="四、常用内置模块"><a href="#四、常用内置模块" class="headerlink" title="四、常用内置模块"></a>四、常用内置模块</h1><p>这里介绍几个常用的内置模块：url, querystring, http, events, fs, stream, readline, crypto, zlib</p><h3 id="1、url"><a href="#1、url" class="headerlink" title="1、url"></a>1、url</h3><h4 id="1-1-parse"><a href="#1-1-parse" class="headerlink" title="1.1 parse"></a>1.1 parse</h4><p>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlString = <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br><span class="hljs-keyword">const</span> parsedStr = url.<span class="hljs-title function_">parse</span>(urlString)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedStr)<br></code></pre></td></tr></table></figure><h4 id="1-2-format"><a href="#1-2-format" class="headerlink" title="1.2 format"></a>1.2 format</h4><p>url.format(urlObject)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlObject = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">slashes</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">auth</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;www.baidu.com:443&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;443&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;www.baidu.com&#x27;</span>,<br>  <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#tag=110&#x27;</span>,<br>  <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mouse&#x27;</span> &#125;,<br>  <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/ad/index.html&#x27;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/ad/index.html?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> parsedObj = url.<span class="hljs-title function_">format</span>(urlObject)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedObj)<br></code></pre></td></tr></table></figure><h4 id="1-3-resolve"><a href="#1-3-resolve" class="headerlink" title="1.3 resolve"></a>1.3 resolve</h4><p>url.resolve(from, to)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">var</span> a = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/one/two/three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>)<br><span class="hljs-keyword">var</span> b = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/&#x27;</span>, <span class="hljs-string">&#x27;/one&#x27;</span>)<br><span class="hljs-keyword">var</span> c = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/one&#x27;</span>, <span class="hljs-string">&#x27;/two&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-string">&quot;,&quot;</span> + b + <span class="hljs-string">&quot;,&quot;</span> + c)<br></code></pre></td></tr></table></figure><h3 id="2、querystring"><a href="#2、querystring" class="headerlink" title="2、querystring"></a>2、querystring</h3><h4 id="2-1-parse"><a href="#2-1-parse" class="headerlink" title="2.1 parse"></a>2.1 parse</h4><p>querystring.parse(str[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qs = <span class="hljs-string">&#x27;x=3&amp;y=4&#x27;</span><br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">parse</span>(qs)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-2-stringify"><a href="#2-2-stringify" class="headerlink" title="2.2 stringify"></a>2.2 stringify</h4><p>querystring.stringify(obj[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qo = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">stringify</span>(qo)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-3-escape-unescape"><a href="#2-3-escape-unescape" class="headerlink" title="2.3 escape&#x2F;unescape"></a>2.3 escape&#x2F;unescape</h4><p>querystring.escape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id=3&amp;city=北京&amp;url=https://www.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> escaped = querystring.<span class="hljs-built_in">escape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(escaped)<br></code></pre></td></tr></table></figure><p>querystring.unescape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> unescaped = querystring.<span class="hljs-built_in">unescape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unescaped)<br></code></pre></td></tr></table></figure><h3 id="3、http-https"><a href="#3、http-https" class="headerlink" title="3、http&#x2F;https"></a>3、http&#x2F;https</h3><h4 id="3-1-get"><a href="#3-1-get" class="headerlink" title="3.1 get"></a>3.1 get</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><br><span class="hljs-comment">// 1、接口 2、跨域</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">var</span> url = request.<span class="hljs-property">url</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br>  <br>  <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span><br><br>  response.<span class="hljs-title function_">writeHeader</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  https.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://m.lagou.com/listmore.json<span class="hljs-subst">$&#123;url&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>        <span class="hljs-attr">ret</span>: <span class="hljs-literal">true</span>,<br>        data<br>      &#125;))<br>    &#125;)<br>  &#125;)<br><br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-post：服务器提交（攻击）"><a href="#3-2-post：服务器提交（攻击）" class="headerlink" title="3.2 post：服务器提交（攻击）"></a>3.2 post：服务器提交（攻击）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> postData = querystring.<span class="hljs-title function_">stringify</span>(&#123;<br>  <span class="hljs-attr">province</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">district</span>: <span class="hljs-string">&#x27;宝山区&#x27;</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;同济支路199号智慧七立方3号楼2-4层&#x27;</span>,<br>  <span class="hljs-attr">latitude</span>: <span class="hljs-number">43.0</span>,<br>  <span class="hljs-attr">longitude</span>: <span class="hljs-number">160.0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;求购一条小鱼&#x27;</span>,<br>  <span class="hljs-attr">contact</span>: <span class="hljs-string">&#x27;13666666&#x27;</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>  <span class="hljs-attr">time</span>: <span class="hljs-number">1571217561</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;ik9hkddr.qcloud.la&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index.php/trade/add_item&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(postData)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doPost</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> data<br>  <br>  <span class="hljs-keyword">let</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> data += chunk)<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  req.<span class="hljs-title function_">write</span>(postData)<br>  req.<span class="hljs-title function_">end</span>()<br>&#125;<br><br><span class="hljs-comment">// setInterval(() =&gt; &#123;</span><br><span class="hljs-comment">//   doPost()</span><br><span class="hljs-comment">// &#125;, 1000)</span><br></code></pre></td></tr></table></figure><h4 id="3-3-跨域：jsonp"><a href="#3-3-跨域：jsonp" class="headerlink" title="3.3 跨域：jsonp"></a>3.3 跨域：jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/user&#x27;</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;urlObj.query.cb&#125;</span>(&#123;&quot;name&quot;: &quot;gp145&quot;&#125;)`</span>)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-4-跨域：CORS"><a href="#3-4-跨域：CORS" class="headerlink" title="3.4 跨域：CORS"></a>3.4 跨域：CORS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    data += chunk<br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">responseResult</span>(querystring.<span class="hljs-title function_">parse</span>(data))<br>  &#125;)<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">responseResult</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/login&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>          <span class="hljs-attr">message</span>: data<br>        &#125;))<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-5-跨域：middleware（http-proxy-middware）"><a href="#3-5-跨域：middleware（http-proxy-middware）" class="headerlink" title="3.5 跨域：middleware（http-proxy-middware）"></a>3.5 跨域：middleware（http-proxy-middware）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> url = req.<span class="hljs-property">url</span><br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\/api/</span>.<span class="hljs-title function_">test</span>(url)) &#123;<br>    <span class="hljs-keyword">let</span> apiProxy = <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123; <br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://m.lagou.com&#x27;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;)<br>  <br>    <span class="hljs-comment">// http-proy-middleware 在Node.js中使用的方法</span><br>    <span class="hljs-title function_">apiProxy</span>(req, res)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">switch</span> (url) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/search.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;search.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;[404]page not found.&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>)<br></code></pre></td></tr></table></figure><h4 id="3-6-爬虫"><a href="#3-6-爬虫" class="headerlink" title="3.6 爬虫"></a>3.6 爬虫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> options = &#123;<br>    <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>    <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;maoyan.com&#x27;</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br>  <br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">filterData</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterData</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> $ = cheerio.<span class="hljs-title function_">load</span>(data)<br>    <span class="hljs-keyword">let</span> $movieList = $(<span class="hljs-string">&#x27;.movie-item&#x27;</span>)<br>    <span class="hljs-keyword">let</span> movies = []<br>    $movieList.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, value</span>) =&gt;</span> &#123;<br>      movies.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">title</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-title&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;title&#x27;</span>),<br>        <span class="hljs-attr">score</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-score i&#x27;</span>).<span class="hljs-title function_">text</span>(),<br>      &#125;)<br>    &#125;)<br>    <br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(movies))<br>  &#125;<br>  <br>  req.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>)<br></code></pre></td></tr></table></figure><h3 id="4、Events"><a href="#4、Events" class="headerlink" title="4、Events"></a>4、Events</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEventEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEventEmitter</span>()<br><br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">movie</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movie)<br>&#125;)<br><br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;我和我的祖国&#x27;</span>)<br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;中国机长&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="5、File-System"><a href="#5、File-System" class="headerlink" title="5、File System"></a>5、File System</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> fsP = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-property">promises</span><br><br><span class="hljs-comment">// 创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 文件夹改名</span><br>fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 写内容到文件里</span><br>fs.<span class="hljs-title function_">writeFile</span>(<br>  <span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>,<br>  <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  <span class="hljs-comment">// 错误优先的回调函数</span><br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件创建成功&#x27;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-comment">// 给文件追加内容</span><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;\nworld&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 读取文件内容</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件</span><br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 批量写文件</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">`./logs/log-<span class="hljs-subst">$&#123;i&#125;</span>.txt`</span>, <span class="hljs-string">`log-<span class="hljs-subst">$&#123;i&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 读取文件/目录信息</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;value&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// console.log(value + &#x27;:&#x27; + stats.size)</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value + <span class="hljs-string">&#x27; is &#x27;</span> + (stats.<span class="hljs-title function_">isDirectory</span>() ? <span class="hljs-string">&#x27;directory&#x27;</span> : <span class="hljs-string">&#x27;file&#x27;</span>))<br>    &#125;)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 同步读取文件</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">message</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法一</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法二</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-comment">// 异步读取文件：方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>;(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">getFile</span>())<br>&#125;)()<br><br><span class="hljs-comment">// 异步读取文件：方法四</span><br><span class="hljs-keyword">const</span> fsp = fsP.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fsP)<br><br><span class="hljs-comment">// watch 监测文件变化</span><br>fs.<span class="hljs-title function_">watch</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6、Stream"><a href="#6、Stream" class="headerlink" title="6、Stream"></a>6、Stream</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="7、Zlib"><a href="#7、Zlib" class="headerlink" title="7、Zlib"></a>7、Zlib</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>)<br><br><span class="hljs-keyword">const</span> gzip = zlib.<span class="hljs-title function_">createGzip</span>()<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>readstream<br>  .<span class="hljs-title function_">pipe</span>(gzip)<br>  .<span class="hljs-title function_">pipe</span>(writestream)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="8、ReadLine"><a href="#8、ReadLine" class="headerlink" title="8、ReadLine"></a>8、ReadLine</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;readline&#x27;</span>)<br><br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span><br>&#125;)<br><br>rl.<span class="hljs-title function_">question</span>(<span class="hljs-string">&#x27;What do you think of Node.js? &#x27;</span>, <span class="hljs-function">(<span class="hljs-params">answer</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Log the answer in a database</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Thank you for your valuable feedback: <span class="hljs-subst">$&#123;answer&#125;</span>`</span>)<br><br>  rl.<span class="hljs-title function_">close</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9、Crypto"><a href="#9、Crypto" class="headerlink" title="9、Crypto"></a>9、Crypto</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&#x27;abcdefg&#x27;</span><br><span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, secret)<br>                   .<span class="hljs-title function_">update</span>(<span class="hljs-string">&#x27;I love you&#x27;</span>)<br>                   .<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash)<br></code></pre></td></tr></table></figure><h1 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> req, res </span>) &#123;<br><br>  <span class="hljs-keyword">switch</span> ( req.<span class="hljs-property">url</span> ) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/home&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;home&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/mine&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;mine&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/login&#x27;</span>: <br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/login.html&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span> ( error ) <span class="hljs-keyword">throw</span> error  <br>        res.<span class="hljs-title function_">write</span>( data )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/fulian.jpg&#x27;</span>:<br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/fulian.jpg&#x27;</span>, <span class="hljs-string">&#x27;binary&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span>( error ) <span class="hljs-keyword">throw</span> error <br>        res.<span class="hljs-title function_">write</span>( data, <span class="hljs-string">&#x27;binary&#x27;</span> )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>: <br>      <span class="hljs-keyword">break</span><br>   &#125;<br><br> &#125;).<span class="hljs-title function_">listen</span>( <span class="hljs-number">8000</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;服务器运行在： http://localhost:8000&#x27;</span> )<br> &#125;)<br></code></pre></td></tr></table></figure><h1 id="五、静态资源服务"><a href="#五、静态资源服务" class="headerlink" title="五、静态资源服务"></a>五、静态资源服务</h1><h3 id="5-1-readStaticFile"><a href="#5-1-readStaticFile" class="headerlink" title="5.1 readStaticFile"></a>5.1 readStaticFile</h3><p>&#x2F;modules&#x2F;readStaticFile.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入依赖的模块</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">var</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mime&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readStaticFile</span>(<span class="hljs-params">res, filePathname</span>) &#123;<br><br>  <span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">parse</span>(filePathname).<span class="hljs-property">ext</span><br>  <span class="hljs-keyword">var</span> mimeType = mime.<span class="hljs-title function_">getType</span>(ext)<br><br>  <span class="hljs-comment">// 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 </span><br>  <span class="hljs-keyword">if</span> (ext) &#123;<br>    <span class="hljs-comment">// 根据传入的目标文件路径来读取对应文件</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePathname, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;)<br>        res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;404 - NOT FOUND&quot;</span>)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: mimeType &#125;)<br>        res.<span class="hljs-title function_">write</span>(data)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 返回 true 表示, 客户端想要的 是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 返回 false 表示, 客户端想要的 不是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = readStaticFile<br></code></pre></td></tr></table></figure><h3 id="5-2-server"><a href="#5-2-server" class="headerlink" title="5.2 server"></a>5.2 server</h3><p>&#x2F;server.js </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入相关模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">var</span> readStaticFile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/readStaticFile&#x27;</span>);<br><br><span class="hljs-comment">// 搭建 HTTP 服务器</span><br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">var</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>);<br>  <span class="hljs-keyword">var</span> urlPathname = urlObj.<span class="hljs-property">pathname</span>;<br>  <span class="hljs-keyword">var</span> filePathname = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/public&quot;</span>, urlPathname);<br><br>  <span class="hljs-comment">// 读取静态文件</span><br>  <span class="hljs-title function_">readStaticFile</span>(res, filePathname);<br>&#125;);<br><br><span class="hljs-comment">// 在 3000 端口监听请求</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器运行中.&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;正在监听 3000 端口:&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NPM详解-从基础到高级的全面教程</title>
    <link href="/posts/46482/"/>
    <url>/posts/46482/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-详解：从基础到高级的全面教程"><a href="#NPM-详解：从基础到高级的全面教程" class="headerlink" title="NPM 详解：从基础到高级的全面教程"></a>NPM 详解：从基础到高级的全面教程</h1><p>NPM (Node Package Manager) 是 Node.js 的默认包管理工具，用于管理项目中的依赖包。作为前端开发和后端开发的重要工具，NPM 的作用不仅仅是安装包，它还包含很多实用的功能，如版本管理、脚本执行和发布包等。在这篇文章中，我们将深入探讨 NPM 的各个方面，帮助你从基础知识开始，到掌握一些高级用法。</p><h1 id="1-NPM-的基础知识"><a href="#1-NPM-的基础知识" class="headerlink" title="1. NPM 的基础知识"></a>1. NPM 的基础知识</h1><h2 id="1-1-什么是-NPM？"><a href="#1-1-什么是-NPM？" class="headerlink" title="1.1 什么是 NPM？"></a>1.1 什么是 NPM？</h2><p>NPM 是 Node.js 的包管理工具，它允许开发者从 NPM 的注册库中下载和分享代码包。NPM 解决了依赖管理问题，使得开发者不必重复造轮子，可以直接安装他人写好的功能模块。</p><ul><li><strong>Registry</strong>: NPM 注册库中存储了海量的开源包。</li><li><strong>Package</strong>: 每个 NPM 包都是一个独立的模块，通常包含一个 <code>package.json</code> 文件，用于描述包的信息和依赖关系。</li></ul><h2 id="1-2-NPM-的安装与配置"><a href="#1-2-NPM-的安装与配置" class="headerlink" title="1.2 NPM 的安装与配置"></a>1.2 NPM 的安装与配置</h2><p>Node.js 安装包中已经包含了 NPM，因此只要安装了 Node.js，就可以使用 NPM。你可以通过以下命令查看 NPM 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm -v<br></code></pre></td></tr></table></figure><p>可以通过 <code>npm config</code> 来查看或设置 NPM 的全局配置。常见的配置有：</p><ul><li><strong>设置 NPM 源</strong>：可以设置使用国内镜像源，如 <code>淘宝镜像</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><ul><li><strong>查看配置</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config list<br></code></pre></td></tr></table></figure><h1 id="2-package-json"><a href="#2-package-json" class="headerlink" title="2.package.json"></a>2.package.json</h1><p><code>package.json</code> 文件是 Node.js 项目的核心配置文件，它记录了项目的元信息和依赖包。我们可以通过 <code>npm init</code> 来创建一个新的 <code>package.json</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br></code></pre></td></tr></table></figure><p>常见字段包括：</p><ul><li><code>name</code>: 项目名称。</li><li><code>version</code>: 项目版本。</li><li><code>scripts</code>: 项目脚本，便于执行一些常见的任务。</li><li><code>dependencies</code>: 项目的运行时依赖包。</li><li><code>devDependencies</code>: 项目的开发时依赖包。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-package-json-的核心字段"><a href="#2-1-package-json-的核心字段" class="headerlink" title="2.1 package.json 的核心字段"></a>2.1 package.json 的核心字段</h2><h3 id="2-1-1-name-包名"><a href="#2-1-1-name-包名" class="headerlink" title="2.1.1 name (包名)"></a>2.1.1 <code>name</code> (包名)</h3><p><code>name</code> 定义了项目的名称。这个名称必须唯一，且在 NPM 注册库中有效。</p><ul><li><p>要求</p><p>：</p><ul><li>必须是小写字母，允许包含连字符（<code>-</code>）或下划线（<code>_</code>）。</li><li>长度应少于 214 个字符。</li><li>不能以 <code>.</code> 或 <code>_</code> 开头。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-version-版本号"><a href="#2-1-2-version-版本号" class="headerlink" title="2.1.2 version (版本号)"></a>2.1.2 <code>version</code> (版本号)</h3><p><code>version</code> 字段遵循 语义化版本规范（SemVer），表示当前包的版本号。常见的版本号格式为 <code>x.y.z</code>：</p><ul><li><code>x</code>: 主版本号，非兼容性 API 变更。</li><li><code>y</code>: 次版本号，向下兼容的新功能。</li><li><code>z</code>: 修订号，向下兼容的错误修复。</li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-3-description-描述"><a href="#2-1-3-description-描述" class="headerlink" title="2.1.3 description (描述)"></a>2.1.3 <code>description</code> (描述)</h3><p><code>description</code> 用于提供包的简短描述，通常会显示在 NPM 页面上，帮助用户快速了解包的功能。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample Node.js project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-4-keywords-关键词"><a href="#2-1-4-keywords-关键词" class="headerlink" title="2.1.4 keywords (关键词)"></a>2.1.4 <code>keywords</code> (关键词)</h3><p><code>keywords</code> 字段是一个字符串数组，帮助开发者通过关键词在 NPM 上搜索到这个包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;API&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-5-homepage-主页"><a href="#2-1-5-homepage-主页" class="headerlink" title="2.1.5 homepage (主页)"></a>2.1.5 <code>homepage</code> (主页)</h3><p>定义项目的主页 URL，通常是项目的官方文档或 GitHub 页面。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-6-license-许可证"><a href="#2-1-6-license-许可证" class="headerlink" title="2.1.6 license (许可证)"></a>2.1.6 <code>license</code> (许可证)</h3><p><code>license</code> 表示项目的许可证类型，用来告知用户如何合法使用代码。常见的值如：<code>MIT</code>、<code>ISC</code>、<code>GPL-3.0</code> 等。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-7-author-作者"><a href="#2-1-7-author-作者" class="headerlink" title="2.1.7 author (作者)"></a>2.1.7 <code>author</code> (作者)</h3><p><code>author</code> 用来描述包的作者信息，可以是一个简单的字符串，也可以包括更多的详细信息。</p><ul><li><strong>简单形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>详细形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john@example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://john.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-8-contributors-贡献者"><a href="#2-1-8-contributors-贡献者" class="headerlink" title="2.1.8 contributors (贡献者)"></a>2.1.8 <code>contributors</code> (贡献者)</h3><p>这个字段记录了项目的贡献者，形式与 <code>author</code> 类似，可以包含多个人。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;contributors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane Smith&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jane@example.com&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-依赖管理"><a href="#2-2-依赖管理" class="headerlink" title="2.2 依赖管理"></a>2.2 依赖管理</h2><h3 id="2-2-1-dependencies-运行时依赖"><a href="#2-2-1-dependencies-运行时依赖" class="headerlink" title="2.2.1 dependencies (运行时依赖)"></a>2.2.1 <code>dependencies</code> (运行时依赖)</h3><p><code>dependencies</code> 用于定义项目在运行时所依赖的包。NPM 会根据此字段安装这些依赖。</p><ul><li><strong>格式</strong>：<code>包名: 版本范围</code></li><li><strong>版本范围符号</strong>：<ul><li><code>^1.0.0</code>：允许安装 1.x.x 的任何更新。</li><li><code>~1.0.0</code>：允许安装 1.0.x 的更新。</li><li><code>1.0.0</code>：锁定版本，不允许更新。</li><li><code>*</code>：任何版本。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-2-devDependencies-开发时依赖"><a href="#2-2-2-devDependencies-开发时依赖" class="headerlink" title="2.2.2 devDependencies (开发时依赖)"></a>2.2.2 <code>devDependencies</code> (开发时依赖)</h3><p><code>devDependencies</code> 记录的是仅在开发环境下需要的依赖包，比如测试框架、构建工具等。这些依赖不会在生产环境中安装。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-peerDependencies-同伴依赖"><a href="#2-2-3-peerDependencies-同伴依赖" class="headerlink" title="2.2.3 peerDependencies (同伴依赖)"></a>2.2.3 <code>peerDependencies</code> (同伴依赖)</h3><p><code>peerDependencies</code> 用于定义包与项目的兼容性要求，常用于插件开发，要求项目必须安装特定版本的某些包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;peerDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=16.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-4-optionalDependencies-可选依赖"><a href="#2-2-4-optionalDependencies-可选依赖" class="headerlink" title="2.2.4 optionalDependencies (可选依赖)"></a>2.2.4 <code>optionalDependencies</code> (可选依赖)</h3><p><code>optionalDependencies</code> 表示非强制安装的依赖，如果安装失败，项目依然可以继续运行。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;optionalDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fsevents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-bundledDependencies-打包依赖"><a href="#2-2-5-bundledDependencies-打包依赖" class="headerlink" title="2.2.5 bundledDependencies (打包依赖)"></a>2.2.5 <code>bundledDependencies</code> (打包依赖)</h3><p><code>bundledDependencies</code> 表示需要一起打包发布的依赖包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bundledDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;lodash&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-NPM-脚本-scripts"><a href="#2-3-NPM-脚本-scripts" class="headerlink" title="2.3 NPM 脚本 (scripts)"></a>2.3 NPM 脚本 (<code>scripts</code>)</h2><p><code>scripts</code> 字段可以定义各种自定义命令和自动化任务。每个脚本可以通过 <code>npm run &lt;script&gt;</code> 来运行。</p><h3 id="2-3-1-基本脚本"><a href="#2-3-1-基本脚本" class="headerlink" title="2.3.1 基本脚本"></a>2.3.1 基本脚本</h3><ul><li><strong>start</strong>：默认启动脚本。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test</strong>：通常用于执行测试。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-自定义脚本"><a href="#2-3-2-自定义脚本" class="headerlink" title="2.3.2 自定义脚本"></a>2.3.2 自定义脚本</h3><p>你可以定义任意名称的脚本，并通过 <code>npm run &lt;script-name&gt;</code> 执行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-4-使用变量"><a href="#2-4-使用变量" class="headerlink" title="2.4 使用变量"></a>2.4 使用变量</h2><p>NPM 允许在脚本中使用变量，如环境变量。通常通过 <code>process.env</code> 读取：</p><ul><li><strong>在脚本中使用环境变量</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>跨平台支持</strong>：为了兼容 Windows 系统，使用 <a href="https://www.npmjs.com/package/cross-env">cross-env</a> 包来设置环境变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install cross-env --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>NODE_ENV=production node app.js</code> 这条命令主要用于设置环境变量 <code>NODE_ENV</code> 并运行应用程序。具体拆解如下：</p><ol><li><p>**<code>NODE_ENV=production</code>**：</p><ul><li>这部分用于设置 <code>NODE_ENV</code> 环境变量的值为 <code>production</code>。<code>NODE_ENV</code> 是 Node.js 应用中常见的一个环境变量，表示应用当前的运行环境。</li><li>通常有以下几种值：<ul><li><code>development</code>：开发环境，用于本地调试、测试。</li><li><code>production</code>：生产环境，用于发布和正式运行。</li><li><code>test</code>：测试环境，用于自动化测试。</li></ul></li></ul><p>在不同的 <code>NODE_ENV</code> 下，代码通常会有不同的行为。比如：</p><ul><li>在开发环境中，可能会启用更多的日志输出、调试功能等。</li><li>在生产环境中，可能会禁用调试功能、启用性能优化等。</li></ul></li><li><p>**<code>node app.js</code>**：</p><ul><li>这部分用于启动 Node.js 应用，运行 <code>app.js</code> 文件。<code>node</code> 是运行 Node.js 脚本的命令，后面的 <code>app.js</code> 是需要执行的 JavaScript 文件。</li></ul><p>因此，整条命令的含义是：在生产环境下执行 <code>app.js</code> 文件。</p></li></ol><p><strong>作用</strong></p><p>通过设置 <code>NODE_ENV</code>，你可以控制应用程序的运行模式。例如，在 <code>production</code> 环境中，很多框架和库（如 Express、React 等）会根据 <code>NODE_ENV</code> 来优化性能和行为，以确保更高的运行效率和安全性。</p><p><strong>举例</strong></p><p>在 Express.js 应用中，使用 <code>NODE_ENV</code> 可以区分开发模式和生产模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 生产环境中的逻辑，比如启用压缩、禁用详细日志等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">compression</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 开发环境中的逻辑，比如启用详细日志、错误提示等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">morgan</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置 <code>NODE_ENV=production</code>，代码会执行生产环境的逻辑。</p><h3 id="2-4-1-npm-package-环境变量"><a href="#2-4-1-npm-package-环境变量" class="headerlink" title="2.4.1 npm_package_* 环境变量"></a>2.4.1 <code>npm_package_*</code> 环境变量</h3><p>这些变量基于 <code>package.json</code> 文件中的字段生成，能够直接访问项目的配置信息。</p><p><strong>常用字段：</strong></p><ul><li><code>npm_package_name</code>：项目名称（<code>package.json</code> 中的 <code>name</code> 字段）</li><li><code>npm_package_version</code>：项目版本（<code>package.json</code> 中的 <code>version</code> 字段）</li><li><code>npm_package_description</code>：项目描述（<code>package.json</code> 中的 <code>description</code> 字段）</li><li><code>npm_package_author</code>：项目作者（<code>package.json</code> 中的 <code>author</code> 字段）</li><li><code>npm_package_license</code>：项目的许可证类型（<code>package.json</code> 中的 <code>license</code> 字段）</li><li><code>npm_package_scripts_*</code>：项目中定义的 <code>scripts</code> 脚本。例如 <code>npm_package_scripts_start</code> 对应 <code>package.json</code> 中的 <code>start</code> 脚本。</li><li><code>npm_package_dependencies_*</code>：项目依赖项版本。例如 <code>npm_package_dependencies_express</code> 对应 <code>package.json</code> 中 <code>dependencies</code> 下的 <code>express</code> 包的版本。</li><li><code>npm_package_devDependencies_*</code>：开发依赖项版本。例如 <code>npm_package_devDependencies_mocha</code> 对应 <code>package.json</code> 中 <code>devDependencies</code> 下的 <code>mocha</code> 包的版本。</li><li><code>npm_package_keywords_*</code>：项目关键词列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取项目名称</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_name</span><br><br><span class="hljs-comment"># 获取 express 依赖的版本</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_dependencies_express</span><br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><p>当你使用 <code>npm run</code> 命令运行脚本时，<code>npm</code> 会自动将 <code>package.json</code> 中的部分内容导出为环境变量，这些环境变量以 <code>npm_package_</code> 为前缀。</p><p>例如，假设你的 <code>package.json</code> 文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-app&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample application&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在运行 <code>npm run start</code> 时，以下环境变量会自动设置：</p><ul><li><code>npm_package_name=my-app</code></li><li><code>npm_package_version=1.0.0</code></li><li><code>npm_package_description=This is a sample application</code></li><li><code>npm_package_author=John Doe</code></li><li><code>npm_package_dependencies_express=^4.17.1</code></li></ul><h4 id="1-使用-npm-package-环境变量"><a href="#1-使用-npm-package-环境变量" class="headerlink" title="1. 使用 npm_package_* 环境变量"></a>1. 使用 <code>npm_package_*</code> 环境变量</h4><p>在脚本中，你可以通过 <code>process.env</code> 来访问这些环境变量。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 package.json 中的字段值</span><br><span class="hljs-keyword">const</span> appName = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>;<br><span class="hljs-keyword">const</span> appVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>;<br><span class="hljs-keyword">const</span> appDescription = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_description</span>;<br><span class="hljs-keyword">const</span> appAuthor = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_author</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Name: <span class="hljs-subst">$&#123;appName&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Version: <span class="hljs-subst">$&#123;appVersion&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Description: <span class="hljs-subst">$&#123;appDescription&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Author: <span class="hljs-subst">$&#123;appAuthor&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="2-运行脚本"><a href="#2-运行脚本" class="headerlink" title="2. 运行脚本"></a>2. 运行脚本</h4><p>假设在 <code>package.json</code> 中定义了以下 <code>scripts</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>当你运行 <code>npm run start</code> 时，<code>npm</code> 会将 <code>package.json</code> 中的内容作为环境变量导出，并在脚本中可以通过 <code>process.env</code> 访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run start<br></code></pre></td></tr></table></figure><p>输出将会是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Name:</span> <span class="hljs-string">my-app</span><br><span class="hljs-attr">App Version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">Description:</span> <span class="hljs-string">This</span> <span class="hljs-string">is</span> <span class="hljs-string">a</span> <span class="hljs-string">sample</span> <span class="hljs-string">application</span><br><span class="hljs-attr">Author:</span> <span class="hljs-string">John</span> <span class="hljs-string">Doe</span><br></code></pre></td></tr></table></figure><h4 id="3-环境变量命名规则"><a href="#3-环境变量命名规则" class="headerlink" title="3. 环境变量命名规则"></a>3. 环境变量命名规则</h4><ul><li><strong>基本字段</strong>：<code>npm_package_</code> 后接字段名称。例如，<code>name</code> 字段对应 <code>npm_package_name</code>，<code>version</code> 字段对应 <code>npm_package_version</code>。</li><li><strong>嵌套字段</strong>：如果字段是嵌套的，则会用 <code>_</code> 分隔。例如，<code>dependencies</code> 下的 <code>express</code> 包版本可以通过 <code>npm_package_dependencies_express</code> 访问。</li><li><strong>数组字段</strong>：对于数组类型的字段，如 <code>keywords</code>，会自动生成索引的环境变量。例如，<code>keywords</code> 数组的第一个元素是 <code>npm_package_keywords_0</code>。</li></ul><h4 id="4-自定义字段"><a href="#4-自定义字段" class="headerlink" title="4. 自定义字段"></a>4. 自定义字段</h4><p><code>npm_package_*</code> 变量支持自定义字段。假设你在 <code>package.json</code> 中添加了自定义字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;customField&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;apiEndpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://api.example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;enableFeatureX&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这些自定义字段可以通过如下环境变量访问：</p><ul><li><code>npm_package_customField_apiEndpoint</code>：自定义字段 <code>apiEndpoint</code> 的值。</li><li><code>npm_package_customField_enableFeatureX</code>：自定义字段 <code>enableFeatureX</code> 的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> apiEndpoint = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_apiEndpoint</span>;<br><span class="hljs-keyword">const</span> enableFeatureX = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_enableFeatureX</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`API Endpoint: <span class="hljs-subst">$&#123;apiEndpoint&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Feature X Enabled: <span class="hljs-subst">$&#123;enableFeatureX&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="5-访问限制"><a href="#5-访问限制" class="headerlink" title="5. 访问限制"></a>5. 访问限制</h4><p>通过 <code>npm_package_*</code> 变量方式访问 <code>package.json</code> 字段有以下几点需要注意：</p><ul><li>只能通过 <code>npm run</code> 命令访问这些环境变量，直接运行 <code>node app.js</code> 是无法自动注入这些变量的。</li><li>如果 <code>package.json</code> 中的某个字段是对象类型，环境变量会为其每个子字段生成对应的变量，但不能直接获取整个对象。</li></ul><h4 id="6-示例：访问-package-json-的-dependencies"><a href="#6-示例：访问-package-json-的-dependencies" class="headerlink" title="6. 示例：访问 package.json 的 dependencies"></a>6. 示例：访问 <code>package.json</code> 的 <code>dependencies</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 访问 dependencies 中的 express 版本</span><br><span class="hljs-keyword">const</span> expressVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_dependencies_express</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Express Version: <span class="hljs-subst">$&#123;expressVersion&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-2-npm-config-变量"><a href="#2-4-2-npm-config-变量" class="headerlink" title="2.4.2 npm_config_* 变量"></a>2.4.2 <code>npm_config_*</code> 变量</h3><p>这些变量用于访问 <code>npm</code> 配置的参数。可以在命令行通过 <code>npm config set</code> 或 <code>npm run</code> 脚本中传递这些配置参数。</p><p><strong>常用配置变量：</strong></p><ul><li><code>npm_config_registry</code>：使用的 npm 注册表 URL。</li><li><code>npm_config_node_version</code>：当前使用的 Node.js 版本。</li><li><code>npm_config_tag</code>：发布时使用的标签（通过 <code>--tag</code> 设置，例如 <code>beta</code>、<code>latest</code>）。</li><li><code>npm_config_global</code>：如果为 <code>true</code>，则指明操作为全局安装或设置。</li><li><code>npm_config_prefix</code>：全局模块的安装路径。</li><li><code>npm_config_cache</code>：npm 的缓存路径。</li><li><code>npm_config_production</code>：如果为 <code>true</code>，表示当前处于生产环境（通过 <code>--production</code> 设置）。</li><li><code>npm_config_init_author_name</code>：初始化项目时的默认作者名称。</li><li><code>npm_config_init_version</code>：初始化项目时的默认版本。</li><li><code>npm_config_save_dev</code>：是否将依赖项保存到 <code>devDependencies</code> 中。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出使用的 npm registry</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_registry</span><br><br><span class="hljs-comment"># 获取配置的默认作者</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_init_author_name</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-npm-lifecycle-变量"><a href="#2-4-3-npm-lifecycle-变量" class="headerlink" title="2.4.3 npm_lifecycle_* 变量"></a>2.4.3 <code>npm_lifecycle_*</code> 变量</h3><p>这些变量在运行 <code>npm run</code> 脚本时自动生成，提供有关当前执行生命周期的信息。</p><p><strong>常用生命周期变量：</strong></p><ul><li><code>npm_lifecycle_event</code>：当前运行的脚本事件名称。例如，<code>npm run build</code> 时，<code>npm_lifecycle_event</code> 为 <code>build</code>。</li><li><code>npm_lifecycle_script</code>：当前正在执行的脚本内容。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前运行的生命周期事件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_lifecycle_event</span><br></code></pre></td></tr></table></figure><h3 id="2-4-4-npm-变量"><a href="#2-4-4-npm-变量" class="headerlink" title="2.4.4 npm_* 变量"></a>2.4.4 <code>npm_*</code> 变量</h3><p>这些变量提供了一些与当前 <code>npm</code> 环境和运行时相关的信息。</p><p><strong>常用变量：</strong></p><ul><li><code>npm_command</code>：当前正在执行的 <code>npm</code> 命令。例如，<code>npm install</code> 时，<code>npm_command</code> 为 <code>install</code>。</li><li><code>npm_execpath</code>：执行 npm 的路径。</li><li><code>npm_node_execpath</code>：Node.js 可执行文件的路径。</li><li><code>npm_config_user_agent</code>：当前 <code>npm</code> 客户端的用户代理字符串。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前的 npm 命令</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_command</span><br><br><span class="hljs-comment"># 输出 npm 可执行文件路径</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_execpath</span><br></code></pre></td></tr></table></figure><h3 id="2-4-5-自定义-npm-config-变量"><a href="#2-4-5-自定义-npm-config-变量" class="headerlink" title="2.4.5 自定义 npm_config_* 变量"></a>2.4.5 自定义 <code>npm_config_*</code> 变量</h3><p>你还可以通过命令行或配置文件自定义 <code>npm_config_*</code> 变量。例如，你可以通过 <code>npm run</code> 命令传递自定义的变量，供脚本使用。</p><p><strong>示例：</strong></p><p>在 <code>package.json</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;view&quot;</span>: <span class="hljs-string">&quot;echo $npm_config_myCustomVar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run view --myCustomVar=HelloWorld<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HelloWorld</span><br></code></pre></td></tr></table></figure><h3 id="2-4-6-总结"><a href="#2-4-6-总结" class="headerlink" title="2.4.6 总结"></a>2.4.6 总结</h3><p>以下是常见 <code>npm</code> 变量的分类总结：</p><table><thead><tr><th>变量类型</th><th>说明</th></tr></thead><tbody><tr><td><code>npm_package_*</code></td><td>访问 <code>package.json</code> 中的字段值</td></tr><tr><td><code>npm_config_*</code></td><td>访问 <code>npm</code> 配置的参数</td></tr><tr><td><code>npm_lifecycle_*</code></td><td>运行时有关生命周期的信息</td></tr><tr><td><code>npm_*</code></td><td>一些与当前 <code>npm</code> 环境相关的信息</td></tr><tr><td>自定义 <code>npm_config_*</code></td><td>通过命令行或配置文件传递的自定义参数</td></tr></tbody></table><p>这些变量在 <code>npm</code> 的脚本管理和环境配置中十分有用，能够帮助你在不同环境下动态获取项目信息、依赖版本或自定义配置等。</p><h2 id="2-5-package-json-其他常见字段"><a href="#2-5-package-json-其他常见字段" class="headerlink" title="2.5 package.json 其他常见字段"></a>2.5 package.json 其他常见字段</h2><h3 id="2-5-1-main-入口文件"><a href="#2-5-1-main-入口文件" class="headerlink" title="2.5.1 main (入口文件)"></a>2.5.1 <code>main</code> (入口文件)</h3><p><code>main</code> 指定了包的入口文件。当用户 <code>require</code> 该包时，首先加载的就是该文件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-2-engines-引擎"><a href="#2-5-2-engines-引擎" class="headerlink" title="2.5.2 engines (引擎)"></a>2.5.2 <code>engines</code> (引擎)</h3><p><code>engines</code> 字段用于指定项目所需的 Node.js 或 NPM 版本。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=12.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;npm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=6.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-repository-仓库"><a href="#2-5-3-repository-仓库" class="headerlink" title="2.5.3 repository (仓库)"></a>2.5.3 <code>repository</code> (仓库)</h3><p><code>repository</code> 字段记录项目的代码仓库地址。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-4-bugs-问题反馈"><a href="#2-5-4-bugs-问题反馈" class="headerlink" title="2.5.4 bugs (问题反馈)"></a>2.5.4 <code>bugs</code> (问题反馈)</h3><p><code>bugs</code> 字段用于提供问题反馈的地址或电子邮件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project/issues&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support@example.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-5-files-发布文件"><a href="#2-5-5-files-发布文件" class="headerlink" title="2.5.5 files (发布文件)"></a>2.5.5 <code>files</code> (发布文件)</h3><p><code>files</code> 字段指定了在发布到 NPM 时需要包含的文件列表。未包含在此列表中的文件将不会发布。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;dist/&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-6-config-自定义配置"><a href="#2-5-6-config-自定义配置" class="headerlink" title="2.5.6 config (自定义配置)"></a>2.5.6 <code>config</code> (自定义配置)</h3><p><code>config</code> 字段允许自定义配置，用于脚本中引用的变量。</p><h1 id="3-NPM-的常用命令"><a href="#3-NPM-的常用命令" class="headerlink" title="3. NPM 的常用命令"></a>3. NPM 的常用命令</h1><h2 id="3-1-安装包"><a href="#3-1-安装包" class="headerlink" title="3.1 安装包"></a>3.1 安装包</h2><ul><li><strong>安装指定依赖包</strong>：默认会将依赖包安装到 <code>node_modules</code> 文件夹下，并更新 <code>package.json</code> 中的依赖。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>安装开发依赖包</strong>：使用 <code>--save-dev</code> 参数可以将包安装到 <code>devDependencies</code> 中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt; --save-dev<br></code></pre></td></tr></table></figure><ul><li><strong>全局安装</strong>：某些工具需要全局安装，如 <code>create-react-app</code>、<code>eslint</code> 等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-2-移除包"><a href="#3-2-移除包" class="headerlink" title="3.2 移除包"></a>3.2 移除包</h2><p>可以通过 <code>uninstall</code> 命令移除包，并自动更新 <code>package.json</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-3-更新包"><a href="#3-3-更新包" class="headerlink" title="3.3 更新包"></a>3.3 更新包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-检查过期包"><a href="#3-4-检查过期包" class="headerlink" title="3.4 检查过期包"></a>3.4 检查过期包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm outdated<br></code></pre></td></tr></table></figure><h2 id="3-5-修复漏洞"><a href="#3-5-修复漏洞" class="headerlink" title="3.5 修复漏洞"></a>3.5 修复漏洞</h2><p>NPM 提供了 <code>audit</code> 命令来检查项目中存在的安全漏洞，并通过 <code>audit fix</code> 自动修复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm audit<br>npm audit fix<br></code></pre></td></tr></table></figure><h2 id="3-6-清理缓存"><a href="#3-6-清理缓存" class="headerlink" title="3.6 清理缓存"></a>3.6 清理缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h1 id="4-NPM-脚本"><a href="#4-NPM-脚本" class="headerlink" title="4. NPM 脚本"></a>4. NPM 脚本</h1><p>NPM 允许在 <code>package.json</code> 文件中的 <code>scripts</code> 部分定义自定义命令。这些命令可以通过 <code>npm run &lt;script-name&gt;</code> 执行，常用于自动化工作流。</p><h2 id="4-1-定义和执行脚本"><a href="#4-1-定义和执行脚本" class="headerlink" title="4.1 定义和执行脚本"></a>4.1 定义和执行脚本</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><ul><li><code>pre</code> 和 <code>post</code> 钩子：NPM 支持在某个脚本执行前后自动执行一些预定义的任务。例如，定义 <code>pretest</code> 或 <code>posttest</code>，它们分别在 <code>test</code> 脚本前后执行。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;pretest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm install&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;posttest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run lint&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-脚本参数"><a href="#4-2-脚本参数" class="headerlink" title="4.2 脚本参数"></a>4.2 脚本参数</h2><p>你可以通过 <code>--</code> 向 NPM 脚本传递参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build -- --mode production<br></code></pre></td></tr></table></figure><h1 id="5-NPM-的版本管理"><a href="#5-NPM-的版本管理" class="headerlink" title="5. NPM 的版本管理"></a>5. NPM 的版本管理</h1><p>NPM 支持多种版本控制策略，便于项目在不同版本的依赖包中自由切换。</p><h2 id="5-1-版本号规则"><a href="#5-1-版本号规则" class="headerlink" title="5.1 版本号规则"></a>5.1 版本号规则</h2><p>NPM 的版本号遵循 语义化版本号 规范：</p><ul><li><strong>主版本号</strong>：非兼容性 API 变更。</li><li><strong>次版本号</strong>：向下兼容的新功能。</li><li><strong>修订号</strong>：向下兼容的问题修复。</li></ul><p>版本号示例：<code>^1.2.3</code>，其中 <code>^</code> 表示允许安装 <code>1.x.x</code> 版本的更新，<code>~1.2.3</code> 表示允许安装 <code>1.2.x</code> 的更新。</p><h2 id="5-2-锁定版本"><a href="#5-2-锁定版本" class="headerlink" title="5.2 锁定版本"></a>5.2 锁定版本</h2><p><code>package-lock.json</code> 是 NPM 自动生成的文件，它锁定了每个依赖包的版本，确保团队中每个人安装的包版本一致，避免版本不兼容问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm ci<br></code></pre></td></tr></table></figure><p><code>npm ci</code> 命令基于 <code>package-lock.json</code> 文件安装所有依赖，适用于 CI&#x2F;CD 环境下的构建流程。</p><h1 id="6-发布自己的-NPM-包"><a href="#6-发布自己的-NPM-包" class="headerlink" title="6. 发布自己的 NPM 包"></a>6. 发布自己的 NPM 包</h1><p>你可以通过 NPM 将自己的包发布到 NPM 注册库供其他开发者使用。</p><h2 id="6-1-创建-NPM-账户"><a href="#6-1-创建-NPM-账户" class="headerlink" title="6.1 创建 NPM 账户"></a>6.1 创建 NPM 账户</h2><p>首先，你需要注册一个 NPM 账户并登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm login<br></code></pre></td></tr></table></figure><h2 id="6-2-准备项目"><a href="#6-2-准备项目" class="headerlink" title="6.2 准备项目"></a>6.2 准备项目</h2><p>确保项目的 <code>package.json</code> 文件正确配置，尤其是以下字段：</p><ul><li><code>name</code>: 包名，需要唯一。</li><li><code>version</code>: 包版本，初始版本可以为 <code>1.0.0</code>。</li><li><code>main</code>: 入口文件。</li></ul><h2 id="6-3-发布包"><a href="#6-3-发布包" class="headerlink" title="6.3 发布包"></a>6.3 发布包</h2><p>执行以下命令将包发布到 NPM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish<br></code></pre></td></tr></table></figure><p>如果是发布新的版本，只需要在 <code>package.json</code> 中修改版本号，再次运行 <code>npm publish</code>。</p><h2 id="6-4-包版本管理"><a href="#6-4-包版本管理" class="headerlink" title="6.4 包版本管理"></a>6.4 包版本管理</h2><p>当你需要发布预览版或测试版时，可以使用 <code>npm publish</code> 的 <code>tag</code> 选项发布特定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish --tag beta<br></code></pre></td></tr></table></figure><h1 id="7-高级使用"><a href="#7-高级使用" class="headerlink" title="7. 高级使用"></a>7. 高级使用</h1><h2 id="7-1-使用-NPM-进行项目初始化"><a href="#7-1-使用-NPM-进行项目初始化" class="headerlink" title="7.1 使用 NPM 进行项目初始化"></a>7.1 使用 NPM 进行项目初始化</h2><p>有时我们需要为某些项目做初始化工作，NPM 的 <code>init</code> 命令可以与预设的模板搭配使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init &lt;模板名&gt;<br></code></pre></td></tr></table></figure><h2 id="7-2-本地开发包"><a href="#7-2-本地开发包" class="headerlink" title="7.2 本地开发包"></a>7.2 本地开发包</h2><p>在开发 NPM 包时，你可以使用 <code>npm link</code> 将本地包链接到全局环境中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><h2 id="7-3-npx-命令"><a href="#7-3-npx-命令" class="headerlink" title="7.3 npx 命令"></a>7.3 npx 命令</h2><p><code>npx</code> 是 NPM 附带的一个命令，它允许直接执行包中的命令，而无需全局安装。例如，运行 <code>create-react-app</code> 时，可以直接使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-react-app my-app<br></code></pre></td></tr></table></figure><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>NPM 是 Node.js 项目的基础工具，它不仅能帮助你高效地管理依赖，还能通过 <code>scripts</code> 和 <code>npx</code> 提升开发效率。通过掌握 NPM 的各种命令和功能，能够更好地维护项目和发布自己的代码包。</p><p>希望通过这篇教程，你对 NPM 有了更全面的理解。</p>]]></content>
    
    
    <categories>
      
      <category>NPM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>NPM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解浏览器原理与DOM</title>
    <link href="/posts/32299/"/>
    <url>/posts/32299/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解浏览器原理与-DOM"><a href="#深入理解浏览器原理与-DOM" class="headerlink" title="深入理解浏览器原理与 DOM"></a>深入理解浏览器原理与 DOM</h1><h1 id="一、什么是浏览器？"><a href="#一、什么是浏览器？" class="headerlink" title="一、什么是浏览器？"></a>一、什么是浏览器？</h1><p>浏览器是用户访问互联网的工具，它负责请求网页内容、解析网页、展示内容并处理用户与网页的互动。现代浏览器如 Chrome、Firefox 和 Safari 不仅支持 HTML、CSS 和 JavaScript，还集成了许多功能来优化用户体验和安全性。</p><h1 id="二、浏览器的工作过程"><a href="#二、浏览器的工作过程" class="headerlink" title="二、浏览器的工作过程"></a>二、浏览器的工作过程</h1><p>浏览器的工作过程可以分为多个步骤，每个步骤都有其重要性。让我们逐步深入了解。</p><h2 id="1-用户输入-URL"><a href="#1-用户输入-URL" class="headerlink" title="1. 用户输入 URL"></a>1. 用户输入 URL</h2><p>用户在浏览器的地址栏中输入一个网址（URL），例如 <code>http://www.example.com</code>。URL 通常包含协议（如 HTTP 或 HTTPS）、域名、路径、查询参数和锚点等信息。</p><h2 id="2-解析-URL"><a href="#2-解析-URL" class="headerlink" title="2. 解析 URL"></a>2. 解析 URL</h2><p>浏览器首先解析输入的 URL，提取出以下组成部分：</p><ul><li><strong>协议</strong>：指示使用的协议（HTTP 或 HTTPS）。</li><li><strong>域名</strong>：指向目标服务器的地址。</li><li><strong>路径</strong>：指向服务器上资源的位置。</li><li><strong>查询参数</strong>：可选，通常用于传递数据给服务器。</li></ul><h2 id="3-DNS-查询"><a href="#3-DNS-查询" class="headerlink" title="3. DNS 查询"></a>3. DNS 查询</h2><p>浏览器需要将域名转换为 IP 地址，才能找到服务器。为此，浏览器会向 DNS（域名系统）发送查询请求。DNS 服务器返回相应的 IP 地址，如果该地址已被缓存，浏览器可以直接使用。</p><h2 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h2><p>一旦获得了服务器的 IP 地址，浏览器会与服务器建立 TCP 连接。这个过程包含以下步骤：</p><ul><li><p>三次握手</p><p>：为了确保连接的可靠性，TCP 协议使用三次握手机制。</p><ol><li>浏览器发送一个 SYN（同步）包给服务器，请求建立连接。</li><li>服务器回复一个 SYN-ACK（同步-确认）包，确认收到请求并准备建立连接。</li><li>浏览器再次发送一个 ACK（确认）包，连接成功建立。</li></ol></li></ul><h2 id="5-发送-HTTP-请求"><a href="#5-发送-HTTP-请求" class="headerlink" title="5. 发送 HTTP 请求"></a>5. 发送 HTTP 请求</h2><p>建立连接后，浏览器会发送一个 HTTP 请求，向服务器请求资源。这个请求包含：</p><ul><li><strong>请求方法</strong>：通常是 GET（获取资源）或 POST（提交数据）。</li><li><strong>请求路径</strong>：服务器上资源的具体路径。</li><li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li><li><strong>请求头</strong>：包含浏览器信息、接受的内容类型等元数据。</li><li><strong>请求体</strong>（可选）：在 POST 请求中，包含发送给服务器的数据。</li></ul><h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>服务器接收到请求后，会处理请求并生成响应。服务器执行的操作可能包括：</p><ul><li>查询数据库。</li><li>处理业务逻辑。</li><li>生成动态网页内容。</li></ul><h2 id="7-服务器发送-HTTP-响应"><a href="#7-服务器发送-HTTP-响应" class="headerlink" title="7. 服务器发送 HTTP 响应"></a>7. 服务器发送 HTTP 响应</h2><p>处理完成后，服务器会发送一个 HTTP 响应回浏览器，响应包括：</p><ul><li><strong>状态码</strong>：指示请求处理的结果，如 200（成功）、404（未找到）或 500（服务器错误）。</li><li><strong>响应头</strong>：包含关于响应的信息，如内容类型、缓存策略、内容长度等。</li><li><strong>响应体</strong>：实际的网页内容，通常是 HTML 文档，也可能包括 CSS、JavaScript、图片等资源。</li></ul><h2 id="8-接收响应"><a href="#8-接收响应" class="headerlink" title="8. 接收响应"></a>8. 接收响应</h2><p>浏览器接收到服务器的响应后，首先检查状态码，确认请求是否成功。如果状态码是 200，浏览器将开始解析响应体。</p><h2 id="9-构建-DOM-树"><a href="#9-构建-DOM-树" class="headerlink" title="9. 构建 DOM 树"></a>9. 构建 DOM 树</h2><p>浏览器会解析 HTML 文档，构建文档对象模型（DOM）树。DOM 是一个树形结构，其中每个节点代表文档中的一个元素或文本。构建 DOM 树的过程如下：</p><ul><li>解析每个 HTML 标签，创建对应的元素节点。</li><li>处理标签之间的关系，形成父子节点的层级结构。</li><li>处理文本节点，将文本内容与相应的元素节点关联。</li></ul><h2 id="10-DOM-的详细解析"><a href="#10-DOM-的详细解析" class="headerlink" title="10. DOM 的详细解析"></a>10. DOM 的详细解析</h2><p>DOM（文档对象模型）是浏览器用来表示和操作 HTML 和 XML 文档的编程接口。以下是对 DOM 的详细讲解：</p><h3 id="1-DOM-的结构"><a href="#1-DOM-的结构" class="headerlink" title="1. DOM 的结构"></a>1. DOM 的结构</h3><p>DOM 树的根节点是 <code>document</code>，它表示整个文档。树的每个节点都是一个对象，代表文档中的元素、属性或文本。DOM 树结构如下：</p><ul><li>document<ul><li>html<ul><li>head<ul><li>title</li><li>meta</li></ul></li><li>body<ul><li>h1</li><li>p</li><li>div<ul><li>span</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="2-DOM-节点类型"><a href="#2-DOM-节点类型" class="headerlink" title="2. DOM 节点类型"></a>2. DOM 节点类型</h3><p>DOM 中的节点可以分为几种类型：</p><ul><li><strong>元素节点</strong>：表示 HTML 标签，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等。</li><li><strong>文本节点</strong>：表示元素内部的文本内容。</li><li><strong>属性节点</strong>：表示元素的属性，如 <code>class</code>、<code>id</code> 等（现代浏览器 API 中，属性节点不再是单独的节点）。</li></ul><h3 id="3-DOM-操作"><a href="#3-DOM-操作" class="headerlink" title="3. DOM 操作"></a>3. DOM 操作</h3><p>JavaScript 可以通过 DOM API 访问和修改 DOM 树，包括：</p><ul><li><strong>访问节点</strong>：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：根据 ID 获取元素。</li><li><code>document.querySelector(&#39;.class&#39;)</code>：根据 CSS 选择器获取元素。</li></ul></li><li><strong>添加节点</strong>：<ul><li><code>element.appendChild(newNode)</code>：将新节点添加到指定元素的子节点列表中。</li><li><code>element.insertBefore(newNode, referenceNode)</code>：在指定节点前插入新节点。</li></ul></li><li><strong>修改节点</strong>：<ul><li><code>element.textContent = &#39;New Text&#39;</code>：更改节点的文本内容。</li><li><code>element.setAttribute(&#39;attribute&#39;, &#39;value&#39;)</code>：设置节点的属性。</li></ul></li><li><strong>删除节点</strong>：<ul><li><code>element.removeChild(childNode)</code>：从 DOM 中删除子节点。</li></ul></li></ul><h2 id="11-构建-CSSOM-树"><a href="#11-构建-CSSOM-树" class="headerlink" title="11. 构建 CSSOM 树"></a>11. 构建 CSSOM 树</h2><p>在解析 HTML 的同时，浏览器会处理页面中的 CSS（包括内联样式和外部样式表），构建 CSSOM（CSS 对象模型）树。CSSOM 表示页面的样式规则，包含每个 CSS 选择器和它所对应的样式。</p><h2 id="12-合并-DOM-和-CSSOM"><a href="#12-合并-DOM-和-CSSOM" class="headerlink" title="12. 合并 DOM 和 CSSOM"></a>12. 合并 DOM 和 CSSOM</h2><p>DOM 树和 CSSOM 树被合并成一棵“渲染树”，它只包含需要渲染的可见元素。渲染树中的每个节点都包含视觉信息，决定元素在页面上的呈现方式。</p><h2 id="13-布局计算（Reflow）"><a href="#13-布局计算（Reflow）" class="headerlink" title="13. 布局计算（Reflow）"></a>13. 布局计算（Reflow）</h2><p>浏览器根据渲染树计算每个元素的位置和大小，这个过程被称为布局（或重排，Reflow）。在此过程中，浏览器考虑样式、内容和屏幕大小等因素，决定每个元素在页面上的具体位置。</p><h2 id="14-绘制（Repaint）"><a href="#14-绘制（Repaint）" class="headerlink" title="14. 绘制（Repaint）"></a>14. 绘制（Repaint）</h2><p>在完成布局后，浏览器将元素绘制到屏幕上。绘制过程会将渲染树的每个节点转换为位图，最终形成用户在屏幕上看到的页面。</p><h2 id="15-执行-JavaScript"><a href="#15-执行-JavaScript" class="headerlink" title="15. 执行 JavaScript"></a>15. 执行 JavaScript</h2><p>页面中的 JavaScript 代码会被执行。JavaScript 可以直接操作 DOM 和 CSSOM，可能会导致页面更新。以下是执行 JavaScript 的几个重要点：</p><ul><li><strong>DOM 操作</strong>：通过 JavaScript，开发者可以动态地添加、删除或修改页面元素。</li><li><strong>事件处理</strong>：JavaScript 可以响应用户的操作，如点击、滚动、输入等，增加交互性。</li></ul><h2 id="16-事件循环"><a href="#16-事件循环" class="headerlink" title="16. 事件循环"></a>16. 事件循环</h2><p>JavaScript 是单线程的，事件循环机制使得 JavaScript 可以异步处理事件。浏览器将用户操作和定时器事件推入一个任务队列，JavaScript 引擎逐一执行这些任务，确保页面的响应性。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>浏览器是一个复杂而强大的工具，理解其工作原理有助于开发者更好地构建和优化网页应用。从用户输入 URL 到最终呈现内容，每一步都涉及到多个子步骤和技术细节。掌握这些知识将使开发者在进行前端开发时更为得心应手，也能帮助他们识别和解决性能问题和兼容性问题。</p><p>希望这篇深入的博客能够帮助你更好地理解浏览器的工作原理、DOM 的结构与操作以及相关机制！如果有任何疑问或想了解更多内容，欢迎随时交流。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器跨域问题详解及解决方案</title>
    <link href="/posts/3208/"/>
    <url>/posts/3208/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题详解及解决方案"><a href="#浏览器跨域问题详解及解决方案" class="headerlink" title="浏览器跨域问题详解及解决方案"></a>浏览器跨域问题详解及解决方案</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>在开发 Web 应用时，浏览器的跨域问题是前端开发者经常遇到的。浏览器的<strong>同源策略</strong>（Same-Origin Policy）是为了保证安全，限制了跨域请求的发起。然而，很多场景下，跨域请求是必须的，比如前端与不同域的后端服务器通信时。因此，理解浏览器跨域问题的原因及其解决方案是非常重要的。</p><p>本文将深入讲解跨域问题的产生原因，并提供常用的解决方案，帮助开发者高效解决跨域问题。</p><hr><h1 id="一、什么是跨域问题？"><a href="#一、什么是跨域问题？" class="headerlink" title="一、什么是跨域问题？"></a><strong>一、什么是跨域问题？</strong></h1><p><strong>跨域</strong>是指浏览器的安全策略，即同源策略（Same-Origin Policy）限制了 JavaScript 只能从与网页同源的服务器请求资源。所谓<strong>同源</strong>，是指协议、域名、端口号三者必须完全相同。</p><ul><li><p><strong>同源</strong>：指的是协议、域名、端口号三者必须一致。</p></li><li><p>跨域</p><p>：如果任意一个不同，都是跨域。例如：</p><ul><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="https://www.example.com'(协议不同)/">https://www.example.com&#39;（协议不同）</a></li><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="http://api.example.com'(域名不同)/">http://api.example.com&#39;（域名不同）</a></li><li>‘<a href="http://www.example.com:8080/">http://www.example.com:8080</a>‘ 与 ‘<a href="http://www.example.com:3000'（端口不同）">http://www.example.com:3000&#39;（端口不同）</a></li></ul></li></ul><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a><strong>浏览器的同源策略</strong></h2><p>同源策略是一种重要的安全策略，它用于阻止一个源（网页）中的脚本读取另一个源中的资源。它的主要目的是为了防止恶意网站通过跨站脚本攻击（XSS）来窃取用户数据。</p><h2 id="跨域请求带来的问题"><a href="#跨域请求带来的问题" class="headerlink" title="跨域请求带来的问题"></a><strong>跨域请求带来的问题</strong></h2><p>跨域问题常出现在通过 Ajax 或 Fetch 发起的 HTTP 请求中，浏览器会根据同源策略阻止跨域请求，导致前端无法拿到不同源的服务器数据。</p><hr><h1 id="二、跨域问题产生的原因"><a href="#二、跨域问题产生的原因" class="headerlink" title="二、跨域问题产生的原因"></a><strong>二、跨域问题产生的原因</strong></h1><p>跨域问题产生的核心原因是<strong>浏览器的同源策略</strong>，具体在以下情况下会产生跨域问题：</p><ol><li><strong>协议不同</strong>：比如 HTTP 和 HTTPS 协议不同，属于跨域。</li><li><strong>域名不同</strong>：比如 <code>example.com</code> 和 <code>sub.example.com</code> 属于跨域。</li><li><strong>端口不同</strong>：同样的域名和协议，但端口不同，比如 <code>example.com:8080</code> 和 <code>example.com:3000</code>。</li></ol><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子</strong>：</h2><ul><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com/api/data">http://example.com/api/data</a> ——<strong>同源</strong>，允许请求。</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="https://example.com/api/data">https://example.com/api/data</a> ——<strong>跨域</strong>，拒绝请求。（协议不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://api.example.com/data">http://api.example.com/data</a> ——<strong>跨域</strong>，拒绝请求。（域名不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com:3000/data">http://example.com:3000/data</a> ——<strong>跨域</strong>，拒绝请求。（端口不同）</li></ul><p>当发生跨域时，浏览器会抛出类似如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://api.example.com/data&#x27;</span> from origin <span class="hljs-string">&#x27;http://www.example.com&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.<br></code></pre></td></tr></table></figure><p>这种错误提示表明请求被浏览器阻止，原因是目标服务器没有配置允许跨域请求的响应头。</p><hr><h1 id="三、跨域问题的常见解决方案"><a href="#三、跨域问题的常见解决方案" class="headerlink" title="三、跨域问题的常见解决方案"></a><strong>三、跨域问题的常见解决方案</strong></h1><p>针对跨域问题，前端和后端都有不同的解决方法。常用的方案包括：</p><h2 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1. CORS（跨域资源共享）"></a><strong>1. CORS（跨域资源共享）</strong></h2><p>CORS（Cross-Origin Resource Sharing）是 W3C 标准，允许浏览器向跨源服务器，发起 XMLHttpRequest 或 Fetch 请求。只要服务器端配置了适当的 CORS 头信息，就可以允许跨域请求。</p><p><strong>服务器端解决方法：</strong></p><p>在后端服务器配置响应头来允许跨域访问。具体操作是设置 HTTP 响应头中的 <code>Access-Control-Allow-Origin</code>，这个头告诉浏览器，允许哪些域进行跨域请求。</p><ul><li><p><strong>基本 CORS 头配置</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br></code></pre></td></tr></table></figure><p>这意味着允许所有来源的跨域请求。如果要限制特定的域，可以将 <code>*</code> 替换为特定域名，比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://www.example.com<br></code></pre></td></tr></table></figure></li><li><p><strong>支持复杂请求</strong>：</p><p>如果是复杂的跨域请求（例如涉及 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等非简单方法，或者带有自定义头部），需要预检请求。此时需要后端配置更多的 CORS 头信息，例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>Content-Type, Authorization<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure><p>这些头信息分别表示允许的 HTTP 方法、允许的自定义头部、以及是否允许携带 Cookie 等认证信息。</p></li></ul><h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a><strong>2. JSONP</strong></h2><p>JSONP（JSON with Padding）是一种传统的跨域请求方案，利用 <code>&lt;script&gt;</code> 标签的跨域能力来请求资源。因为 <code>&lt;script&gt;</code> 标签不受同源策略的限制，可以加载任意来源的脚本，JSONP 通过动态插入 <code>&lt;script&gt;</code> 标签来实现跨域请求。</p><p><strong>实现步骤</strong>：</p><ul><li><p>前端发起请求时，在 URL 中添加一个回调函数参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理返回数据</span><br>&#125;<br><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li><p>后端返回的数据需要被包裹在回调函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleResponse</span>(&#123;<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: [...]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>虽然 JSONP 可以实现跨域请求，但它只支持 GET 请求，不支持其他 HTTP 方法。</p><h2 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a><strong>3. 反向代理</strong></h2><p>反向代理是一种通过代理服务器转发请求的方式。前端请求会先发到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将响应返回给前端。</p><p><strong>实现步骤</strong>：</p><ul><li><p>配置代理服务器（如 Nginx 或 Node.js 中的代理模块）来转发请求：</p><p>在 Nginx 中的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://api.example.com;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，前端只需要请求 <code>/api/</code>，Nginx 会将请求转发到 <code>http://api.example.com</code>，从而避免跨域问题。</p></li></ul><h2 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a><strong>4. WebSocket</strong></h2><p>WebSocket 协议不受同源策略的限制，可以实现跨域通信。如果项目中需要实时通信，WebSocket 是一种不错的选择。</p><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://example.com/socket&#x27;</span>);<br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from server &#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="四、前端解决方案"><a href="#四、前端解决方案" class="headerlink" title="四、前端解决方案"></a><strong>四、前端解决方案</strong></h1><ol><li><p><strong>CORS 前端控制</strong> 前端可以通过控制请求时的一些参数，避免复杂请求的跨域问题。例如使用简单请求方法（GET、POST）或避免自定义请求头等。</p></li><li><p><strong>使用代理开发服务器</strong> 在开发环境中，使用 Webpack DevServer 或 Vite 等开发工具时，可以通过设置代理解决跨域问题。比如在 <code>vue.config.js</code> 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="五、简单请求"><a href="#五、简单请求" class="headerlink" title="五、简单请求"></a>五、简单请求</h1><p>在浏览器的同源策略下，只有某些特定的请求不会触发跨域问题。浏览器针对不同的请求类型进行了区分，只有符合特定条件的请求才会被认为是安全的，属于<strong>简单请求（Simple Requests）</strong>，这些请求不会触发浏览器的<strong>CORS 预检（Preflight）请求</strong>，因此也不会被同源策略限制。</p><h2 id="1、不会触发跨域的请求类型（简单请求）"><a href="#1、不会触发跨域的请求类型（简单请求）" class="headerlink" title="1、不会触发跨域的请求类型（简单请求）"></a><strong>1、不会触发跨域的请求类型（简单请求）</strong></h2><p>根据<strong>CORS（跨域资源共享）</strong>的规范，以下请求被定义为“简单请求”：</p><h3 id="1-1-请求方法必须是以下三种之一："><a href="#1-1-请求方法必须是以下三种之一：" class="headerlink" title="1.1. 请求方法必须是以下三种之一："></a>1.1. <strong>请求方法必须是以下三种之一</strong>：</h3><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><p>这意味着浏览器只会认为这些方法是安全的，任何其他 HTTP 方法（如 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等）都会被视为复杂请求，从而触发跨域检查。</p><h3 id="1-2-请求头必须是以下几种之一："><a href="#1-2-请求头必须是以下几种之一：" class="headerlink" title="1.2. 请求头必须是以下几种之一："></a>1.2. <strong>请求头必须是以下几种之一</strong>：</h3><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（有特定限制，见下一条）</li><li><code>DPR</code>（Device Pixel Ratio）</li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><p>浏览器默认允许这些请求头传递。如果请求中包含了其他自定义头字段，则会被认为是复杂请求，会触发跨域预检。</p><h3 id="1-3-Content-Type-必须是以下三种之一："><a href="#1-3-Content-Type-必须是以下三种之一：" class="headerlink" title="1.3. Content-Type 必须是以下三种之一："></a>1.3. <strong><code>Content-Type</code> 必须是以下三种之一</strong>：</h3><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>这些 <code>Content-Type</code> 类型是最常用的，特别是 <code>application/x-www-form-urlencoded</code>，它是表单提交的默认编码格式。如果使用了其他 <code>Content-Type</code>（例如 <code>application/json</code>），请求会被认为是复杂请求，触发跨域预检。</p><h3 id="1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性："><a href="#1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性：" class="headerlink" title="1.4. 请求不包含任何自定义的 XMLHttpRequest 对象属性："></a>1.4. <strong>请求不包含任何自定义的 <code>XMLHttpRequest</code> 对象属性</strong>：</h3><p>例如 <code>request.withCredentials = true</code> 会导致请求包含用户凭证（cookies、HTTP authentication 等），这将使请求成为复杂请求，触发 CORS 检查。</p><p><strong>简单请求的示例</strong>：</p><ul><li><p><strong>GET 请求</strong>：向目标 API 发起 GET 请求并获取数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>POST 请求</strong>：发送表单数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、简单请求不会触发跨域预检的原因"><a href="#2、简单请求不会触发跨域预检的原因" class="headerlink" title="2、简单请求不会触发跨域预检的原因"></a><strong>2、简单请求不会触发跨域预检的原因</strong></h2><p>浏览器的安全模型假定，简单请求不会带来高风险，因为它们遵循了 HTTP 协议中广泛使用的标准行为。预检请求的目的是检查目标服务器是否允许跨域访问，确保请求不会有潜在的安全问题。</p><p>而简单请求（如上述 <code>GET</code> 和 <code>POST</code>）通常是安全的，因为它们不使用自定义头字段或不发送敏感的内容类型。浏览器认为这些请求不需要额外的安全检查，所以不会触发跨域预检。</p><h2 id="3、哪些请求会触发跨域？"><a href="#3、哪些请求会触发跨域？" class="headerlink" title="3、哪些请求会触发跨域？"></a><strong>3、哪些请求会触发跨域？</strong></h2><p>如果不符合上面简单请求的条件，以下情况会导致请求被认为是复杂请求，从而触发跨域检查：</p><ul><li>使用了 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>、<code>OPTIONS</code> 等不属于简单请求的方法。</li><li>请求中包含了自定义头，如 <code>Authorization</code>、<code>X-Custom-Header</code> 等。</li><li>使用了 <code>Content-Type</code> 头的其他类型（如 <code>application/json</code>、<code>application/xml</code>）。</li><li>使用了带有 <code>withCredentials: true</code> 的请求，表示请求携带用户凭证（如 Cookies）。</li></ul><h2 id="4、复杂请求和预检请求"><a href="#4、复杂请求和预检请求" class="headerlink" title="4、复杂请求和预检请求"></a><strong>4、复杂请求和预检请求</strong></h2><p>复杂请求会触发浏览器发起一个 <code>OPTIONS</code> 请求，称为<strong>预检请求（Preflight Request）</strong>，服务器需要在这个请求中返回允许跨域访问的 CORS 头信息。只有当预检请求通过后，浏览器才会真正发起复杂请求。</p><hr><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、<strong>总结</strong></h2><p>不会触发跨域的基础请求，遵循了简单请求的规则：</p><ol><li><strong>HTTP 方法</strong>：仅限 <code>GET</code>、<code>POST</code>、<code>HEAD</code>。</li><li><strong>请求头</strong>：仅使用特定的标准头字段，如 <code>Accept</code>、<code>Content-Type</code>，且 <code>Content-Type</code> 必须是 <code>text/plain</code>、<code>multipart/form-data</code> 或 <code>application/x-www-form-urlencoded</code>。</li><li><strong>不使用自定义请求头</strong>，例如 <code>Authorization</code> 等。</li><li><strong>不带凭证</strong>，即不使用 <code>withCredentials: true</code>。</li></ol><p>理解这些规则可以帮助你在开发中规避跨域问题，或者正确配置 CORS 来处理复杂请求。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h1><p>跨域问题是浏览器为了安全性引入的，同源策略的限制避免了跨站点攻击（XSS、CSRF），但同时也带来了开发中的诸多不便。解决跨域问题的方案多种多样，前后端可以根据项目的需求选择合适的方式来处理。</p><ol><li><strong>CORS</strong> 是最常用、最标准的跨域解决方案，推荐使用。</li><li><strong>JSONP</strong> 适用于简单的 GET 请求，但随着 CORS 的普及使用较少。</li><li><strong>反向代理</strong> 在开发环境或生产环境中都非常实用，尤其是在分布式系统中。</li><li><strong>WebSocket</strong> 则适用于需要双向实时通信的场景。</li></ol><p>选择合适的跨域解决方案可以极大提高开发效率，也能让系统更安全地进行数据交互。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6新特性详解</title>
    <link href="/posts/34057/"/>
    <url>/posts/34057/</url>
    
    <content type="html"><![CDATA[<p>ES6（ECMAScript 6，也称为ECMAScript 2015）是JavaScript语言的一个重大更新，引入了许多新特性，旨在使代码更简洁、更易读，同时提供更强大的功能。以下是ES6中引入的主要新特性及其详细解释：</p><hr><h1 id="1-let-和-const-关键字"><a href="#1-let-和-const-关键字" class="headerlink" title="1. let 和 const 关键字"></a>1. <strong><code>let</code> 和 <code>const</code> 关键字</strong></h1><h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a><strong><code>let</code> 声明</strong></h4><ul><li><strong>块级作用域</strong>：<code>let</code> 声明的变量具有块级作用域，即变量只在其所在的代码块 <code>&#123;&#125;</code> 内有效。</li><li><strong>不允许重复声明</strong>：在同一作用域内，不能使用 <code>let</code> 重复声明同一个变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出 10</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 未定义</span><br></code></pre></td></tr></table></figure><h4 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a><strong><code>const</code> 声明</strong></h4><ul><li><strong>常量声明</strong>：<code>const</code> 用于声明常量，变量的值一旦赋值就不能再改变。</li><li><strong>块级作用域</strong>：<code>const</code> 也具有块级作用域。</li><li><strong>必须初始化</strong>：使用 <code>const</code> 声明时，必须同时进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.1415</span>; <span class="hljs-comment">// 报错，无法重新赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-箭头函数（Arrow-Functions）"><a href="#2-箭头函数（Arrow-Functions）" class="headerlink" title="2. 箭头函数（Arrow Functions）"></a>2. <strong>箭头函数（Arrow Functions）</strong></h1><p>箭头函数（Arrow Functions）是 JavaScript 中一种简洁的函数书写方式，它不仅使代码更简洁，而且在一些语法和行为上与普通函数不同。箭头函数自 ES6 引入以来，广泛应用于 JavaScript 开发中。</p><h2 id="2-1-箭头函数的基本语法"><a href="#2-1-箭头函数的基本语法" class="headerlink" title="2.1. 箭头函数的基本语法"></a>2.1. <strong>箭头函数的基本语法</strong></h2><p>箭头函数的基本语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">functionName</span> = (<span class="hljs-params">parameter1, parameter2, ...</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>const functionName</code> 是常规的变量声明方式，可以替换为 <code>let</code> 或 <code>var</code>。</li><li><code>(parameter1, parameter2, ...)</code> 是函数的参数，可以是零个或多个。</li><li><code>=&gt;</code> 是箭头函数的关键字，表示函数的开始。</li><li><code>&#123;&#125;</code> 包围着函数体，表示函数执行的操作。如果只有一行语句，可以省略花括号和 <code>return</code>。</li></ul><h2 id="2-2-最简单的箭头函数"><a href="#2-2-最简单的箭头函数" class="headerlink" title="2.2. 最简单的箭头函数"></a>2.2. <strong>最简单的箭头函数</strong></h2><p>一个简单的箭头函数，它没有参数，返回一个固定值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sayHello</span>());  <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><p>在这里，<code>sayHello</code> 是一个没有参数的箭头函数，直接返回 <code>&#39;Hello, World!&#39;</code> 字符串。</p><h2 id="2-3-有参数的箭头函数"><a href="#2-3-有参数的箭头函数" class="headerlink" title="2.3. 有参数的箭头函数"></a>2.3. 有参数的箭头函数</h2><p>箭头函数可以有一个或多个参数。对于一个参数时，可以省略圆括号；多个参数时，圆括号是必须的。</p><p><strong>单个参数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x * x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">square</span>(<span class="hljs-number">5</span>));  <span class="hljs-comment">// 输出: 25</span><br></code></pre></td></tr></table></figure><p><strong>多个参数：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出: 7</span><br></code></pre></td></tr></table></figure><h2 id="2-4-有返回值的箭头函数"><a href="#2-4-有返回值的箭头函数" class="headerlink" title="2.4. 有返回值的箭头函数"></a>2.4. <strong>有返回值的箭头函数</strong></h2><p>当箭头函数的函数体中只有一个表达式时，<code>return</code> 语句可以省略，表达式的结果会自动作为返回值返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">x, y</span>) =&gt; x * y;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出: 6</span><br></code></pre></td></tr></table></figure><p>对于多个表达式的箭头函数，必须使用花括号 <code>&#123;&#125;</code> 包裹函数体，并显式写出 <code>return</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addAndMultiply</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> sum = a + b;<br>  <span class="hljs-keyword">return</span> sum * <span class="hljs-number">2</span>;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addAndMultiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出: 14</span><br></code></pre></td></tr></table></figure><h2 id="2-5-箭头函数与-this"><a href="#2-5-箭头函数与-this" class="headerlink" title="2.5. 箭头函数与 this"></a>2.5. <strong>箭头函数与 <code>this</code></strong></h2><p>箭头函数与普通函数最大的区别之一是它不会创建自己的 <code>this</code> 值，而是继承（”绑定”）外部上下文中的 <code>this</code> 值。这意味着，在箭头函数中，<code>this</code> 的指向由外部作用域决定，通常是它被定义时的 <code>this</code>。</p><p><strong>普通函数中的 <code>this</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// undefined，因为普通函数的 `this` 指向 `setTimeout` 的作用域</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数中的 <code>this</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// John，因为箭头函数继承了外部作用域的 `this`</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上面的例子中，普通函数中的 <code>this</code> 指向 <code>setTimeout</code> 的上下文，而箭头函数中的 <code>this</code> 指向外部的 <code>Person</code> 对象，继承了外部的 <code>this</code>。</p><h2 id="2-6-箭头函数与-arguments-对象"><a href="#2-6-箭头函数与-arguments-对象" class="headerlink" title="2.6. 箭头函数与 arguments 对象"></a><strong>2.6. 箭头函数与 <code>arguments</code> 对象</strong></h2><p>箭头函数没有自己的 <code>arguments</code> 对象。它会继承外部函数的 <code>arguments</code> 对象。如果你需要使用 <code>arguments</code>，可以选择使用普通函数。</p><p><strong>普通函数的 <code>arguments</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-comment">// &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;</span><br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数无法使用 <code>arguments</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-comment">// 报错: arguments is not defined</span><br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h2 id="2-7-箭头函数在回调中的应用"><a href="#2-7-箭头函数在回调中的应用" class="headerlink" title="2.7. 箭头函数在回调中的应用"></a>2.7. <strong>箭头函数在回调中的应用</strong></h2><p>箭头函数通常用于回调函数，因为它的简洁性和继承外部 <code>this</code> 的特性，使得它在事件处理、数组方法（如 <code>map</code>、<code>filter</code>）等回调场景中非常有用。</p><p><strong>例子：使用 <code>map</code> 和箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> doubled = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled);  <span class="hljs-comment">// 输出: [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><p><strong>例子：在事件监听器中使用箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-8-箭头函数的限制"><a href="#2-8-箭头函数的限制" class="headerlink" title="2.8. 箭头函数的限制"></a>2.8. <strong>箭头函数的限制</strong></h2><p>虽然箭头函数有许多优点，但它也有一些限制和特性：</p><ol><li><p><strong>不能用作构造函数</strong>：箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();  <span class="hljs-comment">// 报错：Foo is not a constructor</span><br></code></pre></td></tr></table></figure></li><li><p>**没有 <code>prototype</code>**：箭头函数没有 <code>prototype</code> 属性，因此不能用作类的构造函数。</p></li><li><p>**不能改变 <code>this</code>**：箭头函数的 <code>this</code> 是继承自外部作用域的，而不是动态绑定的。如果你希望在调用时动态绑定 <code>this</code>，需要使用普通函数。</p></li></ol><h2 id="2-9-箭头函数与函数表达式"><a href="#2-9-箭头函数与函数表达式" class="headerlink" title="2.9. 箭头函数与函数表达式"></a>2.9. <strong>箭头函数与函数表达式</strong></h2><p>箭头函数通常与函数表达式一起使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure><h2 id="2-10-箭头函数的书写规范"><a href="#2-10-箭头函数的书写规范" class="headerlink" title="2.10. 箭头函数的书写规范"></a>2.10. <strong>箭头函数的书写规范</strong></h2><ul><li>如果箭头函数有多个参数，必须使用圆括号。</li><li>如果箭头函数只有一个参数且没有类型约束，可以省略圆括号。</li><li>如果箭头函数的主体只有一个表达式，可以省略花括号和 <code>return</code> 关键字。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>箭头函数是 JavaScript 中非常强大和简洁的特性，它在简化代码的同时，也带来了新的行为特性，特别是在 <code>this</code> 和 <code>arguments</code> 的处理上。箭头函数适用于需要短小、简洁的回调函数，尤其在处理数组、事件监听等场景时非常常见。尽管如此，在某些需要动态 <code>this</code> 或构造函数的场景中，普通函数依然是更合适的选择。</p><hr><h1 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3. 模板字符串（Template Literals）"></a>3. <strong>模板字符串（Template Literals）</strong></h1><ul><li><strong>多行字符串</strong>：使用反引号 &#96;&#96;&#96; 包裹，可以直接编写多行字符串。</li><li><strong>字符串插值</strong>：使用 <code>$&#123;表达式&#125;</code> 在字符串中嵌入变量或表达式的值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!</span><br><span class="hljs-string">Welcome to ES6 features.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Hello, Alice!</span><br><span class="hljs-comment">// Welcome to ES6 features.</span><br></code></pre></td></tr></table></figure><hr><h1 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. <strong>默认参数（Default Parameters）</strong></h1><ul><li><strong>函数参数默认值</strong>：在函数定义时，可以为参数指定默认值，当调用函数时未传入该参数时，使用默认值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;Guest&#x27;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// 输出 Hello, Bob!</span><br><span class="hljs-title function_">greet</span>();      <span class="hljs-comment">// 输出 Hello, Guest!</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-剩余参数和展开运算符（Rest-and-Spread-Operators）"><a href="#5-剩余参数和展开运算符（Rest-and-Spread-Operators）" class="headerlink" title="5. 剩余参数和展开运算符（Rest and Spread Operators）"></a>5. <strong>剩余参数和展开运算符（Rest and Spread Operators）</strong></h1><h4 id="剩余参数（Rest-Parameter）"><a href="#剩余参数（Rest-Parameter）" class="headerlink" title="剩余参数（Rest Parameter）"></a><strong>剩余参数（Rest Parameter）</strong></h4><ul><li><strong>函数参数</strong>：使用 <code>...</code> 收集函数的剩余参数，形成一个数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =&gt;</span> total + num, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h4 id="展开运算符（Spread-Operator）"><a href="#展开运算符（Spread-Operator）" class="headerlink" title="展开运算符（Spread Operator）"></a><strong>展开运算符（Spread Operator）</strong></h4><ul><li><strong>数组和对象展开</strong>：使用 <code>...</code> 将数组或对象展开。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组展开</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// 输出 [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// 对象展开</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// 输出 &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-解构赋值（Destructuring-Assignment）"><a href="#6-解构赋值（Destructuring-Assignment）" class="headerlink" title="6. 解构赋值（Destructuring Assignment）"></a>6. <strong>解构赋值（Destructuring Assignment）</strong></h1><ul><li><strong>数组解构</strong>：从数组中提取值，按照对应位置赋值给变量。</li><li><strong>对象解构</strong>：从对象中提取属性，赋值给与属性同名的变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构</span><br><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y); <span class="hljs-comment">// 输出 1 2</span><br><br><span class="hljs-comment">// 对象解构</span><br><span class="hljs-keyword">const</span> &#123; name, age &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// 输出 Alice 25</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-增强的对象字面量（Enhanced-Object-Literals）"><a href="#7-增强的对象字面量（Enhanced-Object-Literals）" class="headerlink" title="7. 增强的对象字面量（Enhanced Object Literals）"></a>7. <strong>增强的对象字面量（Enhanced Object Literals）</strong></h1><h3 id="1-属性简写（Property-Shorthand）"><a href="#1-属性简写（Property-Shorthand）" class="headerlink" title="1. 属性简写（Property Shorthand）"></a>1. 属性简写（Property Shorthand）</h3><p>在 ES6 之前，如果我们要在对象中设置属性，属性名通常与变量名相同，这时需要重复编写属性和变量名。但通过增强的对象字面量，可以直接使用简写语法。</p><h4 id="传统语法："><a href="#传统语法：" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: name,<br>  <span class="hljs-attr">age</span>: age<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-增强对象字面量的属性简写："><a href="#ES6-增强对象字面量的属性简写：" class="headerlink" title="ES6 增强对象字面量的属性简写："></a>ES6 增强对象字面量的属性简写：</h4><p>如果属性名和变量名相同，可以省略重复的部分，简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  name, <span class="hljs-comment">// 相当于 name: name</span><br>  age   <span class="hljs-comment">// 相当于 age: age</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：减少代码冗余，特别是在需要设置多个属性时，代码更简洁明了。</li></ul><h3 id="2-方法简写（Method-Shorthand）"><a href="#2-方法简写（Method-Shorthand）" class="headerlink" title="2. 方法简写（Method Shorthand）"></a>2. 方法简写（Method Shorthand）</h3><p>在对象中定义方法时，传统的写法需要显式使用 <code>function</code> 关键字。在增强的对象字面量中，可以使用更简洁的语法直接定义对象的方法。</p><h4 id="传统语法：-1"><a href="#传统语法：-1" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><h4 id="ES6-方法简写："><a href="#ES6-方法简写：" class="headerlink" title="ES6 方法简写："></a>ES6 方法简写：</h4><p>我们可以省略 <code>function</code> 关键字，直接用简写的形式来定义方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 简写方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：方法简写使得对象中的函数声明更简洁，代码也更容易阅读。</li></ul><h3 id="3-计算属性名（Computed-Property-Names）"><a href="#3-计算属性名（Computed-Property-Names）" class="headerlink" title="3. 计算属性名（Computed Property Names）"></a>3. 计算属性名（Computed Property Names）</h3><p>在增强的对象字面量中，允许动态地为对象的属性名赋值。你可以在对象定义时，通过方括号 <code>[]</code> 包裹表达式，使用计算出的值作为属性名。</p><h4 id="传统语法（ES5-没有计算属性名的支持）："><a href="#传统语法（ES5-没有计算属性名的支持）：" class="headerlink" title="传统语法（ES5 没有计算属性名的支持）："></a>传统语法（ES5 没有计算属性名的支持）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> person = &#123;&#125;;<br><br>person[key] = <span class="hljs-number">25</span>;  <span class="hljs-comment">// 动态添加属性</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-计算属性名："><a href="#ES6-计算属性名：" class="headerlink" title="ES6 计算属性名："></a>ES6 计算属性名：</h4><p>通过计算属性名的方式，可以直接在对象定义时动态设置属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  [key]: <span class="hljs-number">25</span>  <span class="hljs-comment">// 计算属性名</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性名不仅仅可以是变量，还可以是更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&#x27;user&#x27;</span>;<br><span class="hljs-keyword">const</span> id = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>_<span class="hljs-subst">$&#123;id&#125;</span>`</span>]: <span class="hljs-string">&#x27;Alice&#x27;</span>  <span class="hljs-comment">// 动态生成属性名 user_42</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// &#123; user_42: &#x27;Alice&#x27; &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：在需要动态生成属性名的场景下，计算属性名提供了灵活的解决方案。</li></ul><h1 id="8-类（Classes）"><a href="#8-类（Classes）" class="headerlink" title="8. 类（Classes）"></a>8. <strong>类（Classes）</strong></h1><ul><li><strong>类的定义</strong>：使用 <code>class</code> 关键字定义类。</li><li><strong>构造函数</strong>：使用 <code>constructor</code> 方法。</li><li><strong>继承</strong>：使用 <code>extends</code> 关键字实现继承，使用 <code>super</code> 调用父类方法。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">speak</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br>dog.<span class="hljs-title function_">speak</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Buddy makes a sound.</span><br><span class="hljs-comment">// Buddy barks.</span><br></code></pre></td></tr></table></figure><hr><h1 id="9-模块（Modules）"><a href="#9-模块（Modules）" class="headerlink" title="9. 模块（Modules）"></a>9. <strong>模块（Modules）</strong></h1><p>在 ES6（ECMAScript 2015）中，<strong>模块（Modules）</strong>是 JavaScript 中引入的一个重要特性，它为开发者提供了更好地组织代码的方式，使得代码更加模块化、可维护。模块系统允许我们将代码分隔成独立的模块，每个模块可以包含自己的变量、函数、类，并且这些模块之间可以通过 <code>export</code> 和 <code>import</code> 进行共享和使用。</p><p>接下来我们详细讲解模块的基本概念、用法以及如何在现代 JavaScript 项目中使用它们。</p><hr><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>在 ES6 之前，JavaScript 并没有原生的模块系统。开发者通常通过一些全局变量来共享数据，或者使用 IIFE（立即执行函数表达式）来模拟模块封装。这种做法容易导致命名冲突、全局污染，以及代码难以维护、复用性差的问题。</p><p>ES6 引入的模块系统解决了这些问题，它允许我们：</p><ul><li>将代码组织成多个独立的文件或模块；</li><li>在不同模块之间导入或导出功能；</li><li>避免全局命名冲突；</li><li>提高代码的可维护性和复用性。</li></ul><h2 id="ES6-模块基础概念"><a href="#ES6-模块基础概念" class="headerlink" title="ES6 模块基础概念"></a>ES6 模块基础概念</h2><p>ES6 模块主要依赖两个关键字：</p><ul><li>**<code>export</code>**：用来从模块中导出变量、函数、类等内容。</li><li>**<code>import</code>**：用来从其他模块中导入内容。</li></ul><h2 id="1-导出（Export）"><a href="#1-导出（Export）" class="headerlink" title="1. 导出（Export）"></a>1. 导出（Export）</h2><p><code>export</code> 用于将模块中的变量、函数、类等导出，供其他模块使用。</p><h3 id="1-1-命名导出（Named-Export）"><a href="#1-1-命名导出（Named-Export）" class="headerlink" title="1.1. 命名导出（Named Export）"></a>1.1. 命名导出（Named Export）</h3><p>命名导出允许你导出多个内容，并且每个导出都有自己明确的名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>  <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们导出了一个常量 <code>pi</code>，一个函数 <code>add</code>，以及一个类 <code>Calculator</code>。这些内容都可以通过名字从其他模块中导入。</p><h3 id="1-2-默认导出（Default-Export）"><a href="#1-2-默认导出（Default-Export）" class="headerlink" title="1.2. 默认导出（Default Export）"></a>1.2. 默认导出（Default Export）</h3><p>默认导出是指模块中可以有一个默认导出的值，导入时可以不需要用花括号。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// greeting.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们导出了一个默认的函数 <code>greet</code>，默认导出在每个模块中只能有一个。</p><h2 id="2-导入（Import）"><a href="#2-导入（Import）" class="headerlink" title="2. 导入（Import）"></a>2. 导入（Import）</h2><p><code>import</code> 用于从其他模块中导入导出的内容。导入可以是命名导出或默认导出。</p><h3 id="2-1-导入命名导出"><a href="#2-1-导入命名导出" class="headerlink" title="2.1. 导入命名导出"></a>2.1. 导入命名导出</h3><p>当从其他模块导入命名导出时，需要使用花括号 <code>&#123;&#125;</code>，并且变量名必须与导出的名称一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; pi, add, <span class="hljs-title class_">Calculator</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们从 <code>math.js</code> 中导入了 <code>pi</code>、<code>add</code> 函数和 <code>Calculator</code> 类，并在 <code>main.js</code> 中使用。</p><h3 id="2-2-导入默认导出"><a href="#2-2-导入默认导出" class="headerlink" title="2.2. 导入默认导出"></a>2.2. 导入默认导出</h3><p>导入默认导出时不需要使用花括号 <code>&#123;&#125;</code>，并且导入时可以任意命名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeting.js&#x27;</span>;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这里，我们导入了 <code>greeting.js</code> 中的默认导出 <code>greet</code> 函数，并直接使用它。</p><h3 id="2-3-导入别名"><a href="#2-3-导入别名" class="headerlink" title="2.3. 导入别名"></a>2.3. 导入别名</h3><p>有时你可能需要对导入的模块重命名，可以使用 <code>as</code> 来设置别名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>使用 <code>as</code> 可以避免命名冲突或让代码语义更加清晰。</p><h3 id="2-4-导入所有导出（import-as）"><a href="#2-4-导入所有导出（import-as）" class="headerlink" title="2.4. 导入所有导出（import * as）"></a>2.4. 导入所有导出（<code>import * as</code>）</h3><p>你也可以将整个模块的所有导出内容作为一个对象导入。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-property">pi</span>);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们将 <code>math.js</code> 中的所有导出作为一个 <code>math</code> 对象导入，然后通过 <code>math</code> 对象访问导出的内容。</p><h2 id="3-重新导出（Re-export）"><a href="#3-重新导出（Re-export）" class="headerlink" title="3. 重新导出（Re-export）"></a>3. 重新导出（Re-export）</h2><p>有时我们需要从一个模块导入一些内容后再导出给其他模块，这时可以使用 <code>export ... from</code> 语法。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> &#123; pi, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里，<code>moduleA.js</code> 重新导出了 <code>math.js</code> 中的 <code>pi</code> 和 <code>add</code>，其他模块可以直接从 <code>moduleA.js</code> 导入这些内容。</p><h2 id="4-动态导入（Dynamic-Import）"><a href="#4-动态导入（Dynamic-Import）" class="headerlink" title="4. 动态导入（Dynamic Import）"></a>4. 动态导入（Dynamic Import）</h2><p>ES6 模块中的 <code>import</code> 通常是静态的，即在编译时已经决定好导入的内容。然而，ES2020 引入了 <strong>动态导入（Dynamic Import）</strong>，它允许我们在运行时动态加载模块。</p><p>动态导入返回一个 <code>Promise</code>，当模块加载完成后会执行后续的操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error loading module:&#x27;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>动态导入特别适合按需加载模块或实现代码拆分（code splitting）。</p><hr><h2 id="ES6-模块的优势"><a href="#ES6-模块的优势" class="headerlink" title="ES6 模块的优势"></a>ES6 模块的优势</h2><ol><li><strong>默认严格模式</strong>：ES6 模块默认采用严格模式（<code>strict mode</code>），这意味着你可以避免一些常见的错误，比如全局变量的隐式声明。</li><li><strong>模块作用域</strong>：每个模块都有自己的作用域，模块内部的变量不会污染全局作用域，减少了命名冲突的可能性。</li><li><strong>按需导入</strong>：通过导入需要的内容，避免加载多余的代码，有助于提升性能。</li><li><strong>提升代码的可维护性和复用性</strong>：通过将功能分散到不同模块中，代码更容易维护，且可以重复使用不同模块中的功能。</li><li><strong>与现代构建工具集成</strong>：许多现代前端工具（如 Webpack、Parcel）和后端框架（如 Node.js）都支持 ES6 模块，可以方便地将模块化代码与构建工具结合使用。</li></ol><hr><h2 id="ES6-模块-vs-CommonJS"><a href="#ES6-模块-vs-CommonJS" class="headerlink" title="ES6 模块 vs CommonJS"></a>ES6 模块 vs CommonJS</h2><p>在 Node.js 中，最常见的模块系统是 <strong>CommonJS</strong>，通过 <code>require</code> 和 <code>module.exports</code> 来实现模块化。但 ES6 模块的出现提供了更标准化、现代化的解决方案。主要区别如下：</p><ul><li><strong>ES6 模块</strong>：通过 <code>import</code> 和 <code>export</code>，是编译时静态加载，支持浏览器原生模块化。</li><li><strong>CommonJS 模块</strong>：通过 <code>require</code> 和 <code>module.exports</code>，是运行时动态加载，最常见于 Node.js 环境中。</li></ul><p>随着 Node.js 开始原生支持 ES6 模块（通过文件扩展名 <code>.mjs</code> 或设置 <code>&quot;type&quot;: &quot;module&quot;</code>），开发者可以逐渐过渡到使用 ES6 模块系统。</p><hr><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. <strong>Promise 对象</strong></h1><p><strong>Promise</strong> 对象是 ES6 引入的一种用于处理异步操作的解决方案，避免了“回调地狱”的问题，使得异步代码的结构更加清晰、可读。<code>Promise</code> 允许你将异步操作的结果（成功或失败）封装成一个对象，并提供链式调用来处理异步操作的结果。</p><hr><h2 id="1-什么是-Promise？"><a href="#1-什么是-Promise？" class="headerlink" title="1. 什么是 Promise？"></a>1. 什么是 Promise？</h2><p><code>Promise</code> 是一个代表未来某个异步操作的结果的对象，它有三种状态：</p><ul><li><strong>Pending（进行中）</strong>：初始状态，异步操作尚未完成。</li><li><strong>Fulfilled（已完成）</strong>：异步操作成功完成，结果已返回。</li><li><strong>Rejected（已失败）</strong>：异步操作失败，返回了失败原因（通常是一个错误对象）。</li></ul><p>每个 <code>Promise</code> 实例一旦状态从 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变，也就是说 Promise 一旦 resolved 或 rejected 之后，结果是不可修改的。</p><h2 id="2-创建-Promise-对象"><a href="#2-创建-Promise-对象" class="headerlink" title="2. 创建 Promise 对象"></a>2. 创建 Promise 对象</h2><p>我们可以通过 <code>new Promise()</code> 构造函数来创建一个 Promise 对象。它接收一个函数作为参数，该函数包含两个参数：<code>resolve</code> 和 <code>reject</code>。</p><ul><li><code>resolve(value)</code>：当异步操作成功时调用，表示完成并将结果传递给下一个链式操作。</li><li><code>reject(error)</code>：当异步操作失败时调用，表示操作失败并将错误传递给错误处理器。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟异步操作的结果</span><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;操作成功！&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-Promise-状态变化"><a href="#3-Promise-状态变化" class="headerlink" title="3. Promise 状态变化"></a>3. Promise 状态变化</h2><p><code>Promise</code> 对象的状态只能从 <code>Pending</code> 转为 <code>Fulfilled</code> 或 <code>Rejected</code>，一旦状态改变，就不能再修改。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功了！&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 输出：Pending</span><br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：成功了！</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 最初状态为 Pending，2秒后会变为 Fulfilled</span><br></code></pre></td></tr></table></figure><h2 id="4-Promise-的使用"><a href="#4-Promise-的使用" class="headerlink" title="4. Promise 的使用"></a>4. Promise 的使用</h2><p>Promise 主要通过 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 进行链式调用来处理异步操作。</p><h3 id="4-1-then-：处理成功结果"><a href="#4-1-then-：处理成功结果" class="headerlink" title="4.1 .then()：处理成功结果"></a>4.1 <code>.then()</code>：处理成功结果</h3><p><code>then()</code> 方法用于处理 Promise 成功的结果。它接收两个回调函数，分别是成功回调和失败回调。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);  <span class="hljs-comment">// 成功的回调</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);  <span class="hljs-comment">// 失败的回调</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-catch-：处理失败结果"><a href="#4-2-catch-：处理失败结果" class="headerlink" title="4.2 .catch()：处理失败结果"></a>4.2 <code>.catch()</code>：处理失败结果</h3><p><code>catch()</code> 方法用于处理 Promise 中的错误或拒绝操作。它相当于 <code>.then()</code> 的第二个参数，但更适用于单独处理错误的场景。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);  <span class="hljs-comment">// 输出：错误：出错了</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-finally-：无论成功或失败都执行"><a href="#4-3-finally-：无论成功或失败都执行" class="headerlink" title="4.3 .finally()：无论成功或失败都执行"></a>4.3 <code>.finally()</code>：无论成功或失败都执行</h3><p><code>finally()</code> 方法无论 Promise 最终是成功还是失败，都会执行一次操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作结束&#x27;</span>);  <span class="hljs-comment">// 无论成功还是失败，都会执行</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="5-Promise-的链式调用"><a href="#5-Promise-的链式调用" class="headerlink" title="5. Promise 的链式调用"></a>5. Promise 的链式调用</h2><p>Promise 的强大之处在于它允许通过链式调用来处理多个异步操作。每个 <code>then()</code> 调用返回一个新的 <code>Promise</code> 对象，从而可以链式调用下一个异步操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：1</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：2</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：4</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，每个 <code>then()</code> 会返回一个新的 Promise，它可以继续链式调用。最终可以通过多个 <code>then()</code> 处理一系列的异步任务。</p><h2 id="6-Promise-静态方法"><a href="#6-Promise-静态方法" class="headerlink" title="6. Promise 静态方法"></a>6. Promise 静态方法</h2><h3 id="6-1-Promise-resolve"><a href="#6-1-Promise-resolve" class="headerlink" title="6.1 Promise.resolve()"></a>6.1 <code>Promise.resolve()</code></h3><p><code>Promise.resolve()</code> 方法返回一个已被 <code>resolve</code> 的 Promise，可以用来快速封装同步值。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：成功</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-2-Promise-reject"><a href="#6-2-Promise-reject" class="headerlink" title="6.2 Promise.reject()"></a>6.2 <code>Promise.reject()</code></h3><p><code>Promise.reject()</code> 方法返回一个已被 <code>reject</code> 的 Promise，用来封装错误或失败的结果。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 输出：失败</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-3-Promise-all"><a href="#6-3-Promise-all" class="headerlink" title="6.3 Promise.all()"></a>6.3 <code>Promise.all()</code></h3><p><code>Promise.all()</code> 方法接受一个包含多个 Promise 的数组，只有当所有 Promise 都成功时，才会执行 <code>then()</code> 回调；如果任何一个 Promise 失败，它就会立即进入 <code>catch()</code>。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);  <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-4-Promise-race"><a href="#6-4-Promise-race" class="headerlink" title="6.4 Promise.race()"></a>6.4 <code>Promise.race()</code></h3><p><code>Promise.race()</code> 方法接受一个包含多个 Promise 的数组，<strong>只要有一个 Promise 完成</strong>，就会进入 <code>then()</code> 回调，无论是成功还是失败。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;p1&#x27;</span>));<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;p2&#x27;</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：p2</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-Promise-实现异步操作"><a href="#7-Promise-实现异步操作" class="headerlink" title="7. Promise 实现异步操作"></a>7. Promise 实现异步操作</h2><p>Promise 的主要用途是处理异步操作，常见的如网络请求、文件读取等。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模拟异步网络请求</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 模拟请求成功</span><br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;请求的数据&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 输出：请求的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="11-Symbol-类型"><a href="#11-Symbol-类型" class="headerlink" title="11. Symbol 类型"></a>11. <strong>Symbol 类型</strong></h1><p><code>Symbol</code> 是 ECMAScript 6（ES6）引入的一种<strong>原始数据类型</strong>，它表示独一无二的值。与其他 JavaScript 数据类型（如字符串、数字、布尔值等）不同，<code>Symbol</code> 的主要作用是创建一个唯一的标识符，用于避免对象属性命名的冲突。</p><h2 id="1-Symbol-基础概念"><a href="#1-Symbol-基础概念" class="headerlink" title="1. Symbol 基础概念"></a>1. <strong>Symbol 基础概念</strong></h2><p><code>Symbol</code> 是通过 <code>Symbol()</code> 函数调用创建的。与其他原始数据类型不同，<code>Symbol</code> 的每个实例都是唯一的，即使两个 <code>Symbol()</code> 的参数相同，它们也是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbol1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-keyword">const</span> symbol2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbol1 === symbol2);  <span class="hljs-comment">// 输出：false</span><br></code></pre></td></tr></table></figure><ul><li>这里，<code>Symbol()</code> 中的参数 <code>&#39;description&#39;</code> 仅用于调试时的描述（可以理解为符号的标签），它不会影响 <code>Symbol</code> 的唯一性。</li></ul><h2 id="2-Symbol-的特性"><a href="#2-Symbol-的特性" class="headerlink" title="2. Symbol 的特性"></a>2. <strong>Symbol 的特性</strong></h2><ul><li><strong>唯一性</strong>：每个 <code>Symbol</code> 都是独一无二的，即使它们的描述相同，创建出来的 <code>Symbol</code> 也不会相等。</li><li><strong>不可改变</strong>：<code>Symbol</code> 是一种不可变的原始值，类似于 <code>string</code> 或 <code>number</code> 类型，它的值不能被修改。</li><li><strong>不可枚举</strong>：使用 <code>for...in</code>、<code>for...of</code> 或 <code>Object.keys()</code> 等方法遍历对象属性时，<code>Symbol</code> 类型的属性不会被枚举出来。</li></ul><h2 id="3-Symbol-作为对象属性的键"><a href="#3-Symbol-作为对象属性的键" class="headerlink" title="3. Symbol 作为对象属性的键"></a>3. <strong>Symbol 作为对象属性的键</strong></h2><p>通常，JavaScript 对象的键是字符串类型，但 <code>Symbol</code> 可以用作对象的键（属性名）。由于 <code>Symbol</code> 是唯一的，可以避免对象中使用相同的属性名导致的冲突。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [mySymbol]: <span class="hljs-string">&#x27;Symbol 属性值&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;普通属性值&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol]);  <span class="hljs-comment">// 输出：Symbol 属性值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);       <span class="hljs-comment">// 输出：普通属性值</span><br></code></pre></td></tr></table></figure><ul><li>注意，这里使用了 <strong>方括号语法</strong> <code>[mySymbol]</code> 来动态地定义对象的 <code>Symbol</code> 属性。</li></ul><h2 id="4-遍历-Symbol-属性"><a href="#4-遍历-Symbol-属性" class="headerlink" title="4. 遍历 Symbol 属性"></a>4. <strong>遍历 Symbol 属性</strong></h2><p>如前所述，<code>Symbol</code> 属性不会被 <code>for...in</code>、<code>Object.keys()</code> 等遍历方法枚举出来，但你可以通过以下几种方法获取对象的 <code>Symbol</code> 属性：</p><ul><li>**<code>Object.getOwnPropertySymbols()</code>**：返回一个包含对象所有 <code>Symbol</code> 属性的数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [sym1]: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  [sym2]: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> symbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbols);  <span class="hljs-comment">// 输出：[Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><ul><li>**<code>Reflect.ownKeys()</code>**：返回对象所有的键，包括字符串和 <code>Symbol</code> 类型。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj));  <span class="hljs-comment">// 输出：[&quot;name&quot;, Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><h2 id="5-全局-Symbol"><a href="#5-全局-Symbol" class="headerlink" title="5. 全局 Symbol"></a>5. <strong>全局 Symbol</strong></h2><p>JavaScript 还提供了 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 两个方法，用于创建和使用<strong>全局 Symbol</strong>。全局 Symbol 是共享的，即通过相同的 key 创建的全局 Symbol 总是相同的。</p><h3 id="5-1-Symbol-for"><a href="#5-1-Symbol-for" class="headerlink" title="5.1 Symbol.for()"></a>5.1 <strong><code>Symbol.for()</code></strong></h3><p><code>Symbol.for()</code> 方法接收一个字符串作为参数，检查全局注册表中是否存在该字符串对应的 Symbol，如果存在则返回该 Symbol，否则新建一个。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><span class="hljs-keyword">const</span> globalSym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalSym1 === globalSym2);  <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><ul><li><code>Symbol.for()</code> 使得相同 key 的 Symbol 是共享的，因此多个地方可以通过相同的 key 来引用同一个 Symbol。</li></ul><h3 id="5-2-Symbol-keyFor"><a href="#5-2-Symbol-keyFor" class="headerlink" title="5.2 Symbol.keyFor()"></a>5.2 <strong><code>Symbol.keyFor()</code></strong></h3><p><code>Symbol.keyFor()</code> 方法用于获取某个全局 Symbol 的 key。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym));  <span class="hljs-comment">// 输出：myKey</span><br></code></pre></td></tr></table></figure><ul><li>注意：<code>Symbol.keyFor()</code> 只能用于全局 <code>Symbol</code>，而不能用于普通的 <code>Symbol</code>。</li></ul><h2 id="6-内置的-Symbol"><a href="#6-内置的-Symbol" class="headerlink" title="6. 内置的 Symbol"></a>6. <strong>内置的 Symbol</strong></h2><p>ES6 还定义了一些内置的 <code>Symbol</code>，这些内置 <code>Symbol</code> 具有特殊的用途，通常用于定义一些 JavaScript 内部行为的自定义实现。</p><ul><li>**<code>Symbol.iterator</code>**：用于定义对象的默认迭代器，允许对象参与 <code>for...of</code> 循环。</li><li>**<code>Symbol.toStringTag</code>**：用于自定义 <code>Object.prototype.toString</code> 的返回值。</li><li>**<code>Symbol.hasInstance</code>**：用于判断对象是否是某个构造函数的实例。</li></ul><h3 id="6-1-Symbol-iterator"><a href="#6-1-Symbol-iterator" class="headerlink" title="6.1 Symbol.iterator"></a>6.1 <code>Symbol.iterator</code></h3><p><code>Symbol.iterator</code> 是一个内置的 <code>Symbol</code>，允许你为对象定义迭代行为，从而使对象可以被 <code>for...of</code> 循环使用。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterableObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">3</span> ? &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> iterableObj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Symbol-toStringTag"><a href="#6-2-Symbol-toStringTag" class="headerlink" title="6.2 Symbol.toStringTag"></a>6.2 <code>Symbol.toStringTag</code></h3><p><code>Symbol.toStringTag</code> 允许你自定义对象在 <code>Object.prototype.toString()</code> 中显示的标签。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;MyCustomObject&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(myObj));  <span class="hljs-comment">// 输出：[object MyCustomObject]</span><br></code></pre></td></tr></table></figure><h2 id="7-Symbol-的应用场景"><a href="#7-Symbol-的应用场景" class="headerlink" title="7. Symbol 的应用场景"></a>7. <strong>Symbol 的应用场景</strong></h2><ul><li><strong>避免对象属性名冲突</strong>：使用 <code>Symbol</code> 作为对象属性的键，保证属性名是唯一的，防止重写或冲突，特别是在大型代码库或第三方库中。</li><li><strong>为对象定义私有属性</strong>：由于 <code>Symbol</code> 属性不可枚举，通常可以用于实现“伪私有”属性，不会被 <code>for...in</code> 遍历到。</li><li><strong>扩展原生对象的行为</strong>：通过使用内置 <code>Symbol</code>，可以扩展 JavaScript 原生对象的行为，比如为对象自定义迭代器。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. <strong>总结</strong></h2><ul><li><strong><code>Symbol</code> 是一种唯一的标识符</strong>，用于避免对象属性名的冲突。</li><li><strong><code>Symbol</code> 属性不可枚举</strong>，不能通过常规的对象遍历方法访问，但可以通过 <code>Object.getOwnPropertySymbols()</code> 或 <code>Reflect.ownKeys()</code> 获取。</li><li><strong>全局 <code>Symbol</code></strong> 可以通过 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 共享并访问。</li><li>ES6 提供了一些**内置的 <code>Symbol</code>**，用于修改 JavaScript 原生行为，如 <code>Symbol.iterator</code>、<code>Symbol.toStringTag</code> 等。</li></ul><p><code>Symbol</code> 是 JavaScript 中一种非常有用的工具，它为我们提供了更多灵活性和控制力，特别是在大型项目中，使用 <code>Symbol</code> 可以有效地避免属性名冲突和确保代码的稳定性。</p><hr><h1 id="12-迭代器（Iterators）和-for-of-循环"><a href="#12-迭代器（Iterators）和-for-of-循环" class="headerlink" title="12. 迭代器（Iterators）和 for...of 循环"></a>12. <strong>迭代器（Iterators）和 <code>for...of</code> 循环</strong></h1><h2 id="1-迭代器（Iterators）"><a href="#1-迭代器（Iterators）" class="headerlink" title="1. 迭代器（Iterators）"></a>1. 迭代器（Iterators）</h2><p><strong>迭代器</strong>是一种用于访问集合中元素的对象，它提供了一种标准化的方法来遍历各种数据结构（如数组、对象、集合等）。迭代器遵循一定的协议，使得各种对象可以被一致地遍历。</p><h3 id="1-1-迭代器协议"><a href="#1-1-迭代器协议" class="headerlink" title="1.1 迭代器协议"></a>1.1 迭代器协议</h3><p>迭代器协议是一组规则，定义了一个对象如何提供遍历操作。任何实现了这些规则的对象都可以称为迭代器。</p><ul><li><p>迭代器对象</p><p>：必须实现 <strong>next</strong> 方法，该方法返回一个对象，这个对象包含两个属性：</p><ul><li><code>value</code>：当前遍历的值。</li><li><code>done</code>：一个布尔值，指示是否已遍历完所有值（<code>true</code> 表示遍历完成，<code>false</code> 表示还有剩余值）。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterator = &#123;<br>  <span class="hljs-attr">current</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">last</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 3, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-可迭代对象（Iterable-Objects）"><a href="#1-2-可迭代对象（Iterable-Objects）" class="headerlink" title="1.2 可迭代对象（Iterable Objects）"></a>1.2 可迭代对象（Iterable Objects）</h3><p>可迭代对象是具有 <code>Symbol.iterator</code> 属性的对象，<code>Symbol.iterator</code> 属性的值是一个函数，这个函数返回一个迭代器。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterable = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-for-of-循环"><a href="#2-for-of-循环" class="headerlink" title="2. for...of 循环"></a>2. <code>for...of</code> 循环</h2><p><code>for...of</code> 循环是 ES6 引入的用于遍历可迭代对象（包括数组、字符串、Map、Set 等）的一种语法。与传统的 <code>for</code> 循环不同，<code>for...of</code> 循环更简洁、易于理解，并且可以直接访问到每个元素。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><strong>基本语法：</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> iterable) &#123;<br>  <span class="hljs-comment">// 处理 element</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-遍历数组"><a href="#2-1-遍历数组" class="headerlink" title="2.1 遍历数组"></a>2.1 遍历数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><h3 id="2-2-遍历字符串"><a href="#2-2-遍历字符串" class="headerlink" title="2.2 遍历字符串"></a>2.2 遍历字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(char);<br>&#125;<br><span class="hljs-comment">// 输出：h, e, l, l, o</span><br></code></pre></td></tr></table></figure><h3 id="2-3-遍历-Set"><a href="#2-3-遍历-Set" class="headerlink" title="2.3 遍历 Set"></a>2.3 遍历 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> mySet) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h3 id="2-4-遍历-Map"><a href="#2-4-遍历-Map" class="headerlink" title="2.4 遍历 Map"></a>2.4 遍历 Map</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：key1: value1, key2: value2</span><br></code></pre></td></tr></table></figure><h2 id="3-自定义可迭代对象"><a href="#3-自定义可迭代对象" class="headerlink" title="3. 自定义可迭代对象"></a>3. 自定义可迭代对象</h2><p>你可以通过实现 <code>Symbol.iterator</code> 方法来自定义一个可迭代对象，并使用 <code>for...of</code> 循环进行遍历。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> customIterable = &#123;<br>  <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; data.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: data[index++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> customIterable) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li><strong>迭代器</strong> 是遵循特定协议的对象，它包含 <code>next</code> 方法来逐步访问集合中的元素。</li><li><strong>可迭代对象</strong> 是实现了 <code>Symbol.iterator</code> 方法的对象，可以被 <code>for...of</code> 循环遍历。</li><li><strong><code>for...of</code> 循环</strong> 使得遍历可迭代对象变得更加简洁直观，可以直接访问每个元素，而无需手动管理迭代器对象。</li></ul><p>通过理解和掌握这些概念，你可以更有效地处理各种数据结构，编写更加清晰和可维护的代码。</p><hr><h1 id="13-生成器（Generators）"><a href="#13-生成器（Generators）" class="headerlink" title="13. 生成器（Generators）"></a>13. <strong>生成器（Generators）</strong></h1><p>生成器是 ECMAScript 6 (ES6) 引入的一种特殊类型的函数，允许函数在执行时被暂停和恢复。生成器在处理需要多次迭代的任务时非常有用，比如遍历数据集、异步操作等。生成器函数可以简化代码逻辑，并提供了一种优雅的方式来管理异步操作。</p><h2 id="1-生成器的基本概念"><a href="#1-生成器的基本概念" class="headerlink" title="1. 生成器的基本概念"></a>1. <strong>生成器的基本概念</strong></h2><p>生成器是能够暂停执行并在之后的时间点恢复执行的函数。生成器函数通过 <code>function*</code> 关键字定义，并且返回一个生成器对象。生成器对象具有 <code>next()</code> 方法，可以用来控制生成器的执行过程。</p><h2 id="2-生成器函数的定义"><a href="#2-生成器函数的定义" class="headerlink" title="2. 生成器函数的定义"></a>2. <strong>生成器函数的定义</strong></h2><p>生成器函数通过 <code>function*</code> 语法定义。生成器函数内部使用 <code>yield</code> 关键字来暂停函数的执行，并返回一个值。每次调用 <code>next()</code> 方法时，生成器会从上次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 语句。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: World</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: !</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="3-生成器对象"><a href="#3-生成器对象" class="headerlink" title="3. 生成器对象"></a>3. <strong>生成器对象</strong></h2><p>生成器函数返回一个生成器对象，该对象具有以下方法：</p><ul><li>**<code>next([value])</code>**：恢复生成器函数的执行，直到下一个 <code>yield</code> 表达式。可以传递一个参数 <code>value</code>，作为 <code>yield</code> 表达式的返回值。返回的对象包含两个属性：<ul><li><code>value</code>：<code>yield</code> 表达式返回的值。</li><li><code>done</code>：布尔值，表示生成器是否已经完成执行。</li></ul></li><li>**<code>return([value])</code>**：结束生成器的执行，返回一个包含 <code>value</code> 的对象。<code>done</code> 属性将被设置为 <code>true</code>。</li><li>**<code>throw(exception)</code>**：在生成器中抛出异常，生成器会捕获这个异常并将其作为 <code>throw</code> 表达式的结果。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)); <span class="hljs-comment">// 输出: Error: Something went wrong</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-生成器的实际应用"><a href="#4-生成器的实际应用" class="headerlink" title="4. 生成器的实际应用"></a>4. <strong>生成器的实际应用</strong></h2><p>生成器在许多实际场景中都非常有用：</p><ul><li><p><strong>迭代器</strong>：生成器提供了一种简洁的方式来实现自定义的迭代器，使得遍历自定义数据结构变得容易。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">range</span>(<span class="hljs-params">start, end</span>) &#123;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    <span class="hljs-keyword">yield</span> start++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>异步编程</strong>：生成器与 Promise 结合可以简化异步编程。通过使用 <code>yield</code> 可以逐步处理异步操作，代码看起来更加同步。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">fetchData</span>();<br>generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(response).<span class="hljs-property">value</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>状态机</strong>：生成器可以用来实现状态机，通过 <code>yield</code> 和 <code>next()</code> 控制状态的转换。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">stateMachine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;start&#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is start&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;middle&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is middle&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;end&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;State is end&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> machine = <span class="hljs-title function_">stateMachine</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is start</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;middle&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is middle</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;end&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is end</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>生成器是 ES6 中一个强大的特性，它提供了一种简单而灵活的方式来控制函数的执行流。通过 <code>function*</code> 语法定义生成器函数，并使用 <code>yield</code> 来暂停和恢复执行。生成器可以用于实现自定义迭代器、简化异步编程、实现状态机等。它们的使用可以使代码更加优雅和易于维护。</p><p>如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="14-Map-和-Set-数据结构"><a href="#14-Map-和-Set-数据结构" class="headerlink" title="14. Map 和 Set 数据结构"></a>14. <strong><code>Map</code> 和 <code>Set</code> 数据结构</strong></h1><p>在 ECMAScript 6 (ES6) 中，<code>Map</code> 和 <code>Set</code> 是两个新的数据结构，它们提供了比传统的对象和数组更强大的功能，特别是在处理键值对和唯一值时。下面是对这两个数据结构的详细解释。</p><hr><h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a><strong><code>Map</code> 数据结构</strong></h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Map</code> 是一个有序的键值对集合，其中的键和值都可以是任何类型的值。与普通的对象不同，<code>Map</code> 的键值对是按插入顺序保持的，并且键的类型不受限制。</p><h3 id="2-创建-Map"><a href="#2-创建-Map" class="headerlink" title="2. 创建 Map"></a>2. <strong>创建 <code>Map</code></strong></h3><p>你可以使用 <code>new Map()</code> 来创建一个新的 <code>Map</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Map</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Map 实例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Map</span><br><span class="hljs-keyword">const</span> mapWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>],<br>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>set(key, value)</code>**：添加或更新键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>get(key)</code>**：根据键获取值。如果键不存在，返回 <code>undefined</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>has(key)</code>**：检查是否存在指定的键。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(key)</code>**：删除指定的键及其对应的值。如果删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Map</code> 中的所有键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Map</code> 中键值对的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li>**<code>keys()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键。</li><li>**<code>values()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的值。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键值对。</li><li>**<code>forEach(callback)</code>**：对 <code>Map</code> 中的每个键值对执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong><code>Set</code> 数据结构</strong></h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Set</code> 是一个值的集合，其中的值是唯一的，不允许重复。<code>Set</code> 的值是按照插入顺序排列的。</p><h3 id="2-创建-Set"><a href="#2-创建-Set" class="headerlink" title="2. 创建 Set"></a>2. <strong>创建 <code>Set</code></strong></h3><p>你可以使用 <code>new Set()</code> 来创建一个新的 <code>Set</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Set</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Set 实例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Set</span><br><span class="hljs-keyword">const</span> setWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>add(value)</code>**：向 <code>Set</code> 中添加一个值。如果值已经存在，则不会重复添加。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;apple&#x27;</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>has(value)</code>**：检查 <code>Set</code> 中是否存在指定的值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;apple&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(value)</code>**：删除 <code>Set</code> 中的指定值。如果值存在并且删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Set</code> 中的所有值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Set</code> 中的值的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li><strong><code>keys()</code></strong> 和 **<code>values()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有值（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有键值对（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>forEach(callback)</code>**：对 <code>Set</code> 中的每个值执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**<code>Map</code>**：适用于需要键值对并且键可以是任意类型的情况。提供了有序的键值对，并且具有丰富的方法来操作数据。</li><li>**<code>Set</code>**：适用于需要唯一值的情况。提供了无重复的值集合，并且具有方便的方法来检查和操作这些值。</li></ul><p>这两个数据结构在 ES6 中提供了比传统的对象和数组更高效和灵活的操作方式。如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="15-WeakMap-和-WeakSet"><a href="#15-WeakMap-和-WeakSet" class="headerlink" title="15. WeakMap 和 WeakSet"></a>15. <strong><code>WeakMap</code> 和 <code>WeakSet</code></strong></h1><ul><li><strong>弱引用</strong>：<code>WeakMap</code> 和 <code>WeakSet</code> 中的键（对于 <code>WeakMap</code>）和值（对于 <code>WeakSet</code>）是弱引用，不会阻止垃圾回收。</li><li><strong>用途</strong>：常用于存储关联到对象的元数据，不会干扰对象的垃圾回收。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some value&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 被垃圾回收，weakMap 中的键值对也会被自动移除</span><br></code></pre></td></tr></table></figure><hr><h1 id="16-新增的字符串、数字、数组方法"><a href="#16-新增的字符串、数字、数组方法" class="headerlink" title="16. 新增的字符串、数字、数组方法"></a>16. <strong>新增的字符串、数字、数组方法</strong></h1><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a><strong>字符串方法</strong></h4><ul><li>**<code>includes()</code>**：判断字符串是否包含指定子串。</li><li>**<code>startsWith()</code>**：判断字符串是否以指定子串开头。</li><li>**<code>endsWith()</code>**：判断字符串是否以指定子串结尾。</li><li>**<code>repeat()</code>**：将字符串重复指定次数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// 输出 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ha&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 HaHaHa</span><br></code></pre></td></tr></table></figure><h4 id="数字方法"><a href="#数字方法" class="headerlink" title="数字方法"></a><strong>数字方法</strong></h4><ul><li>**<code>Number.isNaN()</code>**：判断值是否为 <code>NaN</code>。</li><li>**<code>Number.isFinite()</code>**：判断值是否为有限数。</li><li>**<code>Number.isInteger()</code>**：判断值是否为整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">4.5</span>)); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h4><ul><li>**<code>Array.from()</code>**：将类数组或可迭代对象转换为数组。</li><li>**<code>Array.of()</code>**：创建一个由参数组成的新数组。</li><li>**<code>find()</code> 和 <code>findIndex()</code>**：找到符合条件的第一个元素或其索引。</li><li>**<code>fill()</code>**：用指定值填充数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 2</span><br><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 输出 [1, 0, 0, 4]</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-Proxy-对象"><a href="#17-Proxy-对象" class="headerlink" title="17. Proxy 对象"></a>17. <strong><code>Proxy</code> 对象</strong></h1><p><code>Proxy</code> 是 ECMAScript 6（ES6）引入的一个新特性，它允许你创建一个对象的代理（Proxy），通过该代理可以定义基本操作的自定义行为，比如属性查找、赋值、枚举、函数调用等。<code>Proxy</code> 提供了一种灵活的机制，用于拦截并修改对目标对象的操作。</p><h2 id="1-创建-Proxy"><a href="#1-创建-Proxy" class="headerlink" title="1. 创建 Proxy"></a>1. <strong>创建 Proxy</strong></h2><p><code>Proxy</code> 构造函数接收两个参数：</p><ul><li>**<code>target</code>**：要创建代理的目标对象，可以是任何对象（包括原始值）。</li><li>**<code>handler</code>**：一个对象，其中定义了代理的行为（即拦截操作）。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><h2 id="2-Handler-对象"><a href="#2-Handler-对象" class="headerlink" title="2. Handler 对象"></a>2. <strong>Handler 对象</strong></h2><p><code>handler</code> 对象包含多个陷阱（trap）方法，这些方法定义了代理如何处理不同的操作。每个陷阱方法对应一个基本操作，如读取属性、设置属性等。</p><p><strong>常见陷阱方法包括：</strong></p><ul><li>**<code>get</code>**：拦截对象属性的读取操作。</li><li>**<code>set</code>**：拦截对象属性的写入操作。</li><li>**<code>has</code>**：拦截 <code>in</code> 操作符。</li><li>**<code>deleteProperty</code>**：拦截 <code>delete</code> 操作符。</li><li>**<code>apply</code>**：拦截函数调用。</li><li>**<code>construct</code>**：拦截构造函数调用。</li><li>**<code>ownKeys</code>**：拦截 <code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.keys()</code>。</li><li>**<code>getPrototypeOf</code>**：拦截 <code>Object.getPrototypeOf()</code>。</li><li>**<code>setPrototypeOf</code>**：拦截 <code>Object.setPrototypeOf()</code>。</li></ul><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h2><p>以下是一些使用 <code>Proxy</code> 对象的示例，展示了如何通过代理对象来拦截和修改对目标对象的操作。</p><h3 id="3-1-属性读取和设置"><a href="#3-1-属性读取和设置" class="headerlink" title="3.1 属性读取和设置"></a>3.1 属性读取和设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>;  <span class="hljs-comment">// 控制台输出: Setting name to John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 控制台输出: Getting name, 输出: John</span><br></code></pre></td></tr></table></figure><ul><li><code>get</code> 陷阱拦截对属性的读取。</li><li><code>set</code> 陷阱拦截对属性的写入。</li></ul><h3 id="3-2-属性存在检查"><a href="#3-2-属性存在检查" class="headerlink" title="3.2 属性存在检查"></a>3.2 属性存在检查</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Checking existence of <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, property);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// 控制台输出: Checking existence of name, 输出: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> proxy);   <span class="hljs-comment">// 控制台输出: Checking existence of age, 输出: false</span><br></code></pre></td></tr></table></figure><ul><li><code>has</code> 陷阱拦截 <code>in</code> 操作符。</li></ul><h3 id="3-3-函数调用"><a href="#3-3-函数调用" class="headerlink" title="3.3 函数调用"></a>3.3 函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling function with arguments <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 控制台输出: Calling function with arguments 1,2, 输出: 3</span><br></code></pre></td></tr></table></figure><ul><li><code>apply</code> 陷阱拦截函数调用。</li></ul><h3 id="3-4-构造函数调用"><a href="#3-4-构造函数调用" class="headerlink" title="3.4 构造函数调用"></a>3.4 构造函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Constructing with arguments <span class="hljs-subst">$&#123;args&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 控制台输出: Constructing with arguments 1,2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);  <span class="hljs-comment">// 输出: target &#123; x: 1, y: 2 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>construct</code> 陷阱拦截构造函数调用。</li></ul><h2 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4. 常见用法"></a>4. <strong>常见用法</strong></h2><ul><li><strong>数据验证</strong>：可以使用 <code>Proxy</code> 对象来验证对目标对象的属性值进行检查，例如确保属性值在某个范围内。</li><li><strong>日志记录</strong>：可以在 <code>Proxy</code> 的陷阱方法中记录对目标对象的所有操作，用于调试和分析。</li><li><strong>防御性编程</strong>：可以通过 <code>Proxy</code> 保护目标对象，防止非法的属性操作。</li><li><strong>虚拟化</strong>：可以使用 <code>Proxy</code> 实现懒加载和其他性能优化技术，例如按需加载对象属性。</li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h2><ul><li><strong>性能</strong>：使用 <code>Proxy</code> 对象会引入额外的开销，因为每个操作都需要经过陷阱函数。对于性能敏感的应用，要慎重使用。</li><li><strong>无法代理的对象</strong>：一些对象（如内置对象、冻结的对象）不能被 <code>Proxy</code> 代理。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><p><code>Proxy</code> 对象是 ES6 引入的强大特性，允许你创建一个代理对象来拦截和自定义对目标对象的操作。通过使用 <code>Proxy</code>，可以实现许多高级功能，如数据验证、日志记录和虚拟化等。在实际应用中，合理使用 <code>Proxy</code> 可以大大提高代码的灵活性和可维护性。</p><hr><h1 id="18-Reflect-API"><a href="#18-Reflect-API" class="headerlink" title="18. Reflect API"></a>18. <strong><code>Reflect</code> API</strong></h1><p><code>Reflect</code> 是 ES6 引入的一个内置对象，它提供了一组方法，用于操作对象的原型和目标对象的内部状态。<code>Reflect</code> 对象主要用于与 <code>Proxy</code> 一起使用，它提供了一些与 <code>Proxy</code> 陷阱方法相对应的基本操作，这些方法可以用来在代理对象内部调用目标对象的原始操作。</p><h2 id="1-Reflect-的方法"><a href="#1-Reflect-的方法" class="headerlink" title="1.Reflect 的方法"></a>1.Reflect 的方法</h2><p><code>Reflect</code> 提供了一些与对象操作相关的静态方法，这些方法对应于对象操作的基本行为。主要的方法包括：</p><ul><li><p><strong><code>Reflect.apply(target, thisArg, argumentsList)</code></strong></p><ul><li><p>用于调用一个函数，类似于 <code>Function.prototype.apply</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：要调用的函数。</li><li><code>thisArg</code>：函数内部的 <code>this</code>。</li><li><code>argumentsList</code>：参数数组。</li></ul></li><li><p><strong>返回值</strong>：函数调用的结果。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(sum, <span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.construct(target, argumentsList, newTarget)</code></strong></p><ul><li><p>用于创建一个对象实例，类似于 <code>new</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：构造函数。</li><li><code>argumentsList</code>：构造函数的参数数组。</li><li><code>newTarget</code>：指定构造函数的原型链的对象。</li></ul></li><li><p><strong>返回值</strong>：构造函数创建的新对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: Alice</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.defineProperty(target, propertyKey, attributes)</code></strong></p><ul><li><p>用于定义目标对象的属性，类似于 <code>Object.defineProperty</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>attributes</code>：属性描述符。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功定义。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.deleteProperty(target, propertyKey)</code></strong></p><ul><li><p>用于删除目标对象的属性，类似于 <code>delete</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：要删除的属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.get(target, propertyKey, receiver)</code></strong></p><ul><li><p>用于获取目标对象的属性值，类似于 <code>target[propertyKey]</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：属性的值。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.getPrototypeOf(target)</code></strong></p><ul><li><p>用于获取目标对象的原型，类似于 <code>Object.getPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：目标对象的原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prototype === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.has(target, propertyKey)</code></strong></p><ul><li><p>用于检查目标对象是否具有指定的属性，类似于 <code>propertyKey in target</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否存在。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.isExtensible(target)</code></strong></p><ul><li><p>用于检查目标对象是否可扩展（即是否可以添加新属性），类似于 <code>Object.isExtensible</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示目标对象是否可扩展。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.ownKeys(target)</code></strong></p><ul><li><p>用于获取目标对象的所有属性名（包括符号属性），类似于 <code>Object.getOwnPropertyNames</code> 和 <code>Object.getOwnPropertySymbols</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：属性名数组。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// 输出: [&#x27;name&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.set(target, propertyKey, value, receiver)</code></strong></p><ul><li><p>用于设置目标对象的属性值，类似于 <code>target[propertyKey] = value</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>value</code>：属性值。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功设置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.setPrototypeOf(target, prototype)</code></strong></p><ul><li><p>用于设置目标对象的原型，类似于 <code>Object.setPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>prototype</code>：新的原型。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示是否成功设置原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> newProto = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, newProto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === newProto);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><ul><li><strong><code>Reflect</code></strong> 对象提供了一组静态方法，用于操作对象的基本行为。</li><li><strong><code>Reflect</code></strong> 方法主要用于与 <code>Proxy</code> 一起使用，以便在代理对象中执行目标对象的操作。</li><li><strong><code>Reflect</code></strong> 提供的方法与目标对象操作的方法一一对应，简化了对象操作的实现逻辑，使得代码更加一致和可维护。</li></ul><p><code>Reflect</code> 对象是一个强大的工具，用于更细粒度地控制对象的行为，并且是 ES6 提供的一个重要功能。</p><hr><h1 id="19-尾调用优化（Tail-Call-Optimization）"><a href="#19-尾调用优化（Tail-Call-Optimization）" class="headerlink" title="19. 尾调用优化（Tail Call Optimization）"></a>19. <strong>尾调用优化（Tail Call Optimization）</strong></h1><p>尾调用优化（TCO）是一种编程语言优化技术，旨在提高递归函数的效率，防止函数调用栈的增长，避免因递归深度过大而导致的栈溢出。尾调用优化的核心思想是将尾递归（即递归调用是函数的最后一步操作）转换为更高效的迭代形式，从而减少内存使用。</p><h2 id="1-尾调用（Tail-Call）"><a href="#1-尾调用（Tail-Call）" class="headerlink" title="1. 尾调用（Tail Call）"></a>1. <strong>尾调用（Tail Call）</strong></h2><p>尾调用是指在函数的最后一步调用另一个函数，而没有任何额外的计算。换句话说，尾调用是函数调用的最后操作，没有任何额外的工作要做。这种调用模式适合进行尾调用优化。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>factorial</code> 函数中的递归调用 <code>factorial(n - 1, n * result)</code> 是尾调用，因为它是函数 <code>factorial</code> 的最后一步操作。</p><h2 id="2-尾调用优化的原理"><a href="#2-尾调用优化的原理" class="headerlink" title="2. 尾调用优化的原理"></a>2. <strong>尾调用优化的原理</strong></h2><p>在尾调用优化中，当一个函数执行尾调用时，编译器或解释器会将当前函数的栈帧复用到被调用函数的栈帧中。这样，递归调用不会增加新的栈帧，从而避免了栈空间的消耗。</p><p><strong>过程：</strong></p><ol><li><strong>当前函数执行到尾调用位置</strong>。</li><li><strong>丢弃当前函数的栈帧</strong>，因为在尾调用时当前函数的执行已经完成。</li><li><strong>重用当前函数的栈帧</strong>，将控制权转移到被调用函数。</li></ol><p>通过这种方式，尾调用优化将递归调用转化为迭代，从而避免了递归深度带来的性能问题。</p><h2 id="3-支持尾调用优化的语言"><a href="#3-支持尾调用优化的语言" class="headerlink" title="3. 支持尾调用优化的语言"></a>3. <strong>支持尾调用优化的语言</strong></h2><p>一些编程语言支持尾调用优化，包括：</p><ul><li><strong>Scheme</strong>：作为 Lisp 家族的一员，Scheme 是一种支持尾调用优化的函数式编程语言。</li><li><strong>Racket</strong>：Racket 也是一种支持尾调用优化的语言，具有类似于 Scheme 的特性。</li><li><strong>Haskell</strong>：Haskell 是一种纯函数式编程语言，支持尾调用优化。</li></ul><h2 id="4-JavaScript-中的尾调用优化"><a href="#4-JavaScript-中的尾调用优化" class="headerlink" title="4. JavaScript 中的尾调用优化"></a>4. <strong>JavaScript 中的尾调用优化</strong></h2><p>虽然 JavaScript 语言规范（ECMAScript 2015）引入了尾调用优化的提案，但实际支持这一特性的浏览器和 JavaScript 引擎的实现仍然不统一。部分浏览器的 JavaScript 引擎可能并不完全支持尾调用优化，因此，在实际开发中不一定能保证尾调用优化的效果。</p><p><strong>ECMAScript 2015（ES6）提案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 规范中定义了尾调用优化的行为，但实际支持情况取决于 JavaScript 引擎的实现。</p><h2 id="5-非支持尾调用优化的情况下的解决方案"><a href="#5-非支持尾调用优化的情况下的解决方案" class="headerlink" title="5. 非支持尾调用优化的情况下的解决方案"></a>5. <strong>非支持尾调用优化的情况下的解决方案</strong></h2><p>如果运行环境不支持尾调用优化，递归深度过大可能会导致栈溢出。在这种情况下，可以使用迭代代替递归，以避免深度递归带来的问题。</p><p><strong>迭代替代尾递归示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    result *= n;<br>    n--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例使用了迭代来计算阶乘，而不是递归，从而避免了栈溢出的问题。</p><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul><li><strong>尾调用</strong> 是指在函数的最后一步调用另一个函数。</li><li><strong>尾调用优化（TCO）</strong> 通过重用栈帧来减少递归深度，避免栈溢出。</li><li>一些编程语言（如 Scheme、Haskell）支持尾调用优化，但 JavaScript 的支持情况不一致。</li><li>当尾调用优化不可用时，可以使用迭代代替递归来避免栈溢出。</li></ul><p>尾调用优化是函数式编程中的一个重要概念，通过优化递归调用，可以使代码更加高效、健壮。在实际开发中，要根据运行环境的特性来决定是否依赖于尾调用优化。</p><hr><h1 id="20-模块加载器（Module-Loader）"><a href="#20-模块加载器（Module-Loader）" class="headerlink" title="20. 模块加载器（Module Loader）"></a>20. <strong>模块加载器（Module Loader）</strong></h1><p>在 ECMAScript 2015（ES6）中，引入了原生的模块系统，这一系统为 JavaScript 提供了标准化的模块化支持，称为 ES6 模块（ESM）。ES6 模块系统具有内建的模块加载器，允许开发者通过 <code>import</code> 和 <code>export</code> 语法来进行模块化编程。</p><h2 id="1-ES6-模块的基本概念"><a href="#1-ES6-模块的基本概念" class="headerlink" title="1. ES6 模块的基本概念"></a>1. <strong>ES6 模块的基本概念</strong></h2><p>在 ES6 中，模块是 JavaScript 代码的基本组织单元。每个模块都有自己的作用域，模块之间的依赖关系通过显式的 <code>import</code> 和 <code>export</code> 语法来定义和管理。</p><p><strong>模块的基本特点</strong>：</p><ul><li><strong>静态加载</strong>：模块在编译时加载，这使得依赖关系可以在编译阶段进行静态分析和优化。</li><li><strong>严格模式</strong>：模块默认在严格模式下运行，这有助于避免一些常见的 JavaScript 错误。</li><li><strong>导入和导出</strong>：模块可以通过 <code>export</code> 导出变量、函数或类，并通过 <code>import</code> 导入其他模块的导出。</li></ul><h2 id="2-模块导出（Export）"><a href="#2-模块导出（Export）" class="headerlink" title="2. 模块导出（Export）"></a>2. <strong>模块导出（Export）</strong></h2><p>ES6 模块通过 <code>export</code> 语法导出模块的功能。导出的内容可以是变量、函数、类或对象。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateArea</span>(<span class="hljs-params">radius</span>) &#123; <span class="hljs-comment">// 导出函数</span><br>  <span class="hljs-keyword">return</span> pi * radius * radius;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123; <span class="hljs-comment">// 导出类</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">radius</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;<br>  &#125;<br>  <span class="hljs-title function_">getArea</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> pi * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-模块导入（Import）"><a href="#3-模块导入（Import）" class="headerlink" title="3. 模块导入（Import）"></a>3. <strong>模块导入（Import）</strong></h2><p>ES6 模块通过 <code>import</code> 语法导入其他模块的内容。可以导入整个模块的功能，也可以导入模块的部分功能。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; pi, calculateArea, <span class="hljs-title class_">Circle</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi); <span class="hljs-comment">// 输出: 3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateArea</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 78.5</span><br><br><span class="hljs-keyword">const</span> myCircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCircle.<span class="hljs-title function_">getArea</span>()); <span class="hljs-comment">// 输出: 78.5</span><br></code></pre></td></tr></table></figure><h2 id="4-默认导出（Default-Export）"><a href="#4-默认导出（Default-Export）" class="headerlink" title="4. 默认导出（Default Export）"></a>4. <strong>默认导出（Default Export）</strong></h2><p>ES6 模块允许每个模块有一个默认导出，这对于导出单一的功能或对象非常有用。默认导出可以是变量、函数或类。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>; <span class="hljs-comment">// 导入默认导出</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><h2 id="5-动态导入（Dynamic-Import）"><a href="#5-动态导入（Dynamic-Import）" class="headerlink" title="5. 动态导入（Dynamic Import）"></a>5. <strong>动态导入（Dynamic Import）</strong></h2><p>ES6 模块也支持动态导入，即在运行时加载模块。这是通过 <code>import()</code> 函数实现的，返回一个 Promise 对象，可以在异步操作中使用。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">pi</span>);<br>&#125;<br><br><span class="hljs-title function_">loadModule</span>();<br></code></pre></td></tr></table></figure><h2 id="6-模块加载器的工作原理"><a href="#6-模块加载器的工作原理" class="headerlink" title="6. 模块加载器的工作原理"></a>6. <strong>模块加载器的工作原理</strong></h2><p>ES6 模块加载器的工作原理包括以下几个步骤：</p><ol><li><strong>解析模块</strong>：当模块被加载时，加载器会解析模块的 <code>import</code> 和 <code>export</code> 语法，确定模块之间的依赖关系。</li><li><strong>加载模块</strong>：根据解析结果，加载器会从指定的路径或 URL 加载模块的代码。</li><li><strong>执行模块</strong>：加载器会执行模块的代码，并处理模块的 <code>export</code> 和 <code>import</code> 语句。</li><li><strong>缓存模块</strong>：已加载的模块会被缓存，以便后续的 <code>import</code> 语句可以复用缓存的模块，避免重复加载。</li><li><strong>导出模块</strong>：模块的功能会通过 <code>export</code> 语法对外提供，其他模块可以通过 <code>import</code> 语法引用这些功能。</li></ol><h2 id="7-模块加载器的特点"><a href="#7-模块加载器的特点" class="headerlink" title="7. 模块加载器的特点"></a>7. <strong>模块加载器的特点</strong></h2><ul><li><strong>静态分析</strong>：ES6 模块的静态结构使得模块系统能够在编译时进行依赖分析和优化。</li><li><strong>作用域隔离</strong>：每个模块都有自己的作用域，避免了全局命名冲突。</li><li><strong>延迟加载</strong>：使用动态导入可以按需加载模块，提高应用程序的性能。</li><li><strong>编译时错误检测</strong>：静态分析可以在编译阶段检测导入和导出语法错误，提升代码质量。</li></ul><h2 id="8-与其他模块系统的比较"><a href="#8-与其他模块系统的比较" class="headerlink" title="8. 与其他模块系统的比较"></a>8. <strong>与其他模块系统的比较</strong></h2><p>与 CommonJS、AMD 和 UMD 等其他模块系统相比，ES6 模块具有以下优势：</p><ul><li><strong>原生支持</strong>：ES6 模块是 JavaScript 的标准部分，所有现代 JavaScript 引擎都支持。</li><li><strong>静态分析</strong>：ES6 模块的静态结构使得编译器和工具能够进行优化。</li><li><strong>模块作用域</strong>：ES6 模块的作用域隔离提供了更好的代码组织和模块管理。</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. <strong>总结</strong></h2><p>ES6 模块系统通过 <code>import</code> 和 <code>export</code> 语法提供了一个标准化的模块化机制，支持静态加载和动态导入。它的引入使得 JavaScript 的模块化编程更加高效和一致，为开发大型应用程序提供了强大的工具。了解 ES6 模块系统的工作原理和使用方法，有助于更好地组织和管理代码，提高代码的可维护性和重用性。</p><hr><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>ES6 的引入使 JavaScript 语言更加完善，提供了更强大的功能和更简洁的语法，极大地提高了开发效率。这些新特性涵盖了变量声明、函数定义、对象和数组操作、类和继承、模块化、异步编程等各个方面。熟练掌握ES6的新特性，将有助于编写出更加高效、可读性更强的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript1-5新特性详解</title>
    <link href="/posts/64231/"/>
    <url>/posts/64231/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-1-到-ECMAScript-5-新特性详解"><a href="#ECMAScript-1-到-ECMAScript-5-新特性详解" class="headerlink" title="ECMAScript 1 到 ECMAScript 5 新特性详解"></a>ECMAScript 1 到 ECMAScript 5 新特性详解</h1><hr><h1 id="ECMAScript-1-ES1-1997"><a href="#ECMAScript-1-ES1-1997" class="headerlink" title="ECMAScript 1 (ES1) - 1997"></a>ECMAScript 1 (ES1) - 1997</h1><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-基本语法和控制结构"><a href="#1-基本语法和控制结构" class="headerlink" title="1. 基本语法和控制结构"></a><strong>1. 基本语法和控制结构</strong></h3><ul><li>ECMAScript 1 引入了变量声明、条件判断、循环等基础控制结构，JavaScript 程序从此可以实现基本的逻辑控制。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// if...else 语句</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成年人&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;未成年人&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  count++;<br>&#125;<br><br><span class="hljs-comment">// for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a><strong>2. 数据类型</strong></h3><p>ES1 定义了基本的数据类型，包括 <code>Number</code>、<code>String</code>、<code>Boolean</code> 和 <code>Object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数据类型</span><br><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>;         <span class="hljs-comment">// Number</span><br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello&quot;</span>;      <span class="hljs-comment">// String</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// Boolean</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;; <span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure><h3 id="3-全局函数"><a href="#3-全局函数" class="headerlink" title="3. 全局函数"></a><strong>3. 全局函数</strong></h3><p>ES1 提供了 <code>parseInt</code> 和 <code>parseFloat</code> 函数，用于将字符串解析为整数和浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;42&quot;</span>));     <span class="hljs-comment">// 42</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.14&quot;</span>)); <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><hr><h1 id="ECMAScript-2-ES2-1998"><a href="#ECMAScript-2-ES2-1998" class="headerlink" title="ECMAScript 2 (ES2) - 1998"></a>ECMAScript 2 (ES2) - 1998</h1><p>ES2 是对 ES1 的规范化和修订版本，没有新特性。主要目的是与 ISO 标准保持一致。</p><hr><h1 id="ECMAScript-3-ES3-1999"><a href="#ECMAScript-3-ES3-1999" class="headerlink" title="ECMAScript 3 (ES3) - 1999"></a>ECMAScript 3 (ES3) - 1999</h1><h2 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-正则表达式（RegExp）"><a href="#1-正则表达式（RegExp）" class="headerlink" title="1. 正则表达式（RegExp）"></a><strong>1. 正则表达式（RegExp）</strong></h3><ul><li><strong>解释</strong>：正则表达式用于字符串模式匹配和替换。</li><li><strong>用法</strong>：<code>/pattern/flags</code> 的形式或通过 <code>RegExp</code> 构造函数创建。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基本用法</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/hello/i</span>;       <span class="hljs-comment">// 不区分大小写匹配 &quot;hello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// RegExp 构造函数</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;HELLO&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 正则表达式匹配</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;The quick brown fox&quot;</span>;<br><span class="hljs-keyword">var</span> result = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b\w&#123;5&#125;\b/g</span>); <span class="hljs-comment">// 匹配所有5个字母的单词</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [&quot;quick&quot;, &quot;brown&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="2-异常处理-try-catch-finally"><a href="#2-异常处理-try-catch-finally" class="headerlink" title="2. 异常处理 (try-catch-finally)"></a><strong>2. 异常处理 (<code>try-catch-finally</code>)</strong></h3><ul><li><strong>解释</strong>：<code>try-catch-finally</code> 结构允许捕获错误并进行相应处理，<code>finally</code> 总是会执行。</li><li><strong>用法</strong>：在 <code>try</code> 块中编写可能引发异常的代码，<code>catch</code> 捕获异常信息，<code>finally</code> 执行必要的清理工作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;&#125;&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Parsing error:&quot;</span>, error.<span class="hljs-property">message</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Finished parsing JSON&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-数组方法"><a href="#3-数组方法" class="headerlink" title="3. 数组方法"></a><strong>3. 数组方法</strong></h3><ul><li><strong>解释</strong>：ES3 引入了 <code>push</code>、<code>pop</code>、<code>shift</code> 和 <code>unshift</code> 等数组操作方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// push 添加元素到数组末尾</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// pop 移除数组最后一个元素</span><br>arr.<span class="hljs-title function_">pop</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// unshift 添加元素到数组开头</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [0, 1, 2, 3]</span><br><br><span class="hljs-comment">// shift 移除数组第一个元素</span><br>arr.<span class="hljs-title function_">shift</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="4-for-in-循环"><a href="#4-for-in-循环" class="headerlink" title="4. for...in 循环"></a><strong>4. <code>for...in</code> 循环</strong></h3><ul><li><strong>解释</strong>：遍历对象的所有可枚举属性。</li><li><strong>用法</strong>：<code>for...in</code> 遍历对象键值对。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-keyword">if</span> (person.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + person[key]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Function-apply-和-Function-call"><a href="#5-Function-apply-和-Function-call" class="headerlink" title="5. Function.apply 和 Function.call"></a><strong>5. <code>Function.apply</code> 和 <code>Function.call</code></strong></h3><ul><li><strong>解释</strong>：<code>apply</code> 和 <code>call</code> 允许将不同的 <code>this</code> 值传递给函数，并立即调用函数。<code>apply</code> 使用数组传递参数，而 <code>call</code> 逐个传递参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + punctuation);<br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><br><span class="hljs-comment">// 使用 call 逐个传递参数</span><br>greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>); <span class="hljs-comment">// &quot;Hello, Alice!&quot;</span><br><br><span class="hljs-comment">// 使用 apply 以数组传递参数</span><br>greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>]); <span class="hljs-comment">// &quot;Hi, Alice?&quot;</span><br></code></pre></td></tr></table></figure><hr><h1 id="ECMAScript-5-ES5-2009"><a href="#ECMAScript-5-ES5-2009" class="headerlink" title="ECMAScript 5 (ES5) - 2009"></a>ECMAScript 5 (ES5) - 2009</h1><h2 id="主要特性-2"><a href="#主要特性-2" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-严格模式（Strict-Mode）"><a href="#1-严格模式（Strict-Mode）" class="headerlink" title="1. 严格模式（Strict Mode）"></a><strong>1. 严格模式（Strict Mode）</strong></h3><ul><li><strong>解释</strong>：严格模式通过 <code>&quot;use strict&quot;;</code> 指令启用，更严格地解析代码，禁止一些不安全的语法。</li><li><strong>用法</strong>：在文件或函数顶部添加 <code>&quot;use strict&quot;;</code>，启用严格模式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>  undeclaredVar = <span class="hljs-number">42</span>; <span class="hljs-comment">// Error: undeclaredVar is not defined</span><br>&#125;<br><span class="hljs-title function_">example</span>();<br></code></pre></td></tr></table></figure><h3 id="2-JSON-支持"><a href="#2-JSON-支持" class="headerlink" title="2. JSON 支持"></a><strong>2. JSON 支持</strong></h3><ul><li><strong>解释</strong>：<code>JSON.parse</code> 和 <code>JSON.stringify</code> 用于处理 JSON 数据格式。</li><li><strong>用法</strong>：<code>JSON.parse</code> 将 JSON 字符串转换为对象；<code>JSON.stringify</code> 将对象转换为 JSON 字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonString = <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonString);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br><br><span class="hljs-keyword">var</span> newJsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newJsonString); <span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-对象增强方法"><a href="#3-对象增强方法" class="headerlink" title="3. 对象增强方法"></a><strong>3. 对象增强方法</strong></h3><ul><li><strong>解释</strong>：<code>Object.create</code>、<code>Object.keys</code> 和 <code>Object.defineProperty</code> 等方法增强了对象操作的灵活性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Object.create</span><br><span class="hljs-keyword">var</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Parent&quot;</span><br><br><span class="hljs-comment">// Object.keys 获取对象的键</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// []</span><br><br><span class="hljs-comment">// Object.defineProperty 定义只读属性</span><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;);<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 无法修改</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br></code></pre></td></tr></table></figure><p><strong><code>Object.keys</code> 只返回对象自身的可枚举属性，而不会包括从原型链上继承的属性。在上述的示例中：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Parent&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><strong><code>child</code> 对象的 <code>name</code> 属性是从 <code>parent</code> 继承而来的，并不是 <code>child</code> 自身的属性，所以 <code>Object.keys(child)</code> 返回空数组。</strong></p><p>如果你想查看 <code>child</code> 包括继承属性在内的所有属性，可以用 <code>for...in</code> 循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> child) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// &quot;name&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何在 <code>child</code> 上定义自身属性</strong></p><p>如果你需要 <code>child</code> 自身拥有一个 <code>name</code> 属性而不是从 <code>parent</code> 继承，可以直接赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Child&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// [&quot;name&quot;]</span><br></code></pre></td></tr></table></figure><p>这样，<code>name</code> 就会作为 <code>child</code> 自身的属性出现。</p><h3 id="4-数组新方法"><a href="#4-数组新方法" class="headerlink" title="4. 数组新方法"></a><strong>4. 数组新方法</strong></h3><h4 id="4-1-Array-isArray"><a href="#4-1-Array-isArray" class="headerlink" title="4.1. Array.isArray()"></a>4.1. <code>Array.isArray()</code></h4><p><code>Array.isArray(value)</code> 用于判断给定的值是否为数组。</p><ul><li><strong>参数</strong>:<ul><li><code>value</code>: 要检查的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果值是数组，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>())); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-2-Array-prototype-forEach"><a href="#4-2-Array-prototype-forEach" class="headerlink" title="4.2. Array.prototype.forEach()"></a>4.2. <code>Array.prototype.forEach()</code></h4><p><code>forEach(callback(currentValue [, index [, array]])[, thisArg])</code> 方法对数组中的每个元素执行一次提供的函数。</p><ul><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><br>    : 要执行的函数，接受以下参数：<br><br>    - `currentValue`: 当前处理的元素。<br>    - `<span class="hljs-keyword">index</span><span class="hljs-symbol">`（可选）: 当前处理元素的索引。</span><br><span class="hljs-symbol">    - `</span><span class="hljs-keyword">array</span><span class="hljs-symbol">`（可选）: 调用 `</span>forEach<span class="hljs-symbol">` 的数组。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  - `</span>thisArg<span class="hljs-symbol">`（可选）: 当执行 `</span>callback<span class="hljs-symbol">` 函数时，用作 `</span>this<span class="hljs-symbol">` 的值。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- **返回值**:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  - 没有返回值（返回 `</span>undefined<span class="hljs-symbol">`）。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">**示例**:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">`</span><span class="hljs-symbol">``</span>javascript<br>const <span class="hljs-keyword">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.forEach((element, <span class="hljs-keyword">index</span>, arr) =&gt; &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-symbol">`Element at index $&#123;index&#125;: $&#123;element&#125;`</span>);<br>&#125;);<br>// Output:<br>// Element at <span class="hljs-keyword">index</span> <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>// <span class="hljs-keyword">Element</span> at <span class="hljs-keyword">index</span> <span class="hljs-number">1</span>: <span class="hljs-number">2</span><br>// <span class="hljs-keyword">Element</span> at <span class="hljs-keyword">index</span> <span class="hljs-number">2</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-3-Array-prototype-map"><a href="#4-3-Array-prototype-map" class="headerlink" title="4.3. Array.prototype.map()"></a>4.3. <code>Array.prototype.map()</code></h4><p><code>map(callback(currentValue [, index [, array]])[, thisArg])</code> 方法返回一个新数组，其结果是通过对原数组的每个元素调用提供的函数得到的。</p><ul><li><p><strong>用于对数组中的每个元素进行转换或操作。</strong></p></li><li><p><strong>返回一个新数组，该数组的每个元素都是对原数组相应元素经过某种处理后的结果。</strong></p></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`currentValue`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`map`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`thisArg`</span>（可选）: 当执行 <span class="hljs-code">`callback`</span> 函数时，用作 <span class="hljs-code">`this`</span> 的值。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回一个新数组。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3];</span><br><span class="hljs-code">const doubled = numbers.map(num =&gt; num * 2);</span><br><span class="hljs-code">console.log(doubled); // [2, 4, 6]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-4-Array-prototype-filter"><a href="#4-4-Array-prototype-filter" class="headerlink" title="4.4. Array.prototype.filter()"></a>4.4. <code>Array.prototype.filter()</code></h4><p><code>filter(callback(element [, index [, array]])[, thisArg])</code> 方法创建一个新数组，包含所有通过测试的元素。</p><ul><li><p><strong>用于从数组中筛选出满足特定条件的元素。</strong></p></li><li><p><strong>返回一个新数组，该数组只包含满足条件的元素。</strong></p></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`element`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`filter`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`thisArg`</span>（可选）: 当执行 <span class="hljs-code">`callback`</span> 函数时，用作 <span class="hljs-code">`this`</span> 的值。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回一个新数组，包含通过测试的所有元素。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3, 4, 5];</span><br><span class="hljs-code">const evenNumbers = numbers.filter(num =&gt; num % 2 === 0);</span><br><span class="hljs-code">console.log(evenNumbers); // [2, 4]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-5-Array-prototype-reduce"><a href="#4-5-Array-prototype-reduce" class="headerlink" title="4.5. Array.prototype.reduce()"></a>4.5. <code>Array.prototype.reduce()</code></h4><p><code>reduce(callback(accumulator, currentValue [, index [, array]])[, initialValue])</code> 方法对数组中的每个元素应用一个函数，将其归纳为单一的值。</p><ul><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`accumulator`</span>: 累加器，累积回调的返回值。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`currentValue`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`reduce`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`initialValue`</span>（可选）: 作为第一次调用 <span class="hljs-code">`callback`</span> 函数时的第一个参数。如果没有提供初始值，则数组的第一个元素将被用作初始值，且不执行回调。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回最终的累加器值。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3, 4];</span><br><span class="hljs-code">const sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);</span><br><span class="hljs-code">console.log(sum); // 10</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>用法</strong></p><h5 id="1-求和"><a href="#1-求和" class="headerlink" title="1. 求和"></a>1. 求和</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 输出: 15</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法将数组中的所有数字相加。<code>initialValue</code> 设置为 <code>0</code>，作为累加器的初始值。</p><h5 id="2-求最大值"><a href="#2-求最大值" class="headerlink" title="2. 求最大值"></a>2. 求最大值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> max = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (currentValue &gt; accumulator) ? currentValue : accumulator;<br>&#125;, numbers[<span class="hljs-number">0</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max); <span class="hljs-comment">// 输出: 5</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法找出数组中的最大值。<code>initialValue</code> 设置为数组的第一个元素。</p><h5 id="3-计数出现次数"><a href="#3-计数出现次数" class="headerlink" title="3. 计数出现次数"></a>3. 计数出现次数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>];<br><span class="hljs-keyword">const</span> count = fruits.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> &#123;<br>  accumulator[currentValue] = (accumulator[currentValue] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;, &#123;&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 输出: &#123; apple: 3, banana: 2, orange: 1 &#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法统计每种水果出现的次数，并将结果存储在一个对象中。</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li><strong>累加器</strong>: 用于求和、计算平均值等。</li><li><strong>汇总数据</strong>: 将数组中的数据汇总为单个对象、字符串或其他数据结构。</li><li><strong>转换数据结构</strong>: 将数组转换为其他数据类型，如对象或另一个数组。</li></ul><h4 id="4-6-Array-prototype-reduceRight"><a href="#4-6-Array-prototype-reduceRight" class="headerlink" title="4.6. Array.prototype.reduceRight()"></a>4.6. <code>Array.prototype.reduceRight()</code></h4><p><code>reduceRight(callback(accumulator, currentValue [, index [, array]])[, initialValue])</code> 方法与 <code>reduce()</code> 类似，<strong>但它从数组的最后一个元素开始向前进行。</strong></p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>reduce</code> 相同。</li><li><code>initialValue</code>（可选）: 同上。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回最终的累加器值。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> concatenated = numbers.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;accumulator&#125;</span>-<span class="hljs-subst">$&#123;currentValue&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(concatenated); <span class="hljs-comment">// &quot;4-3-2-1&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-7-Array-prototype-some"><a href="#4-7-Array-prototype-some" class="headerlink" title="4.7. Array.prototype.some()"></a>4.7. <code>Array.prototype.some()</code></h4><p><code>some(callback(element [, index [, array]])[, thisArg])</code> 方法测试数组中是否至少有一个元素通过了提供的函数测试。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果数组中至少有一个元素通过测试，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> hasEven = numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasEven); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-8-Array-prototype-every"><a href="#4-8-Array-prototype-every" class="headerlink" title="4.8. Array.prototype.every()"></a>4.8. <code>Array.prototype.every()</code></h4><p><code>every(callback(element [, index [, array]])[, thisArg])</code> 方法测试数组中的所有元素是否都通过了提供的函数测试。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果所有元素都通过测试，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">const</span> allEven = numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allEven); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-9-Array-prototype-indexOf"><a href="#4-9-Array-prototype-indexOf" class="headerlink" title="4.9. Array.prototype.indexOf()"></a>4.9. <code>Array.prototype.indexOf()</code></h4><p><code>indexOf(searchElement[, fromIndex])</code> 方法返回数组中首次出现指定值的索引，如果未找到则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为 <code>0</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回指定元素的索引，如果未找到则返回 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h4 id="4-10-Array-prototype-lastIndexOf"><a href="#4-10-Array-prototype-lastIndexOf" class="headerlink" title="4.10. Array.prototype.lastIndexOf()"></a>4.10. <code>Array.prototype.lastIndexOf()</code></h4><p><code>lastIndexOf(searchElement[, fromIndex])</code> 方法返回数组中最后一次出现指定值的索引，如果未找到则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为数组长度减一，即从最后一个元素开始查找。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回指定元素的最后一次出现的索引，如果未找到则返回 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h4 id="4-11-Array-prototype-splice"><a href="#4-11-Array-prototype-splice" class="headerlink" title="4.11. Array.prototype.splice()"></a>4.11. <code>Array.prototype.splice()</code></h4><p><code>splice(start, deleteCount[, item1[, item2[, ...]]])</code> 方法可以添加、删除或替换数组中的元素。它会修改原数组，并返回被删除的元素（如果有）。</p><ul><li><strong>参数</strong>:<ul><li><code>start</code>: 从该索引开始修改数组。</li><li><code>deleteCount</code>: 要删除的元素数量。</li><li><code>item1, item2, ...</code>（可选）: 要添加到数组的新元素。(<strong>需要注意的是插入的位置是在删除的位置</strong>)</li></ul></li><li><strong>返回值</strong>:<ul><li>返回包含已删除元素的数组，如果没有删除元素，则返回空数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> removed = array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [1, 5, 6, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(removed); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="4-12-Array-prototype-slice"><a href="#4-12-Array-prototype-slice" class="headerlink" title="4.12. Array.prototype.slice()"></a>4.12. <code>Array.prototype.slice()</code></h4><p><code>slice(start, end)</code> 方法返回数组的一个浅拷贝（即包含原数组中所选元素的数组）。不修改原数组。</p><ul><li><strong>参数</strong>:<ul><li><code>start</code>: 提取的第一个元素的索引（包含）。</li><li><code>end</code>（可选）: 提取的最后一个元素的索引（不包含），默认为数组长度。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回包含指定元素的新数组。</li></ul></li></ul><p><strong>示例</strong></p><p>下面通过几个示例来说明 <code>slice()</code> 的浅拷贝特性。</p><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 提取索引 1 到 3 的元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>newArray</code> 是从 <code>originalArray</code> 中提取的元素，<code>originalArray</code> 保持不变。</p><h5 id="2-修改新数组中的基本类型"><a href="#2-修改新数组中的基本类型" class="headerlink" title="2. 修改新数组中的基本类型"></a>2. 修改新数组中的基本类型</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>();<br><br>newArray[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改新数组的第一个元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalArray); <span class="hljs-comment">// 输出: [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [10, 2, 3]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>originalArray</code> 的内容没有受到影响，因为这里是基本数据类型（数字），直接的值拷贝。</p><h5 id="3-修改新数组中的对象"><a href="#3-修改新数组中的对象" class="headerlink" title="3. 修改新数组中的对象"></a>3. 修改新数组中的对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>();<br><br>newArray[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改新数组中的对象的属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalArray); <span class="hljs-comment">// 输出: [&#123; value: 10 &#125;, &#123; value: 2 &#125;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [&#123; value: 10 &#125;, &#123; value: 2 &#125;]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>originalArray</code> 的第一个元素的属性 <code>value</code> 被修改了，因为 <code>newArray</code> 和 <code>originalArray</code> 中的元素都是对同一个对象的引用。</p><p><strong>小结</strong></p><ul><li><strong><code>slice()</code> 创建的新数组是对原数组的浅拷贝。</strong></li><li><strong>如果原数组中的元素是基本类型，修改新数组不会影响原数组。</strong></li><li><strong>如果原数组中的元素是对象，修改新数组中的对象会影响到原数组，因为它们引用的是同一个对象。</strong></li></ul><h4 id="4-13-Array-prototype-concat"><a href="#4-13-Array-prototype-concat" class="headerlink" title="4.13. Array.prototype.concat()"></a>4.13. <code>Array.prototype.concat()</code></h4><p><code>concat(value1[, value2[, ...]])</code> 方法用于合并两个或多个数组，并返回一个新数组。</p><ul><li><strong>参数</strong>:<ul><li><code>value1, value2, ...</code>: 要合并的数组或值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回一个新数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> array2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> newArray = array1.<span class="hljs-title function_">concat</span>(array2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h4 id="4-14-Array-prototype-join"><a href="#4-14-Array-prototype-join" class="headerlink" title="4.14. Array.prototype.join()"></a>4.14. <code>Array.prototype.join()</code></h4><p><code>join(separator)</code> 方法将数组的所有元素连接成一个字符串。</p><ul><li><strong>参数</strong>:<ul><li><code>separator</code>（可选）: 用于分隔每个元素的字符串，默认为逗号 <code>,</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回由数组元素连接而成的字符串。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> joined = array.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(joined); <span class="hljs-comment">// &quot;1-2-3&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-15-Array-prototype-reverse"><a href="#4-15-Array-prototype-reverse" class="headerlink" title="4.15. Array.prototype.reverse()"></a>4.15. <code>Array.prototype.reverse()</code></h4><p><code>reverse()</code> 方法反转数组中的元素顺序。</p><ul><li><strong>参数</strong>:<ul><li>无。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回反转后的数组（是原数组的引用）。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">reverse</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><h4 id="4-16-Array-prototype-sort"><a href="#4-16-Array-prototype-sort" class="headerlink" title="4.16. Array.prototype.sort()"></a>4.16. <code>Array.prototype.sort()</code></h4><p><code>sort(compareFunction)</code> 方法是用于对数组中的元素进行排序的一个内置方法。它会改变原数组并返回引用相同的数组。默认情况下，<code>sort()</code> 方法将元素按字符串Unicode编码进行排序。要进行数值排序或自定义排序，可以提供一个比较函数。</p><ul><li><strong>参数</strong>:<ul><li><code>compareFunction</code>（可选）: 一个用于比较两个元素的函数。如果提供该函数，数组会根据其返回值进行排序。<ul><li>如果返回值小于 0，则 <code>a</code> 在 <code>b</code> 之前。</li><li>如果返回值大于 0，则 <code>a</code> 在 <code>b</code> 之后。</li><li>如果返回值等于 0，则 <code>a</code> 和 <code>b</code> 的相对位置保持不变。</li></ul></li></ul></li><li><strong>返回值</strong>:<ul><li>返回已排序的数组（是原数组的引用）。</li></ul></li></ul><h5 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1.默认行为"></a>1.默认行为</h5><p>当没有提供 <code>compareFunction</code> 时，<code>sort()</code> 方法将元素转换为字符串，然后按字符顺序进行排序。例如，数字会被转为字符串并按字典序排列。</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br>fruits.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span><br></code></pre></td></tr></table></figure><h5 id="2-数字排序的例子"><a href="#2-数字排序的例子" class="headerlink" title="2.数字排序的例子"></a>2.数字排序的例子</h5><p>由于默认的排序是按照字符串顺序进行的，对于数字排序可能会导致意想不到的结果。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>];<br>numbers.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [1, 10, 2, 21]</span><br></code></pre></td></tr></table></figure><p>为了进行数值排序，我们需要提供一个比较函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>];<br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 从小到大排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [1, 2, 10, 21]</span><br><br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a); <span class="hljs-comment">// 从大到小排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [21, 10, 2, 1]</span><br></code></pre></td></tr></table></figure><h5 id="3-自定义排序"><a href="#3-自定义排序" class="headerlink" title="3.自定义排序"></a>3.自定义排序</h5><p>我们可以根据需要自定义比较函数，以实现不同的排序规则。例如，我们可以根据对象的属性进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> items = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Banana&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">5</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Cherry&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">15</span> &#125;<br>];<br><br><span class="hljs-comment">// 按价格从小到大排序</span><br>items.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">price</span> - b.<span class="hljs-property">price</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items);<br><span class="hljs-comment">// 输出: [&#123; name: &#x27;Banana&#x27;, price: 5 &#125;, &#123; name: &#x27;Apple&#x27;, price: 10 &#125;, &#123; name: &#x27;Cherry&#x27;, price: 15 &#125;]</span><br></code></pre></td></tr></table></figure><h5 id="4-排序的稳定性"><a href="#4-排序的稳定性" class="headerlink" title="4.排序的稳定性"></a>4.排序的稳定性</h5><p><strong>在 ECMAScript 2019（ES10）之前，<code>sort()</code> 方法的排序算法是不稳定的。这意味着如果两个元素相等，它们的相对顺序可能会被改变。从 ECMAScript 2019 开始，排序的稳定性得到了保证，但具体实现仍然依赖于 JavaScript 引擎。</strong></p><h5 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h5><ol><li><strong>原地排序</strong>: <code>sort()</code> 方法会改变原数组，而不是创建一个新数组。</li><li><strong>返回值</strong>: <code>sort()</code> 方法返回对原数组的引用。</li><li><strong>空数组</strong>: 对于空数组，<code>sort()</code> 方法不会有任何效果。</li></ol><h5 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h5><ul><li><code>Array.prototype.sort()</code> 是一个强大而灵活的方法，适用于多种排序需求。</li><li>使用自定义比较函数可以轻松实现数字、字符串和对象的排序。</li><li>理解默认排序行为非常重要，以避免在处理数字时产生意外结果。</li></ul><h4 id="4-17-Array-prototype-fill"><a href="#4-17-Array-prototype-fill" class="headerlink" title="4.17. Array.prototype.fill()"></a>4.17. <code>Array.prototype.fill()</code></h4><p><code>fill(value[, start[, end]])</code> 方法用指定的值填充数组的所有元素。</p><ul><li><strong>参数</strong>:<ul><li><code>value</code>: 用于填充数组的值。</li><li><code>start</code>（可选）: 开始填充的索引，默认为 <code>0</code>。</li><li><code>end</code>（可选）: 停止填充的索引，默认为数组长度。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回填充后的数组（是原数组的引用）。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [1, 0, 0]</span><br></code></pre></td></tr></table></figure><h4 id="4-18-Array-prototype-includes"><a href="#4-18-Array-prototype-includes" class="headerlink" title="4.18. Array.prototype.includes()"></a>4.18. <code>Array.prototype.includes()</code></h4><p><code>includes(searchElement[, fromIndex])</code> 方法确定数组是否包含指定值，返回 <code>true</code> 或 <code>false</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为 <code>0</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果数组中包含指定值，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="4-19-Array-prototype-flat"><a href="#4-19-Array-prototype-flat" class="headerlink" title="4.19. Array.prototype.flat()"></a>4.19. <code>Array.prototype.flat()</code></h4><p><code>flat(depth)</code> 方法用于将嵌套的数组展平。</p><ul><li><strong>参数</strong>:<ul><li><code>depth</code>（可选）: 要展平的层数，默认为 <code>1</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回展平后的新数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]];<br><span class="hljs-keyword">const</span> flattened = array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flattened); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="4-20-Array-prototype-flatMap"><a href="#4-20-Array-prototype-flatMap" class="headerlink" title="4.20. Array.prototype.flatMap()"></a>4.20. <code>Array.prototype.flatMap()</code></h4><p><code>flatMap(callback(currentValue[, index[, array]])[, thisArg])</code> 方法先对每个元素应用映射函数，然后再将结果压平。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>map</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回新的数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> flatMapped = array.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> [num, num * <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flatMapped); <span class="hljs-comment">// [1, 2, 2, 4, 3, 6]</span><br></code></pre></td></tr></table></figure><h4 id="4-21-Array-prototype-find"><a href="#4-21-Array-prototype-find" class="headerlink" title="4.21. Array.prototype.find()"></a>4.21. <code>Array.prototype.find()</code></h4><p><code>find(callback(element[, index[, array]])[, thisArg])</code> 方法返回数组中满足提供测试函数的第一个元素的值，否则返回 <code>undefined</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回满足条件的第一个元素，或 <code>undefined</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> found = array.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(found); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="4-22-Array-prototype-findIndex"><a href="#4-22-Array-prototype-findIndex" class="headerlink" title="4.22. Array.prototype.findIndex()"></a>4.22. <code>Array.prototype.findIndex()</code></h4><p><code>findIndex(callback(element[, index[, array]])[, thisArg])</code> 方法返回数组中满足提供测试函数的第一个元素的索引，否则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回满足条件的第一个元素的索引，或 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> index = array.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript新特性总览</title>
    <link href="/posts/65387/"/>
    <url>/posts/65387/</url>
    
    <content type="html"><![CDATA[<h3 id="1-ECMAScript-1-ES1-1997"><a href="#1-ECMAScript-1-ES1-1997" class="headerlink" title="1. ECMAScript 1 (ES1) - 1997"></a>1. ECMAScript 1 (ES1) - 1997</h3><ul><li><strong>首个版本</strong>：定义了基本的 JavaScript 语法和功能，奠定了 JavaScript 标准的基础。</li></ul><h3 id="2-ECMAScript-2-ES2-1998"><a href="#2-ECMAScript-2-ES2-1998" class="headerlink" title="2. ECMAScript 2 (ES2) - 1998"></a>2. ECMAScript 2 (ES2) - 1998</h3><ul><li><strong>小幅更新</strong>：对 ES1 进行了一些格式化的调整，以匹配 ISO&#x2F;IEC 16262 国际标准，基本没有新功能。</li></ul><h3 id="3-ECMAScript-3-ES3-1999"><a href="#3-ECMAScript-3-ES3-1999" class="headerlink" title="3. ECMAScript 3 (ES3) - 1999"></a>3. ECMAScript 3 (ES3) - 1999</h3><ul><li><strong>扩展语言特性</strong>：添加了许多新功能，包括正则表达式支持、更好的错误处理机制、<code>try/catch</code> 异常处理、<code>Array</code> 和 <code>String</code> 方法（如 <code>map</code>、<code>filter</code> 和 <code>split</code>）。</li><li><strong>标志性的语言特性</strong>：如 <code>Object</code>、<code>Array</code> 等的标准化。</li></ul><h3 id="4-ECMAScript-4-ES4-未发布"><a href="#4-ECMAScript-4-ES4-未发布" class="headerlink" title="4. ECMAScript 4 (ES4) - 未发布"></a>4. ECMAScript 4 (ES4) - <strong>未发布</strong></h3><ul><li><strong>开发中止</strong>：ES4 原计划加入大量新特性，例如模块、类、接口和类型检查。但由于复杂度和各方意见不一致，最终未发布。</li></ul><h3 id="5-ECMAScript-5-ES5-2009"><a href="#5-ECMAScript-5-ES5-2009" class="headerlink" title="5. ECMAScript 5 (ES5) - 2009"></a>5. ECMAScript 5 (ES5) - 2009</h3><ul><li><p>关键性更新</p><ul><li><strong>严格模式</strong>：通过 <code>&quot;use strict&quot;</code> 引入严格模式，以增强代码的安全性和性能。</li><li><strong>原生 JSON 支持</strong>：加入 <code>JSON.parse</code> 和 <code>JSON.stringify</code>。</li><li><strong>增强对象和数组方法</strong>：如 <code>Object.create</code>、<code>Object.keys</code>、<code>Array.isArray</code>、<code>forEach</code>、<code>map</code>、<code>filter</code>、<code>reduce</code>。</li><li><strong>属性描述符</strong>：允许通过 <code>Object.defineProperty</code> 来控制对象属性的可写性、可枚举性等。</li><li><strong>增强数组的处理能力</strong>：扩展了数组的高阶函数。</li></ul></li></ul><h3 id="6-ECMAScript-6-ES6-ES2015-2015"><a href="#6-ECMAScript-6-ES6-ES2015-2015" class="headerlink" title="6. ECMAScript 6 (ES6&#x2F;ES2015) - 2015"></a>6. ECMAScript 6 (ES6&#x2F;ES2015) - 2015</h3><ul><li><p>重大更新</p><p>：引入了现代 JavaScript 的大部分关键特性。</p><ul><li>**<code>let</code> 和 <code>const</code>**：块级作用域变量声明。</li><li><strong>箭头函数</strong>：简化函数表达式的写法，同时绑定 <code>this</code>。</li><li><strong>模板字符串</strong>：通过反引号 &#96;&#96;&#96; 来进行多行字符串和嵌入变量。</li><li><strong>解构赋值</strong>：支持对象和数组的解构赋值。</li><li><strong>默认参数</strong>：为函数参数设置默认值。</li><li><strong>展开运算符（Spread Operator）</strong>：简化数组和对象的合并。</li><li><strong>Promise</strong>：处理异步操作的新方法。</li><li><strong>模块化</strong>：引入 <code>import</code> 和 <code>export</code>，标准化模块管理。</li><li><strong>类（Class）</strong>：支持基于原型的类语法。</li><li><strong>Symbol</strong>：新的原始数据类型，用于创建唯一的标识符。</li></ul></li></ul><h3 id="7-ECMAScript-2016-ES7-2016"><a href="#7-ECMAScript-2016-ES7-2016" class="headerlink" title="7. ECMAScript 2016 (ES7) - 2016"></a>7. ECMAScript 2016 (ES7) - 2016</h3><ul><li><p>少量新特性</p><ul><li><strong>指数运算符</strong>：使用 <code>**</code> 来代替 <code>Math.pow</code>。</li></ul></li><li><p><strong>Array.prototype.includes</strong>：检查数组是否包含某个元素，比 <code>indexOf</code> 更加直观。</p></li></ul><h3 id="8-ECMAScript-2017-ES8-2017"><a href="#8-ECMAScript-2017-ES8-2017" class="headerlink" title="8. ECMAScript 2017 (ES8) - 2017"></a>8. ECMAScript 2017 (ES8) - 2017</h3><ul><li><strong>异步函数</strong>：支持 <code>async/await</code>，使异步代码更接近同步写法。</li><li><strong>Object.entries 和 Object.values</strong>：提取对象的键值对和所有值。</li><li><strong>字符串填充方法</strong>：<code>padStart</code> 和 <code>padEnd</code>。</li><li><strong>共享内存和原子操作</strong>：增加 <code>SharedArrayBuffer</code> 和 <code>Atomics</code> 对象，允许更高效的并行编程。</li></ul><h3 id="9-ECMAScript-2018-ES9-2018"><a href="#9-ECMAScript-2018-ES9-2018" class="headerlink" title="9. ECMAScript 2018 (ES9) - 2018"></a>9. ECMAScript 2018 (ES9) - 2018</h3><ul><li><strong>Rest&#x2F;Spread 运算符扩展</strong>：支持在对象中的展开和剩余参数语法。</li><li><strong>异步迭代器</strong>：引入 <code>for await...of</code> 循环。</li><li><strong>Promise.finally</strong>：在 <code>Promise</code> 完成后执行指定代码。</li><li><strong>正则表达式增强</strong>：添加了命名捕获组、后行断言（lookbehind）、dotAll 模式等。</li></ul><h3 id="10-ECMAScript-2019-ES10-2019"><a href="#10-ECMAScript-2019-ES10-2019" class="headerlink" title="10. ECMAScript 2019 (ES10) - 2019"></a>10. ECMAScript 2019 (ES10) - 2019</h3><ul><li><strong>Array.prototype.flat 和 flatMap</strong>：将多维数组展平。</li><li><strong>Object.fromEntries</strong>：将键值对列表转换为对象。</li><li><strong>字符串修剪方法</strong>：<code>trimStart</code> 和 <code>trimEnd</code>。</li><li><strong>可选捕获绑定</strong>：<code>try/catch</code> 中可以省略 <code>catch</code> 的参数。</li><li><strong>Function.prototype.toString 修复</strong>：输出函数代码的完整实现。</li></ul><h3 id="11-ECMAScript-2020-ES11-2020"><a href="#11-ECMAScript-2020-ES11-2020" class="headerlink" title="11. ECMAScript 2020 (ES11) - 2020"></a>11. ECMAScript 2020 (ES11) - 2020</h3><ul><li><strong>可选链（Optional Chaining）</strong>：使用 <code>?.</code> 避免访问空值对象属性时报错。</li><li><strong>空值合并运算符（Nullish Coalescing）</strong>：<code>??</code> 在 <code>null</code> 或 <code>undefined</code> 时返回默认值。</li><li>**动态 <code>import()</code>**：允许动态加载模块，返回 Promise。</li><li><strong>BigInt 类型</strong>：处理超过 <code>Number</code> 的安全范围的大整数。</li><li><strong>Promise.allSettled</strong>：等待所有 <code>Promise</code> 完成，无论成功还是失败。</li></ul><h3 id="12-ECMAScript-2021-ES12-2021"><a href="#12-ECMAScript-2021-ES12-2021" class="headerlink" title="12. ECMAScript 2021 (ES12) - 2021"></a>12. ECMAScript 2021 (ES12) - 2021</h3><ul><li><strong>逻辑赋值运算符</strong>：<code>&amp;&amp;=</code>, <code>||=</code>, <code>??=</code> 等赋值简写形式。</li><li>**<code>String.prototype.replaceAll</code>**：允许替换所有匹配项。</li><li><strong>WeakRefs 和 FinalizationRegistry</strong>：对垃圾回收的支持，允许在对象被清理前执行回调。</li><li><strong>Promise.any</strong>：只要有一个 <code>Promise</code> 成功则返回。</li></ul><h3 id="13-ECMAScript-2022-ES13-2022"><a href="#13-ECMAScript-2022-ES13-2022" class="headerlink" title="13. ECMAScript 2022 (ES13) - 2022"></a>13. ECMAScript 2022 (ES13) - 2022</h3><ul><li><strong><code>at()</code> 方法</strong>：<code>Array</code> 和 <code>String</code> 的 <code>.at()</code> 方法支持负索引访问。</li><li>**<code>Object.hasOwn()</code>**：比 <code>Object.prototype.hasOwnProperty</code> 更简洁的对象属性判断。</li><li><strong>类字段与私有属性</strong>：类内直接定义字段，私有属性以 <code>#</code> 开头。</li><li><strong>正则表达式匹配索引</strong>：<code>matchAll</code> 中捕获匹配的起始和结束索引。</li></ul><h3 id="14-ECMAScript-2023-ES14-2023"><a href="#14-ECMAScript-2023-ES14-2023" class="headerlink" title="14. ECMAScript 2023 (ES14) - 2023"></a>14. ECMAScript 2023 (ES14) - 2023</h3><ul><li>**Array.prototype.toSorted()**：不修改原数组的情况下排序。</li><li>**Array.prototype.toReversed() 和 toSpliced()**：不修改原数组，返回翻转或删除后的副本。</li><li><strong>Symbol.symbols</strong>：一种新的内置 <code>Symbol</code>，允许标记不可修改的字段。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventEmitter</title>
    <link href="/posts/36600/"/>
    <url>/posts/36600/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">2</span> 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br><span class="hljs-number">1</span> 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-property">js</span>:<span class="hljs-number">201</span> <br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// process.nextTick error, or &#x27;error&#x27; event on first tick </span><br>^ <br><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Uncaught</span>, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">emit</span> (events.<span class="hljs-property">js</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span>) <br>at <span class="hljs-title class_">Object</span>.&lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>byvoid/error.<span class="hljs-property">js</span>:<span class="hljs-number">5</span>:<span class="hljs-number">9</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">_compile</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">441</span>:<span class="hljs-number">26</span>) <br>at <span class="hljs-title class_">Object</span>..<span class="hljs-property">js</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">459</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">348</span>:<span class="hljs-number">31</span>) <br>at <span class="hljs-title class_">Function</span>.<span class="hljs-property">_load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">308</span>:<span class="hljs-number">12</span>) <br>at <span class="hljs-title class_">Array</span><span class="hljs-number">.0</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">479</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">_tickCallback</span> (node.<span class="hljs-property">js</span>:<span class="hljs-number">192</span>:<span class="hljs-number">40</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Node.js的线程机制</title>
    <link href="/posts/22142/"/>
    <url>/posts/22142/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Node-js的线程机制、事件循环与高并发处理"><a href="#深入理解Node-js的线程机制、事件循环与高并发处理" class="headerlink" title="深入理解Node.js的线程机制、事件循环与高并发处理"></a>深入理解Node.js的线程机制、事件循环与高并发处理</h1><p>Node.js因其强大的高并发处理能力而备受青睐。这一能力得益于其事件驱动的非阻塞I&#x2F;O模型和高效的事件循环机制。在这篇博客中，我们将深入探讨Node.js的线程机制、事件循环的工作流程与优先级，以及如何避免阻塞主线程的最佳实践。通过这些内容，你将更好地理解Node.js的内部运行机制，并学会如何编写高效的Node.js应用程序。</p><hr><h2 id="1-Node-js-的线程机制"><a href="#1-Node-js-的线程机制" class="headerlink" title="1. Node.js 的线程机制"></a>1. Node.js 的线程机制</h2><p>Node.js 是单线程的，但它通过多线程的方式处理高并发。JavaScript代码运行在主线程中，而Node.js使用的<a href="https://libuv.org/">libuv</a>库则提供了一个基于事件循环的异步I&#x2F;O模型，使得主线程不会因为I&#x2F;O操作而被阻塞。</p><h3 id="主线程与-libuv-线程池"><a href="#主线程与-libuv-线程池" class="headerlink" title="主线程与 libuv 线程池"></a><strong>主线程与 <a href="https://libuv.org/">libuv</a> 线程池</strong></h3><ul><li><strong>主线程</strong>：Node.js中的JavaScript代码在一个单独的主线程中运行，该线程处理所有的同步代码。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：用于处理阻塞性任务，如文件I&#x2F;O、DNS查询等，工作线程池通常包含4个线程，可以根据需要配置更多。</li></ul><p>Node.js通过将耗时的I&#x2F;O操作交给<a href="https://libuv.org/">libuv</a>线程池中的工作线程来处理，从而避免主线程被阻塞。这种设计使得Node.js可以在单线程的主线程中处理大量并发请求，而不会因为阻塞I&#x2F;O操作而降低性能。</p><h3 id="重点知识："><a href="#重点知识：" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>主线程</strong>：负责执行所有同步任务。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：处理阻塞I&#x2F;O任务，防止主线程阻塞。</li></ul><hr><h2 id="2-Node-js-的高并发原理"><a href="#2-Node-js-的高并发原理" class="headerlink" title="2. Node.js 的高并发原理"></a>2. Node.js 的高并发原理</h2><p>Node.js的高并发处理能力主要源于其事件驱动的非阻塞I&#x2F;O模型。通过事件循环，Node.js可以在单线程环境中处理大量的并发请求。</p><h3 id="事件驱动的非阻塞I-O模型"><a href="#事件驱动的非阻塞I-O模型" class="headerlink" title="事件驱动的非阻塞I&#x2F;O模型"></a><strong>事件驱动的非阻塞I&#x2F;O模型</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：Node.js 的I&#x2F;O操作不会阻塞主线程，而是将I&#x2F;O操作委托给<a href="https://libuv.org/">libuv</a>线程池处理，主线程在I&#x2F;O操作完成之前可以继续执行其他任务。</li><li><strong>异步任务队列</strong>：异步操作的回调函数会被放入任务队列中，等待主线程空闲时由事件循环调度执行。</li></ul><p>通过这种非阻塞设计，Node.js能够高效地处理并发请求。</p><h5 id="代码示例：异步I-O操作"><a href="#代码示例：异步I-O操作" class="headerlink" title="代码示例：异步I&#x2F;O操作"></a><strong>代码示例：异步I&#x2F;O操作</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File content:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This log comes first!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>fs.readFile</code> 是一个异步操作，它会将回调函数放入任务队列中，而不会阻塞主线程。因此，<code>console.log(&#39;This log comes first!&#39;)</code> 会先于文件内容的输出执行。</p><h3 id="重点知识：-1"><a href="#重点知识：-1" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：避免主线程因I&#x2F;O操作而阻塞。</li><li><strong>异步任务队列</strong>：存储需要执行的异步操作回调。</li></ul><hr><h2 id="3-事件循环的工作机制与优先级"><a href="#3-事件循环的工作机制与优先级" class="headerlink" title="3. 事件循环的工作机制与优先级"></a>3. 事件循环的工作机制与优先级</h2><p>事件循环是Node.js运行的核心机制，它决定了程序中代码的执行顺序。我们将详细剖析事件循环的工作流程及其优先级，帮助你更好地理解Node.js的并发处理。</p><h3 id="事件循环的工作流程"><a href="#事件循环的工作流程" class="headerlink" title="事件循环的工作流程"></a><strong>事件循环的工作流程</strong></h3><ol><li><strong>执行同步代码</strong>：事件循环首先执行主线程中的同步代码，这些代码会被立即执行。</li><li><strong>进入事件循环</strong>：当同步代码执行完毕后，事件循环开始检查任务队列中是否有待处理的异步回调。</li><li><strong>处理异步回调</strong>：事件循环依次从任务队列中取出回调函数并执行。</li><li><strong>循环往复</strong>：事件循环不断检查并处理任务队列中的任务，直到队列为空。</li></ol><h3 id="事件循环的优先级"><a href="#事件循环的优先级" class="headerlink" title="事件循环的优先级"></a><strong>事件循环的优先级</strong></h3><p>事件循环在执行任务时遵循一定的优先级。常见的优先级顺序如下：</p><ul><li><strong>Microtasks（微任务）</strong>：包括 <code>process.nextTick</code> 和 <code>Promise</code> 的回调。这些任务优先级最高，通常会在当前操作结束后立即执行。</li><li><strong>Timers（计时器）</strong>：如 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>I&#x2F;O callbacks</strong>：处理来自I&#x2F;O操作的回调。</li><li><strong>Check</strong>：执行 <code>setImmediate</code> 的回调函数。</li><li><strong>Close callbacks</strong>：处理 <code>close</code> 事件的回调。</li></ul><h5 id="代码示例：事件循环的优先级"><a href="#代码示例：事件循环的优先级" class="headerlink" title="代码示例：事件循环的优先级"></a><strong>代码示例：事件循环的优先级</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Sync</span> code<br>nextTick<br><span class="hljs-title class_">Promise</span><br><span class="hljs-built_in">setTimeout</span><br>setImmediate<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;Sync code&#39;)</code> 立即执行，<code>process.nextTick</code> 和 <code>Promise</code> 回调作为微任务执行，其次是 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调。</p><h3 id="重点知识：-2"><a href="#重点知识：-2" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>事件循环阶段</strong>：不同类型的任务在事件循环中具有不同的优先级。</li><li><strong>Microtasks</strong>：优先级最高的任务，通常在当前事件循环阶段结束后立即执行。</li></ul><hr><h2 id="4-为什么先执行同步代码，再执行事件循环？"><a href="#4-为什么先执行同步代码，再执行事件循环？" class="headerlink" title="4. 为什么先执行同步代码，再执行事件循环？"></a>4. 为什么先执行同步代码，再执行事件循环？</h2><p>Node.js在执行代码时，首先会运行同步代码，这是因为同步代码通常包含程序的初始化、配置、变量定义等重要操作。如果不先执行同步代码，异步回调可能会在未准备好的上下文中被触发，导致程序行为不可预测。</p><h3 id="同步代码的定义"><a href="#同步代码的定义" class="headerlink" title="同步代码的定义"></a><strong>同步代码的定义</strong></h3><p>同步代码是指立即执行并返回结果的代码，不依赖于异步事件的完成。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is synchronous code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>同步代码执行完后，事件循环才会开始处理异步任务。</p><h5 id="代码示例：同步代码与异步代码"><a href="#代码示例：同步代码与异步代码" class="headerlink" title="代码示例：同步代码与异步代码"></a><strong>代码示例：同步代码与异步代码</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is asynchronous&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在此例中，<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 是同步代码，它们会立即执行，而 <code>setTimeout</code> 的回调则是异步代码，会在同步代码执行完毕后，由事件循环调度执行。</p><h3 id="避免将复杂任务放入主线程"><a href="#避免将复杂任务放入主线程" class="headerlink" title="避免将复杂任务放入主线程"></a><strong>避免将复杂任务放入主线程</strong></h3><p>在主线程中放入复杂的同步任务，会阻塞主线程，导致事件循环无法及时处理异步任务。为了解决这个问题，我们可以使用以下几种方法：</p><ol><li><strong>将任务拆分</strong>：将复杂的同步任务拆分为多个小任务，分批执行。</li><li>**使用 <code>setImmediate</code>**：将长时间执行的任务放入下一个事件循环阶段执行。</li><li>**使用 <code>Worker Threads</code>**：将复杂计算任务放入工作线程中执行，避免阻塞主线程。</li></ol><h5 id="代码示例：使用-setImmediate-避免阻塞"><a href="#代码示例：使用-setImmediate-避免阻塞" class="headerlink" title="代码示例：使用 setImmediate 避免阻塞"></a><strong>代码示例：使用 <code>setImmediate</code> 避免阻塞</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">complexTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task Done:&#x27;</span>, count);<br>&#125;<br><br><span class="hljs-title function_">setImmediate</span>(complexTask);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will log before complexTask finishes&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>complexTask</code> 是一个可能会阻塞主线程的复杂任务。通过使用 <code>setImmediate</code>，我们可以将其延迟到当前事件循环阶段结束后再执行，从而避免阻塞其他重要的任务。</p><h5 id="使用-Worker-Threads-进行并行计算"><a href="#使用-Worker-Threads-进行并行计算" class="headerlink" title="使用 Worker Threads 进行并行计算"></a><strong>使用 <code>Worker Threads</code> 进行并行计算</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from worker:&#x27;</span>, message));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  parentPort.<span class="hljs-title function_">postMessage</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，复杂的计算任务被移至工作线程中执行，不再阻塞主线程。这使得主线程可以继续处理其他任务，而不会受到复杂计算的影响。</p><h3 id="重点知识：-3"><a href="#重点知识：-3" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>避免主线程阻塞</strong>：将复杂任务分拆或延迟执行，避免阻塞事件循环。</li><li><strong>Worker Threads</strong>：用于处理计算密集型任务，减少主线程压力。</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对Node.js线程机制、事件循环与高并发处理的深入探讨，我们了解到如何编写高效的Node.js应用程序。理解事件循环的工作原理和优先级，可以帮助我们更好地管理异步任务的执行顺序，避免主线程被阻塞。同时，采用合理的技术，如 <code>Worker Threads</code> 和 <code>setImmediate</code>，能够有效地提升程序性能，确保高并发环境下的稳定性。</p><hr><p>这篇博客详细解释了Node.js的线程机制及事件循环，并提供了避免主线程阻塞的实际解决方案。希望这些内容对你理解和优化Node.js应用程序有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的回收机制</title>
    <link href="/posts/580/"/>
    <url>/posts/580/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-的垃圾回收机制"><a href="#一、JavaScript-的垃圾回收机制" class="headerlink" title="一、JavaScript 的垃圾回收机制"></a>一、JavaScript 的垃圾回收机制</h1><p>JavaScript 的垃圾回收机制主要依赖于一种称为 <strong>“标记-清除”（Mark-and-Sweep）</strong> 的算法。垃圾回收（Garbage Collection, GC）负责自动管理内存，回收不再使用的对象所占用的内存，以防止内存泄漏。</p><h3 id="垃圾回收的工作原理"><a href="#垃圾回收的工作原理" class="headerlink" title="垃圾回收的工作原理"></a>垃圾回收的工作原理</h3><ol><li><strong>标记阶段（Marking Phase）</strong>:<ul><li>垃圾回收器会在内存中“标记”所有活动的、可到达的对象。所谓“可到达”是指对象可以通过根（通常是全局变量或当前作用域中的变量）直接或间接访问到。</li><li>垃圾回收器从根开始，递归地遍历所有引用的对象，并标记这些对象为“活动的”。</li></ul></li><li><strong>清除阶段（Sweeping Phase）</strong>:<ul><li>在标记阶段结束后，垃圾回收器会遍历内存中的所有对象，清除没有被标记的对象（即那些不可到达的对象）。</li><li>清除后，这些对象所占用的内存将被回收并重新分配。</li></ul></li></ol><h3 id="触发垃圾回收的条件"><a href="#触发垃圾回收的条件" class="headerlink" title="触发垃圾回收的条件"></a>触发垃圾回收的条件</h3><ul><li>JavaScript 引擎的垃圾回收器在运行时会周期性地执行垃圾回收，以回收不再使用的内存。</li><li>垃圾回收器的执行是非确定性的，这意味着你不能确切知道何时会触发垃圾回收。通常是在内存分配请求达到一定阈值或空闲时执行。</li></ul><h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><ol><li><p><strong>内存泄漏</strong>: 当程序中不再需要的对象无法被垃圾回收器清除时，内存泄漏就会发生，导致内存使用量持续增长。</p><ul><li><p><strong>未解除的事件监听器</strong>: 如果在不再需要时没有手动移除事件监听器，监听器中对对象的引用将导致这些对象无法被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachEventListener</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element clicked!&#x27;</span>);<br>    &#125;<br><br>    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br><br>    <span class="hljs-comment">// 模拟在元素销毁时忘记移除监听器</span><br>    <span class="hljs-comment">// element.removeEventListener(&#x27;click&#x27;, handleClick);</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数后，element和handleClick函数依然存在引用，导致element不能被回收。</span><br><span class="hljs-title function_">attachEventListener</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p><strong>事件监听器的引用</strong>：</p><ul><li>当你调用 <code>element.addEventListener(&#39;click&#39;, handleClick)</code> 时，浏览器内部实际上在 <code>element</code> 对象的某个地方（通常是在它的事件监听器列表中）保存了对 <code>handleClick</code> 函数的引用。这意味着 <code>element</code> 本身还存活在内存中，因为它的事件监听器依然在引用它。</li></ul><p><strong>引用链的存在</strong>：</p><ul><li>尽管 <code>element</code> 是一个局部变量，函数 <code>attachEventListener</code> 执行完后不会直接持有对它的引用，但是因为事件监听器 (<code>handleClick</code>) 被添加到了 <code>element</code> 上，<code>element</code> 对象内部保存了对 <code>handleClick</code> 的引用。</li><li>反过来，因为 <code>handleClick</code> 函数是在 <code>attachEventListener</code> 内部定义的，它对定义该函数的外部作用域有引用链，因此，这种引用链会一直存在，直到 <code>element</code> 被手动移除事件监听器或者 <code>element</code> 本身被彻底销毁。</li></ul><p><strong>内存泄漏的来源</strong>：</p><ul><li>如果 <code>element</code> 被从 DOM 中移除（比如被 <code>document.removeChild</code>），但没有调用 <code>element.removeEventListener(&#39;click&#39;, handleClick)</code>，<code>element</code> 仍然不能被垃圾回收，因为它的事件监听器中仍然持有对 <code>handleClick</code> 的引用。</li><li>因为 <code>handleClick</code> 还在 <code>element</code> 的事件监听列表中，JavaScript 引擎会认为 <code>element</code> 还可能被使用，因此不会回收 <code>element</code> 或其关联的内存。</li></ul><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​在不再需要时调用 <code>removeEventListener</code> 来移除事件监听器。</p></li><li><p><strong>闭包导致的引用</strong>: 闭包中保存的变量会保持对外部作用域中对象的引用，可能导致无法回收这些对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 返回的 innerFunction 持有对 largeObject 的引用，即使 largeObject 在函数作用域外部已经不需要。</span><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// closure 的引用存在，导致 largeObject 无法被垃圾回收。</span><br><span class="hljs-title function_">closure</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h6><p>在 JavaScript 中，闭包中的引用指向其创建时的环境（即作用域链上的上级）。具体来说：</p><ul><li>当 <code>createClosure</code> 函数执行时，它创建了一个作用域，该作用域中包含 <code>largeObject</code>。</li><li><code>innerFunction</code> 被返回，并且它在其创建时保留了对 <code>largeObject</code> 的引用。</li><li><code>largeObject</code> 的引用存在于 <code>innerFunction</code> 的闭包环境中。</li></ul><p>因此，<code>innerFunction</code> 的作用域链包括 <code>largeObject</code> 所在的作用域。即使 <code>createClosure</code> 执行完毕并退出，<code>innerFunction</code> 仍然能访问 <code>largeObject</code>。</p><p><span style="color: red;"><em><strong>总的来说，如果closure没被销毁那么闭包中的数据会一直存在，所以尽量避免闭包被全局变量所持有，且尽量避免闭包引用大的数据结构，这样会比较消耗内存</strong></em></span></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​要释放 <code>largeObject</code> 的引用，可以在不再需要 <code>innerFunction</code> 时清除对 <code>largeObject</code> 的引用。在这种情况下，确保在 <code>innerFunction</code> 不再使用 <code>largeObject</code> 后，手动清理引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在此处进行逻辑处理</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// 使用完闭包后，手动设置 largeObject 为 null</span><br><span class="hljs-comment">// 这是实际清理引用的地方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 可以设置 closure 为 null 或 undefined</span><br>    closure = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用 releaseClosure 释放对 largeObject 的引用</span><br><span class="hljs-title function_">releaseClosure</span>();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>: 全局变量在整个程序生命周期中都存在，会阻止其被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVariable = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;I&#x27;m a global variable&quot;</span> &#125;;<br><br><span class="hljs-comment">// 全局变量在程序结束前一直存在，无法回收。</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>未清理的定时器</strong>: 忘记清除不再需要的 <code>setInterval</code> 或 <code>setTimeout</code>，可能导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 设置一个定时器，每秒执行一次</span><br>    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 模拟元素销毁时忘记清除定时器</span><br>    <span class="hljs-comment">// clearInterval(intervalId);</span><br>&#125;<br><br><span class="hljs-comment">// 调用后，即使 element 被移除，intervalId 依然存在，导致内存泄漏。</span><br><span class="hljs-title function_">startTimer</span>();<br><br></code></pre></td></tr></table></figure><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><p>​ 在不再需要定时器时调用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存管理不善</strong>: 虽然 JavaScript 有自动垃圾回收，但开发者仍需注意合理使用内存。例如，避免创建大量不必要的对象或保留不必要的引用。</p></li></ol><h3 id="现代-JavaScript-引擎的优化"><a href="#现代-JavaScript-引擎的优化" class="headerlink" title="现代 JavaScript 引擎的优化"></a>现代 JavaScript 引擎的优化</h3><p>除了基本的标记-清除算法，现代 JavaScript 引擎（如 V8）通常还使用一些优化技术，如：</p><ul><li><strong>增量标记（Incremental Marking）</strong>: 将标记阶段拆分为多个小步骤，避免长时间的卡顿。</li><li><strong>世代回收（Generational Garbage Collection）</strong>: 将内存划分为“新生代”和“老生代”两个区域，短命对象会快速回收，长命对象则被移至老生代以减少处理频率。</li><li><strong>惰性清理（Lazy Cleanup）</strong>: 仅在需要时才清理内存，以进一步减少不必要的垃圾回收操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据hexo创建个人博客</title>
    <link href="/posts/62544/"/>
    <url>/posts/62544/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h2><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p><h2 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h2><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p><h1 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="/posts/62544/1.png"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="/posts/62544/2.png"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="/posts/62544/3.png"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/posts/62544/4.png"></p><p>浏览器中访问，展示成功。</p><p><img src="/posts/62544/5.png"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面默认主图风格如下">http://localhost:4000&#39;，页面默认主图风格如下</a></p><p><img src="/posts/62544/6.png"></p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。个人比较喜欢<code>Fluid</code>。</p><h2 id="1-Fluid主题"><a href="#1-Fluid主题" class="headerlink" title="1.Fluid主题"></a>1.Fluid主题</h2><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 <strong>安装主题</strong></h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h3 id="1-2-指定主题"><a href="#1-2-指定主题" class="headerlink" title="1.2 指定主题"></a>1.2 <strong>指定主题</strong></h3><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="1-3-创建「关于页」"><a href="#1-3-创建「关于页」" class="headerlink" title="1.3 创建「关于页」"></a>1.3 <strong>创建「关于页」</strong></h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br><br></code></pre></td></tr></table></figure><h3 id="1-4-本地启动"><a href="#1-4-本地启动" class="headerlink" title="1.4 本地启动**"></a>1.4 本地启动**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，`Fluid`主题风格页面如下">http://localhost:4000&#39;，`Fluid`主题风格页面如下</a></p><p><img src="/posts/62544/7.png"></p><h1 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h1><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><h2 id="1-添加hexo-asset-image插件"><a href="#1-添加hexo-asset-image插件" class="headerlink" title="1.添加hexo-asset-image插件"></a>1.添加hexo-asset-image插件</h2><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p>hexo-asset-image插件的作用就是为图片资源默认追加上时间路径前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这里不要用</p><p><img src="/posts/62544/8.png"></p><h2 id="2-修改-Hexo-博客目录中的-config-yml"><a href="#2-修改-Hexo-博客目录中的-config-yml" class="headerlink" title="2.修改 Hexo 博客目录中的 _config.yml"></a>2.修改 Hexo 博客目录中的 <code>_config.yml</code></h2><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="/posts/62544/9.png"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="/posts/62544/10.png"></p><p>在测试文章.md中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在\source\images目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:<br><span class="hljs-bullet">-</span> 原创<br>categories:<br><span class="hljs-section">- Java</span><br><span class="hljs-section">---</span><br><br>这是一篇测试文章<br><br>![<span class="hljs-string">图片引用方一</span>](<span class="hljs-link">测试文章/test.png</span>)<br><br>![<span class="hljs-string">图片引用方法二</span>](<span class="hljs-link">test.png</span>)<br><br>![<span class="hljs-string">图片引用方法三</span>](<span class="hljs-link">/images/test.png</span>)<br><br></code></pre></td></tr></table></figure><h2 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.<strong>本地启动</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面如下，文章添加成功">http://localhost:4000&#39;，页面如下，文章添加成功</a></p><p><img src="/posts/62544/11.png"></p><h1 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h1><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h2 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h2><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="/posts/62544/12.png"></p><h2 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2.博客标题"></a>2.博客标题</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="/posts/62544/13.png"></p><h2 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="/posts/62544/14.png"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="/posts/62544/15.png"></p><h1 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h1><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h2 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h2><h3 id="进入-官网-注册账号"><a href="#进入-官网-注册账号" class="headerlink" title="进入 官网 注册账号"></a>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</h3><p><img src="/posts/62544/16.png"></p><h3 id="需实名认证，完成后才能使用各项服务"><a href="#需实名认证，完成后才能使用各项服务" class="headerlink" title="需实名认证，完成后才能使用各项服务"></a>需实名认证，完成后才能使用各项服务</h3><p><img src="/posts/62544/17.png"></p><p>验证邮箱</p><p><img src="/posts/62544/18.png"></p><h3 id="创建应用，选择开发版即可，免费的"><a href="#创建应用，选择开发版即可，免费的" class="headerlink" title="创建应用，选择开发版即可，免费的"></a>创建应用，选择<code>开发版</code>即可，免费的</h3><p><img src="/posts/62544/19.png"></p><h3 id="进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用"><a href="#进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用" class="headerlink" title="进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用"></a>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</h3><p><img src="/posts/62544/20.png"></p><h2 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h2><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h3 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h3><p>打开统计开关</p><p><img src="/posts/62544/21.png"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="/posts/62544/22.png"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="/posts/62544/23.png"></p><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><img src="/posts/62544/24.png"></p><h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p><img src="/posts/62544/25.png"></p><p>页面效果</p><p><img src="/posts/62544/26.png"></p><h1 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h1><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h2 id="启用评论插件"><a href="#启用评论插件" class="headerlink" title="启用评论插件"></a>启用评论插件</h2><p><img src="/posts/62544/27.png"></p><h2 id="配置-LeanCloud-的-appId-和-appkey"><a href="#配置-LeanCloud-的-appId-和-appkey" class="headerlink" title="配置 LeanCloud 的 appId 和 appkey"></a>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></h2><p><img src="/posts/62544/28.png"></p><h2 id="重新部署后，查看页面效果，评论功能已开启"><a href="#重新部署后，查看页面效果，评论功能已开启" class="headerlink" title="重新部署后，查看页面效果，评论功能已开启"></a>重新部署后，查看页面效果，评论功能已开启</h2><p><img src="/posts/62544/29.png"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h1 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="1-1-安装hexo-deployer-git"><a href="#1-1-安装hexo-deployer-git" class="headerlink" title="1.1 安装hexo-deployer-git"></a>1.1 安装hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="1-2-修改根目录下的-config-yml，配置-GitHub-相关信息"><a href="#1-2-修改根目录下的-config-yml，配置-GitHub-相关信息" class="headerlink" title="1.2 修改根目录下的 _config.yml，配置 GitHub 相关信息"></a>1.2 修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><h3 id="1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图"><a href="#1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图" class="headerlink" title="1.3 其中 token 为 GitHub 的 Personal access tokens，获取方式如下图"></a>1.3 其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</h3><p><img src="/posts/62544/30.png"></p><h3 id="1-4-部署到GitHub"><a href="#1-4-部署到GitHub" class="headerlink" title="1.4 部署到GitHub"></a>1.4 部署到GitHub</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a></p><p><img src="/posts/62544/31.png"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="/posts/62544/32.png"></p><h1 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>代理</h1><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location &#x2F;blog 路径一致。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rkyao/fronted/hexo-blog<br></code></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/conf<br>vim nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">server节点下添加如下配置</span><br>location /blog &#123;<br>    alias  /opt/rkyao/fronted/hexo-blog;<br>    index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://47.96.106.173/blog/<br></code></pre></td></tr></table></figure><h1 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h1><p>可访问如下地址查看<br><a href="https://yonghengshikong.github.io/">https://yonghengshikong.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命名</title>
    <link href="/posts/16107/"/>
    <url>/posts/16107/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-创建新的博客"><a href="#1-创建新的博客" class="headerlink" title="1.创建新的博客"></a>1.创建新的博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="2-本地运行"><a href="#2-本地运行" class="headerlink" title="2.本地运行"></a>2.本地运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3.生成静态文件"></a>3.生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="4-部署到远程站点"><a href="#4-部署到远程站点" class="headerlink" title="4.部署到远程站点"></a>4.部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="5-清除本地缓存"><a href="#5-清除本地缓存" class="headerlink" title="5.清除本地缓存"></a>5.清除本地缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c<br></code></pre></td></tr></table></figure><h3 id="6-组合命令-生成且部署到远程"><a href="#6-组合命令-生成且部署到远程" class="headerlink" title="6.组合命令(生成且部署到远程)"></a>6.组合命令(生成且部署到远程)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
