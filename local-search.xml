<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八、NodeJs 模块系统</title>
    <link href="/posts/56695/"/>
    <url>/posts/56695/</url>
    
    <content type="html"><![CDATA[<h1 id="八、NodeJs-模块系统"><a href="#八、NodeJs-模块系统" class="headerlink" title="八、NodeJs 模块系统"></a>八、NodeJs 模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展。</p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>在 Node.js 中，引入一个模块非常简单，如下我们创建一个 <strong>main.js</strong> 文件并引入 hello 模块，代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>);<br>hello.<span class="hljs-title function_">world</span>();<br></code></pre></td></tr></table></figure><p>以上实例中，代码 require(‘.&#x2F;hello’) 引入了当前目录下的 hello.js 文件（.&#x2F; 为当前目录，node.js 默认后缀为 js）。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p><p>接下来我们就来创建 hello.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">world</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘.&#x2F;hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p><p>有时候我们只是想把一个对象封装到模块中，格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//hello.js </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">var</span> name; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thyName</span>) &#123; <br>        name = thyName; <br>    &#125;; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name); <br>    &#125;; <br>&#125;; <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Hello</span>;<br></code></pre></td></tr></table></figure><p>这样就可以直接获得这个对象了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>); <br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>(); <br>hello.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;BYVoid&#x27;</span>); <br>hello.<span class="hljs-title function_">sayHello</span>(); <br></code></pre></td></tr></table></figure><p>模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.world &#x3D; function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p><hr><h2 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><br>...<br><br>http.<span class="hljs-title function_">createServer</span>(...);<br></code></pre></td></tr></table></figure><p>Node.js 中自带了一个叫做 <strong>http</strong> 的模块，在我们的代码中请求它并把返回值赋给一个本地变量。</p><p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p><p>Node.js 的 require 方法中的文件查找策略如下：</p><p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p><p><img src="/posts/56695/nodejs-require.jpg"></p><h3 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h3><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p><h3 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载"></a>从原生模块加载</h3><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http&#x2F;http.js&#x2F;http.node&#x2F;http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p><p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p><h3 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h3><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p><p>require方法接受以下几种参数的传递：</p><ul><li>http、fs、path等，原生模块。</li><li>.&#x2F;mod或..&#x2F;mod，相对路径的文件模块。</li><li>&#x2F;pathtomodule&#x2F;mod，绝对路径的文件模块。</li><li>mod，非原生模块的文件模块。</li></ul><p>在路径 Y 下执行 require(X) 语句执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果 X 是内置模块<br>   a. 返回内置模块<br>   b. 停止执行<br>2. 如果 X 以 <span class="hljs-string">&#x27;/&#x27;</span> 开头<br>   a. 设置 Y 为文件根路径<br>3. 如果 X 以 <span class="hljs-string">&#x27;./&#x27;</span> 或 <span class="hljs-string">&#x27;/&#x27;</span> or <span class="hljs-string">&#x27;../&#x27;</span> 开头<br>   a. LOAD_AS_FILE(Y + X)<br>   b. LOAD_AS_DIRECTORY(Y + X)<br>4. LOAD_NODE_MODULES(X, <span class="hljs-built_in">dirname</span>(Y))<br>5. 抛出异常 <span class="hljs-string">&quot;not found&quot;</span><br><br>LOAD_AS_FILE(X)<br>1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。<br>3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。<br>4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。<br><br>LOAD_INDEX(X)<br>1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。<br>3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。<br><br>LOAD_AS_DIRECTORY(X)<br>1. 如果 X/package.json 是一个文件,<br>   a. 解析 X/package.json, 并查找 <span class="hljs-string">&quot;main&quot;</span> 字段。<br>   b. <span class="hljs-built_in">let</span> M = X + (json main 字段)<br>   c. LOAD_AS_FILE(M)<br>   d. LOAD_INDEX(M)<br>2. LOAD_INDEX(X)<br><br>LOAD_NODE_MODULES(X, START)<br>1. <span class="hljs-built_in">let</span> DIRS=NODE_MODULES_PATHS(START)<br>2. <span class="hljs-keyword">for</span> each DIR <span class="hljs-keyword">in</span> DIRS:<br>   a. LOAD_AS_FILE(DIR/X)<br>   b. LOAD_AS_DIRECTORY(DIR/X)<br><br>NODE_MODULES_PATHS(START)<br>1. <span class="hljs-built_in">let</span> PARTS = path <span class="hljs-built_in">split</span>(START)<br>2. <span class="hljs-built_in">let</span> I = count of PARTS - 1<br>3. <span class="hljs-built_in">let</span> DIRS = []<br>4. <span class="hljs-keyword">while</span> I &gt;= 0,<br>   a. <span class="hljs-keyword">if</span> PARTS[I] = <span class="hljs-string">&quot;node_modules&quot;</span> CONTINUE<br>   b. DIR = path <span class="hljs-built_in">join</span>(PARTS[0 .. I] + <span class="hljs-string">&quot;node_modules&quot;</span>)<br>   c. DIRS = DIRS + DIR<br>   d. <span class="hljs-built_in">let</span> I = I - 1<br>5. <span class="hljs-built_in">return</span> DIRS<br></code></pre></td></tr></table></figure><blockquote><p><strong>exports 和 module.exports 的使用</strong></p><p>如果要对外暴露属性或方法，就用 <strong>exports</strong> 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 <strong>module.exports</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七、NodeJs HTTP协议</title>
    <link href="/posts/5656/"/>
    <url>/posts/5656/</url>
    
    <content type="html"><![CDATA[<h1 id="七、NodeJs-HTTP协议"><a href="#七、NodeJs-HTTP协议" class="headerlink" title="七、NodeJs HTTP协议"></a>七、NodeJs HTTP协议</h1><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>HTTP（hypertext transport protocol）协议；中文叫超文本传输协议</p><p>是一种基于TCP&#x2F;IP的应用层通信协议</p><p>这个协议详细规定了 浏览器 和万维网 服务器 之间互相通信的规则。</p><p>协议中主要规定了两个方面的内容</p><ul><li><p>客户端:用来向服务器发送数据，可以被称之为请求报文</p></li><li><p>服务端:向客户端返回数据，可以被称之为响应报文</p></li></ul><p>报文:可以简单理解为就是一堆字符串</p><h1 id="二、请求报文的组成"><a href="#二、请求报文的组成" class="headerlink" title="二、请求报文的组成"></a>二、请求报文的组成</h1><ul><li><p>请求行</p></li><li><p>请求头</p></li><li><p>空行</p></li><li><p>请求体</p></li></ul><h1 id="三、HTTP的请求行"><a href="#三、HTTP的请求行" class="headerlink" title="三、HTTP的请求行"></a>三、HTTP的请求行</h1><ul><li><p>请求方法（get、post、put、delete等）</p></li><li><p>请求URL（统一资源定位器）</p></li></ul><p>例如:<a href="http://www.baidu.com/index.html?a%EF%BC%9D100&b%EF%BC%9D200#logo">http://www.baidu.com:80/index.html?a＝100&amp;b＝200#logo</a></p><ul><li><p>http: 协议（https、ftp、ssh等）</p></li><li><p><a href="http://www.baidu.com/">www.baidu.com</a>         域名</p></li><li><p>80                                端口号</p></li><li><p>&#x2F;index.html                路径</p></li><li><p>a&#x3D;1008.b&#x3D;200           查询字符串</p></li><li><p>#logo                           哈希（锚点链接）</p></li></ul><p>HTTP协议版本号</p><h1 id="四、HTTP请求头"><a href="#四、HTTP请求头" class="headerlink" title="四、HTTP请求头"></a>四、HTTP请求头</h1><p>格式:『头名:头值』</p><p>常见的请求头有:</p><table><thead><tr><th>请求头</th><th>解释</th></tr></thead><tbody><tr><td>Host</td><td>主机名</td></tr><tr><td>Connection</td><td>连接的设置keep-alive（保持连接）；close（关闭连接）</td></tr><tr><td>Cache-Control</td><td>缓存控制 max-age＝0 （没有缓存）</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>将网页中的http请求转化为https请求（很少用）老网站升级</td></tr><tr><td>User-Agent</td><td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自哪个客户端，一般在PC端和手机端的区分</td></tr><tr><td>Accept</td><td>设置浏览器接收的数据类型</td></tr><tr><td>Accept-Encoding</td><td>设置接收的压缩方式</td></tr><tr><td>Accept-Language</td><td>设置接收的语言q＝0.7为喜好系数，满分为1</td></tr><tr><td>Cookie</td><td>后面单独讲</td></tr></tbody></table><h1 id="五、HTTP的请求体"><a href="#五、HTTP的请求体" class="headerlink" title="五、HTTP的请求体"></a>五、HTTP的请求体</h1><p>请求体内容的格式是非常灵活的，</p><p>（可以是空）⇒GET请求，</p><p>（也可以是字符串，还可以是JSON)⇒POST请求</p><p>例如:</p><ul><li><p>字符串:keywords&#x3D;手机8price&#x3D;2000</p></li><li><p>JSON:｛＂keywords＂:＂手机＂，＂price＂:2000｝</p></li></ul><h1 id="六、响应报文的组成"><a href="#六、响应报文的组成" class="headerlink" title="六、响应报文的组成"></a>六、响应报文的组成</h1><ul><li><strong>响应行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure><ul><li><p>HTTP&#x2F;1.1:HTTP协议版本号</p></li><li><p>200:响应状态码 404 Not Found 500 Internal Server Error 还有一些状态码，参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p></li><li><p>OK:响应状态描述</p></li></ul><p><span style="background:#e5eecc">响应状态码和响应字符串关系是–对应的。</span></p><ul><li><strong>响应头</strong></li></ul><table border="1"><tr><td colspan="1" rowspan="1">Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据Connection 链接设置</td></tr><tr><td colspan="1" rowspan="1">Content-Type:text/html;charset=utf-8 设置响应体的数据类型以及字符集，响应体为html，字符集utf-8</td></tr><tr><td colspan="1" rowspan="1">Content-Length:响应体的长度，单位为字节</td></tr></table><ul><li><p><strong>空行</strong></p></li><li><p><strong>响应体</strong></p></li></ul><p><strong>响应体内容的类型是非常灵活的，常见的类型有HTML、CSS、JS、图片、JSON</strong></p><h1 id="七、创建HTTP服务"><a href="#七、创建HTTP服务" class="headerlink" title="七、创建HTTP服务"></a>七、创建HTTP服务</h1><p>使用nodejs 创建 HTTP服务</p><h2 id="7-1-操作步骤"><a href="#7-1-操作步骤" class="headerlink" title="7.1 操作步骤"></a>7.1 操作步骤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//2. 创建服务对象 create 创建 server 服务</span><br><span class="hljs-comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据</span><br><span class="hljs-comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello HTTP server&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//3. 监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口 9000 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>http.createServer 里的回调函数的执行时机: 当接收到 HTTP 请求的时候，就会执行</strong></p><h2 id="7-2-测试"><a href="#7-2-测试" class="headerlink" title="7.2 测试"></a>7.2 测试</h2><p>浏览器请求对应端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://127.0.0.1:9000<br></code></pre></td></tr></table></figure><h2 id="7-3-注意事项"><a href="#7-3-注意事项" class="headerlink" title="7.3 注意事项"></a>7.3 注意事项</h2><h3 id="1-命令行-ctrl＋c停止服务"><a href="#1-命令行-ctrl＋c停止服务" class="headerlink" title="1.命令行 ctrl＋c停止服务"></a>1.命令行 <strong>ctrl＋c</strong>停止服务</h3><h3 id="2-当服务启动后，更新代码-必须重启服务才能生效"><a href="#2-当服务启动后，更新代码-必须重启服务才能生效" class="headerlink" title="2.当服务启动后，更新代码 必须重启服务才能生效"></a>2.当服务启动后，更新代码 必须重启服务才能生效</h3><h3 id="3-响应内容中文乱码的解决办法"><a href="#3-响应内容中文乱码的解决办法" class="headerlink" title="3.响应内容中文乱码的解决办法"></a>3.响应内容中文乱码的解决办法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-端口号被占用"><a href="#4-端口号被占用" class="headerlink" title="4.端口号被占用"></a>4.端口号被占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: listen EADDRINUSE: address already <span class="hljs-keyword">in</span> use :::9000<br></code></pre></td></tr></table></figure><p>1）关闭当前正在运行监听端口的服务（使用较多）</p><p>2）修改其他端口号</p><p>5.HTTP协议默认端口是80。HTTPS协议的默认端口是443，HTTP服务开发常用端口有3000，8080,8090,9000等</p><p><strong>如果端口被其他程序占用，可以使用资源监视器 找到占用端口的程序，然后使用 任务管理器 关闭对应的程序</strong></p><h1 id="八、浏览器查看HTTP报文"><a href="#八、浏览器查看HTTP报文" class="headerlink" title="八、浏览器查看HTTP报文"></a>八、浏览器查看HTTP报文</h1><p><strong>点击步骤</strong></p><p><img src="/posts/5656/image-20241014173924293.png"></p><h2 id="8-1查看请求行与请求头"><a href="#8-1查看请求行与请求头" class="headerlink" title="8.1查看请求行与请求头"></a>8.1查看请求行与请求头</h2><h2 id><a href="#" class="headerlink" title></a><img src="/posts/5656/image-20241014174034947.png"></h2><h2 id="8-2查看请求体"><a href="#8-2查看请求体" class="headerlink" title="8.2查看请求体"></a>8.2查看请求体</h2><p><img src="/posts/5656/image-20241014174143907.png"></p><h2 id="8-3查看URL查询字符串"><a href="#8-3查看URL查询字符串" class="headerlink" title="8.3查看URL查询字符串"></a>8.3查看URL查询字符串</h2><p><img src="/posts/5656/image-20241014174204151.png"></p><h2 id="8-4查看响应行与响应头"><a href="#8-4查看响应行与响应头" class="headerlink" title="8.4查看响应行与响应头"></a>8.4查看响应行与响应头</h2><p><img src="/posts/5656/image-20241014174335095.png"></p><h2 id="8-5查看响应体"><a href="#8-5查看响应体" class="headerlink" title="8.5查看响应体"></a>8.5查看响应体</h2><p><img src="/posts/5656/image-20241014174400437.png"></p><h1 id="九、获取HTTP请求报文"><a href="#九、获取HTTP请求报文" class="headerlink" title="九、获取HTTP请求报文"></a>九、获取HTTP请求报文</h1><p>想要获取请求的数据，需要通过request 对象</p><table><thead><tr><th>含义</th><th>语法</th><th>重点掌握</th></tr></thead><tbody><tr><td>请求方法</td><td>request.method</td><td>*</td></tr><tr><td>请求版本</td><td>request.httpVersion</td><td></td></tr><tr><td>请求路径</td><td>request.url</td><td>*</td></tr><tr><td>URL 路径</td><td>require(‘url’).parse(request.url).pathname</td><td>*</td></tr><tr><td>URL查询字符串</td><td>require(‘url’).parse(request.url, true).query</td><td>*</td></tr><tr><td>请求头</td><td>request.headers</td><td>*</td></tr><tr><td>请求体</td><td>request.on(‘data, function(chunk){}); request.on(‘end’, function(){});</td><td></td></tr></tbody></table><p><strong>注意事项:</strong></p><p>1.request.url只能获取路径以及查询字符串，无法获取URL中的域名以及协议的内容</p><p>2.request.headers将请求信息转化成一个对象，并将属性名都转化成了『小写』</p><p>3.关于路径:如果访问网站的时候，只填写了IP地址或者是域名信息，此时请求的路径为『&#x2F;』</p><p>4.关于favicon.ico:这个请求是属于浏览器自动发送的请求</p><h2 id="9-1-搭建HTTP服务"><a href="#9-1-搭建HTTP服务" class="headerlink" title="9.1 搭建HTTP服务"></a>9.1 搭建HTTP服务</h2><p>按照以下要求搭建HTTP服务</p><table><thead><tr><th>请求类型（方法）</th><th>请求地址</th><th>响应体结果</th></tr></thead><tbody><tr><td>get</td><td>&#x2F;login</td><td>登录页面</td></tr><tr><td>get</td><td>&#x2F;reg</td><td>注册页面</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、引入http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-comment">//2、建立服务</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request; <span class="hljs-comment">//对象的解构赋值</span><br>    <span class="hljs-comment">//设置响应头信息</span><br>    <span class="hljs-comment">//解决中文乱码</span><br>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/register&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;注册页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;登录页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//3、监听端口</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="十、设置HTTP响应报文"><a href="#十、设置HTTP响应报文" class="headerlink" title="十、设置HTTP响应报文"></a>十、设置HTTP响应报文</h1><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage（用的非常少）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader（＇头名，＇头值）</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’) response.end(‘xxx’)</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//write 和 end 的两种使用情况:</span><br><span class="hljs-comment">//1. write 和 end 的结合使用 响应体相对分散</span><br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">//每一个请求，在处理的时候必须要执行 end 方法的</span><br><span class="hljs-comment">//2. 单独使用 end 方法 响应体相对集中</span><br>response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="10-1-示例"><a href="#10-1-示例" class="headerlink" title="10.1 示例"></a>10.1 示例</h2><p>搭建HTTP服务，响应一个4行3列的表格，并且要求表格有 隔行换色效果，且点击单元格能 高亮显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="hljs-string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="hljs-string">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="hljs-string">    &lt;style&gt;</span><br><span class="hljs-string">    td&#123;</span><br><span class="hljs-string">    padding: 20px 40px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(odd)&#123;</span><br><span class="hljs-string">    background: #aef;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(even)&#123;</span><br><span class="hljs-string">    background: #fcb;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table, td&#123;</span><br><span class="hljs-string">    border-collapse: collapse;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &lt;/style&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;/table&gt;</span><br><span class="hljs-string">    &lt;script&gt;</span><br><span class="hljs-string">    //获取所有的 td</span><br><span class="hljs-string">    let tds = document.querySelectorAll(&#x27;td&#x27;);</span><br><span class="hljs-string">    //遍历</span><br><span class="hljs-string">    tds.forEach(item =&gt; &#123;</span><br><span class="hljs-string">    item.onclick = function()&#123;</span><br><span class="hljs-string">    this.style.background = &#x27;#222&#x27;;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">`</span>); <span class="hljs-comment">//设置响应体</span><br>&#125;);<br><span class="hljs-comment">//监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动....&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="十一、网页资源的基本加载过程"><a href="#十一、网页资源的基本加载过程" class="headerlink" title="十一、网页资源的基本加载过程"></a>十一、网页资源的基本加载过程</h1><p><img src="/posts/5656/image-20241014175420098.png"></p><p>网页资源的加载都是循序渐进的，首先获取HTML的内容，然后解析HTML在发送其他资源的请求，如CSS， Javascript，图片等。理解了这个内容对于后续的学习与成长有非常大的帮助</p><h1 id="十二、静态资源服务"><a href="#十二、静态资源服务" class="headerlink" title="十二、静态资源服务"></a>十二、静态资源服务</h1><p>静态资源是指内容长时间不发生改变的资源，例如图片，视频，cSS文件，JS文件，HTML文件，字体文件等</p><p>动态资源是指内容经常更新的资源，例如百度首页，网易首页，京东搜索列表页面等</p><h2 id="12-1-网站根目录或静态资源目录"><a href="#12-1-网站根目录或静态资源目录" class="headerlink" title="12.1 网站根目录或静态资源目录"></a>12.1 网站根目录或静态资源目录</h2><p>HTTP服务在哪个文件夹中寻找静态资源，那个文件夹就是静态资源目录，也称之为 网站根目录</p><p>思考:vscode 中使用live-server访问HTML时，它启动的服务中网站根目录是谁？</p><h2 id="12-2-网页中的URL"><a href="#12-2-网页中的URL" class="headerlink" title="12.2 网页中的URL"></a>12.2 网页中的URL</h2><p>网页中的URL主要分为两大类:相对路径与绝对路径</p><h3 id="12-2-1-绝对路径"><a href="#12-2-1-绝对路径" class="headerlink" title="12.2.1 绝对路径"></a>12.2.1 绝对路径</h3><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><table><thead><tr><th>形式</th><th>特点</th></tr></thead><tbody><tr><td><a href="http://atguigu.com/web">http://atguigu.com/web</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td>&#x2F;&#x2F;atguigu.com&#x2F;web</td><td>与页面URL的协议拼接形成完整URL再发送请求。大型网站用的比较多</td></tr><tr><td>&#x2F;web</td><td>与页面URL的协议、主机名、端口拼接形成完整URL再发送请求。中小型网站</td></tr></tbody></table><h3 id="12-2-2-相对路径"><a href="#12-2-2-相对路径" class="headerlink" title="12.2.2 相对路径"></a>12.2.2 相对路径</h3><p>相对路径在发送请求时，需要与当前页面URL路径进行计算，得到完整URL后，再发送请求，学习阶段用的较多</p><p>例如当前网页url为<a href="http://www.atguigu.com/course/h5.html">http://www.atguigu.com/course/h5.html</a></p><table><thead><tr><th>形式</th><th>最终的URL</th></tr></thead><tbody><tr><td>.&#x2F;css&#x2F;app.css</td><td><a href="http://www.atguigu.com/course/css/app.css">http://www.atguigu.com/course/css/app.css</a></td></tr><tr><td>js&#x2F;app.js</td><td><a href="http://www.atguigu.com/course/js/app.js">http://www.atguigu.com/course/js/app.js</a></td></tr><tr><td>..&#x2F;img&#x2F;logo.png</td><td><a href="http://www.atguigu.com/img/logo.png">http://www.atguigu.com/img/logo.png</a></td></tr><tr><td>..&#x2F;..&#x2F;mp4&#x2F;show.mp4</td><td><a href="http://www.atguigu.com/mp4/show.mp4">http://www.atguigu.com/mp4/show.mp4</a></td></tr></tbody></table><h3 id="12-2-3-网页中使用URL的场景小结"><a href="#12-2-3-网页中使用URL的场景小结" class="headerlink" title="12.2.3 网页中使用URL的场景小结"></a>12.2.3 网页中使用URL的场景小结</h3><p>包括但不限于如下场景:</p><ul><li><p>a标签href</p></li><li><p>link标签 href</p></li><li><p>script标签src</p></li><li><p>img标签 src</p></li><li><p>video audio 标签 src</p></li><li><p>form中的action</p></li><li><p>AJAX请求中的URL</p></li></ul><h2 id="12-3-设置资源类型（mime类型）"><a href="#12-3-设置资源类型（mime类型）" class="headerlink" title="12.3 设置资源类型（mime类型）"></a>12.3 设置资源类型（mime类型）</h2><p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。</p><p><code>mime 类型结构:［type］/［subType］</code></p><p><code>例如:text/html text/css image/jpeg image/png application/json</code></p><p>HTTP服务可以设置响应头Content-Type 来表明响应体的MIME类型，浏览器会根据该类型决定如何处理资源</p><p>下面是常见文件对应的mime类型</p><ul><li><p>html:’text&#x2F;html’,</p></li><li><p>css:’text&#x2F;css’,</p></li><li><p>js: ‘text&#x2F;javascript’,</p></li><li><p>png: ‘image&#x2F;png’,</p></li><li><p>jpg: ‘image&#x2F;jpeg’,</p></li><li><p>gif: ‘image&#x2F;gif’,</p></li><li><p>mp4: ‘video&#x2F;mp4’,</p></li><li><p>mp3: ‘audio&#x2F;mpeg’,</p></li><li><p>json: ‘application&#x2F;json’</p></li></ul><p>对于未知的资源类型，可以选择 application&#x2F;octet-stream类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的下载效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//判断请求方式以及请求路径</span><br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/index.html&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/css/app.css&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/css/app.css&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/js/app.js&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/js/app.js&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//404响应</span><br>        response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>很明显上面的代码，当只要有一个请求路径就需要进行判断，显然这种方式不够完美，那么我们需要封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//文件夹路径</span><br>    <span class="hljs-keyword">let</span> rootDir = __dirname + <span class="hljs-string">&#x27;/public&#x27;</span>;<br>    <span class="hljs-comment">//拼接文件路径</span><br>    <span class="hljs-keyword">let</span> filePath = rootDir + url;<br>    <span class="hljs-comment">//读取文件内容</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断</span><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-comment">//如果出现错误，响应404状态码</span><br>            response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>            response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//响应文件内容</span><br>            response.<span class="hljs-title function_">end</span>(data);<br>        &#125;<br>    &#125;)<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="12-4-GET和POST请求场景小结"><a href="#12-4-GET和POST请求场景小结" class="headerlink" title="12.4 GET和POST请求场景小结"></a>12.4 GET和POST请求场景小结</h2><h3 id="12-4-1-GET-请求的情况"><a href="#12-4-1-GET-请求的情况" class="headerlink" title="12.4.1 GET 请求的情况:"></a>12.4.1 <strong>GET 请求的情况:</strong></h3><p>在地址栏直接输入url访问</p><ul><li><p>点击a链接</p></li><li><p>link标签引入css</p></li><li><p>script 标签引入js</p></li><li><p>img标签引入图片</p></li><li><p>form标签中的method为get（不区分大小写）</p></li><li><p>ajax中的get请求</p></li></ul><h3 id="12-4-2-POST-请求的情况"><a href="#12-4-2-POST-请求的情况" class="headerlink" title="12.4.2 POST 请求的情况:"></a>12.4.2 <strong>POST 请求的情况:</strong></h3><ul><li><p>form标签中的method为post（不区分大小写）</p></li><li><p>AJAX的post请求</p></li></ul><h2 id="十三、GET和POST请求的区别"><a href="#十三、GET和POST请求的区别" class="headerlink" title="十三、GET和POST请求的区别"></a>十三、GET和POST请求的区别</h2><p>GET和POST是HTTP协议请求的两种方式。</p><ul><li><p>GET主要用来获取数据，POST主要用来提交数据</p></li><li><p>GET带参数请求是将参数缀到URL之后，在地址栏中输入url访问网站就是GET请求，POST带参数请求是将参数放到请求体中</p></li><li><p>POST 请求相对GET安全一些，因为在浏览器中参数会暴露在地址栏</p></li><li><p>GET请求大小有限制，一般为2K，而POST 请求则没有大小限制</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、NodeJs path模块</title>
    <link href="/posts/5760/"/>
    <url>/posts/5760/</url>
    
    <content type="html"><![CDATA[<h1 id="六、NodeJs-path模块"><a href="#六、NodeJs-path模块" class="headerlink" title="六、NodeJs path模块"></a>六、NodeJs path模块</h1><p>path 模块提供了操作路径的功能，我们将介绍如下几个较为常用的几个 API：</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>path.resolve</td><td>拼接规范的绝对路径 常用</td></tr><tr><td>path.sep</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse</td><td>解析路径并返回对象</td></tr><tr><td>path.basename</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname</td><td>获取路径的目录名</td></tr><tr><td>path.extname</td><td>获得路径的扩展名</td></tr></tbody></table><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">//获取路径分隔符</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-property">sep</span>);<br><br><span class="hljs-comment">//拼接绝对路径</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;test&#x27;</span>));<br><br><span class="hljs-comment">//解析路径</span><br><br><span class="hljs-keyword">let</span> pathname = <span class="hljs-string">&#x27;D:/program file/nodejs/node.exe&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">parse</span>(pathname));<br><br><span class="hljs-comment">//获取路径基础名称</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(pathname))<br><br><span class="hljs-comment">//获取路径的目录名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">dirname</span>(pathname));<br><br><span class="hljs-comment">//获取路径的扩展名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(pathname));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、NodeJs fs模块</title>
    <link href="/posts/3454/"/>
    <url>/posts/3454/</url>
    
    <content type="html"><![CDATA[<h1 id="五、NodeJs-fs模块"><a href="#五、NodeJs-fs模块" class="headerlink" title="五、NodeJs fs模块"></a>五、NodeJs fs模块</h1><p>fs 全称为 file system，称之为文件系统，是 Node.js 中的内置模块，可以对计算机中的磁盘进行操作。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile &#x2F; appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h1 id="一、文件写入"><a href="#一、文件写入" class="headerlink" title="一、文件写入"></a>一、文件写入</h1><p>文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果</p><h2 id="1-1-writeFile-异步写入"><a href="#1-1-writeFile-异步写入" class="headerlink" title="1-1. writeFile 异步写入"></a>1-1. writeFile 异步写入</h2><p>语法： </p><p><strong>fs.writeFile(file, data[, options], callback)</strong></p><p>参数说明：</p><ul><li><p>file 文件名</p></li><li><p>data 待写入的数据</p></li><li><p>options 选项设置（可选）</p></li><li><p>callback 写入回调</p></li></ul><p>返回值： undefined</p><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// require 是 Node.js 环境中的&#x27;全局&#x27;变量，用来导入模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">//将 『三人行，必有我师焉。』 写入到当前文件夹下的『座右铭.txt』文件中</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)；<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-2-writeFileSync-同步写入"><a href="#1-2-writeFileSync-同步写入" class="headerlink" title="1-2. writeFileSync 同步写入"></a>1-2. writeFileSync 同步写入</h2><p> 语法: </p><p><strong>fs.writeFileSync(file, data[, options])</strong></p><p> 参数与 fs.writeFile 大体一致，只是没有 callback 参数</p><p> 返回值：undefined</p><p> <strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>    fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p> Node.js 中的磁盘操作是由其他线程完成的，结果的处理有两种模式：</p><p> 同步处理 JavaScript 主线程会等待其他线程的执行结果，然后再继续执行主线程的代码，</p><p> 效率较低</p><p> 异步处理 JavaScript 主线程不会等待其他线程的执行结果，直接执行后续的主线程代码，</p><p>效率较好</p><h2 id="1-3-appendFile-appendFileSync-追加写入"><a href="#1-3-appendFile-appendFileSync-追加写入" class="headerlink" title="1-3. appendFile &#x2F; appendFileSync 追加写入"></a>1-3. appendFile &#x2F; appendFileSync 追加写入</h2><p> appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同</p><p> 语法:</p><ul><li><p><strong>fs.appendFile(file, data[, options], callback)</strong></p></li><li><p><strong>fs.appendFileSync(file, data[, options])</strong></p></li></ul><p> 返回值： 二者都为 undefined</p><p> 实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;择其善者而从之，其不善者而改之。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;追加成功&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">appendFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;\r\n温故而知新, 可以为师矣&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-4-createWriteStream-流式写入"><a href="#1-4-createWriteStream-流式写入" class="headerlink" title="1-4. createWriteStream 流式写入"></a>1-4. createWriteStream 流式写入</h2><p> 语法：</p><p> <strong>fs.createWriteStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>返回值：Object</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ws = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;天光云影共徘徊\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;问渠那得清如许\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;为有源头活水来\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure><p> 程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p> 流式写入方式适用于大文件写入或者频繁写入的场景, writeFile 适合于写入频率较低的场景</p><h2 id="1-5-写入文件的场景"><a href="#1-5-写入文件的场景" class="headerlink" title="1-5 写入文件的场景"></a>1-5 写入文件的场景</h2><p> 文件写入在计算机中是一个非常常见的操作，下面的场景都用到了文件写入</p><ul><li><p>下载文件</p></li><li><p>安装软件</p></li><li><p>保存程序日志，如 Git</p></li><li><p>编辑器保存文件</p></li><li><p>视频录制</p></li></ul><p> 当需要持久化保存数据的时候，应该想到文件写入</p><h1 id="二、文件读取"><a href="#二、文件读取" class="headerlink" title="二、文件读取"></a>二、文件读取</h1><p> 文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h2 id="2-1-readFile-异步读取"><a href="#2-1-readFile-异步读取" class="headerlink" title="2-1 readFile 异步读取"></a>2-1 readFile 异步读取</h2><p> 语法：<strong>fs.readFile(path[, options], callback)</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li><li><p>callback 回调函数</p></li></ul><p> 返回值： undefined</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="2-2-readFileSync-同步读取"><a href="#2-2-readFileSync-同步读取" class="headerlink" title="2-2 readFileSync 同步读取"></a>2-2 readFileSync 同步读取</h2><p> 语法：<strong>fs.readFileSync(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li></ul><p> 返回值： string | Buffer</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>);<br><span class="hljs-keyword">let</span> data2 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="2-3-createReadStream-流式读取"><a href="#2-3-createReadStream-流式读取" class="headerlink" title="2-3 createReadStream 流式读取"></a>2-3 createReadStream 流式读取</h2><p> 语法：<strong>fs.createReadStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li></ul><p> 返回值： Object</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建读取流对象</span><br><span class="hljs-keyword">let</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br><span class="hljs-comment">//每次取出 64k 数据后执行一次 data 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;);<br><span class="hljs-comment">//读取完毕后, 执行 end 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-4-读取文件应用场景"><a href="#2-4-读取文件应用场景" class="headerlink" title="2-4 读取文件应用场景"></a>2-4 读取文件应用场景</h2><ul><li><p>电脑开机</p></li><li><p>程序运行</p></li><li><p>编辑器打开文件</p></li><li><p>查看图片</p></li><li><p>播放视频</p></li><li><p>播放音乐</p></li><li><p>Git 查看日志</p></li><li><p>上传文件</p></li><li><p>查看聊天记录</p></li></ul><h1 id="三、文件移动与重命名"><a href="#三、文件移动与重命名" class="headerlink" title="三、文件移动与重命名"></a>三、文件移动与重命名</h1><p> 在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名文件或文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rename(oldPath, newPath, callback)</strong></p></li><li><p><strong>fs.renameSync(oldPath, newPath)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>oldPath 文件当前的路径</p></li><li><p>newPath 文件新的路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><p> &#x2F;&#x2F;创建读取流对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/观书有感.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;移动完成&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">renameSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/我的座右铭.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="四、文件删除"><a href="#四、文件删除" class="headerlink" title="四、文件删除"></a>四、文件删除</h1><p> 在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件</p><p> 语法：</p><ul><li><p><strong>fs.unlink(path, callback)</strong></p></li><li><p><strong>fs.unlinkSync(path)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br>fs.<span class="hljs-title function_">unlinkSync</span>(<span class="hljs-string">&#x27;./test2.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="五、文件夹操作"><a href="#五、文件夹操作" class="headerlink" title="五、文件夹操作"></a>五、文件夹操作</h1><p> 借助 Node.js 的能力，我们可以对文件夹进行创建 、读取、 删除等操作</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir &#x2F; mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir &#x2F; readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir &#x2F; rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h2 id="5-1-mkdir-创建文件夹"><a href="#5-1-mkdir-创建文件夹" class="headerlink" title="5-1 mkdir 创建文件夹"></a>5-1 mkdir 创建文件夹</h2><p> 在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹</p><p> 语法：</p><ul><li><p><strong>fs.mkdir(path[, options], callback)</strong></p></li><li><p><strong>fs.mkdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归异步创建</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./1/2/3&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归同步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-string">&#x27;./x/y/z&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p> &#x2F;&#x2F;异步创建文件夹</p><h2 id="5-2-readdir-读取文件夹"><a href="#5-2-readdir-读取文件夹" class="headerlink" title="5-2 readdir 读取文件夹"></a>5-2 readdir 读取文件夹</h2><p> 在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹</p><p> 语法：</p><ul><li><p><strong>fs.readdir(path[, options], callback)</strong></p></li><li><p><strong>fs.readdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步读取</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步读取</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h2 id="5-3-rmdir-删除文件夹"><a href="#5-3-rmdir-删除文件夹" class="headerlink" title="5-3 rmdir 删除文件夹"></a>5-3 rmdir 删除文件夹</h2><p> 在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rmdir(path[, options], callback)</strong></p></li><li><p><strong>fs.rmdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//异步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./1&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归删除&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//同步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdirSync</span>(<span class="hljs-string">&#x27;./x&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><h1 id="六、查看资源状态"><a href="#六、查看资源状态" class="headerlink" title="六、查看资源状态"></a>六、查看资源状态</h1><p> 在 Node.js 中，我们可以使用 stat 或 statSync 来查看资源的详细信息</p><p> 语法：</p><ul><li><p><strong>fs.stat(path[, options], callback)</strong></p></li><li><p><strong>fs.statSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步获取状态</span><br>fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步获取状态</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">statSync</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><p> 结果值对象结构：</p><ul><li><p>size 文件体积</p></li><li><p>birthtime 创建时间</p></li><li><p>mtime 最后修改时间</p></li><li><p>isFile 检测是否为文件</p></li><li><p>isDirectory 检测是否为文件夹</p></li></ul><p> ….</p><h1 id="七、相对路径问题"><a href="#七、相对路径问题" class="headerlink" title="七、相对路径问题"></a>七、相对路径问题</h1><p> fs 模块对资源进行操作时，路径的写法有两种：</p><p> <strong>相对路径</strong></p><ul><li><p>.&#x2F;座右铭.txt 当前目录下的座右铭.txt</p></li><li><p>座右铭.txt 等效于上面的写法</p></li><li><p>..&#x2F;座右铭.txt 当前目录的上一级目录中的座右铭.txt</p></li></ul><p> <strong>绝对路径</strong></p><ul><li><p>D:&#x2F;Program Files windows 系统下的绝对路径</p></li><li><p>&#x2F;usr&#x2F;bin Linux 系统下的绝对路径</p></li></ul><p> 相对路径中所谓的当前目录，指的是命令行的工作目录，而并非是文件的所在目录</p><p> 所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG</p><h1 id="八、-dirname"><a href="#八、-dirname" class="headerlink" title="八、__dirname"></a>八、__dirname</h1><p> __dirname 与 require 类似，都是 Node.js 环境中的’全局’变量</p><p> __dirname 保存着当前文件所在目录的绝对路径，可以使用 __dirname 与文件名拼接成绝对路径</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><p> <em>使用 fs 模块的时候，尽量使用 __dirname 将路径转化为绝对路径，这样可以避免相对路径产生的Bug</em></p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、NodeJs Stream(流)</title>
    <link href="/posts/6344/"/>
    <url>/posts/6344/</url>
    
    <content type="html"><![CDATA[<h1 id="四、NodeJs-Stream-流"><a href="#四、NodeJs-Stream-流" class="headerlink" title="四、NodeJs Stream(流)"></a>四、NodeJs Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p><p>Node.js，Stream 有四种流类型：</p><ul><li><strong>Readable</strong> - 可读操作。</li><li><strong>Writable</strong> - 可写操作。</li><li><strong>Duplex</strong> - 可读可写操作.</li><li><strong>Transform</strong> - 操作被写入数据，然后读出结果。</li></ul><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><ul><li><strong>data</strong> - 当有数据可读时触发。</li><li><strong>end</strong> - 没有更多的数据可读时触发。</li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul><p>本教程会为大家介绍常用的流操作。</p><hr><h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-comment">// 创建可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 设置编码为 utf8。</span><br>readerStream.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 处理流事件 --&gt; data, end, and error</span><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) &#123;<br>   data += chunk;<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;菜鸟教程官网地址：www.runoob.com&#x27;</span>;<br><br><span class="hljs-comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 使用 utf8 编码写入数据</span><br>writerStream.<span class="hljs-title function_">write</span>(data,<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 标记文件末尾</span><br>writerStream.<span class="hljs-title function_">end</span>();<br><br><span class="hljs-comment">// 处理流事件 --&gt; finish、error</span><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入完成。&quot;</span>);<br>&#125;);<br><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br>写入完成。<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p><p><img src="/posts/6344/bVcla61.png"></p><p>如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。</p><p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p><p>设置 input.txt 文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br><span class="hljs-comment">// 创建一个可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个可写流</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 管道读写操作</span><br><span class="hljs-comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br>readerStream.<span class="hljs-title function_">pipe</span>(writerStream);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><hr><h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p><p>接下来我们就是用管道和链式来压缩和解压文件。</p><p>创建 compress.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 压缩 input.txt 文件为 input.txt.gz</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件压缩完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node compress.js <br>文件压缩完成。<br></code></pre></td></tr></table></figure><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p><p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 解压 input.txt.gz 文件为 input.txt</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGunzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件解压完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node decompress.js <br>文件解压完成。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、NodeJs Buffer(缓冲区)</title>
    <link href="/posts/16461/"/>
    <url>/posts/16461/</url>
    
    <content type="html"><![CDATA[<h1 id="三、NodeJs-Buffer-缓冲区"><a href="#三、NodeJs-Buffer-缓冲区" class="headerlink" title="三、NodeJs Buffer(缓冲区)"></a>三、NodeJs Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p><p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I&#x2F;O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><blockquote><p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 <strong>Buffer.from()</strong> 接口去创建Buffer对象。</p></blockquote><hr><h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br><br><span class="hljs-comment">// 输出 72756e6f6f62</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>));<br><br><span class="hljs-comment">// 输出 cnVub29i</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;base64&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Node.js 目前支持的字符编码包括：</strong></p><ul><li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li><li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li><li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li><li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li><li><strong>base64</strong> - Base64 编码。</li><li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li><li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li><li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li></ul><hr><h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p><ul><li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li><li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li><li><strong>Buffer.allocUnsafeSlow(size)</strong></li><li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li><li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li><li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li><li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="hljs-comment">// 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="hljs-comment">// 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="hljs-comment">// 因此需要使用 fill() 或 write() 重写。</span><br><span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf6 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>, <span class="hljs-string">&#x27;latin1&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>写入 Node 缓冲区的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">write</span>(string[, offset[, length]][, encoding])<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>string</strong> - 写入缓冲区的字符串。</li><li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li><li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li></ul><p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">256</span>);<br>len = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;www.runoob.com&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入字节数 : &quot;</span>+  len);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span> main.js<br>写入字节数 : 14<br></code></pre></td></tr></table></figure><hr><h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>读取 Node 缓冲区数据的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toString</span>([encoding[, start[, end]]])<br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li><li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li><li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">26</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) &#123;<br>  buf[i] = i + <span class="hljs-number">97</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>));       <span class="hljs-comment">// 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));   <span class="hljs-comment">//使用 &#x27;ascii&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));    <span class="hljs-comment">// 使用 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-literal">undefined</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)); <span class="hljs-comment">// 使用默认的 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>abcdefghijklmnopqrstuvwxyz<br>abcde<br>abcde<br>abcde<br></code></pre></td></tr></table></figure><hr><h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toJSON</span>()<br></code></pre></td></tr></table></figure><p>当字符串化一个 Buffer 实例时，<a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a> 会隐式地调用该 **toJSON()**。</p><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回 JSON 对象。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>]);<br><span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(buf);<br><br><span class="hljs-comment">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);<br><br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> value &amp;&amp; value.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;Buffer&#x27;</span> ?<br>    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(value.<span class="hljs-property">data</span>) :<br>    value;<br>&#125;);<br><br><span class="hljs-comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Buffer&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>:[1,2,3,4,5]&#125;<br>&lt;Buffer 01 02 03 04 05&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区合并的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(list[, totalLength])<br></code></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li><li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buffer1,buffer2]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer3 内容: &quot;</span> + buffer3.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer3 内容: 菜鸟教程www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">compare</span>(otherBuffer);<br></code></pre></td></tr></table></figure><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</li></ul><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个数字，表示 <strong>buf</strong> 在 <strong>otherBuffer</strong> 之前，之后或相同。</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>);<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>);<br><span class="hljs-keyword">var</span> result = buffer1.<span class="hljs-title function_">compare</span>(buffer2);<br><br><span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之前&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 与 &quot;</span> + buffer2 + <span class="hljs-string">&quot;相同&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之后&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ABC在ABCD之前<br></code></pre></td></tr></table></figure><hr><h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区拷贝语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">copy</span>(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])<br></code></pre></td></tr></table></figure><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</li><li><strong>targetStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>没有返回值。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abcdefghijkl&#x27;</span>);<br><span class="hljs-keyword">var</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);<br><br><span class="hljs-comment">//将 buf2 插入到 buf1 指定位置上</span><br>buf2.<span class="hljs-title function_">copy</span>(buf1, <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">abRUNOOBijkl<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">slice</span>([start[, end]])<br></code></pre></td></tr></table></figure><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>start</strong> - 数字, 可选, 默认: 0</li><li><strong>end</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>);<br><span class="hljs-comment">// 剪切缓冲区</span><br><span class="hljs-keyword">var</span> buffer2 = buffer1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer2 content: &quot;</span> + buffer2.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer2 content: ru<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区长度计算语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h3><p>返回 Buffer 对象所占据的内存长度。</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>);<br><span class="hljs-comment">//  缓冲区长度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer length: &quot;</span> + buffer.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer length: 14<br></code></pre></td></tr></table></figure><hr><h2 id="方法参考手册"><a href="#方法参考手册" class="headerlink" title="方法参考手册"></a>方法参考手册</h2><p>以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>new Buffer(size)</strong> 分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。废弃的: 使用 Buffer.alloc() 代替（或 Buffer.allocUnsafe()）。</td></tr><tr><td align="left">2</td><td align="left"><strong>new Buffer(buffer)</strong> 拷贝参数 buffer 的数据到 Buffer 实例。废弃的: 使用 Buffer.from(buffer) 代替。</td></tr><tr><td align="left">3</td><td align="left"><strong>new Buffer(str[, encoding])</strong> 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 废弃的: 使用 Buffer.from(string[, encoding]) 代替。</td></tr><tr><td align="left">4</td><td align="left"><strong>buf.length</strong> 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td></tr><tr><td align="left">5</td><td align="left"><strong>buf.write(string[, offset[, length]][, encoding])</strong> 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</td></tr><tr><td align="left">6</td><td align="left"><strong>buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如： <code>const buf = Buffer.allocUnsafe(6); buf.writeUIntLE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer ab 90 78 56 34 12&gt; console.log(buf);</code>noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">7</td><td align="left"><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。<code>const buf = Buffer.allocUnsafe(6); buf.writeUIntBE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer 12 34 56 78 90 ab&gt; console.log(buf);</code></td></tr><tr><td align="left">8</td><td align="left"><strong>buf.writeIntLE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">9</td><td align="left"><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">10</td><td align="left"><strong>buf.readUIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">11</td><td align="left"><strong>buf.readUIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">12</td><td align="left"><strong>buf.readIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">13</td><td align="left"><strong>buf.readIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">14</td><td align="left"><strong>buf.toString([encoding[, start[, end]]])</strong> 根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</td></tr><tr><td align="left">15</td><td align="left"><strong>buf.toJSON()</strong> 将 Buffer 实例转换为 JSON 对象。</td></tr><tr><td align="left">16</td><td align="left"><strong>buf[index]</strong> 获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td></tr><tr><td align="left">17</td><td align="left"><strong>buf.equals(otherBuffer)</strong> 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td></tr><tr><td align="left">18</td><td align="left"><strong>buf.compare(otherBuffer)</strong> 比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td></tr><tr><td align="left">19</td><td align="left"><strong>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</strong> buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td></tr><tr><td align="left">20</td><td align="left"><strong>buf.slice([start[, end]])</strong> 剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td></tr><tr><td align="left">21</td><td align="left"><strong>buf.readUInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">22</td><td align="left"><strong>buf.readUInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">23</td><td align="left"><strong>buf.readUInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">24</td><td align="left"><strong>buf.readUInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">25</td><td align="left"><strong>buf.readUInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">26</td><td align="left"><strong>buf.readInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">27</td><td align="left"><strong>buf.readInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">28</td><td align="left"><strong>buf.readInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">29</td><td align="left"><strong>buf.readInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">30</td><td align="left"><strong>buf.readInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">31</td><td align="left"><strong>buf.readFloatLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">32</td><td align="left"><strong>buf.readFloatBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">33</td><td align="left"><strong>buf.readDoubleLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">34</td><td align="left"><strong>buf.readDoubleBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">35</td><td align="left"><strong>buf.writeUInt8(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td></tr><tr><td align="left">36</td><td align="left"><strong>buf.writeUInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">37</td><td align="left"><strong>buf.writeUInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">38</td><td align="left"><strong>buf.writeUInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">39</td><td align="left"><strong>buf.writeUInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">40</td><td align="left"><strong>buf.writeInt8(value, offset[, noAssert])</strong></td></tr><tr><td align="left">41</td><td align="left"><strong>buf.writeInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">42</td><td align="left"><strong>buf.writeInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">43</td><td align="left"><strong>buf.writeInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">44</td><td align="left"><strong>buf.writeInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">45</td><td align="left"><strong>buf.writeFloatLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">46</td><td align="left"><strong>buf.writeFloatBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">47</td><td align="left"><strong>buf.writeDoubleLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">48</td><td align="left"><strong>buf.writeDoubleBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">49</td><td align="left"><strong>buf.fill(value[, offset][, end])</strong> 使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、NodeJs EventEmitter</title>
    <link href="/posts/42651/"/>
    <url>/posts/42651/</url>
    
    <content type="html"><![CDATA[<h1 id="二、NodeJs-EventEmitter"><a href="#二、NodeJs-EventEmitter" class="headerlink" title="二、NodeJs EventEmitter"></a>二、NodeJs EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>2 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br>1 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">node.js:201 <br>throw e; // process.nextTick error, or <span class="hljs-string">&#x27;error&#x27;</span> event on first tick <br>^ <br>Error: Uncaught, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at EventEmitter.emit (events.js:50:15) <br>at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) <br>at Module._compile (module.js:441:26) <br>at Object..js (module.js:459:10) <br>at Module.load (module.js:348:31) <br>at Function._load (module.js:308:12) <br>at Array.0 (module.js:479:10) <br>at EventEmitter._tickCallback (node.js:192:40) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、NodeJs 事件循环</title>
    <link href="/posts/17687/"/>
    <url>/posts/17687/</url>
    
    <content type="html"><![CDATA[<h1 id="一、NodeJs-事件循环"><a href="#一、NodeJs-事件循环" class="headerlink" title="一、NodeJs 事件循环"></a>一、NodeJs 事件循环</h1><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p><p>Node.js 几乎每一个 API 都是支持回调函数的。</p><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p><hr><h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><p><img src="/posts/17687/event_loop.jpg"></p><p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>以下程序绑定事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定事件及事件的处理程序</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, eventHandler);<br></code></pre></td></tr></table></figure><p>我们可以通过程序触发事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 触发事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建 main.js 文件，代码如下所示：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>&#x2F;&#x2F; 引入 events 模块 var events &#x3D; require(‘events’); &#x2F;&#x2F; 创建 eventEmitter 对象 var eventEmitter &#x3D; new events.EventEmitter();  &#x2F;&#x2F; 创建事件处理程序 var connectHandler &#x3D; function connected() {   console.log(‘连接成功。’);     &#x2F;&#x2F; 触发 data_received 事件    eventEmitter.emit(‘data_received’); }  &#x2F;&#x2F; 绑定 connection 事件处理程序 eventEmitter.on(‘connection’, connectHandler);  &#x2F;&#x2F; 使用匿名函数绑定 data_received 事件 eventEmitter.on(‘data_received’, function(){   console.log(‘数据接收成功。’); });  &#x2F;&#x2F; 触发 connection 事件  eventEmitter.emit(‘connection’);  console.log(“程序执行完毕。”);</p><p>接下来让我们执行以上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>连接成功。<br>数据接收成功。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p><p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>   <span class="hljs-keyword">if</span> (err)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p><p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p><p>执行以上代码，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>Error: ENOENT, open <span class="hljs-string">&#x27;input.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs基础</title>
    <link href="/posts/31322/"/>
    <url>/posts/31322/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Node-js是什么"><a href="#一、Node-js是什么" class="headerlink" title="一、Node.js是什么"></a>一、Node.js是什么</h1><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p><h3 id="1、特性"><a href="#1、特性" class="headerlink" title="1、特性"></a>1、特性</h3><p>Node.js 可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p><ul><li>文件的读写 (File System)</li><li>进程的管理 (Process)</li><li>网络通信 (HTTP&#x2F;HTTPS)</li><li>……</li></ul><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><h4 id="2-1-浏览器安全级别的限制"><a href="#2-1-浏览器安全级别的限制" class="headerlink" title="2.1 浏览器安全级别的限制"></a>2.1 浏览器安全级别的限制</h4><p><strong>Ajax测试</strong></p><p>浏览器访问存在跨域问题，所以以下的get请求无法成功！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#x27;</span>, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">send</span>()</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>浏览器预览</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">browser-sync start --server --files **/* --directory<br></code></pre></td></tr></table></figure><h4 id="2-2-文件的读写-File-System"><a href="#2-2-文件的读写-File-System" class="headerlink" title="2.2 文件的读写 (File System)"></a>2.2 文件的读写 (File System)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./ajax.png&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-3-进程的管理（Process）"><a href="#2-3-进程的管理（Process）" class="headerlink" title="2.3 进程的管理（Process）"></a>2.3 进程的管理（Process）</h4><p><strong>NodeJs可以通过process来获取执行命令中传入的参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(argv)<br>&#125;<br><br><span class="hljs-title function_">main</span>(process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node 2.3-process.js argv1 argv2<br></code></pre></td></tr></table></figure><h4 id="2-4-网络通信（HTTP-HTTPS）"><a href="#2-4-网络通信（HTTP-HTTPS）" class="headerlink" title="2.4 网络通信（HTTP&#x2F;HTTPS）"></a>2.4 网络通信（HTTP&#x2F;HTTPS）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span><br>  &#125;)<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;hello nodejs&quot;</span>)<br>  res.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h1 id="二、Node-相关工具"><a href="#二、Node-相关工具" class="headerlink" title="二、Node 相关工具"></a>二、Node 相关工具</h1><h3 id="1、NVM-Node-Version-Manager"><a href="#1、NVM-Node-Version-Manager" class="headerlink" title="1、NVM: Node Version Manager"></a>1、NVM: Node Version Manager</h3><p><strong>1.1 Mac 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/nvm-sh/nvm/blob/master/README.md<br></code></pre></td></tr></table></figure><p><strong>1.2 Windows 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm-windows<br>nodist<br></code></pre></td></tr></table></figure><h3 id="2、NPM-Node-Package-Manager"><a href="#2、NPM-Node-Package-Manager" class="headerlink" title="2、NPM: Node Package Manager"></a>2、NPM: Node Package Manager</h3><h4 id="2-1-全局安装package"><a href="#2-1-全局安装package" class="headerlink" title="2.1 全局安装package"></a>2.1 全局安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install forever --global (-g)<br>$ forever<br>$ npm uninstall forever --global<br>$ forever<br></code></pre></td></tr></table></figure><p><strong>全局安装包的目录</strong></p><ul><li>Mac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Users/felix/.nvm/versions/node/nvm各个版本/bin/<br></code></pre></td></tr></table></figure></li><li>Windows<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\你的用户名\AppData\Roaming\npm\node_modules<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-本地安装package"><a href="#2-2-本地安装package" class="headerlink" title="2.2 本地安装package"></a>2.2 本地安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/desktop<br>$ <span class="hljs-built_in">mkdir</span> gp-project<br>$ <span class="hljs-built_in">cd</span> gp-project<br>$ npm install underscore<br>$ npm list (<span class="hljs-built_in">ls</span>)<br></code></pre></td></tr></table></figure><h4 id="2-3-package-json初始化"><a href="#2-3-package-json初始化" class="headerlink" title="2.3 package.json初始化"></a>2.3 package.json初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm init -y<br>$ <span class="hljs-built_in">ls</span><br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-4-使用package-json"><a href="#2-4-使用package-json" class="headerlink" title="2.4 使用package.json"></a>2.4 使用package.json</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install underscore --save<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ npm install lodash --save-dev<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ <span class="hljs-built_in">rm</span> -rf node_modules<br>$ <span class="hljs-built_in">ls</span><br>$ npm install<br>$ npm uninstall underscore --save<br>$ npm list | grep underscore<br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-5-安装指定版本的包"><a href="#2-5-安装指定版本的包" class="headerlink" title="2.5 安装指定版本的包"></a>2.5 安装指定版本的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm list<br>$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.8.0<br>$ npm list<br>$ npm uninstall underscore<br>$ npm list<br></code></pre></td></tr></table></figure><h4 id="2-6-更新本地安装的包"><a href="#2-6-更新本地安装的包" class="headerlink" title="2.6 更新本地安装的包"></a>2.6 更新本地安装的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.4.4 --save-dev<br>$ npm list | grep gulp<br>$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本<br>$ npm list | grep gulp<br>$ npm update<br></code></pre></td></tr></table></figure><h4 id="2-7-清除缓存"><a href="#2-7-清除缓存" class="headerlink" title="2.7 清除缓存"></a>2.7 清除缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h4 id="2-8-上传自己的包"><a href="#2-8-上传自己的包" class="headerlink" title="2.8 上传自己的包"></a>2.8 上传自己的包</h4><h6 id="2-8-1-编写模块"><a href="#2-8-1-编写模块" class="headerlink" title="2.8.1 编写模块"></a>2.8.1 编写模块</h6><p>保存为index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span>; <br>&#125; <br></code></pre></td></tr></table></figure><h6 id="2-8-2-初始化包描述文件"><a href="#2-8-2-初始化包描述文件" class="headerlink" title="2.8.2 初始化包描述文件"></a>2.8.2 初始化包描述文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init <br></code></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19-npm&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.1&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19 self module&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make test&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Git&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git+https://github.com/lurongtao/gp19-npm.git&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>    <span class="hljs-string">&quot;demo&quot;</span> <br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Felixlu&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm/issues&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm#readme&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><h6 id="2-8-3-注册npm仓库账号"><a href="#2-8-3-注册npm仓库账号" class="headerlink" title="2.8.3 注册npm仓库账号"></a>2.8.3 注册npm仓库账号</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://www.npmjs.com 上面的账号<br>felix_lurt/qqmko09ijn<br>$ npm adduser<br></code></pre></td></tr></table></figure><h6 id="2-8-4-上传包"><a href="#2-8-4-上传包" class="headerlink" title="2.8.4 上传包"></a>2.8.4 上传包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm publish<br></code></pre></td></tr></table></figure><p>坑：403 Forbidden</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看npm源：npm config get registry<br>切换npm源方法一：npm config <span class="hljs-built_in">set</span> registry http://registry.npmjs.org<br>切换npm源方法二：nrm use npm<br></code></pre></td></tr></table></figure><h6 id="2-8-5-安装包"><a href="#2-8-5-安装包" class="headerlink" title="2.8.5 安装包"></a>2.8.5 安装包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install gp19-npm<br></code></pre></td></tr></table></figure><h6 id="2-8-6-卸载包"><a href="#2-8-6-卸载包" class="headerlink" title="2.8.6 卸载包"></a>2.8.6 卸载包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看当前项目引用了哪些包 ：<br>npm <span class="hljs-built_in">ls</span><br>卸载包：<br>npm unpublish --force<br></code></pre></td></tr></table></figure><h6 id="2-8-7-使用引入包"><a href="#2-8-7-使用引入包" class="headerlink" title="2.8.7 使用引入包"></a>2.8.7 使用引入包</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gp19-npm&#x27;</span>)<br>hello.<span class="hljs-title function_">sayHello</span>()<br></code></pre></td></tr></table></figure><h4 id="2-9-npm-脚本"><a href="#2-9-npm-脚本" class="headerlink" title="2.9 npm 脚本"></a>2.9 npm 脚本</h4><p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。</p><p><strong>一、什么是 npm 脚本？</strong></p><p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node build.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>二、执行顺序</strong></p><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><p>script1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br></code></pre></td></tr></table></figure><p>script2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y)<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script1.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;script2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script2.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果是并行执行（即同时的平行执行），可以使用 <code>&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp; npm run script2<br></code></pre></td></tr></table></figure><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用 <code>&amp;&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp;&amp; npm run script2<br></code></pre></td></tr></table></figure><p><strong>三、简写形式</strong></p><p>常用的 npm 脚本简写形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm start 是 npm run start<br></code></pre></td></tr></table></figure><p><strong>四、变量</strong></p><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p><p>首先，通过 <code>npm_package_</code> 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。</p><blockquote><p>注意：一定要在 npm 脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到值的</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.2.5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node view.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回 1.2.5。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// view.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>); <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>); <span class="hljs-comment">// 1.2.5</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用$npm_package_name 和 $npm_package_version 取到这两个值。</p><p>npm_package_前缀也支持嵌套的package.json字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>scripts<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_package_repository_type&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。</p><p>下面是另外一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_scripts_install 变量的值等于 foo.js。</p><p>然后，npm 脚本还可以通过 npm_config_ 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_config_tag&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>注意，package.json 里面的 config 对象，可以被环境变量覆盖。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;config&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;port&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;start&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node server.js&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_config_port 变量返回的是 8080。这个值可以用下面的方法覆盖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> foo:port 80<br></code></pre></td></tr></table></figure><p>最后，env命令可以列出所有环境变量。</p><p>“env”: “env”</p><h4 id="2-10-npm-安装-git-上发布的包"><a href="#2-10-npm-安装-git-上发布的包" class="headerlink" title="2.10 npm 安装 git 上发布的包"></a>2.10 npm 安装 git 上发布的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这样适合安装公司内部的git服务器上的项目</span><br>npm install git+https://git@github.com:lurongtao/gp-project.git<br><br><span class="hljs-comment"># 或者以ssh的方式</span><br>npm install git+ssh://git@github.com:lurongtao/gp-project.git<br></code></pre></td></tr></table></figure><h4 id="2-11-cross-env-使用"><a href="#2-11-cross-env-使用" class="headerlink" title="2.11 cross-env 使用"></a>2.11 cross-env 使用</h4><h5 id="2-11-1-cross-env是什么"><a href="#2-11-1-cross-env是什么" class="headerlink" title="2.11.1 cross-env是什么"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p><h5 id="2-11-2-出现原因"><a href="#2-11-2-出现原因" class="headerlink" title="2.11.2 出现原因"></a>2.11.2 出现原因</h5><p>当您使用 NODE_ENV&#x3D;production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows 不支持 NODE_ENV&#x3D;production 的设置方式。</p><h5 id="2-11-3-解决"><a href="#2-11-3-解决" class="headerlink" title="2.11.3 解决"></a>2.11.3 解决</h5><p>cross-env 使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包(cross-env)能够提供一个设置环境变量的 scripts，让你能够以 Unix 方式设置环境变量，然后在 Windows 上也能兼容运行。</p><h5 id="2-11-4-安装"><a href="#2-11-4-安装" class="headerlink" title="2.11.4 安装"></a>2.11.4 安装</h5><p>npm install –save-dev cross-env</p><h5 id="2-11-5-使用"><a href="#2-11-5-使用" class="headerlink" title="2.11.5 使用"></a>2.11.5 使用</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>NODE_ENV环境变量将由 cross-env 设置<br>打印 process.env.NODE_ENV &#x3D;&#x3D;&#x3D; ‘production’</p><h3 id="3、NRM-npm-registry-manager"><a href="#3、NRM-npm-registry-manager" class="headerlink" title="3、NRM: npm registry manager"></a>3、NRM: npm registry manager</h3><h4 id="3-1-手工切换源"><a href="#3-1-手工切换源" class="headerlink" title="3.1 手工切换源"></a>3.1 手工切换源</h4><h5 id="3-1-1-查看当前源"><a href="#3-1-1-查看当前源" class="headerlink" title="3.1.1 查看当前源"></a>3.1.1 查看当前源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h5 id="3-1-2-切换淘宝源"><a href="#3-1-2-切换淘宝源" class="headerlink" title="3.1.2 切换淘宝源"></a>3.1.2 切换淘宝源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h4 id="3-2-NRM-管理源"><a href="#3-2-NRM-管理源" class="headerlink" title="3.2 NRM 管理源"></a>3.2 NRM 管理源</h4><p>NRM (npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h5 id="3-2-1-安装-nrm"><a href="#3-2-1-安装-nrm" class="headerlink" title="3.2.1 安装 nrm"></a>3.2.1 安装 nrm</h5><p>在命令行执行命令，npm install -g nrm，全局安装nrm。</p><h5 id="3-2-2-使用-nrm"><a href="#3-2-2-使用-nrm" class="headerlink" title="3.2.2 使用 nrm"></a>3.2.2 使用 nrm</h5><p>执行命令 nrm ls 查看可选的源。<br>其中，带*的是当前使用的源，上面的输出表明当前源是官方源。</p><h5 id="3-2-3-切换-nrm"><a href="#3-2-3-切换-nrm" class="headerlink" title="3.2.3 切换 nrm"></a>3.2.3 切换 nrm</h5><p>如果要切换到taobao源，执行命令nrm use taobao。</p><h5 id="3-2-4-测试速度"><a href="#3-2-4-测试速度" class="headerlink" title="3.2.4 测试速度"></a>3.2.4 测试速度</h5><p>你还可以通过 nrm test 测试相应源的响应时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nrm <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="4、NPX-npm-package-extention"><a href="#4、NPX-npm-package-extention" class="headerlink" title="4、NPX: npm package extention"></a>4、NPX: npm package extention</h3><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g npx<br></code></pre></td></tr></table></figure><h4 id="4-1-调用项目安装的模块"><a href="#4-1-调用项目安装的模块" class="headerlink" title="4.1 调用项目安装的模块"></a>4.1 调用项目安装的模块</h4><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -D mocha<br></code></pre></td></tr></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 项目的根目录下执行</span><br>$ <span class="hljs-keyword">node</span><span class="hljs-title">-modules</span>/.bin/mocha --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx mocha <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于 <span class="hljs-built_in">ls</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npx <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。</p><h4 id="4-2-避免全局安装模块"><a href="#4-2-避免全局安装模块" class="headerlink" title="4.2 避免全局安装模块"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app 这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">npx</span> <span class="hljs-built_in">create-react-app</span> <span class="hljs-string">my-react-app</span><br></code></pre></td></tr></table></figure><p>上面代码运行时，npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ npx http-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="4-3-–no-install-参数和-–ignore-existing-参数"><a href="#4-3-–no-install-参数和-–ignore-existing-参数" class="headerlink" title="4.3 –no-install 参数和 –ignore-existing 参数"></a>4.3 –no-install 参数和 –ignore-existing 参数</h4><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> npx --<span class="hljs-keyword">no</span>-install http-server<br></code></pre></td></tr></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx <span class="hljs-comment">--ignore-existing http-server</span><br></code></pre></td></tr></table></figure><h1 id="三、模块-包-与-CommonJS"><a href="#三、模块-包-与-CommonJS" class="headerlink" title="三、模块&#x2F;包 与 CommonJS"></a>三、模块&#x2F;包 与 CommonJS</h1><h3 id="1、模块-包分类"><a href="#1、模块-包分类" class="headerlink" title="1、模块&#x2F;包分类"></a>1、模块&#x2F;包分类</h3><p>Node.js 有三类模块，即内置的模块、第三方的模块、自定义的模块。</p><h4 id="1-1-内置的模块"><a href="#1-1-内置的模块" class="headerlink" title="1.1 内置的模块"></a>1.1 内置的模块</h4><p>Node.js 内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> extname = path.<span class="hljs-title function_">extname</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(extname)<br></code></pre></td></tr></table></figure><h4 id="1-2-第三方的Node-js模块"><a href="#1-2-第三方的Node-js模块" class="headerlink" title="1.2 第三方的Node.js模块"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> chalk<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chalk&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">blue</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="1-3-自定义的Node-js模块"><a href="#1-3-自定义的Node-js模块" class="headerlink" title="1.3 自定义的Node.js模块"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p><p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p><h5 id="1-3-1-模块定义、接口暴露和引用接口"><a href="#1-3-1-模块定义、接口暴露和引用接口" class="headerlink" title="1.3.1 模块定义、接口暴露和引用接口"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能 抽离成为一个单独的 js  文件 作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。</p><p>m1.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;gp19&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayName</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module 1&#x27;</span>)<br><br><span class="hljs-comment">// 接口暴露方法一：</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br><br><span class="hljs-comment">// 接口暴露方法二：</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">say</span> = sayName<br><br><span class="hljs-comment">// 错误！</span><br><span class="hljs-built_in">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br></code></pre></td></tr></table></figure><p>main.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./m1&#x27;</span>)<br>m1.<span class="hljs-title function_">say</span>()<br></code></pre></td></tr></table></figure><h5 id="1-3-2-模块的循环引用"><a href="#1-3-2-模块的循环引用" class="headerlink" title="1.3.2 模块的循环引用"></a>1.3.2 模块的循环引用</h5><p>由于 exports 使用方式方式不对，会在两个不同 js 循环引用的情况下，导致其中一个 js 无法获取另外一个 js 的方法，从而导致执行报错。如：</p><ul><li>a.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in a, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>b.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b starting&#x27;</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in b, a.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;main starting&#x27;</span>)<br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in main, a.done = %j, b.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>, b.<span class="hljs-property">done</span>)<br></code></pre></td></tr></table></figure><p>main.js 首先会 load a.js, 此时执行到const b &#x3D; require(‘.&#x2F;b.js’);的时候，程序会转去loadb.js, 在b.js中执行到const a &#x3D; require(‘.&#x2F;a.js’); 为了防止无限循环，将a.jsexports的未完成副本返回到b.js模块。然后b.js完成加载，并将其导出对象提供给a.js模块。</p><p>我们知道nodeJs的对每个js文件进行了一层包装称为module，module中有一个属性exports，当调用require(‘a.js’)的时候其实返回的是module.exports对象，module.exports初始化为一个{}空的object，所以在上面的例子中，执行到b.js中const a &#x3D; require(‘.&#x2F;a.js’);时不会load新的a module, 而是将已经load但是还未完成的a module的exports属性返回给b module，所以b.js拿到的是a module的exports对象，即：{done:false}, 虽然在a.js中exports.done被修改成了true，但是由于此时a.js未load完成，所以在b.js输出的a module的属性done为false，而在main.js中输出的a module的属性done为true. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。 </p><h1 id="四、常用内置模块"><a href="#四、常用内置模块" class="headerlink" title="四、常用内置模块"></a>四、常用内置模块</h1><p>这里介绍几个常用的内置模块：url, querystring, http, events, fs, stream, readline, crypto, zlib</p><h3 id="1、url"><a href="#1、url" class="headerlink" title="1、url"></a>1、url</h3><h4 id="1-1-parse"><a href="#1-1-parse" class="headerlink" title="1.1 parse"></a>1.1 parse</h4><p>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlString = <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br><span class="hljs-keyword">const</span> parsedStr = url.<span class="hljs-title function_">parse</span>(urlString)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedStr)<br></code></pre></td></tr></table></figure><h4 id="1-2-format"><a href="#1-2-format" class="headerlink" title="1.2 format"></a>1.2 format</h4><p>url.format(urlObject)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlObject = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">slashes</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">auth</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;www.baidu.com:443&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;443&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;www.baidu.com&#x27;</span>,<br>  <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#tag=110&#x27;</span>,<br>  <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mouse&#x27;</span> &#125;,<br>  <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/ad/index.html&#x27;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/ad/index.html?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> parsedObj = url.<span class="hljs-title function_">format</span>(urlObject)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedObj)<br></code></pre></td></tr></table></figure><h4 id="1-3-resolve"><a href="#1-3-resolve" class="headerlink" title="1.3 resolve"></a>1.3 resolve</h4><p>url.resolve(from, to)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">var</span> a = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/one/two/three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>)<br><span class="hljs-keyword">var</span> b = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/&#x27;</span>, <span class="hljs-string">&#x27;/one&#x27;</span>)<br><span class="hljs-keyword">var</span> c = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/one&#x27;</span>, <span class="hljs-string">&#x27;/two&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-string">&quot;,&quot;</span> + b + <span class="hljs-string">&quot;,&quot;</span> + c)<br></code></pre></td></tr></table></figure><h3 id="2、querystring"><a href="#2、querystring" class="headerlink" title="2、querystring"></a>2、querystring</h3><h4 id="2-1-parse"><a href="#2-1-parse" class="headerlink" title="2.1 parse"></a>2.1 parse</h4><p>querystring.parse(str[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qs = <span class="hljs-string">&#x27;x=3&amp;y=4&#x27;</span><br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">parse</span>(qs)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-2-stringify"><a href="#2-2-stringify" class="headerlink" title="2.2 stringify"></a>2.2 stringify</h4><p>querystring.stringify(obj[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qo = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">stringify</span>(qo)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-3-escape-unescape"><a href="#2-3-escape-unescape" class="headerlink" title="2.3 escape&#x2F;unescape"></a>2.3 escape&#x2F;unescape</h4><p>querystring.escape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id=3&amp;city=北京&amp;url=https://www.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> escaped = querystring.<span class="hljs-built_in">escape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(escaped)<br></code></pre></td></tr></table></figure><p>querystring.unescape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> unescaped = querystring.<span class="hljs-built_in">unescape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unescaped)<br></code></pre></td></tr></table></figure><h3 id="3、http-https"><a href="#3、http-https" class="headerlink" title="3、http&#x2F;https"></a>3、http&#x2F;https</h3><h4 id="3-1-get"><a href="#3-1-get" class="headerlink" title="3.1 get"></a>3.1 get</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><br><span class="hljs-comment">// 1、接口 2、跨域</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">var</span> url = request.<span class="hljs-property">url</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br>  <br>  <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span><br><br>  response.<span class="hljs-title function_">writeHeader</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  https.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://m.lagou.com/listmore.json<span class="hljs-subst">$&#123;url&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>        <span class="hljs-attr">ret</span>: <span class="hljs-literal">true</span>,<br>        data<br>      &#125;))<br>    &#125;)<br>  &#125;)<br><br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-post：服务器提交（攻击）"><a href="#3-2-post：服务器提交（攻击）" class="headerlink" title="3.2 post：服务器提交（攻击）"></a>3.2 post：服务器提交（攻击）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> postData = querystring.<span class="hljs-title function_">stringify</span>(&#123;<br>  <span class="hljs-attr">province</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">district</span>: <span class="hljs-string">&#x27;宝山区&#x27;</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;同济支路199号智慧七立方3号楼2-4层&#x27;</span>,<br>  <span class="hljs-attr">latitude</span>: <span class="hljs-number">43.0</span>,<br>  <span class="hljs-attr">longitude</span>: <span class="hljs-number">160.0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;求购一条小鱼&#x27;</span>,<br>  <span class="hljs-attr">contact</span>: <span class="hljs-string">&#x27;13666666&#x27;</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>  <span class="hljs-attr">time</span>: <span class="hljs-number">1571217561</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;ik9hkddr.qcloud.la&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index.php/trade/add_item&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(postData)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doPost</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> data<br>  <br>  <span class="hljs-keyword">let</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> data += chunk)<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  req.<span class="hljs-title function_">write</span>(postData)<br>  req.<span class="hljs-title function_">end</span>()<br>&#125;<br><br><span class="hljs-comment">// setInterval(() =&gt; &#123;</span><br><span class="hljs-comment">//   doPost()</span><br><span class="hljs-comment">// &#125;, 1000)</span><br></code></pre></td></tr></table></figure><h4 id="3-3-跨域：jsonp"><a href="#3-3-跨域：jsonp" class="headerlink" title="3.3 跨域：jsonp"></a>3.3 跨域：jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/user&#x27;</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;urlObj.query.cb&#125;</span>(&#123;&quot;name&quot;: &quot;gp145&quot;&#125;)`</span>)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-4-跨域：CORS"><a href="#3-4-跨域：CORS" class="headerlink" title="3.4 跨域：CORS"></a>3.4 跨域：CORS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    data += chunk<br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">responseResult</span>(querystring.<span class="hljs-title function_">parse</span>(data))<br>  &#125;)<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">responseResult</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/login&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>          <span class="hljs-attr">message</span>: data<br>        &#125;))<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-5-跨域：middleware（http-proxy-middware）"><a href="#3-5-跨域：middleware（http-proxy-middware）" class="headerlink" title="3.5 跨域：middleware（http-proxy-middware）"></a>3.5 跨域：middleware（http-proxy-middware）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> url = req.<span class="hljs-property">url</span><br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\/api/</span>.<span class="hljs-title function_">test</span>(url)) &#123;<br>    <span class="hljs-keyword">let</span> apiProxy = <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123; <br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://m.lagou.com&#x27;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;)<br>  <br>    <span class="hljs-comment">// http-proy-middleware 在Node.js中使用的方法</span><br>    <span class="hljs-title function_">apiProxy</span>(req, res)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">switch</span> (url) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/search.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;search.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;[404]page not found.&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>)<br></code></pre></td></tr></table></figure><h4 id="3-6-爬虫"><a href="#3-6-爬虫" class="headerlink" title="3.6 爬虫"></a>3.6 爬虫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> options = &#123;<br>    <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>    <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;maoyan.com&#x27;</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br>  <br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">filterData</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterData</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> $ = cheerio.<span class="hljs-title function_">load</span>(data)<br>    <span class="hljs-keyword">let</span> $movieList = $(<span class="hljs-string">&#x27;.movie-item&#x27;</span>)<br>    <span class="hljs-keyword">let</span> movies = []<br>    $movieList.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, value</span>) =&gt;</span> &#123;<br>      movies.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">title</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-title&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;title&#x27;</span>),<br>        <span class="hljs-attr">score</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-score i&#x27;</span>).<span class="hljs-title function_">text</span>(),<br>      &#125;)<br>    &#125;)<br>    <br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(movies))<br>  &#125;<br>  <br>  req.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>)<br></code></pre></td></tr></table></figure><h3 id="4、Events"><a href="#4、Events" class="headerlink" title="4、Events"></a>4、Events</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEventEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEventEmitter</span>()<br><br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">movie</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movie)<br>&#125;)<br><br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;我和我的祖国&#x27;</span>)<br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;中国机长&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="5、File-System"><a href="#5、File-System" class="headerlink" title="5、File System"></a>5、File System</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> fsP = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-property">promises</span><br><br><span class="hljs-comment">// 创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 文件夹改名</span><br>fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 写内容到文件里</span><br>fs.<span class="hljs-title function_">writeFile</span>(<br>  <span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>,<br>  <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  <span class="hljs-comment">// 错误优先的回调函数</span><br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件创建成功&#x27;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-comment">// 给文件追加内容</span><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;\nworld&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 读取文件内容</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件</span><br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 批量写文件</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">`./logs/log-<span class="hljs-subst">$&#123;i&#125;</span>.txt`</span>, <span class="hljs-string">`log-<span class="hljs-subst">$&#123;i&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 读取文件/目录信息</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;value&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// console.log(value + &#x27;:&#x27; + stats.size)</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value + <span class="hljs-string">&#x27; is &#x27;</span> + (stats.<span class="hljs-title function_">isDirectory</span>() ? <span class="hljs-string">&#x27;directory&#x27;</span> : <span class="hljs-string">&#x27;file&#x27;</span>))<br>    &#125;)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 同步读取文件</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">message</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法一</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法二</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-comment">// 异步读取文件：方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>;(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">getFile</span>())<br>&#125;)()<br><br><span class="hljs-comment">// 异步读取文件：方法四</span><br><span class="hljs-keyword">const</span> fsp = fsP.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fsP)<br><br><span class="hljs-comment">// watch 监测文件变化</span><br>fs.<span class="hljs-title function_">watch</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6、Stream"><a href="#6、Stream" class="headerlink" title="6、Stream"></a>6、Stream</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="7、Zlib"><a href="#7、Zlib" class="headerlink" title="7、Zlib"></a>7、Zlib</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>)<br><br><span class="hljs-keyword">const</span> gzip = zlib.<span class="hljs-title function_">createGzip</span>()<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>readstream<br>  .<span class="hljs-title function_">pipe</span>(gzip)<br>  .<span class="hljs-title function_">pipe</span>(writestream)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="8、ReadLine"><a href="#8、ReadLine" class="headerlink" title="8、ReadLine"></a>8、ReadLine</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;readline&#x27;</span>)<br><br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span><br>&#125;)<br><br>rl.<span class="hljs-title function_">question</span>(<span class="hljs-string">&#x27;What do you think of Node.js? &#x27;</span>, <span class="hljs-function">(<span class="hljs-params">answer</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Log the answer in a database</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Thank you for your valuable feedback: <span class="hljs-subst">$&#123;answer&#125;</span>`</span>)<br><br>  rl.<span class="hljs-title function_">close</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9、Crypto"><a href="#9、Crypto" class="headerlink" title="9、Crypto"></a>9、Crypto</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&#x27;abcdefg&#x27;</span><br><span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, secret)<br>                   .<span class="hljs-title function_">update</span>(<span class="hljs-string">&#x27;I love you&#x27;</span>)<br>                   .<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash)<br></code></pre></td></tr></table></figure><h1 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> req, res </span>) &#123;<br><br>  <span class="hljs-keyword">switch</span> ( req.<span class="hljs-property">url</span> ) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/home&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;home&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/mine&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;mine&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/login&#x27;</span>: <br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/login.html&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span> ( error ) <span class="hljs-keyword">throw</span> error  <br>        res.<span class="hljs-title function_">write</span>( data )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/fulian.jpg&#x27;</span>:<br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/fulian.jpg&#x27;</span>, <span class="hljs-string">&#x27;binary&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span>( error ) <span class="hljs-keyword">throw</span> error <br>        res.<span class="hljs-title function_">write</span>( data, <span class="hljs-string">&#x27;binary&#x27;</span> )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>: <br>      <span class="hljs-keyword">break</span><br>   &#125;<br><br> &#125;).<span class="hljs-title function_">listen</span>( <span class="hljs-number">8000</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;服务器运行在： http://localhost:8000&#x27;</span> )<br> &#125;)<br></code></pre></td></tr></table></figure><h1 id="五、静态资源服务"><a href="#五、静态资源服务" class="headerlink" title="五、静态资源服务"></a>五、静态资源服务</h1><h3 id="5-1-readStaticFile"><a href="#5-1-readStaticFile" class="headerlink" title="5.1 readStaticFile"></a>5.1 readStaticFile</h3><p>&#x2F;modules&#x2F;readStaticFile.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入依赖的模块</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">var</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mime&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readStaticFile</span>(<span class="hljs-params">res, filePathname</span>) &#123;<br><br>  <span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">parse</span>(filePathname).<span class="hljs-property">ext</span><br>  <span class="hljs-keyword">var</span> mimeType = mime.<span class="hljs-title function_">getType</span>(ext)<br><br>  <span class="hljs-comment">// 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 </span><br>  <span class="hljs-keyword">if</span> (ext) &#123;<br>    <span class="hljs-comment">// 根据传入的目标文件路径来读取对应文件</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePathname, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;)<br>        res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;404 - NOT FOUND&quot;</span>)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: mimeType &#125;)<br>        res.<span class="hljs-title function_">write</span>(data)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 返回 true 表示, 客户端想要的 是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 返回 false 表示, 客户端想要的 不是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = readStaticFile<br></code></pre></td></tr></table></figure><h3 id="5-2-server"><a href="#5-2-server" class="headerlink" title="5.2 server"></a>5.2 server</h3><p>&#x2F;server.js </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入相关模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">var</span> readStaticFile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/readStaticFile&#x27;</span>);<br><br><span class="hljs-comment">// 搭建 HTTP 服务器</span><br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">var</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>);<br>  <span class="hljs-keyword">var</span> urlPathname = urlObj.<span class="hljs-property">pathname</span>;<br>  <span class="hljs-keyword">var</span> filePathname = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/public&quot;</span>, urlPathname);<br><br>  <span class="hljs-comment">// 读取静态文件</span><br>  <span class="hljs-title function_">readStaticFile</span>(res, filePathname);<br>&#125;);<br><br><span class="hljs-comment">// 在 3000 端口监听请求</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器运行中.&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;正在监听 3000 端口:&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NPM详解-从基础到高级的全面教程</title>
    <link href="/posts/46482/"/>
    <url>/posts/46482/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-详解：从基础到高级的全面教程"><a href="#NPM-详解：从基础到高级的全面教程" class="headerlink" title="NPM 详解：从基础到高级的全面教程"></a>NPM 详解：从基础到高级的全面教程</h1><p>NPM (Node Package Manager) 是 Node.js 的默认包管理工具，用于管理项目中的依赖包。作为前端开发和后端开发的重要工具，NPM 的作用不仅仅是安装包，它还包含很多实用的功能，如版本管理、脚本执行和发布包等。在这篇文章中，我们将深入探讨 NPM 的各个方面，帮助你从基础知识开始，到掌握一些高级用法。</p><h1 id="1-NPM-的基础知识"><a href="#1-NPM-的基础知识" class="headerlink" title="1. NPM 的基础知识"></a>1. NPM 的基础知识</h1><h2 id="1-1-什么是-NPM？"><a href="#1-1-什么是-NPM？" class="headerlink" title="1.1 什么是 NPM？"></a>1.1 什么是 NPM？</h2><p>NPM 是 Node.js 的包管理工具，它允许开发者从 NPM 的注册库中下载和分享代码包。NPM 解决了依赖管理问题，使得开发者不必重复造轮子，可以直接安装他人写好的功能模块。</p><ul><li><strong>Registry</strong>: NPM 注册库中存储了海量的开源包。</li><li><strong>Package</strong>: 每个 NPM 包都是一个独立的模块，通常包含一个 <code>package.json</code> 文件，用于描述包的信息和依赖关系。</li></ul><h2 id="1-2-NPM-的安装与配置"><a href="#1-2-NPM-的安装与配置" class="headerlink" title="1.2 NPM 的安装与配置"></a>1.2 NPM 的安装与配置</h2><p>Node.js 安装包中已经包含了 NPM，因此只要安装了 Node.js，就可以使用 NPM。你可以通过以下命令查看 NPM 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm -v<br></code></pre></td></tr></table></figure><p>可以通过 <code>npm config</code> 来查看或设置 NPM 的全局配置。常见的配置有：</p><ul><li><strong>设置 NPM 源</strong>：可以设置使用国内镜像源，如 <code>淘宝镜像</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><ul><li><strong>查看配置</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config list<br></code></pre></td></tr></table></figure><h1 id="2-package-json"><a href="#2-package-json" class="headerlink" title="2.package.json"></a>2.package.json</h1><p><code>package.json</code> 文件是 Node.js 项目的核心配置文件，它记录了项目的元信息和依赖包。我们可以通过 <code>npm init</code> 来创建一个新的 <code>package.json</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br></code></pre></td></tr></table></figure><p>常见字段包括：</p><ul><li><code>name</code>: 项目名称。</li><li><code>version</code>: 项目版本。</li><li><code>scripts</code>: 项目脚本，便于执行一些常见的任务。</li><li><code>dependencies</code>: 项目的运行时依赖包。</li><li><code>devDependencies</code>: 项目的开发时依赖包。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-package-json-的核心字段"><a href="#2-1-package-json-的核心字段" class="headerlink" title="2.1 package.json 的核心字段"></a>2.1 package.json 的核心字段</h2><h3 id="2-1-1-name-包名"><a href="#2-1-1-name-包名" class="headerlink" title="2.1.1 name (包名)"></a>2.1.1 <code>name</code> (包名)</h3><p><code>name</code> 定义了项目的名称。这个名称必须唯一，且在 NPM 注册库中有效。</p><ul><li><p>要求</p><p>：</p><ul><li>必须是小写字母，允许包含连字符（<code>-</code>）或下划线（<code>_</code>）。</li><li>长度应少于 214 个字符。</li><li>不能以 <code>.</code> 或 <code>_</code> 开头。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-version-版本号"><a href="#2-1-2-version-版本号" class="headerlink" title="2.1.2 version (版本号)"></a>2.1.2 <code>version</code> (版本号)</h3><p><code>version</code> 字段遵循 语义化版本规范（SemVer），表示当前包的版本号。常见的版本号格式为 <code>x.y.z</code>：</p><ul><li><code>x</code>: 主版本号，非兼容性 API 变更。</li><li><code>y</code>: 次版本号，向下兼容的新功能。</li><li><code>z</code>: 修订号，向下兼容的错误修复。</li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-3-description-描述"><a href="#2-1-3-description-描述" class="headerlink" title="2.1.3 description (描述)"></a>2.1.3 <code>description</code> (描述)</h3><p><code>description</code> 用于提供包的简短描述，通常会显示在 NPM 页面上，帮助用户快速了解包的功能。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample Node.js project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-4-keywords-关键词"><a href="#2-1-4-keywords-关键词" class="headerlink" title="2.1.4 keywords (关键词)"></a>2.1.4 <code>keywords</code> (关键词)</h3><p><code>keywords</code> 字段是一个字符串数组，帮助开发者通过关键词在 NPM 上搜索到这个包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;API&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-5-homepage-主页"><a href="#2-1-5-homepage-主页" class="headerlink" title="2.1.5 homepage (主页)"></a>2.1.5 <code>homepage</code> (主页)</h3><p>定义项目的主页 URL，通常是项目的官方文档或 GitHub 页面。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-6-license-许可证"><a href="#2-1-6-license-许可证" class="headerlink" title="2.1.6 license (许可证)"></a>2.1.6 <code>license</code> (许可证)</h3><p><code>license</code> 表示项目的许可证类型，用来告知用户如何合法使用代码。常见的值如：<code>MIT</code>、<code>ISC</code>、<code>GPL-3.0</code> 等。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-7-author-作者"><a href="#2-1-7-author-作者" class="headerlink" title="2.1.7 author (作者)"></a>2.1.7 <code>author</code> (作者)</h3><p><code>author</code> 用来描述包的作者信息，可以是一个简单的字符串，也可以包括更多的详细信息。</p><ul><li><strong>简单形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>详细形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john@example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://john.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-8-contributors-贡献者"><a href="#2-1-8-contributors-贡献者" class="headerlink" title="2.1.8 contributors (贡献者)"></a>2.1.8 <code>contributors</code> (贡献者)</h3><p>这个字段记录了项目的贡献者，形式与 <code>author</code> 类似，可以包含多个人。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;contributors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane Smith&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jane@example.com&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-依赖管理"><a href="#2-2-依赖管理" class="headerlink" title="2.2 依赖管理"></a>2.2 依赖管理</h2><h3 id="2-2-1-dependencies-运行时依赖"><a href="#2-2-1-dependencies-运行时依赖" class="headerlink" title="2.2.1 dependencies (运行时依赖)"></a>2.2.1 <code>dependencies</code> (运行时依赖)</h3><p><code>dependencies</code> 用于定义项目在运行时所依赖的包。NPM 会根据此字段安装这些依赖。</p><ul><li><strong>格式</strong>：<code>包名: 版本范围</code></li><li><strong>版本范围符号</strong>：<ul><li><code>^1.0.0</code>：允许安装 1.x.x 的任何更新。</li><li><code>~1.0.0</code>：允许安装 1.0.x 的更新。</li><li><code>1.0.0</code>：锁定版本，不允许更新。</li><li><code>*</code>：任何版本。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-2-devDependencies-开发时依赖"><a href="#2-2-2-devDependencies-开发时依赖" class="headerlink" title="2.2.2 devDependencies (开发时依赖)"></a>2.2.2 <code>devDependencies</code> (开发时依赖)</h3><p><code>devDependencies</code> 记录的是仅在开发环境下需要的依赖包，比如测试框架、构建工具等。这些依赖不会在生产环境中安装。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-peerDependencies-同伴依赖"><a href="#2-2-3-peerDependencies-同伴依赖" class="headerlink" title="2.2.3 peerDependencies (同伴依赖)"></a>2.2.3 <code>peerDependencies</code> (同伴依赖)</h3><p><code>peerDependencies</code> 用于定义包与项目的兼容性要求，常用于插件开发，要求项目必须安装特定版本的某些包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;peerDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=16.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-4-optionalDependencies-可选依赖"><a href="#2-2-4-optionalDependencies-可选依赖" class="headerlink" title="2.2.4 optionalDependencies (可选依赖)"></a>2.2.4 <code>optionalDependencies</code> (可选依赖)</h3><p><code>optionalDependencies</code> 表示非强制安装的依赖，如果安装失败，项目依然可以继续运行。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;optionalDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fsevents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-bundledDependencies-打包依赖"><a href="#2-2-5-bundledDependencies-打包依赖" class="headerlink" title="2.2.5 bundledDependencies (打包依赖)"></a>2.2.5 <code>bundledDependencies</code> (打包依赖)</h3><p><code>bundledDependencies</code> 表示需要一起打包发布的依赖包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bundledDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;lodash&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-NPM-脚本-scripts"><a href="#2-3-NPM-脚本-scripts" class="headerlink" title="2.3 NPM 脚本 (scripts)"></a>2.3 NPM 脚本 (<code>scripts</code>)</h2><p><code>scripts</code> 字段可以定义各种自定义命令和自动化任务。每个脚本可以通过 <code>npm run &lt;script&gt;</code> 来运行。</p><h3 id="2-3-1-基本脚本"><a href="#2-3-1-基本脚本" class="headerlink" title="2.3.1 基本脚本"></a>2.3.1 基本脚本</h3><ul><li><strong>start</strong>：默认启动脚本。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test</strong>：通常用于执行测试。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-自定义脚本"><a href="#2-3-2-自定义脚本" class="headerlink" title="2.3.2 自定义脚本"></a>2.3.2 自定义脚本</h3><p>你可以定义任意名称的脚本，并通过 <code>npm run &lt;script-name&gt;</code> 执行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-4-使用变量"><a href="#2-4-使用变量" class="headerlink" title="2.4 使用变量"></a>2.4 使用变量</h2><p>NPM 允许在脚本中使用变量，如环境变量。通常通过 <code>process.env</code> 读取：</p><ul><li><strong>在脚本中使用环境变量</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>跨平台支持</strong>：为了兼容 Windows 系统，使用 <a href="https://www.npmjs.com/package/cross-env">cross-env</a> 包来设置环境变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install cross-env --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>NODE_ENV=production node app.js</code> 这条命令主要用于设置环境变量 <code>NODE_ENV</code> 并运行应用程序。具体拆解如下：</p><ol><li><p>**<code>NODE_ENV=production</code>**：</p><ul><li>这部分用于设置 <code>NODE_ENV</code> 环境变量的值为 <code>production</code>。<code>NODE_ENV</code> 是 Node.js 应用中常见的一个环境变量，表示应用当前的运行环境。</li><li>通常有以下几种值：<ul><li><code>development</code>：开发环境，用于本地调试、测试。</li><li><code>production</code>：生产环境，用于发布和正式运行。</li><li><code>test</code>：测试环境，用于自动化测试。</li></ul></li></ul><p>在不同的 <code>NODE_ENV</code> 下，代码通常会有不同的行为。比如：</p><ul><li>在开发环境中，可能会启用更多的日志输出、调试功能等。</li><li>在生产环境中，可能会禁用调试功能、启用性能优化等。</li></ul></li><li><p>**<code>node app.js</code>**：</p><ul><li>这部分用于启动 Node.js 应用，运行 <code>app.js</code> 文件。<code>node</code> 是运行 Node.js 脚本的命令，后面的 <code>app.js</code> 是需要执行的 JavaScript 文件。</li></ul><p>因此，整条命令的含义是：在生产环境下执行 <code>app.js</code> 文件。</p></li></ol><p><strong>作用</strong></p><p>通过设置 <code>NODE_ENV</code>，你可以控制应用程序的运行模式。例如，在 <code>production</code> 环境中，很多框架和库（如 Express、React 等）会根据 <code>NODE_ENV</code> 来优化性能和行为，以确保更高的运行效率和安全性。</p><p><strong>举例</strong></p><p>在 Express.js 应用中，使用 <code>NODE_ENV</code> 可以区分开发模式和生产模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 生产环境中的逻辑，比如启用压缩、禁用详细日志等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">compression</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 开发环境中的逻辑，比如启用详细日志、错误提示等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">morgan</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置 <code>NODE_ENV=production</code>，代码会执行生产环境的逻辑。</p><h3 id="2-4-1-npm-package-环境变量"><a href="#2-4-1-npm-package-环境变量" class="headerlink" title="2.4.1 npm_package_* 环境变量"></a>2.4.1 <code>npm_package_*</code> 环境变量</h3><p>这些变量基于 <code>package.json</code> 文件中的字段生成，能够直接访问项目的配置信息。</p><p><strong>常用字段：</strong></p><ul><li><code>npm_package_name</code>：项目名称（<code>package.json</code> 中的 <code>name</code> 字段）</li><li><code>npm_package_version</code>：项目版本（<code>package.json</code> 中的 <code>version</code> 字段）</li><li><code>npm_package_description</code>：项目描述（<code>package.json</code> 中的 <code>description</code> 字段）</li><li><code>npm_package_author</code>：项目作者（<code>package.json</code> 中的 <code>author</code> 字段）</li><li><code>npm_package_license</code>：项目的许可证类型（<code>package.json</code> 中的 <code>license</code> 字段）</li><li><code>npm_package_scripts_*</code>：项目中定义的 <code>scripts</code> 脚本。例如 <code>npm_package_scripts_start</code> 对应 <code>package.json</code> 中的 <code>start</code> 脚本。</li><li><code>npm_package_dependencies_*</code>：项目依赖项版本。例如 <code>npm_package_dependencies_express</code> 对应 <code>package.json</code> 中 <code>dependencies</code> 下的 <code>express</code> 包的版本。</li><li><code>npm_package_devDependencies_*</code>：开发依赖项版本。例如 <code>npm_package_devDependencies_mocha</code> 对应 <code>package.json</code> 中 <code>devDependencies</code> 下的 <code>mocha</code> 包的版本。</li><li><code>npm_package_keywords_*</code>：项目关键词列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取项目名称</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_name</span><br><br><span class="hljs-comment"># 获取 express 依赖的版本</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_dependencies_express</span><br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><p>当你使用 <code>npm run</code> 命令运行脚本时，<code>npm</code> 会自动将 <code>package.json</code> 中的部分内容导出为环境变量，这些环境变量以 <code>npm_package_</code> 为前缀。</p><p>例如，假设你的 <code>package.json</code> 文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-app&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample application&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在运行 <code>npm run start</code> 时，以下环境变量会自动设置：</p><ul><li><code>npm_package_name=my-app</code></li><li><code>npm_package_version=1.0.0</code></li><li><code>npm_package_description=This is a sample application</code></li><li><code>npm_package_author=John Doe</code></li><li><code>npm_package_dependencies_express=^4.17.1</code></li></ul><h4 id="1-使用-npm-package-环境变量"><a href="#1-使用-npm-package-环境变量" class="headerlink" title="1. 使用 npm_package_* 环境变量"></a>1. 使用 <code>npm_package_*</code> 环境变量</h4><p>在脚本中，你可以通过 <code>process.env</code> 来访问这些环境变量。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 package.json 中的字段值</span><br><span class="hljs-keyword">const</span> appName = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>;<br><span class="hljs-keyword">const</span> appVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>;<br><span class="hljs-keyword">const</span> appDescription = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_description</span>;<br><span class="hljs-keyword">const</span> appAuthor = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_author</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Name: <span class="hljs-subst">$&#123;appName&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Version: <span class="hljs-subst">$&#123;appVersion&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Description: <span class="hljs-subst">$&#123;appDescription&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Author: <span class="hljs-subst">$&#123;appAuthor&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="2-运行脚本"><a href="#2-运行脚本" class="headerlink" title="2. 运行脚本"></a>2. 运行脚本</h4><p>假设在 <code>package.json</code> 中定义了以下 <code>scripts</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>当你运行 <code>npm run start</code> 时，<code>npm</code> 会将 <code>package.json</code> 中的内容作为环境变量导出，并在脚本中可以通过 <code>process.env</code> 访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run start<br></code></pre></td></tr></table></figure><p>输出将会是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Name:</span> <span class="hljs-string">my-app</span><br><span class="hljs-attr">App Version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">Description:</span> <span class="hljs-string">This</span> <span class="hljs-string">is</span> <span class="hljs-string">a</span> <span class="hljs-string">sample</span> <span class="hljs-string">application</span><br><span class="hljs-attr">Author:</span> <span class="hljs-string">John</span> <span class="hljs-string">Doe</span><br></code></pre></td></tr></table></figure><h4 id="3-环境变量命名规则"><a href="#3-环境变量命名规则" class="headerlink" title="3. 环境变量命名规则"></a>3. 环境变量命名规则</h4><ul><li><strong>基本字段</strong>：<code>npm_package_</code> 后接字段名称。例如，<code>name</code> 字段对应 <code>npm_package_name</code>，<code>version</code> 字段对应 <code>npm_package_version</code>。</li><li><strong>嵌套字段</strong>：如果字段是嵌套的，则会用 <code>_</code> 分隔。例如，<code>dependencies</code> 下的 <code>express</code> 包版本可以通过 <code>npm_package_dependencies_express</code> 访问。</li><li><strong>数组字段</strong>：对于数组类型的字段，如 <code>keywords</code>，会自动生成索引的环境变量。例如，<code>keywords</code> 数组的第一个元素是 <code>npm_package_keywords_0</code>。</li></ul><h4 id="4-自定义字段"><a href="#4-自定义字段" class="headerlink" title="4. 自定义字段"></a>4. 自定义字段</h4><p><code>npm_package_*</code> 变量支持自定义字段。假设你在 <code>package.json</code> 中添加了自定义字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;customField&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;apiEndpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://api.example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;enableFeatureX&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这些自定义字段可以通过如下环境变量访问：</p><ul><li><code>npm_package_customField_apiEndpoint</code>：自定义字段 <code>apiEndpoint</code> 的值。</li><li><code>npm_package_customField_enableFeatureX</code>：自定义字段 <code>enableFeatureX</code> 的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> apiEndpoint = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_apiEndpoint</span>;<br><span class="hljs-keyword">const</span> enableFeatureX = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_enableFeatureX</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`API Endpoint: <span class="hljs-subst">$&#123;apiEndpoint&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Feature X Enabled: <span class="hljs-subst">$&#123;enableFeatureX&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="5-访问限制"><a href="#5-访问限制" class="headerlink" title="5. 访问限制"></a>5. 访问限制</h4><p>通过 <code>npm_package_*</code> 变量方式访问 <code>package.json</code> 字段有以下几点需要注意：</p><ul><li>只能通过 <code>npm run</code> 命令访问这些环境变量，直接运行 <code>node app.js</code> 是无法自动注入这些变量的。</li><li>如果 <code>package.json</code> 中的某个字段是对象类型，环境变量会为其每个子字段生成对应的变量，但不能直接获取整个对象。</li></ul><h4 id="6-示例：访问-package-json-的-dependencies"><a href="#6-示例：访问-package-json-的-dependencies" class="headerlink" title="6. 示例：访问 package.json 的 dependencies"></a>6. 示例：访问 <code>package.json</code> 的 <code>dependencies</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 访问 dependencies 中的 express 版本</span><br><span class="hljs-keyword">const</span> expressVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_dependencies_express</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Express Version: <span class="hljs-subst">$&#123;expressVersion&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-2-npm-config-变量"><a href="#2-4-2-npm-config-变量" class="headerlink" title="2.4.2 npm_config_* 变量"></a>2.4.2 <code>npm_config_*</code> 变量</h3><p>这些变量用于访问 <code>npm</code> 配置的参数。可以在命令行通过 <code>npm config set</code> 或 <code>npm run</code> 脚本中传递这些配置参数。</p><p><strong>常用配置变量：</strong></p><ul><li><code>npm_config_registry</code>：使用的 npm 注册表 URL。</li><li><code>npm_config_node_version</code>：当前使用的 Node.js 版本。</li><li><code>npm_config_tag</code>：发布时使用的标签（通过 <code>--tag</code> 设置，例如 <code>beta</code>、<code>latest</code>）。</li><li><code>npm_config_global</code>：如果为 <code>true</code>，则指明操作为全局安装或设置。</li><li><code>npm_config_prefix</code>：全局模块的安装路径。</li><li><code>npm_config_cache</code>：npm 的缓存路径。</li><li><code>npm_config_production</code>：如果为 <code>true</code>，表示当前处于生产环境（通过 <code>--production</code> 设置）。</li><li><code>npm_config_init_author_name</code>：初始化项目时的默认作者名称。</li><li><code>npm_config_init_version</code>：初始化项目时的默认版本。</li><li><code>npm_config_save_dev</code>：是否将依赖项保存到 <code>devDependencies</code> 中。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出使用的 npm registry</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_registry</span><br><br><span class="hljs-comment"># 获取配置的默认作者</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_init_author_name</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-npm-lifecycle-变量"><a href="#2-4-3-npm-lifecycle-变量" class="headerlink" title="2.4.3 npm_lifecycle_* 变量"></a>2.4.3 <code>npm_lifecycle_*</code> 变量</h3><p>这些变量在运行 <code>npm run</code> 脚本时自动生成，提供有关当前执行生命周期的信息。</p><p><strong>常用生命周期变量：</strong></p><ul><li><code>npm_lifecycle_event</code>：当前运行的脚本事件名称。例如，<code>npm run build</code> 时，<code>npm_lifecycle_event</code> 为 <code>build</code>。</li><li><code>npm_lifecycle_script</code>：当前正在执行的脚本内容。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前运行的生命周期事件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_lifecycle_event</span><br></code></pre></td></tr></table></figure><h3 id="2-4-4-npm-变量"><a href="#2-4-4-npm-变量" class="headerlink" title="2.4.4 npm_* 变量"></a>2.4.4 <code>npm_*</code> 变量</h3><p>这些变量提供了一些与当前 <code>npm</code> 环境和运行时相关的信息。</p><p><strong>常用变量：</strong></p><ul><li><code>npm_command</code>：当前正在执行的 <code>npm</code> 命令。例如，<code>npm install</code> 时，<code>npm_command</code> 为 <code>install</code>。</li><li><code>npm_execpath</code>：执行 npm 的路径。</li><li><code>npm_node_execpath</code>：Node.js 可执行文件的路径。</li><li><code>npm_config_user_agent</code>：当前 <code>npm</code> 客户端的用户代理字符串。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前的 npm 命令</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_command</span><br><br><span class="hljs-comment"># 输出 npm 可执行文件路径</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_execpath</span><br></code></pre></td></tr></table></figure><h3 id="2-4-5-自定义-npm-config-变量"><a href="#2-4-5-自定义-npm-config-变量" class="headerlink" title="2.4.5 自定义 npm_config_* 变量"></a>2.4.5 自定义 <code>npm_config_*</code> 变量</h3><p>你还可以通过命令行或配置文件自定义 <code>npm_config_*</code> 变量。例如，你可以通过 <code>npm run</code> 命令传递自定义的变量，供脚本使用。</p><p><strong>示例：</strong></p><p>在 <code>package.json</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;view&quot;</span>: <span class="hljs-string">&quot;echo $npm_config_myCustomVar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run view --myCustomVar=HelloWorld<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HelloWorld</span><br></code></pre></td></tr></table></figure><h3 id="2-4-6-总结"><a href="#2-4-6-总结" class="headerlink" title="2.4.6 总结"></a>2.4.6 总结</h3><p>以下是常见 <code>npm</code> 变量的分类总结：</p><table><thead><tr><th>变量类型</th><th>说明</th></tr></thead><tbody><tr><td><code>npm_package_*</code></td><td>访问 <code>package.json</code> 中的字段值</td></tr><tr><td><code>npm_config_*</code></td><td>访问 <code>npm</code> 配置的参数</td></tr><tr><td><code>npm_lifecycle_*</code></td><td>运行时有关生命周期的信息</td></tr><tr><td><code>npm_*</code></td><td>一些与当前 <code>npm</code> 环境相关的信息</td></tr><tr><td>自定义 <code>npm_config_*</code></td><td>通过命令行或配置文件传递的自定义参数</td></tr></tbody></table><p>这些变量在 <code>npm</code> 的脚本管理和环境配置中十分有用，能够帮助你在不同环境下动态获取项目信息、依赖版本或自定义配置等。</p><h2 id="2-5-package-json-其他常见字段"><a href="#2-5-package-json-其他常见字段" class="headerlink" title="2.5 package.json 其他常见字段"></a>2.5 package.json 其他常见字段</h2><h3 id="2-5-1-main-入口文件"><a href="#2-5-1-main-入口文件" class="headerlink" title="2.5.1 main (入口文件)"></a>2.5.1 <code>main</code> (入口文件)</h3><p><code>main</code> 指定了包的入口文件。当用户 <code>require</code> 该包时，首先加载的就是该文件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-2-engines-引擎"><a href="#2-5-2-engines-引擎" class="headerlink" title="2.5.2 engines (引擎)"></a>2.5.2 <code>engines</code> (引擎)</h3><p><code>engines</code> 字段用于指定项目所需的 Node.js 或 NPM 版本。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=12.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;npm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=6.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-repository-仓库"><a href="#2-5-3-repository-仓库" class="headerlink" title="2.5.3 repository (仓库)"></a>2.5.3 <code>repository</code> (仓库)</h3><p><code>repository</code> 字段记录项目的代码仓库地址。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-4-bugs-问题反馈"><a href="#2-5-4-bugs-问题反馈" class="headerlink" title="2.5.4 bugs (问题反馈)"></a>2.5.4 <code>bugs</code> (问题反馈)</h3><p><code>bugs</code> 字段用于提供问题反馈的地址或电子邮件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project/issues&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support@example.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-5-files-发布文件"><a href="#2-5-5-files-发布文件" class="headerlink" title="2.5.5 files (发布文件)"></a>2.5.5 <code>files</code> (发布文件)</h3><p><code>files</code> 字段指定了在发布到 NPM 时需要包含的文件列表。未包含在此列表中的文件将不会发布。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;dist/&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-6-config-自定义配置"><a href="#2-5-6-config-自定义配置" class="headerlink" title="2.5.6 config (自定义配置)"></a>2.5.6 <code>config</code> (自定义配置)</h3><p><code>config</code> 字段允许自定义配置，用于脚本中引用的变量。</p><h1 id="3-NPM-的常用命令"><a href="#3-NPM-的常用命令" class="headerlink" title="3. NPM 的常用命令"></a>3. NPM 的常用命令</h1><h2 id="3-1-安装包"><a href="#3-1-安装包" class="headerlink" title="3.1 安装包"></a>3.1 安装包</h2><ul><li><strong>安装指定依赖包</strong>：默认会将依赖包安装到 <code>node_modules</code> 文件夹下，并更新 <code>package.json</code> 中的依赖。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>安装开发依赖包</strong>：使用 <code>--save-dev</code> 参数可以将包安装到 <code>devDependencies</code> 中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt; --save-dev<br></code></pre></td></tr></table></figure><ul><li><strong>全局安装</strong>：某些工具需要全局安装，如 <code>create-react-app</code>、<code>eslint</code> 等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-2-移除包"><a href="#3-2-移除包" class="headerlink" title="3.2 移除包"></a>3.2 移除包</h2><p>可以通过 <code>uninstall</code> 命令移除包，并自动更新 <code>package.json</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-3-更新包"><a href="#3-3-更新包" class="headerlink" title="3.3 更新包"></a>3.3 更新包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-检查过期包"><a href="#3-4-检查过期包" class="headerlink" title="3.4 检查过期包"></a>3.4 检查过期包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm outdated<br></code></pre></td></tr></table></figure><h2 id="3-5-修复漏洞"><a href="#3-5-修复漏洞" class="headerlink" title="3.5 修复漏洞"></a>3.5 修复漏洞</h2><p>NPM 提供了 <code>audit</code> 命令来检查项目中存在的安全漏洞，并通过 <code>audit fix</code> 自动修复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm audit<br>npm audit fix<br></code></pre></td></tr></table></figure><h2 id="3-6-清理缓存"><a href="#3-6-清理缓存" class="headerlink" title="3.6 清理缓存"></a>3.6 清理缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h1 id="4-NPM-脚本"><a href="#4-NPM-脚本" class="headerlink" title="4. NPM 脚本"></a>4. NPM 脚本</h1><p>NPM 允许在 <code>package.json</code> 文件中的 <code>scripts</code> 部分定义自定义命令。这些命令可以通过 <code>npm run &lt;script-name&gt;</code> 执行，常用于自动化工作流。</p><h2 id="4-1-定义和执行脚本"><a href="#4-1-定义和执行脚本" class="headerlink" title="4.1 定义和执行脚本"></a>4.1 定义和执行脚本</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><ul><li><code>pre</code> 和 <code>post</code> 钩子：NPM 支持在某个脚本执行前后自动执行一些预定义的任务。例如，定义 <code>pretest</code> 或 <code>posttest</code>，它们分别在 <code>test</code> 脚本前后执行。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;pretest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm install&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;posttest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run lint&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-脚本参数"><a href="#4-2-脚本参数" class="headerlink" title="4.2 脚本参数"></a>4.2 脚本参数</h2><p>你可以通过 <code>--</code> 向 NPM 脚本传递参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build -- --mode production<br></code></pre></td></tr></table></figure><h1 id="5-NPM-的版本管理"><a href="#5-NPM-的版本管理" class="headerlink" title="5. NPM 的版本管理"></a>5. NPM 的版本管理</h1><p>NPM 支持多种版本控制策略，便于项目在不同版本的依赖包中自由切换。</p><h2 id="5-1-版本号规则"><a href="#5-1-版本号规则" class="headerlink" title="5.1 版本号规则"></a>5.1 版本号规则</h2><p>NPM 的版本号遵循 语义化版本号 规范：</p><ul><li><strong>主版本号</strong>：非兼容性 API 变更。</li><li><strong>次版本号</strong>：向下兼容的新功能。</li><li><strong>修订号</strong>：向下兼容的问题修复。</li></ul><p>版本号示例：<code>^1.2.3</code>，其中 <code>^</code> 表示允许安装 <code>1.x.x</code> 版本的更新，<code>~1.2.3</code> 表示允许安装 <code>1.2.x</code> 的更新。</p><h2 id="5-2-锁定版本"><a href="#5-2-锁定版本" class="headerlink" title="5.2 锁定版本"></a>5.2 锁定版本</h2><p><code>package-lock.json</code> 是 NPM 自动生成的文件，它锁定了每个依赖包的版本，确保团队中每个人安装的包版本一致，避免版本不兼容问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm ci<br></code></pre></td></tr></table></figure><p><code>npm ci</code> 命令基于 <code>package-lock.json</code> 文件安装所有依赖，适用于 CI&#x2F;CD 环境下的构建流程。</p><h1 id="6-发布自己的-NPM-包"><a href="#6-发布自己的-NPM-包" class="headerlink" title="6. 发布自己的 NPM 包"></a>6. 发布自己的 NPM 包</h1><p>你可以通过 NPM 将自己的包发布到 NPM 注册库供其他开发者使用。</p><h2 id="6-1-创建-NPM-账户"><a href="#6-1-创建-NPM-账户" class="headerlink" title="6.1 创建 NPM 账户"></a>6.1 创建 NPM 账户</h2><p>首先，你需要注册一个 NPM 账户并登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm login<br></code></pre></td></tr></table></figure><h2 id="6-2-准备项目"><a href="#6-2-准备项目" class="headerlink" title="6.2 准备项目"></a>6.2 准备项目</h2><p>确保项目的 <code>package.json</code> 文件正确配置，尤其是以下字段：</p><ul><li><code>name</code>: 包名，需要唯一。</li><li><code>version</code>: 包版本，初始版本可以为 <code>1.0.0</code>。</li><li><code>main</code>: 入口文件。</li></ul><h2 id="6-3-发布包"><a href="#6-3-发布包" class="headerlink" title="6.3 发布包"></a>6.3 发布包</h2><p>执行以下命令将包发布到 NPM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish<br></code></pre></td></tr></table></figure><p>如果是发布新的版本，只需要在 <code>package.json</code> 中修改版本号，再次运行 <code>npm publish</code>。</p><h2 id="6-4-包版本管理"><a href="#6-4-包版本管理" class="headerlink" title="6.4 包版本管理"></a>6.4 包版本管理</h2><p>当你需要发布预览版或测试版时，可以使用 <code>npm publish</code> 的 <code>tag</code> 选项发布特定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish --tag beta<br></code></pre></td></tr></table></figure><h1 id="7-高级使用"><a href="#7-高级使用" class="headerlink" title="7. 高级使用"></a>7. 高级使用</h1><h2 id="7-1-使用-NPM-进行项目初始化"><a href="#7-1-使用-NPM-进行项目初始化" class="headerlink" title="7.1 使用 NPM 进行项目初始化"></a>7.1 使用 NPM 进行项目初始化</h2><p>有时我们需要为某些项目做初始化工作，NPM 的 <code>init</code> 命令可以与预设的模板搭配使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init &lt;模板名&gt;<br></code></pre></td></tr></table></figure><h2 id="7-2-本地开发包"><a href="#7-2-本地开发包" class="headerlink" title="7.2 本地开发包"></a>7.2 本地开发包</h2><p>在开发 NPM 包时，你可以使用 <code>npm link</code> 将本地包链接到全局环境中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><h2 id="7-3-npx-命令"><a href="#7-3-npx-命令" class="headerlink" title="7.3 npx 命令"></a>7.3 npx 命令</h2><p><code>npx</code> 是 NPM 附带的一个命令，它允许直接执行包中的命令，而无需全局安装。例如，运行 <code>create-react-app</code> 时，可以直接使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-react-app my-app<br></code></pre></td></tr></table></figure><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>NPM 是 Node.js 项目的基础工具，它不仅能帮助你高效地管理依赖，还能通过 <code>scripts</code> 和 <code>npx</code> 提升开发效率。通过掌握 NPM 的各种命令和功能，能够更好地维护项目和发布自己的代码包。</p><p>希望通过这篇教程，你对 NPM 有了更全面的理解。</p>]]></content>
    
    
    <categories>
      
      <category>NPM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
      <tag>NPM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解浏览器原理与DOM</title>
    <link href="/posts/32299/"/>
    <url>/posts/32299/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解浏览器原理与-DOM"><a href="#深入理解浏览器原理与-DOM" class="headerlink" title="深入理解浏览器原理与 DOM"></a>深入理解浏览器原理与 DOM</h1><h1 id="一、什么是浏览器？"><a href="#一、什么是浏览器？" class="headerlink" title="一、什么是浏览器？"></a>一、什么是浏览器？</h1><p>浏览器是用户访问互联网的工具，它负责请求网页内容、解析网页、展示内容并处理用户与网页的互动。现代浏览器如 Chrome、Firefox 和 Safari 不仅支持 HTML、CSS 和 JavaScript，还集成了许多功能来优化用户体验和安全性。</p><h1 id="二、浏览器的工作过程"><a href="#二、浏览器的工作过程" class="headerlink" title="二、浏览器的工作过程"></a>二、浏览器的工作过程</h1><p>浏览器的工作过程可以分为多个步骤，每个步骤都有其重要性。让我们逐步深入了解。</p><h2 id="1-用户输入-URL"><a href="#1-用户输入-URL" class="headerlink" title="1. 用户输入 URL"></a>1. 用户输入 URL</h2><p>用户在浏览器的地址栏中输入一个网址（URL），例如 <code>http://www.example.com</code>。URL 通常包含协议（如 HTTP 或 HTTPS）、域名、路径、查询参数和锚点等信息。</p><h2 id="2-解析-URL"><a href="#2-解析-URL" class="headerlink" title="2. 解析 URL"></a>2. 解析 URL</h2><p>浏览器首先解析输入的 URL，提取出以下组成部分：</p><ul><li><strong>协议</strong>：指示使用的协议（HTTP 或 HTTPS）。</li><li><strong>域名</strong>：指向目标服务器的地址。</li><li><strong>路径</strong>：指向服务器上资源的位置。</li><li><strong>查询参数</strong>：可选，通常用于传递数据给服务器。</li></ul><h2 id="3-DNS-查询"><a href="#3-DNS-查询" class="headerlink" title="3. DNS 查询"></a>3. DNS 查询</h2><p>浏览器需要将域名转换为 IP 地址，才能找到服务器。为此，浏览器会向 DNS（域名系统）发送查询请求。DNS 服务器返回相应的 IP 地址，如果该地址已被缓存，浏览器可以直接使用。</p><h2 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h2><p>一旦获得了服务器的 IP 地址，浏览器会与服务器建立 TCP 连接。这个过程包含以下步骤：</p><ul><li><p>三次握手</p><p>：为了确保连接的可靠性，TCP 协议使用三次握手机制。</p><ol><li>浏览器发送一个 SYN（同步）包给服务器，请求建立连接。</li><li>服务器回复一个 SYN-ACK（同步-确认）包，确认收到请求并准备建立连接。</li><li>浏览器再次发送一个 ACK（确认）包，连接成功建立。</li></ol></li></ul><h2 id="5-发送-HTTP-请求"><a href="#5-发送-HTTP-请求" class="headerlink" title="5. 发送 HTTP 请求"></a>5. 发送 HTTP 请求</h2><p>建立连接后，浏览器会发送一个 HTTP 请求，向服务器请求资源。这个请求包含：</p><ul><li><strong>请求方法</strong>：通常是 GET（获取资源）或 POST（提交数据）。</li><li><strong>请求路径</strong>：服务器上资源的具体路径。</li><li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li><li><strong>请求头</strong>：包含浏览器信息、接受的内容类型等元数据。</li><li><strong>请求体</strong>（可选）：在 POST 请求中，包含发送给服务器的数据。</li></ul><h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>服务器接收到请求后，会处理请求并生成响应。服务器执行的操作可能包括：</p><ul><li>查询数据库。</li><li>处理业务逻辑。</li><li>生成动态网页内容。</li></ul><h2 id="7-服务器发送-HTTP-响应"><a href="#7-服务器发送-HTTP-响应" class="headerlink" title="7. 服务器发送 HTTP 响应"></a>7. 服务器发送 HTTP 响应</h2><p>处理完成后，服务器会发送一个 HTTP 响应回浏览器，响应包括：</p><ul><li><strong>状态码</strong>：指示请求处理的结果，如 200（成功）、404（未找到）或 500（服务器错误）。</li><li><strong>响应头</strong>：包含关于响应的信息，如内容类型、缓存策略、内容长度等。</li><li><strong>响应体</strong>：实际的网页内容，通常是 HTML 文档，也可能包括 CSS、JavaScript、图片等资源。</li></ul><h2 id="8-接收响应"><a href="#8-接收响应" class="headerlink" title="8. 接收响应"></a>8. 接收响应</h2><p>浏览器接收到服务器的响应后，首先检查状态码，确认请求是否成功。如果状态码是 200，浏览器将开始解析响应体。</p><h2 id="9-构建-DOM-树"><a href="#9-构建-DOM-树" class="headerlink" title="9. 构建 DOM 树"></a>9. 构建 DOM 树</h2><p>浏览器会解析 HTML 文档，构建文档对象模型（DOM）树。DOM 是一个树形结构，其中每个节点代表文档中的一个元素或文本。构建 DOM 树的过程如下：</p><ul><li>解析每个 HTML 标签，创建对应的元素节点。</li><li>处理标签之间的关系，形成父子节点的层级结构。</li><li>处理文本节点，将文本内容与相应的元素节点关联。</li></ul><h2 id="10-DOM-的详细解析"><a href="#10-DOM-的详细解析" class="headerlink" title="10. DOM 的详细解析"></a>10. DOM 的详细解析</h2><p>DOM（文档对象模型）是浏览器用来表示和操作 HTML 和 XML 文档的编程接口。以下是对 DOM 的详细讲解：</p><h3 id="1-DOM-的结构"><a href="#1-DOM-的结构" class="headerlink" title="1. DOM 的结构"></a>1. DOM 的结构</h3><p>DOM 树的根节点是 <code>document</code>，它表示整个文档。树的每个节点都是一个对象，代表文档中的元素、属性或文本。DOM 树结构如下：</p><ul><li>document<ul><li>html<ul><li>head<ul><li>title</li><li>meta</li></ul></li><li>body<ul><li>h1</li><li>p</li><li>div<ul><li>span</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="2-DOM-节点类型"><a href="#2-DOM-节点类型" class="headerlink" title="2. DOM 节点类型"></a>2. DOM 节点类型</h3><p>DOM 中的节点可以分为几种类型：</p><ul><li><strong>元素节点</strong>：表示 HTML 标签，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等。</li><li><strong>文本节点</strong>：表示元素内部的文本内容。</li><li><strong>属性节点</strong>：表示元素的属性，如 <code>class</code>、<code>id</code> 等（现代浏览器 API 中，属性节点不再是单独的节点）。</li></ul><h3 id="3-DOM-操作"><a href="#3-DOM-操作" class="headerlink" title="3. DOM 操作"></a>3. DOM 操作</h3><p>JavaScript 可以通过 DOM API 访问和修改 DOM 树，包括：</p><ul><li><strong>访问节点</strong>：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：根据 ID 获取元素。</li><li><code>document.querySelector(&#39;.class&#39;)</code>：根据 CSS 选择器获取元素。</li></ul></li><li><strong>添加节点</strong>：<ul><li><code>element.appendChild(newNode)</code>：将新节点添加到指定元素的子节点列表中。</li><li><code>element.insertBefore(newNode, referenceNode)</code>：在指定节点前插入新节点。</li></ul></li><li><strong>修改节点</strong>：<ul><li><code>element.textContent = &#39;New Text&#39;</code>：更改节点的文本内容。</li><li><code>element.setAttribute(&#39;attribute&#39;, &#39;value&#39;)</code>：设置节点的属性。</li></ul></li><li><strong>删除节点</strong>：<ul><li><code>element.removeChild(childNode)</code>：从 DOM 中删除子节点。</li></ul></li></ul><h2 id="11-构建-CSSOM-树"><a href="#11-构建-CSSOM-树" class="headerlink" title="11. 构建 CSSOM 树"></a>11. 构建 CSSOM 树</h2><p>在解析 HTML 的同时，浏览器会处理页面中的 CSS（包括内联样式和外部样式表），构建 CSSOM（CSS 对象模型）树。CSSOM 表示页面的样式规则，包含每个 CSS 选择器和它所对应的样式。</p><h2 id="12-合并-DOM-和-CSSOM"><a href="#12-合并-DOM-和-CSSOM" class="headerlink" title="12. 合并 DOM 和 CSSOM"></a>12. 合并 DOM 和 CSSOM</h2><p>DOM 树和 CSSOM 树被合并成一棵“渲染树”，它只包含需要渲染的可见元素。渲染树中的每个节点都包含视觉信息，决定元素在页面上的呈现方式。</p><h2 id="13-布局计算（Reflow）"><a href="#13-布局计算（Reflow）" class="headerlink" title="13. 布局计算（Reflow）"></a>13. 布局计算（Reflow）</h2><p>浏览器根据渲染树计算每个元素的位置和大小，这个过程被称为布局（或重排，Reflow）。在此过程中，浏览器考虑样式、内容和屏幕大小等因素，决定每个元素在页面上的具体位置。</p><h2 id="14-绘制（Repaint）"><a href="#14-绘制（Repaint）" class="headerlink" title="14. 绘制（Repaint）"></a>14. 绘制（Repaint）</h2><p>在完成布局后，浏览器将元素绘制到屏幕上。绘制过程会将渲染树的每个节点转换为位图，最终形成用户在屏幕上看到的页面。</p><h2 id="15-执行-JavaScript"><a href="#15-执行-JavaScript" class="headerlink" title="15. 执行 JavaScript"></a>15. 执行 JavaScript</h2><p>页面中的 JavaScript 代码会被执行。JavaScript 可以直接操作 DOM 和 CSSOM，可能会导致页面更新。以下是执行 JavaScript 的几个重要点：</p><ul><li><strong>DOM 操作</strong>：通过 JavaScript，开发者可以动态地添加、删除或修改页面元素。</li><li><strong>事件处理</strong>：JavaScript 可以响应用户的操作，如点击、滚动、输入等，增加交互性。</li></ul><h2 id="16-事件循环"><a href="#16-事件循环" class="headerlink" title="16. 事件循环"></a>16. 事件循环</h2><p>JavaScript 是单线程的，事件循环机制使得 JavaScript 可以异步处理事件。浏览器将用户操作和定时器事件推入一个任务队列，JavaScript 引擎逐一执行这些任务，确保页面的响应性。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>浏览器是一个复杂而强大的工具，理解其工作原理有助于开发者更好地构建和优化网页应用。从用户输入 URL 到最终呈现内容，每一步都涉及到多个子步骤和技术细节。掌握这些知识将使开发者在进行前端开发时更为得心应手，也能帮助他们识别和解决性能问题和兼容性问题。</p><p>希望这篇深入的博客能够帮助你更好地理解浏览器的工作原理、DOM 的结构与操作以及相关机制！如果有任何疑问或想了解更多内容，欢迎随时交流。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器跨域问题详解及解决方案</title>
    <link href="/posts/3208/"/>
    <url>/posts/3208/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题详解及解决方案"><a href="#浏览器跨域问题详解及解决方案" class="headerlink" title="浏览器跨域问题详解及解决方案"></a>浏览器跨域问题详解及解决方案</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>在开发 Web 应用时，浏览器的跨域问题是前端开发者经常遇到的。浏览器的<strong>同源策略</strong>（Same-Origin Policy）是为了保证安全，限制了跨域请求的发起。然而，很多场景下，跨域请求是必须的，比如前端与不同域的后端服务器通信时。因此，理解浏览器跨域问题的原因及其解决方案是非常重要的。</p><p>本文将深入讲解跨域问题的产生原因，并提供常用的解决方案，帮助开发者高效解决跨域问题。</p><hr><h1 id="一、什么是跨域问题？"><a href="#一、什么是跨域问题？" class="headerlink" title="一、什么是跨域问题？"></a><strong>一、什么是跨域问题？</strong></h1><p><strong>跨域</strong>是指浏览器的安全策略，即同源策略（Same-Origin Policy）限制了 JavaScript 只能从与网页同源的服务器请求资源。所谓<strong>同源</strong>，是指协议、域名、端口号三者必须完全相同。</p><ul><li><p><strong>同源</strong>：指的是协议、域名、端口号三者必须一致。</p></li><li><p>跨域</p><p>：如果任意一个不同，都是跨域。例如：</p><ul><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="https://www.example.com'(协议不同)/">https://www.example.com&#39;（协议不同）</a></li><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="http://api.example.com'(域名不同)/">http://api.example.com&#39;（域名不同）</a></li><li>‘<a href="http://www.example.com:8080/">http://www.example.com:8080</a>‘ 与 ‘<a href="http://www.example.com:3000'（端口不同）">http://www.example.com:3000&#39;（端口不同）</a></li></ul></li></ul><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a><strong>浏览器的同源策略</strong></h2><p>同源策略是一种重要的安全策略，它用于阻止一个源（网页）中的脚本读取另一个源中的资源。它的主要目的是为了防止恶意网站通过跨站脚本攻击（XSS）来窃取用户数据。</p><h2 id="跨域请求带来的问题"><a href="#跨域请求带来的问题" class="headerlink" title="跨域请求带来的问题"></a><strong>跨域请求带来的问题</strong></h2><p>跨域问题常出现在通过 Ajax 或 Fetch 发起的 HTTP 请求中，浏览器会根据同源策略阻止跨域请求，导致前端无法拿到不同源的服务器数据。</p><hr><h1 id="二、跨域问题产生的原因"><a href="#二、跨域问题产生的原因" class="headerlink" title="二、跨域问题产生的原因"></a><strong>二、跨域问题产生的原因</strong></h1><p>跨域问题产生的核心原因是<strong>浏览器的同源策略</strong>，具体在以下情况下会产生跨域问题：</p><ol><li><strong>协议不同</strong>：比如 HTTP 和 HTTPS 协议不同，属于跨域。</li><li><strong>域名不同</strong>：比如 <code>example.com</code> 和 <code>sub.example.com</code> 属于跨域。</li><li><strong>端口不同</strong>：同样的域名和协议，但端口不同，比如 <code>example.com:8080</code> 和 <code>example.com:3000</code>。</li></ol><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子</strong>：</h2><ul><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com/api/data">http://example.com/api/data</a> ——<strong>同源</strong>，允许请求。</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="https://example.com/api/data">https://example.com/api/data</a> ——<strong>跨域</strong>，拒绝请求。（协议不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://api.example.com/data">http://api.example.com/data</a> ——<strong>跨域</strong>，拒绝请求。（域名不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com:3000/data">http://example.com:3000/data</a> ——<strong>跨域</strong>，拒绝请求。（端口不同）</li></ul><p>当发生跨域时，浏览器会抛出类似如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://api.example.com/data&#x27;</span> from origin <span class="hljs-string">&#x27;http://www.example.com&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.<br></code></pre></td></tr></table></figure><p>这种错误提示表明请求被浏览器阻止，原因是目标服务器没有配置允许跨域请求的响应头。</p><hr><h1 id="三、跨域问题的常见解决方案"><a href="#三、跨域问题的常见解决方案" class="headerlink" title="三、跨域问题的常见解决方案"></a><strong>三、跨域问题的常见解决方案</strong></h1><p>针对跨域问题，前端和后端都有不同的解决方法。常用的方案包括：</p><h2 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1. CORS（跨域资源共享）"></a><strong>1. CORS（跨域资源共享）</strong></h2><p>CORS（Cross-Origin Resource Sharing）是 W3C 标准，允许浏览器向跨源服务器，发起 XMLHttpRequest 或 Fetch 请求。只要服务器端配置了适当的 CORS 头信息，就可以允许跨域请求。</p><p><strong>服务器端解决方法：</strong></p><p>在后端服务器配置响应头来允许跨域访问。具体操作是设置 HTTP 响应头中的 <code>Access-Control-Allow-Origin</code>，这个头告诉浏览器，允许哪些域进行跨域请求。</p><ul><li><p><strong>基本 CORS 头配置</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br></code></pre></td></tr></table></figure><p>这意味着允许所有来源的跨域请求。如果要限制特定的域，可以将 <code>*</code> 替换为特定域名，比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://www.example.com<br></code></pre></td></tr></table></figure></li><li><p><strong>支持复杂请求</strong>：</p><p>如果是复杂的跨域请求（例如涉及 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等非简单方法，或者带有自定义头部），需要预检请求。此时需要后端配置更多的 CORS 头信息，例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>Content-Type, Authorization<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure><p>这些头信息分别表示允许的 HTTP 方法、允许的自定义头部、以及是否允许携带 Cookie 等认证信息。</p></li></ul><h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a><strong>2. JSONP</strong></h2><p>JSONP（JSON with Padding）是一种传统的跨域请求方案，利用 <code>&lt;script&gt;</code> 标签的跨域能力来请求资源。因为 <code>&lt;script&gt;</code> 标签不受同源策略的限制，可以加载任意来源的脚本，JSONP 通过动态插入 <code>&lt;script&gt;</code> 标签来实现跨域请求。</p><p><strong>实现步骤</strong>：</p><ul><li><p>前端发起请求时，在 URL 中添加一个回调函数参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理返回数据</span><br>&#125;<br><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li><p>后端返回的数据需要被包裹在回调函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleResponse</span>(&#123;<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: [...]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>虽然 JSONP 可以实现跨域请求，但它只支持 GET 请求，不支持其他 HTTP 方法。</p><h2 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a><strong>3. 反向代理</strong></h2><p>反向代理是一种通过代理服务器转发请求的方式。前端请求会先发到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将响应返回给前端。</p><p><strong>实现步骤</strong>：</p><ul><li><p>配置代理服务器（如 Nginx 或 Node.js 中的代理模块）来转发请求：</p><p>在 Nginx 中的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://api.example.com;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，前端只需要请求 <code>/api/</code>，Nginx 会将请求转发到 <code>http://api.example.com</code>，从而避免跨域问题。</p></li></ul><h2 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a><strong>4. WebSocket</strong></h2><p>WebSocket 协议不受同源策略的限制，可以实现跨域通信。如果项目中需要实时通信，WebSocket 是一种不错的选择。</p><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://example.com/socket&#x27;</span>);<br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from server &#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="四、前端解决方案"><a href="#四、前端解决方案" class="headerlink" title="四、前端解决方案"></a><strong>四、前端解决方案</strong></h1><ol><li><p><strong>CORS 前端控制</strong> 前端可以通过控制请求时的一些参数，避免复杂请求的跨域问题。例如使用简单请求方法（GET、POST）或避免自定义请求头等。</p></li><li><p><strong>使用代理开发服务器</strong> 在开发环境中，使用 Webpack DevServer 或 Vite 等开发工具时，可以通过设置代理解决跨域问题。比如在 <code>vue.config.js</code> 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="五、简单请求"><a href="#五、简单请求" class="headerlink" title="五、简单请求"></a>五、简单请求</h1><p>在浏览器的同源策略下，只有某些特定的请求不会触发跨域问题。浏览器针对不同的请求类型进行了区分，只有符合特定条件的请求才会被认为是安全的，属于<strong>简单请求（Simple Requests）</strong>，这些请求不会触发浏览器的<strong>CORS 预检（Preflight）请求</strong>，因此也不会被同源策略限制。</p><h2 id="1、不会触发跨域的请求类型（简单请求）"><a href="#1、不会触发跨域的请求类型（简单请求）" class="headerlink" title="1、不会触发跨域的请求类型（简单请求）"></a><strong>1、不会触发跨域的请求类型（简单请求）</strong></h2><p>根据<strong>CORS（跨域资源共享）</strong>的规范，以下请求被定义为“简单请求”：</p><h3 id="1-1-请求方法必须是以下三种之一："><a href="#1-1-请求方法必须是以下三种之一：" class="headerlink" title="1.1. 请求方法必须是以下三种之一："></a>1.1. <strong>请求方法必须是以下三种之一</strong>：</h3><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><p>这意味着浏览器只会认为这些方法是安全的，任何其他 HTTP 方法（如 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等）都会被视为复杂请求，从而触发跨域检查。</p><h3 id="1-2-请求头必须是以下几种之一："><a href="#1-2-请求头必须是以下几种之一：" class="headerlink" title="1.2. 请求头必须是以下几种之一："></a>1.2. <strong>请求头必须是以下几种之一</strong>：</h3><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（有特定限制，见下一条）</li><li><code>DPR</code>（Device Pixel Ratio）</li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><p>浏览器默认允许这些请求头传递。如果请求中包含了其他自定义头字段，则会被认为是复杂请求，会触发跨域预检。</p><h3 id="1-3-Content-Type-必须是以下三种之一："><a href="#1-3-Content-Type-必须是以下三种之一：" class="headerlink" title="1.3. Content-Type 必须是以下三种之一："></a>1.3. <strong><code>Content-Type</code> 必须是以下三种之一</strong>：</h3><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>这些 <code>Content-Type</code> 类型是最常用的，特别是 <code>application/x-www-form-urlencoded</code>，它是表单提交的默认编码格式。如果使用了其他 <code>Content-Type</code>（例如 <code>application/json</code>），请求会被认为是复杂请求，触发跨域预检。</p><h3 id="1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性："><a href="#1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性：" class="headerlink" title="1.4. 请求不包含任何自定义的 XMLHttpRequest 对象属性："></a>1.4. <strong>请求不包含任何自定义的 <code>XMLHttpRequest</code> 对象属性</strong>：</h3><p>例如 <code>request.withCredentials = true</code> 会导致请求包含用户凭证（cookies、HTTP authentication 等），这将使请求成为复杂请求，触发 CORS 检查。</p><p><strong>简单请求的示例</strong>：</p><ul><li><p><strong>GET 请求</strong>：向目标 API 发起 GET 请求并获取数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>POST 请求</strong>：发送表单数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、简单请求不会触发跨域预检的原因"><a href="#2、简单请求不会触发跨域预检的原因" class="headerlink" title="2、简单请求不会触发跨域预检的原因"></a><strong>2、简单请求不会触发跨域预检的原因</strong></h2><p>浏览器的安全模型假定，简单请求不会带来高风险，因为它们遵循了 HTTP 协议中广泛使用的标准行为。预检请求的目的是检查目标服务器是否允许跨域访问，确保请求不会有潜在的安全问题。</p><p>而简单请求（如上述 <code>GET</code> 和 <code>POST</code>）通常是安全的，因为它们不使用自定义头字段或不发送敏感的内容类型。浏览器认为这些请求不需要额外的安全检查，所以不会触发跨域预检。</p><h2 id="3、哪些请求会触发跨域？"><a href="#3、哪些请求会触发跨域？" class="headerlink" title="3、哪些请求会触发跨域？"></a><strong>3、哪些请求会触发跨域？</strong></h2><p>如果不符合上面简单请求的条件，以下情况会导致请求被认为是复杂请求，从而触发跨域检查：</p><ul><li>使用了 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>、<code>OPTIONS</code> 等不属于简单请求的方法。</li><li>请求中包含了自定义头，如 <code>Authorization</code>、<code>X-Custom-Header</code> 等。</li><li>使用了 <code>Content-Type</code> 头的其他类型（如 <code>application/json</code>、<code>application/xml</code>）。</li><li>使用了带有 <code>withCredentials: true</code> 的请求，表示请求携带用户凭证（如 Cookies）。</li></ul><h2 id="4、复杂请求和预检请求"><a href="#4、复杂请求和预检请求" class="headerlink" title="4、复杂请求和预检请求"></a><strong>4、复杂请求和预检请求</strong></h2><p>复杂请求会触发浏览器发起一个 <code>OPTIONS</code> 请求，称为<strong>预检请求（Preflight Request）</strong>，服务器需要在这个请求中返回允许跨域访问的 CORS 头信息。只有当预检请求通过后，浏览器才会真正发起复杂请求。</p><hr><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、<strong>总结</strong></h2><p>不会触发跨域的基础请求，遵循了简单请求的规则：</p><ol><li><strong>HTTP 方法</strong>：仅限 <code>GET</code>、<code>POST</code>、<code>HEAD</code>。</li><li><strong>请求头</strong>：仅使用特定的标准头字段，如 <code>Accept</code>、<code>Content-Type</code>，且 <code>Content-Type</code> 必须是 <code>text/plain</code>、<code>multipart/form-data</code> 或 <code>application/x-www-form-urlencoded</code>。</li><li><strong>不使用自定义请求头</strong>，例如 <code>Authorization</code> 等。</li><li><strong>不带凭证</strong>，即不使用 <code>withCredentials: true</code>。</li></ol><p>理解这些规则可以帮助你在开发中规避跨域问题，或者正确配置 CORS 来处理复杂请求。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h1><p>跨域问题是浏览器为了安全性引入的，同源策略的限制避免了跨站点攻击（XSS、CSRF），但同时也带来了开发中的诸多不便。解决跨域问题的方案多种多样，前后端可以根据项目的需求选择合适的方式来处理。</p><ol><li><strong>CORS</strong> 是最常用、最标准的跨域解决方案，推荐使用。</li><li><strong>JSONP</strong> 适用于简单的 GET 请求，但随着 CORS 的普及使用较少。</li><li><strong>反向代理</strong> 在开发环境或生产环境中都非常实用，尤其是在分布式系统中。</li><li><strong>WebSocket</strong> 则适用于需要双向实时通信的场景。</li></ol><p>选择合适的跨域解决方案可以极大提高开发效率，也能让系统更安全地进行数据交互。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6新特性详解</title>
    <link href="/posts/34057/"/>
    <url>/posts/34057/</url>
    
    <content type="html"><![CDATA[<p>ES6（ECMAScript 6，也称为ECMAScript 2015）是JavaScript语言的一个重大更新，引入了许多新特性，旨在使代码更简洁、更易读，同时提供更强大的功能。以下是ES6中引入的主要新特性及其详细解释：</p><hr><h1 id="1-let-和-const-关键字"><a href="#1-let-和-const-关键字" class="headerlink" title="1. let 和 const 关键字"></a>1. <strong><code>let</code> 和 <code>const</code> 关键字</strong></h1><h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a><strong><code>let</code> 声明</strong></h4><ul><li><strong>块级作用域</strong>：<code>let</code> 声明的变量具有块级作用域，即变量只在其所在的代码块 <code>&#123;&#125;</code> 内有效。</li><li><strong>不允许重复声明</strong>：在同一作用域内，不能使用 <code>let</code> 重复声明同一个变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出 10</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 未定义</span><br></code></pre></td></tr></table></figure><h4 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a><strong><code>const</code> 声明</strong></h4><ul><li><strong>常量声明</strong>：<code>const</code> 用于声明常量，变量的值一旦赋值就不能再改变。</li><li><strong>块级作用域</strong>：<code>const</code> 也具有块级作用域。</li><li><strong>必须初始化</strong>：使用 <code>const</code> 声明时，必须同时进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.1415</span>; <span class="hljs-comment">// 报错，无法重新赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-箭头函数（Arrow-Functions）"><a href="#2-箭头函数（Arrow-Functions）" class="headerlink" title="2. 箭头函数（Arrow Functions）"></a>2. <strong>箭头函数（Arrow Functions）</strong></h1><ul><li><strong>简化函数定义</strong>：使用 <code>=&gt;</code> 符号定义函数，语法更简洁。</li><li>**不绑定 <code>this</code>**：箭头函数不创建自己的 <code>this</code>，它会捕获上下文的 <code>this</code> 值。</li><li><strong>不能用作构造函数</strong>：箭头函数不能使用 <code>new</code> 关键字调用。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 5</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3. 模板字符串（Template Literals）"></a>3. <strong>模板字符串（Template Literals）</strong></h1><ul><li><strong>多行字符串</strong>：使用反引号 &#96;&#96;&#96; 包裹，可以直接编写多行字符串。</li><li><strong>字符串插值</strong>：使用 <code>$&#123;表达式&#125;</code> 在字符串中嵌入变量或表达式的值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!</span><br><span class="hljs-string">Welcome to ES6 features.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Hello, Alice!</span><br><span class="hljs-comment">// Welcome to ES6 features.</span><br></code></pre></td></tr></table></figure><hr><h1 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. <strong>默认参数（Default Parameters）</strong></h1><ul><li><strong>函数参数默认值</strong>：在函数定义时，可以为参数指定默认值，当调用函数时未传入该参数时，使用默认值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;Guest&#x27;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// 输出 Hello, Bob!</span><br><span class="hljs-title function_">greet</span>();      <span class="hljs-comment">// 输出 Hello, Guest!</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-剩余参数和展开运算符（Rest-and-Spread-Operators）"><a href="#5-剩余参数和展开运算符（Rest-and-Spread-Operators）" class="headerlink" title="5. 剩余参数和展开运算符（Rest and Spread Operators）"></a>5. <strong>剩余参数和展开运算符（Rest and Spread Operators）</strong></h1><h4 id="剩余参数（Rest-Parameter）"><a href="#剩余参数（Rest-Parameter）" class="headerlink" title="剩余参数（Rest Parameter）"></a><strong>剩余参数（Rest Parameter）</strong></h4><ul><li><strong>函数参数</strong>：使用 <code>...</code> 收集函数的剩余参数，形成一个数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =&gt;</span> total + num, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h4 id="展开运算符（Spread-Operator）"><a href="#展开运算符（Spread-Operator）" class="headerlink" title="展开运算符（Spread Operator）"></a><strong>展开运算符（Spread Operator）</strong></h4><ul><li><strong>数组和对象展开</strong>：使用 <code>...</code> 将数组或对象展开。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组展开</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// 输出 [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// 对象展开</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// 输出 &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-解构赋值（Destructuring-Assignment）"><a href="#6-解构赋值（Destructuring-Assignment）" class="headerlink" title="6. 解构赋值（Destructuring Assignment）"></a>6. <strong>解构赋值（Destructuring Assignment）</strong></h1><ul><li><strong>数组解构</strong>：从数组中提取值，按照对应位置赋值给变量。</li><li><strong>对象解构</strong>：从对象中提取属性，赋值给与属性同名的变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构</span><br><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y); <span class="hljs-comment">// 输出 1 2</span><br><br><span class="hljs-comment">// 对象解构</span><br><span class="hljs-keyword">const</span> &#123; name, age &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// 输出 Alice 25</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-增强的对象字面量（Enhanced-Object-Literals）"><a href="#7-增强的对象字面量（Enhanced-Object-Literals）" class="headerlink" title="7. 增强的对象字面量（Enhanced Object Literals）"></a>7. <strong>增强的对象字面量（Enhanced Object Literals）</strong></h1><h3 id="1-属性简写（Property-Shorthand）"><a href="#1-属性简写（Property-Shorthand）" class="headerlink" title="1. 属性简写（Property Shorthand）"></a>1. 属性简写（Property Shorthand）</h3><p>在 ES6 之前，如果我们要在对象中设置属性，属性名通常与变量名相同，这时需要重复编写属性和变量名。但通过增强的对象字面量，可以直接使用简写语法。</p><h4 id="传统语法："><a href="#传统语法：" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: name,<br>  <span class="hljs-attr">age</span>: age<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-增强对象字面量的属性简写："><a href="#ES6-增强对象字面量的属性简写：" class="headerlink" title="ES6 增强对象字面量的属性简写："></a>ES6 增强对象字面量的属性简写：</h4><p>如果属性名和变量名相同，可以省略重复的部分，简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  name, <span class="hljs-comment">// 相当于 name: name</span><br>  age   <span class="hljs-comment">// 相当于 age: age</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：减少代码冗余，特别是在需要设置多个属性时，代码更简洁明了。</li></ul><h3 id="2-方法简写（Method-Shorthand）"><a href="#2-方法简写（Method-Shorthand）" class="headerlink" title="2. 方法简写（Method Shorthand）"></a>2. 方法简写（Method Shorthand）</h3><p>在对象中定义方法时，传统的写法需要显式使用 <code>function</code> 关键字。在增强的对象字面量中，可以使用更简洁的语法直接定义对象的方法。</p><h4 id="传统语法：-1"><a href="#传统语法：-1" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><h4 id="ES6-方法简写："><a href="#ES6-方法简写：" class="headerlink" title="ES6 方法简写："></a>ES6 方法简写：</h4><p>我们可以省略 <code>function</code> 关键字，直接用简写的形式来定义方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 简写方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：方法简写使得对象中的函数声明更简洁，代码也更容易阅读。</li></ul><h3 id="3-计算属性名（Computed-Property-Names）"><a href="#3-计算属性名（Computed-Property-Names）" class="headerlink" title="3. 计算属性名（Computed Property Names）"></a>3. 计算属性名（Computed Property Names）</h3><p>在增强的对象字面量中，允许动态地为对象的属性名赋值。你可以在对象定义时，通过方括号 <code>[]</code> 包裹表达式，使用计算出的值作为属性名。</p><h4 id="传统语法（ES5-没有计算属性名的支持）："><a href="#传统语法（ES5-没有计算属性名的支持）：" class="headerlink" title="传统语法（ES5 没有计算属性名的支持）："></a>传统语法（ES5 没有计算属性名的支持）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> person = &#123;&#125;;<br><br>person[key] = <span class="hljs-number">25</span>;  <span class="hljs-comment">// 动态添加属性</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-计算属性名："><a href="#ES6-计算属性名：" class="headerlink" title="ES6 计算属性名："></a>ES6 计算属性名：</h4><p>通过计算属性名的方式，可以直接在对象定义时动态设置属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  [key]: <span class="hljs-number">25</span>  <span class="hljs-comment">// 计算属性名</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性名不仅仅可以是变量，还可以是更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&#x27;user&#x27;</span>;<br><span class="hljs-keyword">const</span> id = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>_<span class="hljs-subst">$&#123;id&#125;</span>`</span>]: <span class="hljs-string">&#x27;Alice&#x27;</span>  <span class="hljs-comment">// 动态生成属性名 user_42</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// &#123; user_42: &#x27;Alice&#x27; &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：在需要动态生成属性名的场景下，计算属性名提供了灵活的解决方案。</li></ul><h1 id="8-类（Classes）"><a href="#8-类（Classes）" class="headerlink" title="8. 类（Classes）"></a>8. <strong>类（Classes）</strong></h1><ul><li><strong>类的定义</strong>：使用 <code>class</code> 关键字定义类。</li><li><strong>构造函数</strong>：使用 <code>constructor</code> 方法。</li><li><strong>继承</strong>：使用 <code>extends</code> 关键字实现继承，使用 <code>super</code> 调用父类方法。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">speak</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br>dog.<span class="hljs-title function_">speak</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Buddy makes a sound.</span><br><span class="hljs-comment">// Buddy barks.</span><br></code></pre></td></tr></table></figure><hr><h1 id="9-模块（Modules）"><a href="#9-模块（Modules）" class="headerlink" title="9. 模块（Modules）"></a>9. <strong>模块（Modules）</strong></h1><p>在 ES6（ECMAScript 2015）中，<strong>模块（Modules）</strong>是 JavaScript 中引入的一个重要特性，它为开发者提供了更好地组织代码的方式，使得代码更加模块化、可维护。模块系统允许我们将代码分隔成独立的模块，每个模块可以包含自己的变量、函数、类，并且这些模块之间可以通过 <code>export</code> 和 <code>import</code> 进行共享和使用。</p><p>接下来我们详细讲解模块的基本概念、用法以及如何在现代 JavaScript 项目中使用它们。</p><hr><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>在 ES6 之前，JavaScript 并没有原生的模块系统。开发者通常通过一些全局变量来共享数据，或者使用 IIFE（立即执行函数表达式）来模拟模块封装。这种做法容易导致命名冲突、全局污染，以及代码难以维护、复用性差的问题。</p><p>ES6 引入的模块系统解决了这些问题，它允许我们：</p><ul><li>将代码组织成多个独立的文件或模块；</li><li>在不同模块之间导入或导出功能；</li><li>避免全局命名冲突；</li><li>提高代码的可维护性和复用性。</li></ul><h2 id="ES6-模块基础概念"><a href="#ES6-模块基础概念" class="headerlink" title="ES6 模块基础概念"></a>ES6 模块基础概念</h2><p>ES6 模块主要依赖两个关键字：</p><ul><li>**<code>export</code>**：用来从模块中导出变量、函数、类等内容。</li><li>**<code>import</code>**：用来从其他模块中导入内容。</li></ul><h2 id="1-导出（Export）"><a href="#1-导出（Export）" class="headerlink" title="1. 导出（Export）"></a>1. 导出（Export）</h2><p><code>export</code> 用于将模块中的变量、函数、类等导出，供其他模块使用。</p><h3 id="1-1-命名导出（Named-Export）"><a href="#1-1-命名导出（Named-Export）" class="headerlink" title="1.1. 命名导出（Named Export）"></a>1.1. 命名导出（Named Export）</h3><p>命名导出允许你导出多个内容，并且每个导出都有自己明确的名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>  <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们导出了一个常量 <code>pi</code>，一个函数 <code>add</code>，以及一个类 <code>Calculator</code>。这些内容都可以通过名字从其他模块中导入。</p><h3 id="1-2-默认导出（Default-Export）"><a href="#1-2-默认导出（Default-Export）" class="headerlink" title="1.2. 默认导出（Default Export）"></a>1.2. 默认导出（Default Export）</h3><p>默认导出是指模块中可以有一个默认导出的值，导入时可以不需要用花括号。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// greeting.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们导出了一个默认的函数 <code>greet</code>，默认导出在每个模块中只能有一个。</p><h2 id="2-导入（Import）"><a href="#2-导入（Import）" class="headerlink" title="2. 导入（Import）"></a>2. 导入（Import）</h2><p><code>import</code> 用于从其他模块中导入导出的内容。导入可以是命名导出或默认导出。</p><h3 id="2-1-导入命名导出"><a href="#2-1-导入命名导出" class="headerlink" title="2.1. 导入命名导出"></a>2.1. 导入命名导出</h3><p>当从其他模块导入命名导出时，需要使用花括号 <code>&#123;&#125;</code>，并且变量名必须与导出的名称一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; pi, add, <span class="hljs-title class_">Calculator</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们从 <code>math.js</code> 中导入了 <code>pi</code>、<code>add</code> 函数和 <code>Calculator</code> 类，并在 <code>main.js</code> 中使用。</p><h3 id="2-2-导入默认导出"><a href="#2-2-导入默认导出" class="headerlink" title="2.2. 导入默认导出"></a>2.2. 导入默认导出</h3><p>导入默认导出时不需要使用花括号 <code>&#123;&#125;</code>，并且导入时可以任意命名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeting.js&#x27;</span>;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这里，我们导入了 <code>greeting.js</code> 中的默认导出 <code>greet</code> 函数，并直接使用它。</p><h3 id="2-3-导入别名"><a href="#2-3-导入别名" class="headerlink" title="2.3. 导入别名"></a>2.3. 导入别名</h3><p>有时你可能需要对导入的模块重命名，可以使用 <code>as</code> 来设置别名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>使用 <code>as</code> 可以避免命名冲突或让代码语义更加清晰。</p><h3 id="2-4-导入所有导出（import-as）"><a href="#2-4-导入所有导出（import-as）" class="headerlink" title="2.4. 导入所有导出（import * as）"></a>2.4. 导入所有导出（<code>import * as</code>）</h3><p>你也可以将整个模块的所有导出内容作为一个对象导入。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-property">pi</span>);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们将 <code>math.js</code> 中的所有导出作为一个 <code>math</code> 对象导入，然后通过 <code>math</code> 对象访问导出的内容。</p><h2 id="3-重新导出（Re-export）"><a href="#3-重新导出（Re-export）" class="headerlink" title="3. 重新导出（Re-export）"></a>3. 重新导出（Re-export）</h2><p>有时我们需要从一个模块导入一些内容后再导出给其他模块，这时可以使用 <code>export ... from</code> 语法。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> &#123; pi, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里，<code>moduleA.js</code> 重新导出了 <code>math.js</code> 中的 <code>pi</code> 和 <code>add</code>，其他模块可以直接从 <code>moduleA.js</code> 导入这些内容。</p><h2 id="4-动态导入（Dynamic-Import）"><a href="#4-动态导入（Dynamic-Import）" class="headerlink" title="4. 动态导入（Dynamic Import）"></a>4. 动态导入（Dynamic Import）</h2><p>ES6 模块中的 <code>import</code> 通常是静态的，即在编译时已经决定好导入的内容。然而，ES2020 引入了 <strong>动态导入（Dynamic Import）</strong>，它允许我们在运行时动态加载模块。</p><p>动态导入返回一个 <code>Promise</code>，当模块加载完成后会执行后续的操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error loading module:&#x27;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>动态导入特别适合按需加载模块或实现代码拆分（code splitting）。</p><hr><h2 id="ES6-模块的优势"><a href="#ES6-模块的优势" class="headerlink" title="ES6 模块的优势"></a>ES6 模块的优势</h2><ol><li><strong>默认严格模式</strong>：ES6 模块默认采用严格模式（<code>strict mode</code>），这意味着你可以避免一些常见的错误，比如全局变量的隐式声明。</li><li><strong>模块作用域</strong>：每个模块都有自己的作用域，模块内部的变量不会污染全局作用域，减少了命名冲突的可能性。</li><li><strong>按需导入</strong>：通过导入需要的内容，避免加载多余的代码，有助于提升性能。</li><li><strong>提升代码的可维护性和复用性</strong>：通过将功能分散到不同模块中，代码更容易维护，且可以重复使用不同模块中的功能。</li><li><strong>与现代构建工具集成</strong>：许多现代前端工具（如 Webpack、Parcel）和后端框架（如 Node.js）都支持 ES6 模块，可以方便地将模块化代码与构建工具结合使用。</li></ol><hr><h2 id="ES6-模块-vs-CommonJS"><a href="#ES6-模块-vs-CommonJS" class="headerlink" title="ES6 模块 vs CommonJS"></a>ES6 模块 vs CommonJS</h2><p>在 Node.js 中，最常见的模块系统是 <strong>CommonJS</strong>，通过 <code>require</code> 和 <code>module.exports</code> 来实现模块化。但 ES6 模块的出现提供了更标准化、现代化的解决方案。主要区别如下：</p><ul><li><strong>ES6 模块</strong>：通过 <code>import</code> 和 <code>export</code>，是编译时静态加载，支持浏览器原生模块化。</li><li><strong>CommonJS 模块</strong>：通过 <code>require</code> 和 <code>module.exports</code>，是运行时动态加载，最常见于 Node.js 环境中。</li></ul><p>随着 Node.js 开始原生支持 ES6 模块（通过文件扩展名 <code>.mjs</code> 或设置 <code>&quot;type&quot;: &quot;module&quot;</code>），开发者可以逐渐过渡到使用 ES6 模块系统。</p><hr><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. <strong>Promise 对象</strong></h1><p><strong>Promise</strong> 对象是 ES6 引入的一种用于处理异步操作的解决方案，避免了“回调地狱”的问题，使得异步代码的结构更加清晰、可读。<code>Promise</code> 允许你将异步操作的结果（成功或失败）封装成一个对象，并提供链式调用来处理异步操作的结果。</p><hr><h2 id="1-什么是-Promise？"><a href="#1-什么是-Promise？" class="headerlink" title="1. 什么是 Promise？"></a>1. 什么是 Promise？</h2><p><code>Promise</code> 是一个代表未来某个异步操作的结果的对象，它有三种状态：</p><ul><li><strong>Pending（进行中）</strong>：初始状态，异步操作尚未完成。</li><li><strong>Fulfilled（已完成）</strong>：异步操作成功完成，结果已返回。</li><li><strong>Rejected（已失败）</strong>：异步操作失败，返回了失败原因（通常是一个错误对象）。</li></ul><p>每个 <code>Promise</code> 实例一旦状态从 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变，也就是说 Promise 一旦 resolved 或 rejected 之后，结果是不可修改的。</p><h2 id="2-创建-Promise-对象"><a href="#2-创建-Promise-对象" class="headerlink" title="2. 创建 Promise 对象"></a>2. 创建 Promise 对象</h2><p>我们可以通过 <code>new Promise()</code> 构造函数来创建一个 Promise 对象。它接收一个函数作为参数，该函数包含两个参数：<code>resolve</code> 和 <code>reject</code>。</p><ul><li><code>resolve(value)</code>：当异步操作成功时调用，表示完成并将结果传递给下一个链式操作。</li><li><code>reject(error)</code>：当异步操作失败时调用，表示操作失败并将错误传递给错误处理器。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟异步操作的结果</span><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;操作成功！&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-Promise-状态变化"><a href="#3-Promise-状态变化" class="headerlink" title="3. Promise 状态变化"></a>3. Promise 状态变化</h2><p><code>Promise</code> 对象的状态只能从 <code>Pending</code> 转为 <code>Fulfilled</code> 或 <code>Rejected</code>，一旦状态改变，就不能再修改。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功了！&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 输出：Pending</span><br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：成功了！</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 最初状态为 Pending，2秒后会变为 Fulfilled</span><br></code></pre></td></tr></table></figure><h2 id="4-Promise-的使用"><a href="#4-Promise-的使用" class="headerlink" title="4. Promise 的使用"></a>4. Promise 的使用</h2><p>Promise 主要通过 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 进行链式调用来处理异步操作。</p><h3 id="4-1-then-：处理成功结果"><a href="#4-1-then-：处理成功结果" class="headerlink" title="4.1 .then()：处理成功结果"></a>4.1 <code>.then()</code>：处理成功结果</h3><p><code>then()</code> 方法用于处理 Promise 成功的结果。它接收两个回调函数，分别是成功回调和失败回调。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);  <span class="hljs-comment">// 成功的回调</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);  <span class="hljs-comment">// 失败的回调</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-catch-：处理失败结果"><a href="#4-2-catch-：处理失败结果" class="headerlink" title="4.2 .catch()：处理失败结果"></a>4.2 <code>.catch()</code>：处理失败结果</h3><p><code>catch()</code> 方法用于处理 Promise 中的错误或拒绝操作。它相当于 <code>.then()</code> 的第二个参数，但更适用于单独处理错误的场景。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);  <span class="hljs-comment">// 输出：错误：出错了</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-finally-：无论成功或失败都执行"><a href="#4-3-finally-：无论成功或失败都执行" class="headerlink" title="4.3 .finally()：无论成功或失败都执行"></a>4.3 <code>.finally()</code>：无论成功或失败都执行</h3><p><code>finally()</code> 方法无论 Promise 最终是成功还是失败，都会执行一次操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作结束&#x27;</span>);  <span class="hljs-comment">// 无论成功还是失败，都会执行</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="5-Promise-的链式调用"><a href="#5-Promise-的链式调用" class="headerlink" title="5. Promise 的链式调用"></a>5. Promise 的链式调用</h2><p>Promise 的强大之处在于它允许通过链式调用来处理多个异步操作。每个 <code>then()</code> 调用返回一个新的 <code>Promise</code> 对象，从而可以链式调用下一个异步操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：1</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：2</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：4</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，每个 <code>then()</code> 会返回一个新的 Promise，它可以继续链式调用。最终可以通过多个 <code>then()</code> 处理一系列的异步任务。</p><h2 id="6-Promise-静态方法"><a href="#6-Promise-静态方法" class="headerlink" title="6. Promise 静态方法"></a>6. Promise 静态方法</h2><h3 id="6-1-Promise-resolve"><a href="#6-1-Promise-resolve" class="headerlink" title="6.1 Promise.resolve()"></a>6.1 <code>Promise.resolve()</code></h3><p><code>Promise.resolve()</code> 方法返回一个已被 <code>resolve</code> 的 Promise，可以用来快速封装同步值。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：成功</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-2-Promise-reject"><a href="#6-2-Promise-reject" class="headerlink" title="6.2 Promise.reject()"></a>6.2 <code>Promise.reject()</code></h3><p><code>Promise.reject()</code> 方法返回一个已被 <code>reject</code> 的 Promise，用来封装错误或失败的结果。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 输出：失败</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-3-Promise-all"><a href="#6-3-Promise-all" class="headerlink" title="6.3 Promise.all()"></a>6.3 <code>Promise.all()</code></h3><p><code>Promise.all()</code> 方法接受一个包含多个 Promise 的数组，只有当所有 Promise 都成功时，才会执行 <code>then()</code> 回调；如果任何一个 Promise 失败，它就会立即进入 <code>catch()</code>。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);  <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-4-Promise-race"><a href="#6-4-Promise-race" class="headerlink" title="6.4 Promise.race()"></a>6.4 <code>Promise.race()</code></h3><p><code>Promise.race()</code> 方法接受一个包含多个 Promise 的数组，<strong>只要有一个 Promise 完成</strong>，就会进入 <code>then()</code> 回调，无论是成功还是失败。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;p1&#x27;</span>));<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;p2&#x27;</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：p2</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-Promise-实现异步操作"><a href="#7-Promise-实现异步操作" class="headerlink" title="7. Promise 实现异步操作"></a>7. Promise 实现异步操作</h2><p>Promise 的主要用途是处理异步操作，常见的如网络请求、文件读取等。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模拟异步网络请求</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 模拟请求成功</span><br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;请求的数据&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 输出：请求的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="11-Symbol-类型"><a href="#11-Symbol-类型" class="headerlink" title="11. Symbol 类型"></a>11. <strong>Symbol 类型</strong></h1><p><code>Symbol</code> 是 ECMAScript 6（ES6）引入的一种<strong>原始数据类型</strong>，它表示独一无二的值。与其他 JavaScript 数据类型（如字符串、数字、布尔值等）不同，<code>Symbol</code> 的主要作用是创建一个唯一的标识符，用于避免对象属性命名的冲突。</p><h2 id="1-Symbol-基础概念"><a href="#1-Symbol-基础概念" class="headerlink" title="1. Symbol 基础概念"></a>1. <strong>Symbol 基础概念</strong></h2><p><code>Symbol</code> 是通过 <code>Symbol()</code> 函数调用创建的。与其他原始数据类型不同，<code>Symbol</code> 的每个实例都是唯一的，即使两个 <code>Symbol()</code> 的参数相同，它们也是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbol1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-keyword">const</span> symbol2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbol1 === symbol2);  <span class="hljs-comment">// 输出：false</span><br></code></pre></td></tr></table></figure><ul><li>这里，<code>Symbol()</code> 中的参数 <code>&#39;description&#39;</code> 仅用于调试时的描述（可以理解为符号的标签），它不会影响 <code>Symbol</code> 的唯一性。</li></ul><h2 id="2-Symbol-的特性"><a href="#2-Symbol-的特性" class="headerlink" title="2. Symbol 的特性"></a>2. <strong>Symbol 的特性</strong></h2><ul><li><strong>唯一性</strong>：每个 <code>Symbol</code> 都是独一无二的，即使它们的描述相同，创建出来的 <code>Symbol</code> 也不会相等。</li><li><strong>不可改变</strong>：<code>Symbol</code> 是一种不可变的原始值，类似于 <code>string</code> 或 <code>number</code> 类型，它的值不能被修改。</li><li><strong>不可枚举</strong>：使用 <code>for...in</code>、<code>for...of</code> 或 <code>Object.keys()</code> 等方法遍历对象属性时，<code>Symbol</code> 类型的属性不会被枚举出来。</li></ul><h2 id="3-Symbol-作为对象属性的键"><a href="#3-Symbol-作为对象属性的键" class="headerlink" title="3. Symbol 作为对象属性的键"></a>3. <strong>Symbol 作为对象属性的键</strong></h2><p>通常，JavaScript 对象的键是字符串类型，但 <code>Symbol</code> 可以用作对象的键（属性名）。由于 <code>Symbol</code> 是唯一的，可以避免对象中使用相同的属性名导致的冲突。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [mySymbol]: <span class="hljs-string">&#x27;Symbol 属性值&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;普通属性值&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol]);  <span class="hljs-comment">// 输出：Symbol 属性值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);       <span class="hljs-comment">// 输出：普通属性值</span><br></code></pre></td></tr></table></figure><ul><li>注意，这里使用了 <strong>方括号语法</strong> <code>[mySymbol]</code> 来动态地定义对象的 <code>Symbol</code> 属性。</li></ul><h2 id="4-遍历-Symbol-属性"><a href="#4-遍历-Symbol-属性" class="headerlink" title="4. 遍历 Symbol 属性"></a>4. <strong>遍历 Symbol 属性</strong></h2><p>如前所述，<code>Symbol</code> 属性不会被 <code>for...in</code>、<code>Object.keys()</code> 等遍历方法枚举出来，但你可以通过以下几种方法获取对象的 <code>Symbol</code> 属性：</p><ul><li>**<code>Object.getOwnPropertySymbols()</code>**：返回一个包含对象所有 <code>Symbol</code> 属性的数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [sym1]: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  [sym2]: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> symbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbols);  <span class="hljs-comment">// 输出：[Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><ul><li>**<code>Reflect.ownKeys()</code>**：返回对象所有的键，包括字符串和 <code>Symbol</code> 类型。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj));  <span class="hljs-comment">// 输出：[&quot;name&quot;, Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><h2 id="5-全局-Symbol"><a href="#5-全局-Symbol" class="headerlink" title="5. 全局 Symbol"></a>5. <strong>全局 Symbol</strong></h2><p>JavaScript 还提供了 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 两个方法，用于创建和使用<strong>全局 Symbol</strong>。全局 Symbol 是共享的，即通过相同的 key 创建的全局 Symbol 总是相同的。</p><h3 id="5-1-Symbol-for"><a href="#5-1-Symbol-for" class="headerlink" title="5.1 Symbol.for()"></a>5.1 <strong><code>Symbol.for()</code></strong></h3><p><code>Symbol.for()</code> 方法接收一个字符串作为参数，检查全局注册表中是否存在该字符串对应的 Symbol，如果存在则返回该 Symbol，否则新建一个。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><span class="hljs-keyword">const</span> globalSym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalSym1 === globalSym2);  <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><ul><li><code>Symbol.for()</code> 使得相同 key 的 Symbol 是共享的，因此多个地方可以通过相同的 key 来引用同一个 Symbol。</li></ul><h3 id="5-2-Symbol-keyFor"><a href="#5-2-Symbol-keyFor" class="headerlink" title="5.2 Symbol.keyFor()"></a>5.2 <strong><code>Symbol.keyFor()</code></strong></h3><p><code>Symbol.keyFor()</code> 方法用于获取某个全局 Symbol 的 key。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym));  <span class="hljs-comment">// 输出：myKey</span><br></code></pre></td></tr></table></figure><ul><li>注意：<code>Symbol.keyFor()</code> 只能用于全局 <code>Symbol</code>，而不能用于普通的 <code>Symbol</code>。</li></ul><h2 id="6-内置的-Symbol"><a href="#6-内置的-Symbol" class="headerlink" title="6. 内置的 Symbol"></a>6. <strong>内置的 Symbol</strong></h2><p>ES6 还定义了一些内置的 <code>Symbol</code>，这些内置 <code>Symbol</code> 具有特殊的用途，通常用于定义一些 JavaScript 内部行为的自定义实现。</p><ul><li>**<code>Symbol.iterator</code>**：用于定义对象的默认迭代器，允许对象参与 <code>for...of</code> 循环。</li><li>**<code>Symbol.toStringTag</code>**：用于自定义 <code>Object.prototype.toString</code> 的返回值。</li><li>**<code>Symbol.hasInstance</code>**：用于判断对象是否是某个构造函数的实例。</li></ul><h3 id="6-1-Symbol-iterator"><a href="#6-1-Symbol-iterator" class="headerlink" title="6.1 Symbol.iterator"></a>6.1 <code>Symbol.iterator</code></h3><p><code>Symbol.iterator</code> 是一个内置的 <code>Symbol</code>，允许你为对象定义迭代行为，从而使对象可以被 <code>for...of</code> 循环使用。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterableObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">3</span> ? &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> iterableObj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Symbol-toStringTag"><a href="#6-2-Symbol-toStringTag" class="headerlink" title="6.2 Symbol.toStringTag"></a>6.2 <code>Symbol.toStringTag</code></h3><p><code>Symbol.toStringTag</code> 允许你自定义对象在 <code>Object.prototype.toString()</code> 中显示的标签。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;MyCustomObject&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(myObj));  <span class="hljs-comment">// 输出：[object MyCustomObject]</span><br></code></pre></td></tr></table></figure><h2 id="7-Symbol-的应用场景"><a href="#7-Symbol-的应用场景" class="headerlink" title="7. Symbol 的应用场景"></a>7. <strong>Symbol 的应用场景</strong></h2><ul><li><strong>避免对象属性名冲突</strong>：使用 <code>Symbol</code> 作为对象属性的键，保证属性名是唯一的，防止重写或冲突，特别是在大型代码库或第三方库中。</li><li><strong>为对象定义私有属性</strong>：由于 <code>Symbol</code> 属性不可枚举，通常可以用于实现“伪私有”属性，不会被 <code>for...in</code> 遍历到。</li><li><strong>扩展原生对象的行为</strong>：通过使用内置 <code>Symbol</code>，可以扩展 JavaScript 原生对象的行为，比如为对象自定义迭代器。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. <strong>总结</strong></h2><ul><li><strong><code>Symbol</code> 是一种唯一的标识符</strong>，用于避免对象属性名的冲突。</li><li><strong><code>Symbol</code> 属性不可枚举</strong>，不能通过常规的对象遍历方法访问，但可以通过 <code>Object.getOwnPropertySymbols()</code> 或 <code>Reflect.ownKeys()</code> 获取。</li><li><strong>全局 <code>Symbol</code></strong> 可以通过 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 共享并访问。</li><li>ES6 提供了一些**内置的 <code>Symbol</code>**，用于修改 JavaScript 原生行为，如 <code>Symbol.iterator</code>、<code>Symbol.toStringTag</code> 等。</li></ul><p><code>Symbol</code> 是 JavaScript 中一种非常有用的工具，它为我们提供了更多灵活性和控制力，特别是在大型项目中，使用 <code>Symbol</code> 可以有效地避免属性名冲突和确保代码的稳定性。</p><hr><h1 id="12-迭代器（Iterators）和-for-of-循环"><a href="#12-迭代器（Iterators）和-for-of-循环" class="headerlink" title="12. 迭代器（Iterators）和 for...of 循环"></a>12. <strong>迭代器（Iterators）和 <code>for...of</code> 循环</strong></h1><h2 id="1-迭代器（Iterators）"><a href="#1-迭代器（Iterators）" class="headerlink" title="1. 迭代器（Iterators）"></a>1. 迭代器（Iterators）</h2><p><strong>迭代器</strong>是一种用于访问集合中元素的对象，它提供了一种标准化的方法来遍历各种数据结构（如数组、对象、集合等）。迭代器遵循一定的协议，使得各种对象可以被一致地遍历。</p><h3 id="1-1-迭代器协议"><a href="#1-1-迭代器协议" class="headerlink" title="1.1 迭代器协议"></a>1.1 迭代器协议</h3><p>迭代器协议是一组规则，定义了一个对象如何提供遍历操作。任何实现了这些规则的对象都可以称为迭代器。</p><ul><li><p>迭代器对象</p><p>：必须实现 <strong>next</strong> 方法，该方法返回一个对象，这个对象包含两个属性：</p><ul><li><code>value</code>：当前遍历的值。</li><li><code>done</code>：一个布尔值，指示是否已遍历完所有值（<code>true</code> 表示遍历完成，<code>false</code> 表示还有剩余值）。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterator = &#123;<br>  <span class="hljs-attr">current</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">last</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 3, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-可迭代对象（Iterable-Objects）"><a href="#1-2-可迭代对象（Iterable-Objects）" class="headerlink" title="1.2 可迭代对象（Iterable Objects）"></a>1.2 可迭代对象（Iterable Objects）</h3><p>可迭代对象是具有 <code>Symbol.iterator</code> 属性的对象，<code>Symbol.iterator</code> 属性的值是一个函数，这个函数返回一个迭代器。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterable = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-for-of-循环"><a href="#2-for-of-循环" class="headerlink" title="2. for...of 循环"></a>2. <code>for...of</code> 循环</h2><p><code>for...of</code> 循环是 ES6 引入的用于遍历可迭代对象（包括数组、字符串、Map、Set 等）的一种语法。与传统的 <code>for</code> 循环不同，<code>for...of</code> 循环更简洁、易于理解，并且可以直接访问到每个元素。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><strong>基本语法：</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> iterable) &#123;<br>  <span class="hljs-comment">// 处理 element</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-遍历数组"><a href="#2-1-遍历数组" class="headerlink" title="2.1 遍历数组"></a>2.1 遍历数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><h3 id="2-2-遍历字符串"><a href="#2-2-遍历字符串" class="headerlink" title="2.2 遍历字符串"></a>2.2 遍历字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(char);<br>&#125;<br><span class="hljs-comment">// 输出：h, e, l, l, o</span><br></code></pre></td></tr></table></figure><h3 id="2-3-遍历-Set"><a href="#2-3-遍历-Set" class="headerlink" title="2.3 遍历 Set"></a>2.3 遍历 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> mySet) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h3 id="2-4-遍历-Map"><a href="#2-4-遍历-Map" class="headerlink" title="2.4 遍历 Map"></a>2.4 遍历 Map</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：key1: value1, key2: value2</span><br></code></pre></td></tr></table></figure><h2 id="3-自定义可迭代对象"><a href="#3-自定义可迭代对象" class="headerlink" title="3. 自定义可迭代对象"></a>3. 自定义可迭代对象</h2><p>你可以通过实现 <code>Symbol.iterator</code> 方法来自定义一个可迭代对象，并使用 <code>for...of</code> 循环进行遍历。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> customIterable = &#123;<br>  <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; data.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: data[index++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> customIterable) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li><strong>迭代器</strong> 是遵循特定协议的对象，它包含 <code>next</code> 方法来逐步访问集合中的元素。</li><li><strong>可迭代对象</strong> 是实现了 <code>Symbol.iterator</code> 方法的对象，可以被 <code>for...of</code> 循环遍历。</li><li><strong><code>for...of</code> 循环</strong> 使得遍历可迭代对象变得更加简洁直观，可以直接访问每个元素，而无需手动管理迭代器对象。</li></ul><p>通过理解和掌握这些概念，你可以更有效地处理各种数据结构，编写更加清晰和可维护的代码。</p><hr><h1 id="13-生成器（Generators）"><a href="#13-生成器（Generators）" class="headerlink" title="13. 生成器（Generators）"></a>13. <strong>生成器（Generators）</strong></h1><p>生成器是 ECMAScript 6 (ES6) 引入的一种特殊类型的函数，允许函数在执行时被暂停和恢复。生成器在处理需要多次迭代的任务时非常有用，比如遍历数据集、异步操作等。生成器函数可以简化代码逻辑，并提供了一种优雅的方式来管理异步操作。</p><h2 id="1-生成器的基本概念"><a href="#1-生成器的基本概念" class="headerlink" title="1. 生成器的基本概念"></a>1. <strong>生成器的基本概念</strong></h2><p>生成器是能够暂停执行并在之后的时间点恢复执行的函数。生成器函数通过 <code>function*</code> 关键字定义，并且返回一个生成器对象。生成器对象具有 <code>next()</code> 方法，可以用来控制生成器的执行过程。</p><h2 id="2-生成器函数的定义"><a href="#2-生成器函数的定义" class="headerlink" title="2. 生成器函数的定义"></a>2. <strong>生成器函数的定义</strong></h2><p>生成器函数通过 <code>function*</code> 语法定义。生成器函数内部使用 <code>yield</code> 关键字来暂停函数的执行，并返回一个值。每次调用 <code>next()</code> 方法时，生成器会从上次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 语句。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: World</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: !</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="3-生成器对象"><a href="#3-生成器对象" class="headerlink" title="3. 生成器对象"></a>3. <strong>生成器对象</strong></h2><p>生成器函数返回一个生成器对象，该对象具有以下方法：</p><ul><li>**<code>next([value])</code>**：恢复生成器函数的执行，直到下一个 <code>yield</code> 表达式。可以传递一个参数 <code>value</code>，作为 <code>yield</code> 表达式的返回值。返回的对象包含两个属性：<ul><li><code>value</code>：<code>yield</code> 表达式返回的值。</li><li><code>done</code>：布尔值，表示生成器是否已经完成执行。</li></ul></li><li>**<code>return([value])</code>**：结束生成器的执行，返回一个包含 <code>value</code> 的对象。<code>done</code> 属性将被设置为 <code>true</code>。</li><li>**<code>throw(exception)</code>**：在生成器中抛出异常，生成器会捕获这个异常并将其作为 <code>throw</code> 表达式的结果。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)); <span class="hljs-comment">// 输出: Error: Something went wrong</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-生成器的实际应用"><a href="#4-生成器的实际应用" class="headerlink" title="4. 生成器的实际应用"></a>4. <strong>生成器的实际应用</strong></h2><p>生成器在许多实际场景中都非常有用：</p><ul><li><p><strong>迭代器</strong>：生成器提供了一种简洁的方式来实现自定义的迭代器，使得遍历自定义数据结构变得容易。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">range</span>(<span class="hljs-params">start, end</span>) &#123;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    <span class="hljs-keyword">yield</span> start++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>异步编程</strong>：生成器与 Promise 结合可以简化异步编程。通过使用 <code>yield</code> 可以逐步处理异步操作，代码看起来更加同步。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">fetchData</span>();<br>generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(response).<span class="hljs-property">value</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>状态机</strong>：生成器可以用来实现状态机，通过 <code>yield</code> 和 <code>next()</code> 控制状态的转换。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">stateMachine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;start&#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is start&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;middle&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is middle&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;end&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;State is end&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> machine = <span class="hljs-title function_">stateMachine</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is start</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;middle&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is middle</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;end&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is end</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>生成器是 ES6 中一个强大的特性，它提供了一种简单而灵活的方式来控制函数的执行流。通过 <code>function*</code> 语法定义生成器函数，并使用 <code>yield</code> 来暂停和恢复执行。生成器可以用于实现自定义迭代器、简化异步编程、实现状态机等。它们的使用可以使代码更加优雅和易于维护。</p><p>如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="14-Map-和-Set-数据结构"><a href="#14-Map-和-Set-数据结构" class="headerlink" title="14. Map 和 Set 数据结构"></a>14. <strong><code>Map</code> 和 <code>Set</code> 数据结构</strong></h1><p>在 ECMAScript 6 (ES6) 中，<code>Map</code> 和 <code>Set</code> 是两个新的数据结构，它们提供了比传统的对象和数组更强大的功能，特别是在处理键值对和唯一值时。下面是对这两个数据结构的详细解释。</p><hr><h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a><strong><code>Map</code> 数据结构</strong></h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Map</code> 是一个有序的键值对集合，其中的键和值都可以是任何类型的值。与普通的对象不同，<code>Map</code> 的键值对是按插入顺序保持的，并且键的类型不受限制。</p><h3 id="2-创建-Map"><a href="#2-创建-Map" class="headerlink" title="2. 创建 Map"></a>2. <strong>创建 <code>Map</code></strong></h3><p>你可以使用 <code>new Map()</code> 来创建一个新的 <code>Map</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Map</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Map 实例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Map</span><br><span class="hljs-keyword">const</span> mapWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>],<br>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>set(key, value)</code>**：添加或更新键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>get(key)</code>**：根据键获取值。如果键不存在，返回 <code>undefined</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>has(key)</code>**：检查是否存在指定的键。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(key)</code>**：删除指定的键及其对应的值。如果删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Map</code> 中的所有键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Map</code> 中键值对的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li>**<code>keys()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键。</li><li>**<code>values()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的值。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键值对。</li><li>**<code>forEach(callback)</code>**：对 <code>Map</code> 中的每个键值对执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong><code>Set</code> 数据结构</strong></h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Set</code> 是一个值的集合，其中的值是唯一的，不允许重复。<code>Set</code> 的值是按照插入顺序排列的。</p><h3 id="2-创建-Set"><a href="#2-创建-Set" class="headerlink" title="2. 创建 Set"></a>2. <strong>创建 <code>Set</code></strong></h3><p>你可以使用 <code>new Set()</code> 来创建一个新的 <code>Set</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Set</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Set 实例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Set</span><br><span class="hljs-keyword">const</span> setWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>add(value)</code>**：向 <code>Set</code> 中添加一个值。如果值已经存在，则不会重复添加。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;apple&#x27;</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>has(value)</code>**：检查 <code>Set</code> 中是否存在指定的值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;apple&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(value)</code>**：删除 <code>Set</code> 中的指定值。如果值存在并且删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Set</code> 中的所有值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Set</code> 中的值的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li><strong><code>keys()</code></strong> 和 **<code>values()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有值（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有键值对（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>forEach(callback)</code>**：对 <code>Set</code> 中的每个值执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**<code>Map</code>**：适用于需要键值对并且键可以是任意类型的情况。提供了有序的键值对，并且具有丰富的方法来操作数据。</li><li>**<code>Set</code>**：适用于需要唯一值的情况。提供了无重复的值集合，并且具有方便的方法来检查和操作这些值。</li></ul><p>这两个数据结构在 ES6 中提供了比传统的对象和数组更高效和灵活的操作方式。如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="15-WeakMap-和-WeakSet"><a href="#15-WeakMap-和-WeakSet" class="headerlink" title="15. WeakMap 和 WeakSet"></a>15. <strong><code>WeakMap</code> 和 <code>WeakSet</code></strong></h1><ul><li><strong>弱引用</strong>：<code>WeakMap</code> 和 <code>WeakSet</code> 中的键（对于 <code>WeakMap</code>）和值（对于 <code>WeakSet</code>）是弱引用，不会阻止垃圾回收。</li><li><strong>用途</strong>：常用于存储关联到对象的元数据，不会干扰对象的垃圾回收。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some value&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 被垃圾回收，weakMap 中的键值对也会被自动移除</span><br></code></pre></td></tr></table></figure><hr><h1 id="16-新增的字符串、数字、数组方法"><a href="#16-新增的字符串、数字、数组方法" class="headerlink" title="16. 新增的字符串、数字、数组方法"></a>16. <strong>新增的字符串、数字、数组方法</strong></h1><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a><strong>字符串方法</strong></h4><ul><li>**<code>includes()</code>**：判断字符串是否包含指定子串。</li><li>**<code>startsWith()</code>**：判断字符串是否以指定子串开头。</li><li>**<code>endsWith()</code>**：判断字符串是否以指定子串结尾。</li><li>**<code>repeat()</code>**：将字符串重复指定次数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// 输出 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ha&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 HaHaHa</span><br></code></pre></td></tr></table></figure><h4 id="数字方法"><a href="#数字方法" class="headerlink" title="数字方法"></a><strong>数字方法</strong></h4><ul><li>**<code>Number.isNaN()</code>**：判断值是否为 <code>NaN</code>。</li><li>**<code>Number.isFinite()</code>**：判断值是否为有限数。</li><li>**<code>Number.isInteger()</code>**：判断值是否为整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">4.5</span>)); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h4><ul><li>**<code>Array.from()</code>**：将类数组或可迭代对象转换为数组。</li><li>**<code>Array.of()</code>**：创建一个由参数组成的新数组。</li><li>**<code>find()</code> 和 <code>findIndex()</code>**：找到符合条件的第一个元素或其索引。</li><li>**<code>fill()</code>**：用指定值填充数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 2</span><br><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 输出 [1, 0, 0, 4]</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-Proxy-对象"><a href="#17-Proxy-对象" class="headerlink" title="17. Proxy 对象"></a>17. <strong><code>Proxy</code> 对象</strong></h1><p><code>Proxy</code> 是 ECMAScript 6（ES6）引入的一个新特性，它允许你创建一个对象的代理（Proxy），通过该代理可以定义基本操作的自定义行为，比如属性查找、赋值、枚举、函数调用等。<code>Proxy</code> 提供了一种灵活的机制，用于拦截并修改对目标对象的操作。</p><h2 id="1-创建-Proxy"><a href="#1-创建-Proxy" class="headerlink" title="1. 创建 Proxy"></a>1. <strong>创建 Proxy</strong></h2><p><code>Proxy</code> 构造函数接收两个参数：</p><ul><li>**<code>target</code>**：要创建代理的目标对象，可以是任何对象（包括原始值）。</li><li>**<code>handler</code>**：一个对象，其中定义了代理的行为（即拦截操作）。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><h2 id="2-Handler-对象"><a href="#2-Handler-对象" class="headerlink" title="2. Handler 对象"></a>2. <strong>Handler 对象</strong></h2><p><code>handler</code> 对象包含多个陷阱（trap）方法，这些方法定义了代理如何处理不同的操作。每个陷阱方法对应一个基本操作，如读取属性、设置属性等。</p><p><strong>常见陷阱方法包括：</strong></p><ul><li>**<code>get</code>**：拦截对象属性的读取操作。</li><li>**<code>set</code>**：拦截对象属性的写入操作。</li><li>**<code>has</code>**：拦截 <code>in</code> 操作符。</li><li>**<code>deleteProperty</code>**：拦截 <code>delete</code> 操作符。</li><li>**<code>apply</code>**：拦截函数调用。</li><li>**<code>construct</code>**：拦截构造函数调用。</li><li>**<code>ownKeys</code>**：拦截 <code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.keys()</code>。</li><li>**<code>getPrototypeOf</code>**：拦截 <code>Object.getPrototypeOf()</code>。</li><li>**<code>setPrototypeOf</code>**：拦截 <code>Object.setPrototypeOf()</code>。</li></ul><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h2><p>以下是一些使用 <code>Proxy</code> 对象的示例，展示了如何通过代理对象来拦截和修改对目标对象的操作。</p><h3 id="3-1-属性读取和设置"><a href="#3-1-属性读取和设置" class="headerlink" title="3.1 属性读取和设置"></a>3.1 属性读取和设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>;  <span class="hljs-comment">// 控制台输出: Setting name to John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 控制台输出: Getting name, 输出: John</span><br></code></pre></td></tr></table></figure><ul><li><code>get</code> 陷阱拦截对属性的读取。</li><li><code>set</code> 陷阱拦截对属性的写入。</li></ul><h3 id="3-2-属性存在检查"><a href="#3-2-属性存在检查" class="headerlink" title="3.2 属性存在检查"></a>3.2 属性存在检查</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Checking existence of <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, property);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// 控制台输出: Checking existence of name, 输出: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> proxy);   <span class="hljs-comment">// 控制台输出: Checking existence of age, 输出: false</span><br></code></pre></td></tr></table></figure><ul><li><code>has</code> 陷阱拦截 <code>in</code> 操作符。</li></ul><h3 id="3-3-函数调用"><a href="#3-3-函数调用" class="headerlink" title="3.3 函数调用"></a>3.3 函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling function with arguments <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 控制台输出: Calling function with arguments 1,2, 输出: 3</span><br></code></pre></td></tr></table></figure><ul><li><code>apply</code> 陷阱拦截函数调用。</li></ul><h3 id="3-4-构造函数调用"><a href="#3-4-构造函数调用" class="headerlink" title="3.4 构造函数调用"></a>3.4 构造函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Constructing with arguments <span class="hljs-subst">$&#123;args&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 控制台输出: Constructing with arguments 1,2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);  <span class="hljs-comment">// 输出: target &#123; x: 1, y: 2 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>construct</code> 陷阱拦截构造函数调用。</li></ul><h2 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4. 常见用法"></a>4. <strong>常见用法</strong></h2><ul><li><strong>数据验证</strong>：可以使用 <code>Proxy</code> 对象来验证对目标对象的属性值进行检查，例如确保属性值在某个范围内。</li><li><strong>日志记录</strong>：可以在 <code>Proxy</code> 的陷阱方法中记录对目标对象的所有操作，用于调试和分析。</li><li><strong>防御性编程</strong>：可以通过 <code>Proxy</code> 保护目标对象，防止非法的属性操作。</li><li><strong>虚拟化</strong>：可以使用 <code>Proxy</code> 实现懒加载和其他性能优化技术，例如按需加载对象属性。</li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h2><ul><li><strong>性能</strong>：使用 <code>Proxy</code> 对象会引入额外的开销，因为每个操作都需要经过陷阱函数。对于性能敏感的应用，要慎重使用。</li><li><strong>无法代理的对象</strong>：一些对象（如内置对象、冻结的对象）不能被 <code>Proxy</code> 代理。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><p><code>Proxy</code> 对象是 ES6 引入的强大特性，允许你创建一个代理对象来拦截和自定义对目标对象的操作。通过使用 <code>Proxy</code>，可以实现许多高级功能，如数据验证、日志记录和虚拟化等。在实际应用中，合理使用 <code>Proxy</code> 可以大大提高代码的灵活性和可维护性。</p><hr><h1 id="18-Reflect-API"><a href="#18-Reflect-API" class="headerlink" title="18. Reflect API"></a>18. <strong><code>Reflect</code> API</strong></h1><p><code>Reflect</code> 是 ES6 引入的一个内置对象，它提供了一组方法，用于操作对象的原型和目标对象的内部状态。<code>Reflect</code> 对象主要用于与 <code>Proxy</code> 一起使用，它提供了一些与 <code>Proxy</code> 陷阱方法相对应的基本操作，这些方法可以用来在代理对象内部调用目标对象的原始操作。</p><h2 id="1-Reflect-的方法"><a href="#1-Reflect-的方法" class="headerlink" title="1.Reflect 的方法"></a>1.Reflect 的方法</h2><p><code>Reflect</code> 提供了一些与对象操作相关的静态方法，这些方法对应于对象操作的基本行为。主要的方法包括：</p><ul><li><p><strong><code>Reflect.apply(target, thisArg, argumentsList)</code></strong></p><ul><li><p>用于调用一个函数，类似于 <code>Function.prototype.apply</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：要调用的函数。</li><li><code>thisArg</code>：函数内部的 <code>this</code>。</li><li><code>argumentsList</code>：参数数组。</li></ul></li><li><p><strong>返回值</strong>：函数调用的结果。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(sum, <span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.construct(target, argumentsList, newTarget)</code></strong></p><ul><li><p>用于创建一个对象实例，类似于 <code>new</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：构造函数。</li><li><code>argumentsList</code>：构造函数的参数数组。</li><li><code>newTarget</code>：指定构造函数的原型链的对象。</li></ul></li><li><p><strong>返回值</strong>：构造函数创建的新对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: Alice</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.defineProperty(target, propertyKey, attributes)</code></strong></p><ul><li><p>用于定义目标对象的属性，类似于 <code>Object.defineProperty</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>attributes</code>：属性描述符。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功定义。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.deleteProperty(target, propertyKey)</code></strong></p><ul><li><p>用于删除目标对象的属性，类似于 <code>delete</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：要删除的属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.get(target, propertyKey, receiver)</code></strong></p><ul><li><p>用于获取目标对象的属性值，类似于 <code>target[propertyKey]</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：属性的值。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.getPrototypeOf(target)</code></strong></p><ul><li><p>用于获取目标对象的原型，类似于 <code>Object.getPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：目标对象的原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prototype === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.has(target, propertyKey)</code></strong></p><ul><li><p>用于检查目标对象是否具有指定的属性，类似于 <code>propertyKey in target</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否存在。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.isExtensible(target)</code></strong></p><ul><li><p>用于检查目标对象是否可扩展（即是否可以添加新属性），类似于 <code>Object.isExtensible</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示目标对象是否可扩展。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.ownKeys(target)</code></strong></p><ul><li><p>用于获取目标对象的所有属性名（包括符号属性），类似于 <code>Object.getOwnPropertyNames</code> 和 <code>Object.getOwnPropertySymbols</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：属性名数组。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// 输出: [&#x27;name&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.set(target, propertyKey, value, receiver)</code></strong></p><ul><li><p>用于设置目标对象的属性值，类似于 <code>target[propertyKey] = value</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>value</code>：属性值。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功设置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.setPrototypeOf(target, prototype)</code></strong></p><ul><li><p>用于设置目标对象的原型，类似于 <code>Object.setPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>prototype</code>：新的原型。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示是否成功设置原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> newProto = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, newProto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === newProto);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><ul><li><strong><code>Reflect</code></strong> 对象提供了一组静态方法，用于操作对象的基本行为。</li><li><strong><code>Reflect</code></strong> 方法主要用于与 <code>Proxy</code> 一起使用，以便在代理对象中执行目标对象的操作。</li><li><strong><code>Reflect</code></strong> 提供的方法与目标对象操作的方法一一对应，简化了对象操作的实现逻辑，使得代码更加一致和可维护。</li></ul><p><code>Reflect</code> 对象是一个强大的工具，用于更细粒度地控制对象的行为，并且是 ES6 提供的一个重要功能。</p><hr><h1 id="19-尾调用优化（Tail-Call-Optimization）"><a href="#19-尾调用优化（Tail-Call-Optimization）" class="headerlink" title="19. 尾调用优化（Tail Call Optimization）"></a>19. <strong>尾调用优化（Tail Call Optimization）</strong></h1><p>尾调用优化（TCO）是一种编程语言优化技术，旨在提高递归函数的效率，防止函数调用栈的增长，避免因递归深度过大而导致的栈溢出。尾调用优化的核心思想是将尾递归（即递归调用是函数的最后一步操作）转换为更高效的迭代形式，从而减少内存使用。</p><h2 id="1-尾调用（Tail-Call）"><a href="#1-尾调用（Tail-Call）" class="headerlink" title="1. 尾调用（Tail Call）"></a>1. <strong>尾调用（Tail Call）</strong></h2><p>尾调用是指在函数的最后一步调用另一个函数，而没有任何额外的计算。换句话说，尾调用是函数调用的最后操作，没有任何额外的工作要做。这种调用模式适合进行尾调用优化。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>factorial</code> 函数中的递归调用 <code>factorial(n - 1, n * result)</code> 是尾调用，因为它是函数 <code>factorial</code> 的最后一步操作。</p><h2 id="2-尾调用优化的原理"><a href="#2-尾调用优化的原理" class="headerlink" title="2. 尾调用优化的原理"></a>2. <strong>尾调用优化的原理</strong></h2><p>在尾调用优化中，当一个函数执行尾调用时，编译器或解释器会将当前函数的栈帧复用到被调用函数的栈帧中。这样，递归调用不会增加新的栈帧，从而避免了栈空间的消耗。</p><p><strong>过程：</strong></p><ol><li><strong>当前函数执行到尾调用位置</strong>。</li><li><strong>丢弃当前函数的栈帧</strong>，因为在尾调用时当前函数的执行已经完成。</li><li><strong>重用当前函数的栈帧</strong>，将控制权转移到被调用函数。</li></ol><p>通过这种方式，尾调用优化将递归调用转化为迭代，从而避免了递归深度带来的性能问题。</p><h2 id="3-支持尾调用优化的语言"><a href="#3-支持尾调用优化的语言" class="headerlink" title="3. 支持尾调用优化的语言"></a>3. <strong>支持尾调用优化的语言</strong></h2><p>一些编程语言支持尾调用优化，包括：</p><ul><li><strong>Scheme</strong>：作为 Lisp 家族的一员，Scheme 是一种支持尾调用优化的函数式编程语言。</li><li><strong>Racket</strong>：Racket 也是一种支持尾调用优化的语言，具有类似于 Scheme 的特性。</li><li><strong>Haskell</strong>：Haskell 是一种纯函数式编程语言，支持尾调用优化。</li></ul><h2 id="4-JavaScript-中的尾调用优化"><a href="#4-JavaScript-中的尾调用优化" class="headerlink" title="4. JavaScript 中的尾调用优化"></a>4. <strong>JavaScript 中的尾调用优化</strong></h2><p>虽然 JavaScript 语言规范（ECMAScript 2015）引入了尾调用优化的提案，但实际支持这一特性的浏览器和 JavaScript 引擎的实现仍然不统一。部分浏览器的 JavaScript 引擎可能并不完全支持尾调用优化，因此，在实际开发中不一定能保证尾调用优化的效果。</p><p><strong>ECMAScript 2015（ES6）提案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 规范中定义了尾调用优化的行为，但实际支持情况取决于 JavaScript 引擎的实现。</p><h2 id="5-非支持尾调用优化的情况下的解决方案"><a href="#5-非支持尾调用优化的情况下的解决方案" class="headerlink" title="5. 非支持尾调用优化的情况下的解决方案"></a>5. <strong>非支持尾调用优化的情况下的解决方案</strong></h2><p>如果运行环境不支持尾调用优化，递归深度过大可能会导致栈溢出。在这种情况下，可以使用迭代代替递归，以避免深度递归带来的问题。</p><p><strong>迭代替代尾递归示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    result *= n;<br>    n--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例使用了迭代来计算阶乘，而不是递归，从而避免了栈溢出的问题。</p><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul><li><strong>尾调用</strong> 是指在函数的最后一步调用另一个函数。</li><li><strong>尾调用优化（TCO）</strong> 通过重用栈帧来减少递归深度，避免栈溢出。</li><li>一些编程语言（如 Scheme、Haskell）支持尾调用优化，但 JavaScript 的支持情况不一致。</li><li>当尾调用优化不可用时，可以使用迭代代替递归来避免栈溢出。</li></ul><p>尾调用优化是函数式编程中的一个重要概念，通过优化递归调用，可以使代码更加高效、健壮。在实际开发中，要根据运行环境的特性来决定是否依赖于尾调用优化。</p><hr><h1 id="20-模块加载器（Module-Loader）"><a href="#20-模块加载器（Module-Loader）" class="headerlink" title="20. 模块加载器（Module Loader）"></a>20. <strong>模块加载器（Module Loader）</strong></h1><p>在 ECMAScript 2015（ES6）中，引入了原生的模块系统，这一系统为 JavaScript 提供了标准化的模块化支持，称为 ES6 模块（ESM）。ES6 模块系统具有内建的模块加载器，允许开发者通过 <code>import</code> 和 <code>export</code> 语法来进行模块化编程。</p><h2 id="1-ES6-模块的基本概念"><a href="#1-ES6-模块的基本概念" class="headerlink" title="1. ES6 模块的基本概念"></a>1. <strong>ES6 模块的基本概念</strong></h2><p>在 ES6 中，模块是 JavaScript 代码的基本组织单元。每个模块都有自己的作用域，模块之间的依赖关系通过显式的 <code>import</code> 和 <code>export</code> 语法来定义和管理。</p><p><strong>模块的基本特点</strong>：</p><ul><li><strong>静态加载</strong>：模块在编译时加载，这使得依赖关系可以在编译阶段进行静态分析和优化。</li><li><strong>严格模式</strong>：模块默认在严格模式下运行，这有助于避免一些常见的 JavaScript 错误。</li><li><strong>导入和导出</strong>：模块可以通过 <code>export</code> 导出变量、函数或类，并通过 <code>import</code> 导入其他模块的导出。</li></ul><h2 id="2-模块导出（Export）"><a href="#2-模块导出（Export）" class="headerlink" title="2. 模块导出（Export）"></a>2. <strong>模块导出（Export）</strong></h2><p>ES6 模块通过 <code>export</code> 语法导出模块的功能。导出的内容可以是变量、函数、类或对象。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateArea</span>(<span class="hljs-params">radius</span>) &#123; <span class="hljs-comment">// 导出函数</span><br>  <span class="hljs-keyword">return</span> pi * radius * radius;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123; <span class="hljs-comment">// 导出类</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">radius</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;<br>  &#125;<br>  <span class="hljs-title function_">getArea</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> pi * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-模块导入（Import）"><a href="#3-模块导入（Import）" class="headerlink" title="3. 模块导入（Import）"></a>3. <strong>模块导入（Import）</strong></h2><p>ES6 模块通过 <code>import</code> 语法导入其他模块的内容。可以导入整个模块的功能，也可以导入模块的部分功能。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; pi, calculateArea, <span class="hljs-title class_">Circle</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi); <span class="hljs-comment">// 输出: 3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateArea</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 78.5</span><br><br><span class="hljs-keyword">const</span> myCircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCircle.<span class="hljs-title function_">getArea</span>()); <span class="hljs-comment">// 输出: 78.5</span><br></code></pre></td></tr></table></figure><h2 id="4-默认导出（Default-Export）"><a href="#4-默认导出（Default-Export）" class="headerlink" title="4. 默认导出（Default Export）"></a>4. <strong>默认导出（Default Export）</strong></h2><p>ES6 模块允许每个模块有一个默认导出，这对于导出单一的功能或对象非常有用。默认导出可以是变量、函数或类。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>; <span class="hljs-comment">// 导入默认导出</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><h2 id="5-动态导入（Dynamic-Import）"><a href="#5-动态导入（Dynamic-Import）" class="headerlink" title="5. 动态导入（Dynamic Import）"></a>5. <strong>动态导入（Dynamic Import）</strong></h2><p>ES6 模块也支持动态导入，即在运行时加载模块。这是通过 <code>import()</code> 函数实现的，返回一个 Promise 对象，可以在异步操作中使用。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">pi</span>);<br>&#125;<br><br><span class="hljs-title function_">loadModule</span>();<br></code></pre></td></tr></table></figure><h2 id="6-模块加载器的工作原理"><a href="#6-模块加载器的工作原理" class="headerlink" title="6. 模块加载器的工作原理"></a>6. <strong>模块加载器的工作原理</strong></h2><p>ES6 模块加载器的工作原理包括以下几个步骤：</p><ol><li><strong>解析模块</strong>：当模块被加载时，加载器会解析模块的 <code>import</code> 和 <code>export</code> 语法，确定模块之间的依赖关系。</li><li><strong>加载模块</strong>：根据解析结果，加载器会从指定的路径或 URL 加载模块的代码。</li><li><strong>执行模块</strong>：加载器会执行模块的代码，并处理模块的 <code>export</code> 和 <code>import</code> 语句。</li><li><strong>缓存模块</strong>：已加载的模块会被缓存，以便后续的 <code>import</code> 语句可以复用缓存的模块，避免重复加载。</li><li><strong>导出模块</strong>：模块的功能会通过 <code>export</code> 语法对外提供，其他模块可以通过 <code>import</code> 语法引用这些功能。</li></ol><h2 id="7-模块加载器的特点"><a href="#7-模块加载器的特点" class="headerlink" title="7. 模块加载器的特点"></a>7. <strong>模块加载器的特点</strong></h2><ul><li><strong>静态分析</strong>：ES6 模块的静态结构使得模块系统能够在编译时进行依赖分析和优化。</li><li><strong>作用域隔离</strong>：每个模块都有自己的作用域，避免了全局命名冲突。</li><li><strong>延迟加载</strong>：使用动态导入可以按需加载模块，提高应用程序的性能。</li><li><strong>编译时错误检测</strong>：静态分析可以在编译阶段检测导入和导出语法错误，提升代码质量。</li></ul><h2 id="8-与其他模块系统的比较"><a href="#8-与其他模块系统的比较" class="headerlink" title="8. 与其他模块系统的比较"></a>8. <strong>与其他模块系统的比较</strong></h2><p>与 CommonJS、AMD 和 UMD 等其他模块系统相比，ES6 模块具有以下优势：</p><ul><li><strong>原生支持</strong>：ES6 模块是 JavaScript 的标准部分，所有现代 JavaScript 引擎都支持。</li><li><strong>静态分析</strong>：ES6 模块的静态结构使得编译器和工具能够进行优化。</li><li><strong>模块作用域</strong>：ES6 模块的作用域隔离提供了更好的代码组织和模块管理。</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. <strong>总结</strong></h2><p>ES6 模块系统通过 <code>import</code> 和 <code>export</code> 语法提供了一个标准化的模块化机制，支持静态加载和动态导入。它的引入使得 JavaScript 的模块化编程更加高效和一致，为开发大型应用程序提供了强大的工具。了解 ES6 模块系统的工作原理和使用方法，有助于更好地组织和管理代码，提高代码的可维护性和重用性。</p><hr><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>ES6 的引入使 JavaScript 语言更加完善，提供了更强大的功能和更简洁的语法，极大地提高了开发效率。这些新特性涵盖了变量声明、函数定义、对象和数组操作、类和继承、模块化、异步编程等各个方面。熟练掌握ES6的新特性，将有助于编写出更加高效、可读性更强的代码。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventEmitter</title>
    <link href="/posts/36600/"/>
    <url>/posts/36600/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">2</span> 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br><span class="hljs-number">1</span> 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-property">js</span>:<span class="hljs-number">201</span> <br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// process.nextTick error, or &#x27;error&#x27; event on first tick </span><br>^ <br><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Uncaught</span>, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">emit</span> (events.<span class="hljs-property">js</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span>) <br>at <span class="hljs-title class_">Object</span>.&lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>byvoid/error.<span class="hljs-property">js</span>:<span class="hljs-number">5</span>:<span class="hljs-number">9</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">_compile</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">441</span>:<span class="hljs-number">26</span>) <br>at <span class="hljs-title class_">Object</span>..<span class="hljs-property">js</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">459</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">348</span>:<span class="hljs-number">31</span>) <br>at <span class="hljs-title class_">Function</span>.<span class="hljs-property">_load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">308</span>:<span class="hljs-number">12</span>) <br>at <span class="hljs-title class_">Array</span><span class="hljs-number">.0</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">479</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">_tickCallback</span> (node.<span class="hljs-property">js</span>:<span class="hljs-number">192</span>:<span class="hljs-number">40</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Node.js的线程机制</title>
    <link href="/posts/22142/"/>
    <url>/posts/22142/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Node-js的线程机制、事件循环与高并发处理"><a href="#深入理解Node-js的线程机制、事件循环与高并发处理" class="headerlink" title="深入理解Node.js的线程机制、事件循环与高并发处理"></a>深入理解Node.js的线程机制、事件循环与高并发处理</h1><p>Node.js因其强大的高并发处理能力而备受青睐。这一能力得益于其事件驱动的非阻塞I&#x2F;O模型和高效的事件循环机制。在这篇博客中，我们将深入探讨Node.js的线程机制、事件循环的工作流程与优先级，以及如何避免阻塞主线程的最佳实践。通过这些内容，你将更好地理解Node.js的内部运行机制，并学会如何编写高效的Node.js应用程序。</p><hr><h2 id="1-Node-js-的线程机制"><a href="#1-Node-js-的线程机制" class="headerlink" title="1. Node.js 的线程机制"></a>1. Node.js 的线程机制</h2><p>Node.js 是单线程的，但它通过多线程的方式处理高并发。JavaScript代码运行在主线程中，而Node.js使用的<a href="https://libuv.org/">libuv</a>库则提供了一个基于事件循环的异步I&#x2F;O模型，使得主线程不会因为I&#x2F;O操作而被阻塞。</p><h3 id="主线程与-libuv-线程池"><a href="#主线程与-libuv-线程池" class="headerlink" title="主线程与 libuv 线程池"></a><strong>主线程与 <a href="https://libuv.org/">libuv</a> 线程池</strong></h3><ul><li><strong>主线程</strong>：Node.js中的JavaScript代码在一个单独的主线程中运行，该线程处理所有的同步代码。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：用于处理阻塞性任务，如文件I&#x2F;O、DNS查询等，工作线程池通常包含4个线程，可以根据需要配置更多。</li></ul><p>Node.js通过将耗时的I&#x2F;O操作交给<a href="https://libuv.org/">libuv</a>线程池中的工作线程来处理，从而避免主线程被阻塞。这种设计使得Node.js可以在单线程的主线程中处理大量并发请求，而不会因为阻塞I&#x2F;O操作而降低性能。</p><h3 id="重点知识："><a href="#重点知识：" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>主线程</strong>：负责执行所有同步任务。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：处理阻塞I&#x2F;O任务，防止主线程阻塞。</li></ul><hr><h2 id="2-Node-js-的高并发原理"><a href="#2-Node-js-的高并发原理" class="headerlink" title="2. Node.js 的高并发原理"></a>2. Node.js 的高并发原理</h2><p>Node.js的高并发处理能力主要源于其事件驱动的非阻塞I&#x2F;O模型。通过事件循环，Node.js可以在单线程环境中处理大量的并发请求。</p><h3 id="事件驱动的非阻塞I-O模型"><a href="#事件驱动的非阻塞I-O模型" class="headerlink" title="事件驱动的非阻塞I&#x2F;O模型"></a><strong>事件驱动的非阻塞I&#x2F;O模型</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：Node.js 的I&#x2F;O操作不会阻塞主线程，而是将I&#x2F;O操作委托给<a href="https://libuv.org/">libuv</a>线程池处理，主线程在I&#x2F;O操作完成之前可以继续执行其他任务。</li><li><strong>异步任务队列</strong>：异步操作的回调函数会被放入任务队列中，等待主线程空闲时由事件循环调度执行。</li></ul><p>通过这种非阻塞设计，Node.js能够高效地处理并发请求。</p><h5 id="代码示例：异步I-O操作"><a href="#代码示例：异步I-O操作" class="headerlink" title="代码示例：异步I&#x2F;O操作"></a><strong>代码示例：异步I&#x2F;O操作</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File content:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This log comes first!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>fs.readFile</code> 是一个异步操作，它会将回调函数放入任务队列中，而不会阻塞主线程。因此，<code>console.log(&#39;This log comes first!&#39;)</code> 会先于文件内容的输出执行。</p><h3 id="重点知识：-1"><a href="#重点知识：-1" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：避免主线程因I&#x2F;O操作而阻塞。</li><li><strong>异步任务队列</strong>：存储需要执行的异步操作回调。</li></ul><hr><h2 id="3-事件循环的工作机制与优先级"><a href="#3-事件循环的工作机制与优先级" class="headerlink" title="3. 事件循环的工作机制与优先级"></a>3. 事件循环的工作机制与优先级</h2><p>事件循环是Node.js运行的核心机制，它决定了程序中代码的执行顺序。我们将详细剖析事件循环的工作流程及其优先级，帮助你更好地理解Node.js的并发处理。</p><h3 id="事件循环的工作流程"><a href="#事件循环的工作流程" class="headerlink" title="事件循环的工作流程"></a><strong>事件循环的工作流程</strong></h3><ol><li><strong>执行同步代码</strong>：事件循环首先执行主线程中的同步代码，这些代码会被立即执行。</li><li><strong>进入事件循环</strong>：当同步代码执行完毕后，事件循环开始检查任务队列中是否有待处理的异步回调。</li><li><strong>处理异步回调</strong>：事件循环依次从任务队列中取出回调函数并执行。</li><li><strong>循环往复</strong>：事件循环不断检查并处理任务队列中的任务，直到队列为空。</li></ol><h3 id="事件循环的优先级"><a href="#事件循环的优先级" class="headerlink" title="事件循环的优先级"></a><strong>事件循环的优先级</strong></h3><p>事件循环在执行任务时遵循一定的优先级。常见的优先级顺序如下：</p><ul><li><strong>Microtasks（微任务）</strong>：包括 <code>process.nextTick</code> 和 <code>Promise</code> 的回调。这些任务优先级最高，通常会在当前操作结束后立即执行。</li><li><strong>Timers（计时器）</strong>：如 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>I&#x2F;O callbacks</strong>：处理来自I&#x2F;O操作的回调。</li><li><strong>Check</strong>：执行 <code>setImmediate</code> 的回调函数。</li><li><strong>Close callbacks</strong>：处理 <code>close</code> 事件的回调。</li></ul><h5 id="代码示例：事件循环的优先级"><a href="#代码示例：事件循环的优先级" class="headerlink" title="代码示例：事件循环的优先级"></a><strong>代码示例：事件循环的优先级</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Sync</span> code<br>nextTick<br><span class="hljs-title class_">Promise</span><br><span class="hljs-built_in">setTimeout</span><br>setImmediate<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;Sync code&#39;)</code> 立即执行，<code>process.nextTick</code> 和 <code>Promise</code> 回调作为微任务执行，其次是 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调。</p><h3 id="重点知识：-2"><a href="#重点知识：-2" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>事件循环阶段</strong>：不同类型的任务在事件循环中具有不同的优先级。</li><li><strong>Microtasks</strong>：优先级最高的任务，通常在当前事件循环阶段结束后立即执行。</li></ul><hr><h2 id="4-为什么先执行同步代码，再执行事件循环？"><a href="#4-为什么先执行同步代码，再执行事件循环？" class="headerlink" title="4. 为什么先执行同步代码，再执行事件循环？"></a>4. 为什么先执行同步代码，再执行事件循环？</h2><p>Node.js在执行代码时，首先会运行同步代码，这是因为同步代码通常包含程序的初始化、配置、变量定义等重要操作。如果不先执行同步代码，异步回调可能会在未准备好的上下文中被触发，导致程序行为不可预测。</p><h3 id="同步代码的定义"><a href="#同步代码的定义" class="headerlink" title="同步代码的定义"></a><strong>同步代码的定义</strong></h3><p>同步代码是指立即执行并返回结果的代码，不依赖于异步事件的完成。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is synchronous code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>同步代码执行完后，事件循环才会开始处理异步任务。</p><h5 id="代码示例：同步代码与异步代码"><a href="#代码示例：同步代码与异步代码" class="headerlink" title="代码示例：同步代码与异步代码"></a><strong>代码示例：同步代码与异步代码</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is asynchronous&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在此例中，<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 是同步代码，它们会立即执行，而 <code>setTimeout</code> 的回调则是异步代码，会在同步代码执行完毕后，由事件循环调度执行。</p><h3 id="避免将复杂任务放入主线程"><a href="#避免将复杂任务放入主线程" class="headerlink" title="避免将复杂任务放入主线程"></a><strong>避免将复杂任务放入主线程</strong></h3><p>在主线程中放入复杂的同步任务，会阻塞主线程，导致事件循环无法及时处理异步任务。为了解决这个问题，我们可以使用以下几种方法：</p><ol><li><strong>将任务拆分</strong>：将复杂的同步任务拆分为多个小任务，分批执行。</li><li>**使用 <code>setImmediate</code>**：将长时间执行的任务放入下一个事件循环阶段执行。</li><li>**使用 <code>Worker Threads</code>**：将复杂计算任务放入工作线程中执行，避免阻塞主线程。</li></ol><h5 id="代码示例：使用-setImmediate-避免阻塞"><a href="#代码示例：使用-setImmediate-避免阻塞" class="headerlink" title="代码示例：使用 setImmediate 避免阻塞"></a><strong>代码示例：使用 <code>setImmediate</code> 避免阻塞</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">complexTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task Done:&#x27;</span>, count);<br>&#125;<br><br><span class="hljs-title function_">setImmediate</span>(complexTask);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will log before complexTask finishes&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>complexTask</code> 是一个可能会阻塞主线程的复杂任务。通过使用 <code>setImmediate</code>，我们可以将其延迟到当前事件循环阶段结束后再执行，从而避免阻塞其他重要的任务。</p><h5 id="使用-Worker-Threads-进行并行计算"><a href="#使用-Worker-Threads-进行并行计算" class="headerlink" title="使用 Worker Threads 进行并行计算"></a><strong>使用 <code>Worker Threads</code> 进行并行计算</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from worker:&#x27;</span>, message));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  parentPort.<span class="hljs-title function_">postMessage</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，复杂的计算任务被移至工作线程中执行，不再阻塞主线程。这使得主线程可以继续处理其他任务，而不会受到复杂计算的影响。</p><h3 id="重点知识：-3"><a href="#重点知识：-3" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>避免主线程阻塞</strong>：将复杂任务分拆或延迟执行，避免阻塞事件循环。</li><li><strong>Worker Threads</strong>：用于处理计算密集型任务，减少主线程压力。</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对Node.js线程机制、事件循环与高并发处理的深入探讨，我们了解到如何编写高效的Node.js应用程序。理解事件循环的工作原理和优先级，可以帮助我们更好地管理异步任务的执行顺序，避免主线程被阻塞。同时，采用合理的技术，如 <code>Worker Threads</code> 和 <code>setImmediate</code>，能够有效地提升程序性能，确保高并发环境下的稳定性。</p><hr><p>这篇博客详细解释了Node.js的线程机制及事件循环，并提供了避免主线程阻塞的实际解决方案。希望这些内容对你理解和优化Node.js应用程序有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的回收机制</title>
    <link href="/posts/580/"/>
    <url>/posts/580/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-的垃圾回收机制"><a href="#一、JavaScript-的垃圾回收机制" class="headerlink" title="一、JavaScript 的垃圾回收机制"></a>一、JavaScript 的垃圾回收机制</h1><p>JavaScript 的垃圾回收机制主要依赖于一种称为 <strong>“标记-清除”（Mark-and-Sweep）</strong> 的算法。垃圾回收（Garbage Collection, GC）负责自动管理内存，回收不再使用的对象所占用的内存，以防止内存泄漏。</p><h3 id="垃圾回收的工作原理"><a href="#垃圾回收的工作原理" class="headerlink" title="垃圾回收的工作原理"></a>垃圾回收的工作原理</h3><ol><li><strong>标记阶段（Marking Phase）</strong>:<ul><li>垃圾回收器会在内存中“标记”所有活动的、可到达的对象。所谓“可到达”是指对象可以通过根（通常是全局变量或当前作用域中的变量）直接或间接访问到。</li><li>垃圾回收器从根开始，递归地遍历所有引用的对象，并标记这些对象为“活动的”。</li></ul></li><li><strong>清除阶段（Sweeping Phase）</strong>:<ul><li>在标记阶段结束后，垃圾回收器会遍历内存中的所有对象，清除没有被标记的对象（即那些不可到达的对象）。</li><li>清除后，这些对象所占用的内存将被回收并重新分配。</li></ul></li></ol><h3 id="触发垃圾回收的条件"><a href="#触发垃圾回收的条件" class="headerlink" title="触发垃圾回收的条件"></a>触发垃圾回收的条件</h3><ul><li>JavaScript 引擎的垃圾回收器在运行时会周期性地执行垃圾回收，以回收不再使用的内存。</li><li>垃圾回收器的执行是非确定性的，这意味着你不能确切知道何时会触发垃圾回收。通常是在内存分配请求达到一定阈值或空闲时执行。</li></ul><h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><ol><li><p><strong>内存泄漏</strong>: 当程序中不再需要的对象无法被垃圾回收器清除时，内存泄漏就会发生，导致内存使用量持续增长。</p><ul><li><p><strong>未解除的事件监听器</strong>: 如果在不再需要时没有手动移除事件监听器，监听器中对对象的引用将导致这些对象无法被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachEventListener</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element clicked!&#x27;</span>);<br>    &#125;<br><br>    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br><br>    <span class="hljs-comment">// 模拟在元素销毁时忘记移除监听器</span><br>    <span class="hljs-comment">// element.removeEventListener(&#x27;click&#x27;, handleClick);</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数后，element和handleClick函数依然存在引用，导致element不能被回收。</span><br><span class="hljs-title function_">attachEventListener</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p><strong>事件监听器的引用</strong>：</p><ul><li>当你调用 <code>element.addEventListener(&#39;click&#39;, handleClick)</code> 时，浏览器内部实际上在 <code>element</code> 对象的某个地方（通常是在它的事件监听器列表中）保存了对 <code>handleClick</code> 函数的引用。这意味着 <code>element</code> 本身还存活在内存中，因为它的事件监听器依然在引用它。</li></ul><p><strong>引用链的存在</strong>：</p><ul><li>尽管 <code>element</code> 是一个局部变量，函数 <code>attachEventListener</code> 执行完后不会直接持有对它的引用，但是因为事件监听器 (<code>handleClick</code>) 被添加到了 <code>element</code> 上，<code>element</code> 对象内部保存了对 <code>handleClick</code> 的引用。</li><li>反过来，因为 <code>handleClick</code> 函数是在 <code>attachEventListener</code> 内部定义的，它对定义该函数的外部作用域有引用链，因此，这种引用链会一直存在，直到 <code>element</code> 被手动移除事件监听器或者 <code>element</code> 本身被彻底销毁。</li></ul><p><strong>内存泄漏的来源</strong>：</p><ul><li>如果 <code>element</code> 被从 DOM 中移除（比如被 <code>document.removeChild</code>），但没有调用 <code>element.removeEventListener(&#39;click&#39;, handleClick)</code>，<code>element</code> 仍然不能被垃圾回收，因为它的事件监听器中仍然持有对 <code>handleClick</code> 的引用。</li><li>因为 <code>handleClick</code> 还在 <code>element</code> 的事件监听列表中，JavaScript 引擎会认为 <code>element</code> 还可能被使用，因此不会回收 <code>element</code> 或其关联的内存。</li></ul><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​在不再需要时调用 <code>removeEventListener</code> 来移除事件监听器。</p></li><li><p><strong>闭包导致的引用</strong>: 闭包中保存的变量会保持对外部作用域中对象的引用，可能导致无法回收这些对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 返回的 innerFunction 持有对 largeObject 的引用，即使 largeObject 在函数作用域外部已经不需要。</span><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// closure 的引用存在，导致 largeObject 无法被垃圾回收。</span><br><span class="hljs-title function_">closure</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h6><p>在 JavaScript 中，闭包中的引用指向其创建时的环境（即作用域链上的上级）。具体来说：</p><ul><li>当 <code>createClosure</code> 函数执行时，它创建了一个作用域，该作用域中包含 <code>largeObject</code>。</li><li><code>innerFunction</code> 被返回，并且它在其创建时保留了对 <code>largeObject</code> 的引用。</li><li><code>largeObject</code> 的引用存在于 <code>innerFunction</code> 的闭包环境中。</li></ul><p>因此，<code>innerFunction</code> 的作用域链包括 <code>largeObject</code> 所在的作用域。即使 <code>createClosure</code> 执行完毕并退出，<code>innerFunction</code> 仍然能访问 <code>largeObject</code>。</p><p><span style="color: red;"><em><strong>总的来说，如果closure没被销毁那么闭包中的数据会一直存在，所以尽量避免闭包被全局变量所持有，且尽量避免闭包引用大的数据结构，这样会比较消耗内存</strong></em></span></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​要释放 <code>largeObject</code> 的引用，可以在不再需要 <code>innerFunction</code> 时清除对 <code>largeObject</code> 的引用。在这种情况下，确保在 <code>innerFunction</code> 不再使用 <code>largeObject</code> 后，手动清理引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在此处进行逻辑处理</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// 使用完闭包后，手动设置 largeObject 为 null</span><br><span class="hljs-comment">// 这是实际清理引用的地方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 可以设置 closure 为 null 或 undefined</span><br>    closure = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用 releaseClosure 释放对 largeObject 的引用</span><br><span class="hljs-title function_">releaseClosure</span>();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>: 全局变量在整个程序生命周期中都存在，会阻止其被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVariable = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;I&#x27;m a global variable&quot;</span> &#125;;<br><br><span class="hljs-comment">// 全局变量在程序结束前一直存在，无法回收。</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>未清理的定时器</strong>: 忘记清除不再需要的 <code>setInterval</code> 或 <code>setTimeout</code>，可能导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 设置一个定时器，每秒执行一次</span><br>    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 模拟元素销毁时忘记清除定时器</span><br>    <span class="hljs-comment">// clearInterval(intervalId);</span><br>&#125;<br><br><span class="hljs-comment">// 调用后，即使 element 被移除，intervalId 依然存在，导致内存泄漏。</span><br><span class="hljs-title function_">startTimer</span>();<br><br></code></pre></td></tr></table></figure><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><p>​ 在不再需要定时器时调用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存管理不善</strong>: 虽然 JavaScript 有自动垃圾回收，但开发者仍需注意合理使用内存。例如，避免创建大量不必要的对象或保留不必要的引用。</p></li></ol><h3 id="现代-JavaScript-引擎的优化"><a href="#现代-JavaScript-引擎的优化" class="headerlink" title="现代 JavaScript 引擎的优化"></a>现代 JavaScript 引擎的优化</h3><p>除了基本的标记-清除算法，现代 JavaScript 引擎（如 V8）通常还使用一些优化技术，如：</p><ul><li><strong>增量标记（Incremental Marking）</strong>: 将标记阶段拆分为多个小步骤，避免长时间的卡顿。</li><li><strong>世代回收（Generational Garbage Collection）</strong>: 将内存划分为“新生代”和“老生代”两个区域，短命对象会快速回收，长命对象则被移至老生代以减少处理频率。</li><li><strong>惰性清理（Lazy Cleanup）</strong>: 仅在需要时才清理内存，以进一步减少不必要的垃圾回收操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据hexo创建个人博客</title>
    <link href="/posts/62544/"/>
    <url>/posts/62544/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h2><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p><h2 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h2><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p><h1 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="/posts/62544/1.png"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="/posts/62544/2.png"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="/posts/62544/3.png"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/posts/62544/4.png"></p><p>浏览器中访问，展示成功。</p><p><img src="/posts/62544/5.png"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面默认主图风格如下">http://localhost:4000&#39;，页面默认主图风格如下</a></p><p><img src="/posts/62544/6.png"></p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。个人比较喜欢<code>Fluid</code>。</p><h2 id="1-Fluid主题"><a href="#1-Fluid主题" class="headerlink" title="1.Fluid主题"></a>1.Fluid主题</h2><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 <strong>安装主题</strong></h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h3 id="1-2-指定主题"><a href="#1-2-指定主题" class="headerlink" title="1.2 指定主题"></a>1.2 <strong>指定主题</strong></h3><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="1-3-创建「关于页」"><a href="#1-3-创建「关于页」" class="headerlink" title="1.3 创建「关于页」"></a>1.3 <strong>创建「关于页」</strong></h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br><br></code></pre></td></tr></table></figure><h3 id="1-4-本地启动"><a href="#1-4-本地启动" class="headerlink" title="1.4 本地启动**"></a>1.4 本地启动**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，`Fluid`主题风格页面如下">http://localhost:4000&#39;，`Fluid`主题风格页面如下</a></p><p><img src="/posts/62544/7.png"></p><h1 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h1><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><h2 id="1-添加hexo-asset-image插件"><a href="#1-添加hexo-asset-image插件" class="headerlink" title="1.添加hexo-asset-image插件"></a>1.添加hexo-asset-image插件</h2><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p>hexo-asset-image插件的作用就是为图片资源默认追加上时间路径前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这里不要用</p><p><img src="/posts/62544/8.png"></p><h2 id="2-修改-Hexo-博客目录中的-config-yml"><a href="#2-修改-Hexo-博客目录中的-config-yml" class="headerlink" title="2.修改 Hexo 博客目录中的 _config.yml"></a>2.修改 Hexo 博客目录中的 <code>_config.yml</code></h2><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="/posts/62544/9.png"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="/posts/62544/10.png"></p><p>在测试文章.md中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在\source\images目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:<br><span class="hljs-bullet">-</span> 原创<br>categories:<br><span class="hljs-section">- Java</span><br><span class="hljs-section">---</span><br><br>这是一篇测试文章<br><br>![<span class="hljs-string">图片引用方一</span>](<span class="hljs-link">测试文章/test.png</span>)<br><br>![<span class="hljs-string">图片引用方法二</span>](<span class="hljs-link">test.png</span>)<br><br>![<span class="hljs-string">图片引用方法三</span>](<span class="hljs-link">/images/test.png</span>)<br><br></code></pre></td></tr></table></figure><h2 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.<strong>本地启动</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面如下，文章添加成功">http://localhost:4000&#39;，页面如下，文章添加成功</a></p><p><img src="/posts/62544/11.png"></p><h1 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h1><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h2 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h2><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="/posts/62544/12.png"></p><h2 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2.博客标题"></a>2.博客标题</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="/posts/62544/13.png"></p><h2 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="/posts/62544/14.png"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="/posts/62544/15.png"></p><h1 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h1><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h2 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h2><h3 id="进入-官网-注册账号"><a href="#进入-官网-注册账号" class="headerlink" title="进入 官网 注册账号"></a>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</h3><p><img src="/posts/62544/16.png"></p><h3 id="需实名认证，完成后才能使用各项服务"><a href="#需实名认证，完成后才能使用各项服务" class="headerlink" title="需实名认证，完成后才能使用各项服务"></a>需实名认证，完成后才能使用各项服务</h3><p><img src="/posts/62544/17.png"></p><p>验证邮箱</p><p><img src="/posts/62544/18.png"></p><h3 id="创建应用，选择开发版即可，免费的"><a href="#创建应用，选择开发版即可，免费的" class="headerlink" title="创建应用，选择开发版即可，免费的"></a>创建应用，选择<code>开发版</code>即可，免费的</h3><p><img src="/posts/62544/19.png"></p><h3 id="进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用"><a href="#进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用" class="headerlink" title="进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用"></a>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</h3><p><img src="/posts/62544/20.png"></p><h2 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h2><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h3 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h3><p>打开统计开关</p><p><img src="/posts/62544/21.png"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="/posts/62544/22.png"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="/posts/62544/23.png"></p><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><img src="/posts/62544/24.png"></p><h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p><img src="/posts/62544/25.png"></p><p>页面效果</p><p><img src="/posts/62544/26.png"></p><h1 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h1><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h2 id="启用评论插件"><a href="#启用评论插件" class="headerlink" title="启用评论插件"></a>启用评论插件</h2><p><img src="/posts/62544/27.png"></p><h2 id="配置-LeanCloud-的-appId-和-appkey"><a href="#配置-LeanCloud-的-appId-和-appkey" class="headerlink" title="配置 LeanCloud 的 appId 和 appkey"></a>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></h2><p><img src="/posts/62544/28.png"></p><h2 id="重新部署后，查看页面效果，评论功能已开启"><a href="#重新部署后，查看页面效果，评论功能已开启" class="headerlink" title="重新部署后，查看页面效果，评论功能已开启"></a>重新部署后，查看页面效果，评论功能已开启</h2><p><img src="/posts/62544/29.png"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h1 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="1-1-安装hexo-deployer-git"><a href="#1-1-安装hexo-deployer-git" class="headerlink" title="1.1 安装hexo-deployer-git"></a>1.1 安装hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="1-2-修改根目录下的-config-yml，配置-GitHub-相关信息"><a href="#1-2-修改根目录下的-config-yml，配置-GitHub-相关信息" class="headerlink" title="1.2 修改根目录下的 _config.yml，配置 GitHub 相关信息"></a>1.2 修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><h3 id="1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图"><a href="#1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图" class="headerlink" title="1.3 其中 token 为 GitHub 的 Personal access tokens，获取方式如下图"></a>1.3 其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</h3><p><img src="/posts/62544/30.png"></p><h3 id="1-4-部署到GitHub"><a href="#1-4-部署到GitHub" class="headerlink" title="1.4 部署到GitHub"></a>1.4 部署到GitHub</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a></p><p><img src="/posts/62544/31.png"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="/posts/62544/32.png"></p><h1 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>代理</h1><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location &#x2F;blog 路径一致。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rkyao/fronted/hexo-blog<br></code></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/conf<br>vim nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">server节点下添加如下配置</span><br>location /blog &#123;<br>    alias  /opt/rkyao/fronted/hexo-blog;<br>    index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://47.96.106.173/blog/<br></code></pre></td></tr></table></figure><h1 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h1><p>可访问如下地址查看<br><a href="https://yonghengshikong.github.io/">https://yonghengshikong.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命名</title>
    <link href="/posts/16107/"/>
    <url>/posts/16107/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-创建新的博客"><a href="#1-创建新的博客" class="headerlink" title="1.创建新的博客"></a>1.创建新的博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="2-本地运行"><a href="#2-本地运行" class="headerlink" title="2.本地运行"></a>2.本地运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3.生成静态文件"></a>3.生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="4-部署到远程站点"><a href="#4-部署到远程站点" class="headerlink" title="4.部署到远程站点"></a>4.部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="5-清除本地缓存"><a href="#5-清除本地缓存" class="headerlink" title="5.清除本地缓存"></a>5.清除本地缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c<br></code></pre></td></tr></table></figure><h3 id="6-组合命令-生成且部署到远程"><a href="#6-组合命令-生成且部署到远程" class="headerlink" title="6.组合命令(生成且部署到远程)"></a>6.组合命令(生成且部署到远程)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
