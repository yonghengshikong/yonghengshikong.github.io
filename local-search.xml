<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS上架分发流程及打包详解</title>
    <link href="/posts/18640/"/>
    <url>/posts/18640/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS上架分发流程及打包详解"><a href="#iOS上架分发流程及打包详解" class="headerlink" title="iOS上架分发流程及打包详解"></a>iOS上架分发流程及打包详解</h1><h1 id="1-准备账号"><a href="#1-准备账号" class="headerlink" title="1. 准备账号"></a>1. 准备账号</h1><ul><li><strong>个人账号：</strong>每年99美元，可以上架项目到App Store，账号内最多添加100台测试设备，需要先在网站上添加设备的udid，并生成描述文件。</li><li><strong>公司账号：</strong>每年99美元，可以上架项目到App Store，账号内最多添加100台测试设备，需要先在网站上添加设备的udid，并生成描述文件。</li><li><strong>企业账号：</strong>每年299美元，无法上架APP，只供企业内部测试使用，最多添加10000台测试设备，使用企业账号进行分发APP时不需要预先在开发者网站加入设备的udid，用户只需要安装并信任描述文件就行。</li></ul><h1 id="2-登录开发者网站，新建APPID"><a href="#2-登录开发者网站，新建APPID" class="headerlink" title="2. 登录开发者网站，新建APPID"></a>2. 登录开发者网站，新建APPID</h1><p>点击链接：<a href="https://links.jianshu.com/go?to=https://developer.apple.com/account">苹果开发者网站</a>，进入网站首页(图2-1)，点击红框的地方进入证书管理网页(图2-2)</p><p><img src="/posts/18640/3794267-a2ff524ba311f0f7-1742303178766-1.png" alt="2-1"></p><p><img src="/posts/18640/3794267-be0210bd7390f8df.png" alt="2-2"></p><p>点击图2-2的那个蓝色加号，添加appid，如图2-3和2-4，选择下一步</p><p><img src="/posts/18640/3794267-14996a15e8ea1b0f.png" alt="2-3"></p><p><img src="/posts/18640/3794267-277a3a1803635caa.png" alt="2-4"></p><p>来到2-5的页面，按照图内提示填写信息</p><p><img src="/posts/18640/3794267-8e4ec4f6f9a4e149.png" alt="2-5"></p><p>页面底下要选择功能（Capabilities）或者服务（App Services），例如地图，推送，NFC，你的APP用到什么功能就勾选哪个，服务同理（图2-6）。</p><p><img src="/posts/18640/3794267-b50d0ed7813321d8.png" alt="2-6"></p><p>点击右上角continue，进入到下一个页面(图2-7)，该页面是给你预览的，看看信息正不正确。如果register按钮不可点击，说明你的bundle ID不符合要求，要back到上一个页面重新填写.点击register完成，回到2-2图示位置，选中左边的“identifiers”，可以在右侧列表中看到刚刚新建的APPID。</p><p><img src="/posts/18640/3794267-2a113a1291fad6c3.png" alt="2-7"></p><h1 id="3-新建证书"><a href="#3-新建证书" class="headerlink" title="3. 新建证书"></a>3. 新建证书</h1><p>新建证书之前，需要在你的苹果电脑上面从机构请求证书，打开电脑的钥匙串，然后点击左上角的菜单，从证书颁发机构请求证书</p><p><img src="/posts/18640/3794267-b595dd1592cc46a9.png" alt="before-1"></p><p><img src="/posts/18640/3794267-21204ae14313afe7.png" alt="before-2"></p><p>电子邮件就填写你的开发者账号邮箱，常用名称自行定义，选中存储到磁盘，点击继续，下载一个文件到你的电脑里面，扩展名是“ .certSigningRequest”</p><p><img src="/posts/18640/3794267-422c1b21d2f1066a.png" alt="before-3"></p><p>下面可以来看开发者网站的证书了。<br> 如图3-1所示，点击蓝色加号，进入到3-2页面，如果你的电脑是初次安装这些证书，请先拉到页面最底部（图3-3），依次点击四个蓝色链接，下载文件并且安装好，否则等你新建好证书之后，安装到你的钥匙串里会发现证书不受信任，还需要手动设置信任才行</p><p><img src="/posts/18640/3794267-887e0bd361049d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/417/format/webp" alt="3-1"></p><p><img src="/posts/18640/3794267-6262f1c273ecc3d7.png" alt="3-2"></p><p><img src="/posts/18640/3794267-24afca81779cc44d.png" alt="3-3"></p><p>下面会依次介绍开发证书，发布证书，推送证书。<br> 如图所示，前面四个都可以使用，不过前两个需要你的xcode版本是在11及之后才行，红框里的说明支持分发模式，这个后面打包的时候再详细说明。</p><p><img src="/posts/18640/3794267-c8656245365c7a80.png" alt="3-4"></p><h2 id="3-1-开发证书和发布证书"><a href="#3-1-开发证书和发布证书" class="headerlink" title="3.1 开发证书和发布证书"></a>3.1 开发证书和发布证书</h2><p>选中图3-4中的第一个选项，然后到下一步页面点击“choose file”，选择上面从证书颁发机构请求的证书，然后点击下一步就可以下载证书了，到文件夹里吗找到证书，双击进行安装到钥匙串。</p><p><img src="/posts/18640/3794267-91996e7f172b5b21.png" alt="3-5"></p><p>新建发布证书的时候选中图3-6所示，然后下一步，后面的流程和开发证书一样，最后下载下来双击要装打到钥匙串。</p><p><img src="/posts/18640/3794267-5adabc74a822b87a.png" alt="3-6"></p><p>访达中和钥匙串中证书如图所示</p><p><img src="/posts/18640/3794267-451336b39ede143a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp" alt="3-7"></p><p><img src="/posts/18640/3794267-a61f69fe3b261c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/435/format/webp" alt="3-8"></p><h2 id="3-2-推送证书"><a href="#3-2-推送证书" class="headerlink" title="3.2 推送证书"></a>3.2 推送证书</h2><p>如图3-9所示，选中第一个证书创建测试推送证书，点击下一步到图3-10，然后选择你在第一步里面创建的那个APPID，点击下一步到2-11，选择钥匙串里面颁发的那个，点击下一步然后下载证书，生产推送证书创建方式也是一样的。</p><p><img src="/posts/18640/3794267-e9dc09f84248a28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686/format/webp" alt="3-9"></p><p><img src="/posts/18640/3794267-ccd548cfd4f220d3.png" alt="3-10"></p><p><img src="/posts/18640/3794267-e497f441e44e99c4.png" alt="3-11"></p><p>推送证书在访达中和钥匙串中如图所示</p><p><img src="/posts/18640/3794267-8692a21ca059bceb.png" alt="3-12"></p><p><img src="/posts/18640/3794267-c0b360a220a274d0.png" alt="3-13"></p><h1 id="4-添加测试设备"><a href="#4-添加测试设备" class="headerlink" title="4. 添加测试设备"></a>4. 添加测试设备</h1><p>如果是直接上架到App Store的可以跳过这一步，上架到类似蒲公英平台的，需要仔细看这一步。不过如果你是小白，还是建议上架完之后回过来看一下这个功能，以后肯定会用到<br> 点开图4-1所示的蓝色加号，进入到设备添加页面</p><p><img src="/posts/18640/3794267-0b205c2450698e31.png" alt="4-1"></p><p>可以看到页面分为左右两块，<br> 左边是单个添加，<em>Platform</em>选择设备类型，<em>Device Name</em>表示设备名称，可以自行填写，<em>Device Name</em>即设备的udid，udid的获取方式可以自行百度，或者使用蒲公英网站一个工具获取：<a href="https://links.jianshu.com/go?to=https://www.pgyer.com/tools/udid">udid获取</a><br> 右侧的批量添加，可以点击<em>Download sample files</em>来下载模板，然后点击<em>Choose File</em>来上传。<br> 不过是使用单个添加设备，还是批量添加设备，<strong>设备的总数量都不能超过100个</strong>。</p><p><img src="/posts/18640/3794267-4215e47d93dbb578.png" alt="4-2"></p><h1 id="5-创建描述文件"><a href="#5-创建描述文件" class="headerlink" title="5. 创建描述文件"></a>5. 创建描述文件</h1><p>如图5-1，点击蓝色加号，进入5-2的页面，描述文件也分开发证书和发布两种模式。</p><p><img src="/posts/18640/3794267-cc98b348c7d1ac53.png" alt="5-1"></p><p><img src="/posts/18640/3794267-f55988e28757089a.png" alt="5-2"></p><h2 id="5-1-创建开发描述文件"><a href="#5-1-创建开发描述文件" class="headerlink" title="5.1 创建开发描述文件"></a>5.1 创建开发描述文件</h2><p>上架App Store的可以跳过次步骤。如图5-3，选中** Development**的第一个，如果你开发的是手表或者电脑的程序就选择第二个第三个，然后点击下一步到图5-4，在这里还要选择对应的APPID，点击下一步到图5-5选择证书，如果有多个开发证书，就全选，表示所有证书都能使用这个描述文件，点击下一步到5-6，选择设备，然后点击下一步填写一个名称，自己能区分就行。点击download进行下载，然后双击安装到本地。</p><p><img src="/posts/18640/3794267-a653117eb55a3366.png" alt="5-3"></p><p><img src="/posts/18640/3794267-bed2b32ef46d1de8.png" alt="5-4"></p><p><img src="/posts/18640/3794267-dcbdff0f6a349da4.png" alt="5-5"></p><p><img src="/posts/18640/3794267-aa2f6d5a718f9e1e.png" alt="5-6"></p><h2 id="5-2-创建分发描述文件"><a href="#5-2-创建分发描述文件" class="headerlink" title="5.2 创建分发描述文件"></a>5.2 创建分发描述文件</h2><p>如果是上架到App Store的可以跳过这一步，如果是上架到类似蒲公英平台的，就需要这一步。如图5-7所示，选择** Distribution**的第一个，如果是tv项目选择第二个，点击下一步，后面的步骤和开发描述文件一样</p><p><img src="/posts/18640/3794267-41b2e67c82028c21.png" alt="5-7"></p><h2 id="5-3-创建发布描述文件"><a href="#5-3-创建发布描述文件" class="headerlink" title="5.3 创建发布描述文件"></a>5.3 创建发布描述文件</h2><p>上架到App Store的话，如图5-8所示，点击下一步，除了不用选择设备，其他的步骤和创建开发描述文件一样，最后也下载下来安装到本地</p><p><img src="/posts/18640/3794267-7df63f837940fb31.png" alt="5-8"></p><p><strong>开发，分发，发布的描述文件在访达中的后缀都是一样的(. mobileprovision)，无法区分所以最好在填写名称的时候标注好。</strong><br> 如果你是创建的开发或者分发的描述文件，想看一下选中的设备里面有没有包含想要的设备，可以在命令行中用 vim 或者cat的命令来打开描述文件。<br> 打开Mac电脑自带的终端，输入”vim “或者“cat ”，记得加空格。然后把描述文件拖到终端，会自动填充文件路径，按下回车键就可以看到描述文件里面的内容了</p><p><img src="/posts/18640/3794267-8500a94f95cf423f.png" alt="5-9"></p><p>可以用鼠标滚轮上下滚动，或者键盘上下键来查看信息。<br>*<key>ProvisionedDevices</key>*下面的列表就是你选中的那些设备的udid。<br> “<key>aps-environment</key>”下面string标签的文本表示描述文件的类型，因为分发和发布都是一样打出来的包都可以直接安装到手机，所以这两个是一样的。<br> 开发：<string>development</string><br> 分发：<string>production</string><br> 发布：<string>production</string><br> 同时按下“command”键和”F”键进行查找，粘贴设备的udid，如果能搜索到，就证明设备已经被选中。<br> 如果是用vim命令查看的文件，英文模式输入法下依次按下“I”键，“esc”键，然后输入冒号“:”，会看到左下角出来冒号，再输入“q”，然后回车就能退到终端页面。如果是cat命令查看的文件，直接按一下回车就好。</p><h1 id="6-在App-Store-Connect网站新建一个APP项目"><a href="#6-在App-Store-Connect网站新建一个APP项目" class="headerlink" title="6. 在App Store Connect网站新建一个APP项目"></a>6. 在App Store Connect网站新建一个APP项目</h1><p>打开<a href="https://links.jianshu.com/go?to=https://appstoreconnect.apple.com/apps">App Store Connect</a>，在首页的左上角店家蓝色加号，选择新建APP会跳出来图6-2所示按照提示填写即可。名称不可以App Store商店中其他的APP名称重复。其中套装ID是选择APPID的，SKU一般都写bundle ID。然后点击创建。</p><p><img src="/posts/18640/3794267-89c5659cf006e561.png" alt="6-1"></p><p><img src="/posts/18640/3794267-6331b5dabe80210f.png" alt="6-2"></p><h2 id="6-1-进入准备提交页面，填写审核内容"><a href="#6-1-进入准备提交页面，填写审核内容" class="headerlink" title="6.1 进入准备提交页面，填写审核内容"></a>6.1 进入准备提交页面，填写审核内容</h2><p>预览图需要无透明度的图片，不能使用模拟器的截屏(但是偶尔也可以通过)。</p><p><img src="/posts/18640/3794267-d56fc277d9e02f72.png" alt="6-3"></p><p>推广文本非必填，<br> 描述属于必填项，对APP进行简介。<br> 此版本新增内容是更新APP版本的时候填写，说明添加或者修改了那些功能。</p><p><img src="/posts/18640/3794267-4ef7bfc4bb0f958e.png" alt="6-4"></p><p>关键词：App Store搜索APP时的联想词，比如火影手游可以加上“火影忍者，横版格斗，热血手游”，圣斗士星矢手游“圣斗士，星矢，卡牌，公平竞技(当然并不公平)”。网易云音乐“网易，音乐，听歌”<br> 技术支持网址：填写你公司的官网。如果你帮别人开发的，填他给你提供的网址。</p><p>营销网址：可选型<br> 版本：这个月应该不用解释了吧，第一版一般都是1.0.0<br> 版权：非网址</p><p><img src="/posts/18640/3794267-e551f6f369b913da.png" alt="6-5"></p><p>根据你自己的需求看看是否需要填写这三个信息</p><p><img src="/posts/18640/3794267-2b1fe3fd3a223a5e.png" alt="6-6"></p><p>构建版本：选择提交审核的二进制文件，现在还没开始打包，等打包后就会有“选择构建版本”的按钮<br> 登录信息：苹果审核 的时候，如果你的APP需要登录才可以，就勾选一下，并且提供一个账号。<br> 联系信息：填写你或者技术主管的联系方式，苹果审核中，如果遇到什么问题，可以通过这里和你们沟通。不过我没遇到过苹果打电话或者发邮件给你。<br> 备注：填写一些信息帮助审核。最好录制一个演示视频来展示APP的功能。APP中有NFC，定位这种功能，自觉录制就行。不能直接进行录屏，必须要用另一个手机从第三角度进行拍摄。</p><p><img src="/posts/18640/3794267-fe5d9fc8fbc9e0d7.png" alt="6-7"></p><p>附件：提供图片，语音或者短视频来帮助审核。<br> 下面三个应该不用解释了。</p><p><img src="/posts/18640/3794267-6233df3b7cf07ecb.png" alt="6-8"></p><h2 id="6-2-APP信息"><a href="#6-2-APP信息" class="headerlink" title="6.2 APP信息"></a>6.2 APP信息</h2><p>设置名称，副标题，APP类型别。Apple ID是你的APP在App Store中的唯一标识，APP内检测版本更新会用的到。</p><p><img src="/posts/18640/3794267-73bf1d55328909f3.png" alt="6-9"></p><p>内容版权：如果APP内有嵌入广告等，就选是</p><p><img src="/posts/18640/3794267-7afb812fed79b123.png" alt="6-10"></p><p>年龄分级，如实选择就行</p><p><img src="/posts/18640/3794267-bc6a18663ee7986b.png" alt="6-11"></p><p>许可协议：如果没有，就不用管</p><p><img src="/posts/18640/3794267-55e5d0b68148f1d3.png" alt="6-12"></p><h2 id="6-3-价格与销售范围"><a href="#6-3-价格与销售范围" class="headerlink" title="6.3 价格与销售范围"></a>6.3 价格与销售范围</h2><p>免费的就选择免费就行，销售范围勾选APP面向客户的国家和地区，税务类别默认App Store软件，如果是游戏或者音乐，选择对应的类别。</p><p><img src="/posts/18640/3794267-d321c77ffba0af53.png" alt="6-13"></p><h2 id="6-4-APP隐私"><a href="#6-4-APP隐私" class="headerlink" title="6.4 APP隐私"></a>6.4 APP隐私</h2><p>隐私政策网址，里面叙述一下APP用到哪些权限，cookie如何处理，责任声明。</p><p><img src="/posts/18640/3794267-a597ad108bc41278.png" alt="6-14"></p><p>数据收集，如果APP内没有记录用户任何行为，就选择否。像美团，淘宝那些喜欢搜集用户行为的，就要如实选择。</p><p><img src="/posts/18640/3794267-afbdc87a59957202.png" alt="6-15"></p><h2 id="6-5-APP审核"><a href="#6-5-APP审核" class="headerlink" title="6.5 APP审核"></a>6.5 APP审核</h2><p>这里会记录历史审核内容，点击进<em>APP提交内容</em>，进入详情页面，消息那里会看到和苹果审核团队的沟通记录</p><p><img src="/posts/18640/3794267-21b97c57fd22de9c.png" alt="6-16"></p><h2 id="6-6-功能模块"><a href="#6-6-功能模块" class="headerlink" title="6.6 功能模块"></a>6.6 功能模块</h2><p>账户内有付费内容，订阅等功能的自行设置，没有的话忽略。</p><p><img src="/posts/18640/3794267-fd48fa37222de530.png" alt="6-17"></p><h2 id="6-7-TestFlight页面"><a href="#6-7-TestFlight页面" class="headerlink" title="6.7 TestFlight页面"></a>6.7 TestFlight页面</h2><p>构建版本记录了你打包上传过的二进制文件，如果正在审核中，对应的构建版本后面会跟“正在审核”的描述，图内是审核完成后的。图6-7那里选择构建版本的时候，就是选择这里的内容。</p><p><img src="/posts/18640/3794267-a72dc1b6b9d11bdd.png" alt="6-18"></p><p>点击进对应的构建版本详情，群组中，可以添加测试组，独立测试员可以添加一个其他的测试账号</p><p><img src="/posts/18640/3794267-a88052ac99c1add5.png" alt="6-19"></p><p><img src="/posts/18640/3794267-1790823f621c2d68.png" alt="6-20"></p><p>内部测试：点击内部测试后面的蓝色加号添加一个测试组，点击测试员后面的蓝色加号再添加测试人员，添加的测试人员，必须是你在用户和访问中添加好的开发者邮箱。添加后，邮箱内会受到一封邮件，查看详情会得到一组大写的邀请码，testflight中的构建版本审核完成后，测试人员在手机上下载“TestFlight”APP，登录上开发者账号，通过邀请码即可获取APP。下拉到底部可以给这个群组指定测试某一个构建版本</p><p><img src="/posts/18640/3794267-c75dad099bf0668a.png" alt="6-21"></p><p><img src="/posts/18640/3794267-bdf22d03acad4244.png" alt="6-22"></p><p><img src="/posts/18640/3794267-4bb01434b46a0bcc.png" alt="6-23"></p><p><img src="/posts/18640/3794267-3ae07f5043e877ea.png" alt="6-24"></p><p>外部测试：外部测试添加测试员和图6-20相同</p><p><img src="/posts/18640/3794267-0c87eb092e93a9e1.png" alt="6-25"></p><h1 id="7-在xcode中打包项目并上传文件"><a href="#7-在xcode中打包项目并上传文件" class="headerlink" title="7. 在xcode中打包项目并上传文件"></a>7. 在xcode中打包项目并上传文件</h1><p>先用xcode打开项目</p><h2 id="7-1-xcode中的配置"><a href="#7-1-xcode中的配置" class="headerlink" title="7.1 xcode中的配置"></a>7.1 xcode中的配置</h2><p>TARGETS里面设置版本号version和构建版本build，构建版本就是图6-18中“版本1.0.0”下面的1和2，在你打包上传完成后，如果发现源码还有问题，修改后还需要再上传的话，就保持版本号不变，构建版本要+1。</p><p><img src="/posts/18640/3794267-b53d5f3d62dcf64a.png" alt="7-1"></p><p>设置证书：可以通过勾选”aUtomatically manage sigining”，然后选择Team来自动匹配描述文件，也可以不勾选，点击“Provisioning Pofile”进行手动指定描述文件</p><p><img src="/posts/18640/3794267-fa2b6c4f19c16e65.png" alt="7-2"></p><p><img src="/posts/18640/3794267-63e5ff2e91ae376a.png" alt="7-3"></p><h2 id="7-2-打包上传"><a href="#7-2-打包上传" class="headerlink" title="7.2 打包上传"></a>7.2 打包上传</h2><p>点击菜单栏的Product–Archive，xcode会进行自动打包，等待一会就好。打包的时候xcode不能指定任何设备，要选择“Any ios Device”，如图7-4</p><p><img src="/posts/18640/3794267-a9767736fa048373.png" alt="7-4"></p><p>打包完成后，桌面会自动跳出来上传配置页面，点击“Distribute App”进入图7-6</p><p><img src="/posts/18640/3794267-7cd684fc6e6d5375.png" alt="7-5"></p><p>选中第一个代表上传到App Store。<br> 选中第二个属于测试分发，上传类似蒲公英的平台，或者有需要超级签名的。<br> 选中第三个是企业账号进行打包<br> 选中第四个表示测试环境的，也无法作为正式版APP使用。<br> ———–分割线———————-<br><strong>更新xcode之后的补充</strong><br> xcode更新了15版本以后，APP打包完想导出IPA包的界面已经更改了。如图7-5-1，想要用企业证书导出IPA的话，需要选中如图所示，点击next，才会出现图7-5的页面。如果只是上架App Store或者进行adhoc打包的话，直接选中第一个或者第二个就行。</p><p><img src="/posts/18640/3794267-34f5b1bf4b86b7e9.png" alt="7-5-1"></p><p>————–分割线———————-<br> 接下来的流程以第一个为例</p><p><img src="/posts/18640/3794267-bf0f6fd7603231a3.png" alt="7-6"></p><p>选中App Store connect，点击next到图7-7，这里的upload或者export代表两种上传方式。upload可以直接进行上传，export会先导出来一个IPA包，然后配合Transporter工具进行上传，好处是可以把IPA包放到另一台电脑上传。</p><p><img src="/posts/18640/3794267-b5d1d08aa116627f.png" alt="7-7"></p><p>选中upload一路next到图7-8，第一个表示自动匹配描述文件，点击next后，再点击upload就会开始上传，第二个表示手动指定，点击next进入7-9进行指定，然后next，再点击upload开始上传</p><p><img src="/posts/18640/3794267-cea5c2b3e8821fa9.png" alt="7-8"></p><p><img src="/posts/18640/3794267-192d1548313c52fe.png" alt="7-9"></p><p><img src="/posts/18640/3794267-8bb66b4cfafe528f.png" alt="7-10"></p><p>选中export，next到图7-8所示，这里手动指定还是自动指定都和upload的流程一样，next之后，点击export，选择一个文件夹存放导出来的内容。在访达内如图7-11所示，扩展名为“.ipa”的就是用来上传的文件，如果是中文名请改成英文</p><p><img src="/posts/18640/3794267-79539a15739114f1.png" alt="7-11"></p><p>然后电脑在App Store中下载Transpoeter，打开并登录开发者账号，点击左上角的加号，从访达中选择IPA文件进行上传。</p><p><img src="/posts/18640/3794267-3fe319824b088175.png" alt="7-12"></p><h1 id="8-提交上架"><a href="#8-提交上架" class="headerlink" title="8. 提交上架"></a>8. 提交上架</h1><p>回到APP store connect网站，刚刚打包上传的文件会显示在testflight中，刚上传的会在构建版本好后面有“正在审核”的字样，审核时间大概半个小时.如果在3-5分钟左右，刷新页面后发现构建版本没了，说你的IPA包有错误，被苹果退回了，可以去开发者账号的邮箱查看苹果审核团队发给你的邮件，修改源码后重新打包上传，这时候的构建版本号不需要再+1。这里的审核完成后，开发者邮箱会收到邮件，如果有开起了测试，那么测试手机上“testflight”APP也会有推送消息。</p><p><img src="/posts/18640/3794267-eca18753e6520c39.png" alt="8-1"></p><p>点击到图8-2，testflight审核成功后，这里的构建版本会出现一个按钮让你选择要上架的构架版本，选择后点击右上角的添加以供审核，再点击一下提交审核，APP状态变成“正在等待审核”，表示提交完成，等待苹果的人工审核就好了，人工审核时间理论上是两天，但是现在一般一天就会有结果。</p><p><img src="/posts/18640/3794267-ebfcd0b382358fd2.png" alt="8-2"></p><h1 id="9-钥匙串导出P12文件"><a href="#9-钥匙串导出P12文件" class="headerlink" title="9. 钥匙串导出P12文件"></a>9. 钥匙串导出P12文件</h1><p>如果另一台电脑也想对同一个项目进行调试，甚至打包上传怎么办，还需要通过第二步的内容进行新建证书吗，当然会不需要，况且发布证书最多只能创建三个，不可能每台电脑都要新建证书。这时候就要用到p12文件了。某一台电脑新建过证书，并且也下载安装到钥匙串了，这时候就可以从钥匙串导出一个p12文件传给另一台电脑，另一台电脑接收后，双击安装到钥匙串，就可以看到该证书了。<br> 选中证书右击，注意不要展开，是选中证书主体，选择“导出<em><strong><strong>证书名</strong></strong></em>”，到图p-2，文件格式扩展名为.p12，然后选择文件夹，填写名称，点击存储，设置密码后存储到磁盘，然后就可以发给其他设备了</p><p><img src="/posts/18640/3794267-e359ce43821f74e9.png" alt="9-1"></p><p><img src="/posts/18640/3794267-2cf95d04115e49df.png" alt="9-2"></p>]]></content>
    
    
    <categories>
      
      <category>IOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏开发-Unity技术框架集合</title>
    <link href="/posts/38425/"/>
    <url>/posts/38425/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-开发工具与资源大全"><a href="#Unity-开发工具与资源大全" class="headerlink" title="Unity 开发工具与资源大全"></a>Unity 开发工具与资源大全</h1><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h2><ul><li><strong><a href="https://assetstore.unity.com/packages/tools/animation/animancer-pro-116514">Animancer-Pro</a></strong><br>基于Playable的简单强大的动画解决方案，适合需要灵活控制动画的开发者。</li></ul><h2 id="关卡原型构建"><a href="#关卡原型构建" class="headerlink" title="关卡原型构建"></a>关卡原型构建</h2><ul><li><strong><a href="https://assetstore.unity.com/packages/tools/modeling/umodeler-80868">ProBuilder&#x2F;UModeler</a></strong><br>快速关卡原型构建解决方案，帮助开发者快速创建和编辑3D模型。</li></ul><h2 id="UI解决方案"><a href="#UI解决方案" class="headerlink" title="UI解决方案"></a>UI解决方案</h2><ul><li><strong><a href="https://github.com/fairygui/FairyGUI-unity">FGUI</a></strong><br>简单强大的UI解决方案，支持跨平台开发，适合需要高效UI开发的团队。</li></ul><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><ul><li><strong><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.5/manual/index.html">URP</a></strong><br>Unity官方可编程渲染管线-通用渲染管线，适合移动端和轻量级图形渲染。</li></ul><h2 id="Shader编辑器"><a href="#Shader编辑器" class="headerlink" title="Shader编辑器"></a>Shader编辑器</h2><ul><li><strong><a href="https://assetstore.unity.com/packages/tools/visual-scripting/amplify-shader-editor-68570">ShaderGraph&#x2F;AmplifyShaderEditor</a></strong><br>自定义Shader编辑器，帮助开发者通过可视化方式创建复杂的Shader。</li></ul><h2 id="可视化脚本"><a href="#可视化脚本" class="headerlink" title="可视化脚本"></a>可视化脚本</h2><ul><li><strong><a href="https://assetstore.unity.com/packages/tools/visual-scripting/bolt-163802">Bolt</a></strong><br>可视化脚本工具，适合不熟悉代码的开发者快速实现游戏逻辑。</li></ul><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><ul><li><p><strong><a href="https://github.com/xasset/xasset">XAsset</a></strong><br>简单强大的资源管理插件，基于引擎自身的依赖关系实现，适合中小型项目。</p></li><li><p><strong><a href="https://github.com/EllanJiang/GameFramework">GameFramework</a></strong><br>提供了高度可定制的资源管理框架，适合需要精细控制资源加载的项目。</p></li></ul><h2 id="热更新方案"><a href="#热更新方案" class="headerlink" title="热更新方案"></a>热更新方案</h2><ul><li><p><strong><a href="https://github.com/focus-creative-games/hybridclr">HybridCLR</a></strong><br>基于C#的热更新方案，目前效率最高的热更方案，单程序域运行。</p></li><li><p><strong><a href="https://github.com/topameng/tolua">tolua</a></strong><br>基于Lua实现的嵌入虚拟机热更解决方案，适合需要Lua脚本的项目。</p></li><li><p><strong><a href="https://github.com/Tencent/xLua">xlua</a></strong><br>基于Lua实现的嵌入虚拟机热更解决方案，新增了动态修复C#函数功能。</p></li><li><p><strong><a href="https://github.com/Ourpalm/ILRuntime">ILRuntime</a></strong><br>自己实现了一个IL运行时的解析器，适合没有JIT环境下的C#热更新。</p></li></ul><h2 id="技能辅助开发工具"><a href="#技能辅助开发工具" class="headerlink" title="技能辅助开发工具"></a>技能辅助开发工具</h2><ul><li><p><strong><a href="https://assetstore.unity.com/packages/tools/animation/slate-cinematic-sequencer-56558">Slate</a></strong><br>类似Timeline的时间线编辑工具，UI效果较好，适合制作过场动画。</p></li><li><p><strong><a href="https://assetstore.unity.com/packages/tools/animation/flux-18440">Flux</a></strong><br>类似Timeline的时间线编辑工具，效果略差，但功能强大。</p></li><li><p><strong><a href="https://assetstore.unity.com/packages/tools/game-toolkits/cline-action-editor-2-163343">SuperCLine</a></strong><br>仿照Flux实现的可直接在项目使用的技能编辑器。</p></li></ul><h2 id="编辑器扩展工具"><a href="#编辑器扩展工具" class="headerlink" title="编辑器扩展工具"></a>编辑器扩展工具</h2><ul><li><p><strong><a href="https://assetstore.unity.com/packages/tools/utilities/odin-inspector-and-serializer-89041">Odin-Inspector</a></strong><br>编辑器扩展、工作流改善，适合需要自定义Inspector的开发者。</p></li><li><p><strong><a href="https://github.com/dbrizov/NaughtyAttributes">NaughtyAttributes</a></strong><br>实现基于属性的常用编辑器效果样式，适合快速开发。</p></li><li><p><strong><a href="https://github.com/smartgrass/XiaoCaoTools">XiaoCaoTools</a></strong><br>基于NaughtyAttributes扩展的Window常用属性编辑器。</p></li><li><p><strong><a href="https://github.com/smartgrass/XCSkillEditor_Unity">XCSkillEditor</a></strong><br>基于Lux开发的技能编辑器。</p></li><li><p><strong><a href="https://gitee.com/mtdmt/MDDSkillEngine">MDDSkillEngine</a></strong><br>基于UnityTimeline实现的技能编辑器。</p></li></ul><h2 id="前端开发框架"><a href="#前端开发框架" class="headerlink" title="前端开发框架"></a>前端开发框架</h2><ul><li><p><strong><a href="https://github.com/egametang/ET">ET</a></strong><br>基于C#实现的双端共享的客户端和服务器框架，适合需要前后端一体化的项目。</p></li><li><p><strong><a href="https://github.com/EllanJiang/GameFramework">GameFramework</a></strong><br>通用涵盖多模块客户端游戏开发框架，适合大型项目。</p></li><li><p><strong><a href="https://github.com/mr-kelly/KSFramework">KSFramework</a></strong><br>通用的客户端框架，适合中小型项目。</p></li><li><p><strong><a href="https://github.com/yimengfan/BDFramework.Core">BDFramework</a></strong><br>通用的客户端框架，适合需要快速开发的团队。</p></li><li><p><strong><a href="https://github.com/liangxiegame/QFramework">QFramework</a></strong><br>通用的客户端框架，适合需要模块化开发的团队。</p></li></ul><h2 id="后端开发框架"><a href="#后端开发框架" class="headerlink" title="后端开发框架"></a>后端开发框架</h2><ul><li><p><strong><a href="https://github.com/egametang/ET">ET</a></strong><br>基于C#实现的双端共享的客户端和服务器框架，适合需要前后端一体化的项目。</p></li><li><p><strong><a href="https://github.com/heroiclabs/nakama">nakama</a></strong><br>通用的服务器框架，适合需要实时多人游戏的项目。</p></li><li><p><strong><a href="https://github.com/ketoo/NoahGameFrame">NoahGameFrame</a></strong><br>通用的服务器框架，适合需要高并发的项目。</p></li><li><p><strong><a href="https://github.com/leeveel/GeekServer">GeekServer</a></strong><br>通用的服务器框架，适合需要高性能的游戏服务器。</p></li></ul><h2 id="Actor框架"><a href="#Actor框架" class="headerlink" title="Actor框架"></a>Actor框架</h2><ul><li><p><strong><a href="https://github.com/akkadotnet/akka.net">Akka.NET</a></strong><br>基于Actor模型的分布式框架，适合需要高并发和分布式系统的项目。</p></li><li><p><strong><a href="https://github.com/AsynkronIT/protoactor-dotnet">Proto.Actor</a></strong><br>轻量级的Actor框架，适合需要高性能和低延迟的项目。</p></li></ul><h2 id="DOTS面向数据技术栈"><a href="#DOTS面向数据技术栈" class="headerlink" title="DOTS面向数据技术栈"></a>DOTS面向数据技术栈</h2><ul><li><p><strong><a href="https://github.com/Leopotam/ecs">Leopotam ECS</a></strong><br>轻量级的ECS框架，适合需要高性能的游戏开发。</p></li><li><p><strong><a href="https://github.com/sebas77/Svelto.ECS">Svelto.ECS</a></strong><br>高性能的ECS框架，适合需要大规模实体管理的项目。</p></li></ul><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><ul><li><p><strong><a href="https://github.com/strangeioc/strangeioc">StrangeIoC</a></strong><br>基于依赖注入的IOC容器，适合需要解耦的项目。</p></li><li><p><strong><a href="https://github.com/modesttree/Zenject">Zenject</a></strong><br>轻量级的依赖注入框架，适合需要模块化开发的项目。</p></li></ul><h2 id="战斗、技能系统"><a href="#战斗、技能系统" class="headerlink" title="战斗、技能系统"></a>战斗、技能系统</h2><ul><li><p><strong><a href="https://github.com/m969/EGamePlay">EGamePlay</a></strong><br>基于ECS的战斗系统框架，适合需要高性能的战斗系统。</p></li><li><p><strong><a href="https://github.com/sjai013/UnityGameplayAbilitySystem">UnityGameplayAbilitySystem</a></strong><br>类似虚幻引擎的Gameplay Ability System，适合需要复杂技能系统的项目。</p></li></ul><h2 id="帧同步框架"><a href="#帧同步框架" class="headerlink" title="帧同步框架"></a>帧同步框架</h2><ul><li><p><strong><a href="https://github.com/JiepengTan/LockstepEngine">LockstepEngine</a></strong><br>基于帧同步的多人游戏框架，适合需要实时同步的项目。</p></li><li><p><strong><a href="https://github.com/proepkes/UnityLockstep">UnityLockstep</a></strong><br>轻量级的帧同步框架，适合需要快速开发的多人游戏。</p></li></ul><h2 id="常用工具插件"><a href="#常用工具插件" class="headerlink" title="常用工具插件"></a>常用工具插件</h2><ul><li><p><strong><a href="https://github.com/Z4nzu/hackingtool">hackingtool</a></strong><br>黑客工具、网络异常模拟，适合需要测试网络异常的项目。</p></li><li><p><strong><a href="https://github.com/ZxIce/AssetCheck">AssetCheck</a></strong><br>资源检查工具，适合需要优化资源加载的项目。</p></li></ul><h2 id="图形渲染"><a href="#图形渲染" class="headerlink" title="图形渲染"></a>图形渲染</h2><ul><li><p><strong><a href="https://github.com/flamacore/UnityHDRPSimpleWater">UnityHDRPSimpleWater</a></strong><br>简单的水渲染解决方案，适合需要快速实现水效果的项目。</p></li><li><p><strong><a href="https://github.com/Kink3d/kMirrors">kMirrors</a></strong><br>URP下的镜面反射解决方案，适合需要镜面反射效果的项目。</p></li></ul><h2 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h2><ul><li><p><strong><a href="https://github.com/RevenantX/LiteNetLib">LiteNetLib</a></strong><br>轻量级的网络库，适合需要高效网络通信的项目。</p></li><li><p><strong><a href="https://github.com/BeardedManStudios/ForgeNetworkingRemastered">ForgeNetworkingRemastered</a></strong><br>高性能的网络库，适合需要实时多人游戏的项目。</p></li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li><strong><a href="https://github.com/google/flatbuffers">FlatBuffers</a></strong><br>高效的序列化库，适合需要快速序列化和反序列化的项目。</li></ul><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h2><ul><li><strong><a href="https://github.com/meniku/NPBehave">NPBehave</a></strong><br>基于行为树的AI框架，适合需要复杂AI逻辑的项目。</li></ul><h2 id="优秀引用库"><a href="#优秀引用库" class="headerlink" title="优秀引用库"></a>优秀引用库</h2><ul><li><strong><a href="https://github.com/RyanNielson/awesome-unity">awesome-unity</a></strong><br>Unity开发者的资源大全，包含各种工具和框架的推荐。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity游戏框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#多线程</title>
    <link href="/posts/54366/"/>
    <url>/posts/54366/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C# 多线程"></a>C# 多线程</h1><p><strong>线程</strong> 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。</p><p>线程是<strong>轻量级进程</strong>。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。</p><p>到目前为止我们编写的程序是一个单线程作为应用程序的运行实例的单一的过程运行的。但是，这样子应用程序同时只能执行一个任务。为了同时执行多个任务，它可以被划分为更小的线程。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。</p><p>下面列出了线程生命周期中的各种状态：</p><ul><li><p><strong>未启动状态</strong>：当线程实例被创建但 Start 方法未被调用时的状况。</p></li><li><p><strong>就绪状态</strong>：当线程准备好运行并等待 CPU 周期时的状况。</p></li><li><p>不可运行状态</p><p>：下面的几种情况下线程是不可运行的：</p><ul><li>已经调用 Sleep 方法</li><li>已经调用 Wait 方法</li><li>通过 I&#x2F;O 操作阻塞</li></ul></li><li><p><strong>死亡状态</strong>：当线程已完成执行或已中止时的状况。</p></li></ul><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在 C# 中，<strong>System.Threading.Thread</strong> 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为<strong>主线程</strong>。</p><p>当 C# 程序开始执行时，主线程自动创建。使用 <strong>Thread</strong> 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 <strong>CurrentThread</strong> 属性访问线程。</p><p>下面的程序演示了主线程的执行：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultithreadingApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">MainThreadProgram</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Thread th = Thread.CurrentThread;<br>            th.Name = <span class="hljs-string">&quot;MainThread&quot;</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;This is &#123;0&#125;&quot;</span>, th.Name);<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">This <span class="hljs-keyword">is</span> MainThread<br></code></pre></td></tr></table></figure><h2 id="Thread-类常用的属性和方法"><a href="#Thread-类常用的属性和方法" class="headerlink" title="Thread 类常用的属性和方法"></a>Thread 类常用的属性和方法</h2><p>下表列出了 <strong>Thread</strong> 类的一些常用的 <strong>属性</strong>：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CurrentContext</td><td align="left">获取线程正在其中执行的当前上下文。</td></tr><tr><td align="left">CurrentCulture</td><td align="left">获取或设置当前线程的区域性。</td></tr><tr><td align="left">CurrentPrincipal</td><td align="left">获取或设置线程的当前负责人（对基于角色的安全性而言）。</td></tr><tr><td align="left">CurrentThread</td><td align="left">获取当前正在运行的线程。</td></tr><tr><td align="left">CurrentUICulture</td><td align="left">获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。</td></tr><tr><td align="left">ExecutionContext</td><td align="left">获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。</td></tr><tr><td align="left">IsAlive</td><td align="left">获取一个值，该值指示当前线程的执行状态。</td></tr><tr><td align="left">IsBackground</td><td align="left">获取或设置一个值，该值指示某个线程是否为后台线程。</td></tr><tr><td align="left">IsThreadPoolThread</td><td align="left">获取一个值，该值指示线程是否属于托管线程池。</td></tr><tr><td align="left">ManagedThreadId</td><td align="left">获取当前托管线程的唯一标识符。</td></tr><tr><td align="left">Name</td><td align="left">获取或设置线程的名称。</td></tr><tr><td align="left">Priority</td><td align="left">获取或设置一个值，该值指示线程的调度优先级。</td></tr><tr><td align="left">ThreadState</td><td align="left">获取一个值，该值包含当前线程的状态。</td></tr></tbody></table><p>下表列出了 <strong>Thread</strong> 类的一些常用的 <strong>方法</strong>：</p><table><thead><tr><th align="left">序号</th><th align="left">方法名 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void Abort()</strong> 在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。调用此方法通常会终止线程。</td></tr><tr><td align="left">2</td><td align="left"><strong>public static LocalDataStoreSlot AllocateDataSlot()</strong> 在所有的线程上分配未命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">3</td><td align="left"><strong>public static LocalDataStoreSlot AllocateNamedDataSlot( string name)</strong> 在所有线程上分配已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">4</td><td align="left"><strong>public static void BeginCriticalRegion()</strong> 通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务。</td></tr><tr><td align="left">5</td><td align="left"><strong>public static void BeginThreadAffinity()</strong> 通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令。</td></tr><tr><td align="left">6</td><td align="left"><strong>public static void EndCriticalRegion()</strong> 通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常仅影响当前任务。</td></tr><tr><td align="left">7</td><td align="left"><strong>public static void EndThreadAffinity()</strong> 通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令。</td></tr><tr><td align="left">8</td><td align="left"><strong>public static void FreeNamedDataSlot(string name)</strong> 为进程中的所有线程消除名称与槽之间的关联。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">9</td><td align="left"><strong>public static Object GetData( LocalDataStoreSlot slot )</strong> 在当前线程的当前域中从当前线程上指定的槽中检索值。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">10</td><td align="left"><strong>public static AppDomain GetDomain()</strong> 返回当前线程正在其中运行的当前域。</td></tr><tr><td align="left">11</td><td align="left"><strong>public static AppDomain GetDomainID()</strong> 返回唯一的应用程序域标识符。</td></tr><tr><td align="left">12</td><td align="left"><strong>public static LocalDataStoreSlot GetNamedDataSlot( string name )</strong> 查找已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">13</td><td align="left"><strong>public void Interrupt()</strong> 中断处于 WaitSleepJoin 线程状态的线程。</td></tr><tr><td align="left">14</td><td align="left"><strong>public void Join()</strong> 在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止。此方法有不同的重载形式。</td></tr><tr><td align="left">15</td><td align="left"><strong>public static void MemoryBarrier()</strong> 按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 MemoryBarrier 调用之后的内存存取，再执行 MemoryBarrier 调用之前的内存存取的方式。</td></tr><tr><td align="left">16</td><td align="left"><strong>public static void ResetAbort()</strong> 取消为当前线程请求的 Abort。</td></tr><tr><td align="left">17</td><td align="left"><strong>public static void SetData( LocalDataStoreSlot slot, Object data )</strong> 在当前正在运行的线程上为此线程的当前域在指定槽中设置数据。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。</td></tr><tr><td align="left">18</td><td align="left"><strong>public void Start()</strong> 开始一个线程。</td></tr><tr><td align="left">19</td><td align="left"><strong>public static void Sleep( int millisecondsTimeout )</strong> 让线程暂停一段时间。</td></tr><tr><td align="left">20</td><td align="left"><strong>public static void SpinWait( int iterations )</strong> 导致线程等待由 iterations 参数定义的时间量。</td></tr><tr><td align="left">21</td><td align="left"><strong>public static byte VolatileRead( ref byte address ) public static double VolatileRead( ref double address ) public static int VolatileRead( ref int address ) public static Object VolatileRead( ref Object address )</strong> 读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。此方法有不同的重载形式。这里只给出了一些形式。</td></tr><tr><td align="left">22</td><td align="left"><strong>public static void VolatileWrite( ref byte address, byte value ) public static void VolatileWrite( ref double address, double value ) public static void VolatileWrite( ref int address, int value ) public static void VolatileWrite( ref Object address, Object value )</strong> 立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。此方法有不同的重载形式。这里只给出了一些形式。</td></tr><tr><td align="left">23</td><td align="left"><strong>public static bool Yield()</strong> 导致调用线程执行准备好在当前处理器上运行的另一个线程。由操作系统选择要执行的线程。</td></tr></tbody></table><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>线程是通过扩展 Thread 类创建的。扩展的 Thread 类调用 <strong>Start()</strong> 方法来开始子线程的执行。</p><p>下面的程序演示了这个概念：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultithreadingApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCreationProgram</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallToChildThread</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Child thread starts&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            ThreadStart childref = <span class="hljs-keyword">new</span> ThreadStart(CallToChildThread);<br>            Console.WriteLine(<span class="hljs-string">&quot;In Main: Creating the Child thread&quot;</span>);<br>            Thread childThread = <span class="hljs-keyword">new</span> Thread(childref);<br>            childThread.Start();<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">In Main: Creating the Child thread<br>Child thread starts<br></code></pre></td></tr></table></figure><h2 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h2><p>Thread 类提供了各种管理线程的方法。</p><p>下面的实例演示了 <strong>sleep()</strong> 方法的使用，用于在一个特定的时间暂停线程。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultithreadingApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCreationProgram</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallToChildThread</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Child thread starts&quot;</span>);<br>            <span class="hljs-comment">// 线程暂停 5000 毫秒</span><br>            <span class="hljs-built_in">int</span> sleepfor = <span class="hljs-number">5000</span>; <br>            Console.WriteLine(<span class="hljs-string">&quot;Child Thread Paused for &#123;0&#125; seconds&quot;</span>, <br>                              sleepfor / <span class="hljs-number">1000</span>);<br>            Thread.Sleep(sleepfor);<br>            Console.WriteLine(<span class="hljs-string">&quot;Child thread resumes&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            ThreadStart childref = <span class="hljs-keyword">new</span> ThreadStart(CallToChildThread);<br>            Console.WriteLine(<span class="hljs-string">&quot;In Main: Creating the Child thread&quot;</span>);<br>            Thread childThread = <span class="hljs-keyword">new</span> Thread(childref);<br>            childThread.Start();<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">In Main:</span> Creating the Child <span class="hljs-keyword">thread</span><br>Child <span class="hljs-keyword">thread</span> starts<br>Child <span class="hljs-keyword">Thread</span> Paused for <span class="hljs-number">5</span> seconds<br>Child <span class="hljs-keyword">thread</span> resumes<br></code></pre></td></tr></table></figure><h2 id="销毁线程"><a href="#销毁线程" class="headerlink" title="销毁线程"></a>销毁线程</h2><p><strong>Abort()</strong> 方法用于销毁线程。</p><p>通过抛出 <strong>threadabortexception</strong> 在运行时中止线程。这个异常不能被捕获，如果有 <em>finally</em> 块，控制会被送至 <em>finally</em> 块。</p><p>下面的程序说明了这点：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultithreadingApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCreationProgram</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallToChildThread</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br><br>                Console.WriteLine(<span class="hljs-string">&quot;Child thread starts&quot;</span>);<br>                <span class="hljs-comment">// 计数到 10</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>; counter &lt;= <span class="hljs-number">10</span>; counter++)<br>                &#123;<br>                    Thread.Sleep(<span class="hljs-number">500</span>);<br>                    Console.WriteLine(counter);<br>                &#125;<br>                Console.WriteLine(<span class="hljs-string">&quot;Child Thread Completed&quot;</span>);<br><br>            &#125;<br>            <span class="hljs-keyword">catch</span> (ThreadAbortException e)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;Thread Abort Exception&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">finally</span><br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;Couldn&#x27;t catch the Thread Exception&quot;</span>);<br>            &#125;<br><br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            ThreadStart childref = <span class="hljs-keyword">new</span> ThreadStart(CallToChildThread);<br>            Console.WriteLine(<span class="hljs-string">&quot;In Main: Creating the Child thread&quot;</span>);<br>            Thread childThread = <span class="hljs-keyword">new</span> Thread(childref);<br>            childThread.Start();<br>            <span class="hljs-comment">// 停止主线程一段时间</span><br>            Thread.Sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-comment">// 现在中止子线程</span><br>            Console.WriteLine(<span class="hljs-string">&quot;In Main: Aborting the Child thread&quot;</span>);<br>            childThread.Abort();<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">In Main:</span> Creating the Child <span class="hljs-keyword">thread</span><br>Child <span class="hljs-keyword">thread</span> starts<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-title">In Main:</span> Aborting the Child <span class="hljs-keyword">thread</span><br><span class="hljs-keyword">Thread</span> Abort Exception<br>Couldn&#x27;t catch the <span class="hljs-keyword">Thread</span> Exception <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#不安全代码(Unsafe Code)</title>
    <link href="/posts/25237/"/>
    <url>/posts/25237/</url>
    
    <content type="html"><![CDATA[<h1 id="C-不安全代码（Unsafe-Code）详解"><a href="#C-不安全代码（Unsafe-Code）详解" class="headerlink" title="C#不安全代码（Unsafe Code）详解"></a>C#不安全代码（Unsafe Code）详解</h1><p>在 C#中，不安全代码（Unsafe Code）是指那些直接操作内存地址的代码。不安全代码允许开发者使用指针等低级别的数据结构，这些在通常的安全代码（Safe Code）中是不允许的。不安全代码提供了更高的性能和更直接的内存操作能力，但也带来了更高的风险，因此需要谨慎使用。</p><h2 id="1-不安全代码的基本概念"><a href="#1-不安全代码的基本概念" class="headerlink" title="1.不安全代码的基本概念"></a>1.不安全代码的基本概念</h2><p>不安全代码是指使用了<code>unsafe</code>关键字的代码块，它允许直接使用指针和执行不安全的操作。使用<code>unsafe</code>关键字可以绕过 C#的安全性检查，因此需要谨慎使用，并且通常需要在项目的配置文件中启用不安全代码的支持。</p><h3 id="1-1-启用不安全代码"><a href="#1-1-启用不安全代码" class="headerlink" title="1.1 启用不安全代码"></a>1.1 启用不安全代码</h3><p>在 Visual Studio 中，可以通过项目属性启用不安全代码的支持：</p><p>• 右键点击项目，选择“属性”。</p><p>• 在“生成”选项卡中，勾选“允许不安全代码”选项。</p><p>在<code>.csproj</code>文件中，可以添加以下配置来启用不安全代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-不安全代码的语法"><a href="#2-不安全代码的语法" class="headerlink" title="2.不安全代码的语法"></a>2.不安全代码的语法</h2><h3 id="2-1-不安全上下文"><a href="#2-1-不安全上下文" class="headerlink" title="2.1 不安全上下文"></a>2.1 不安全上下文</h3><p>不安全代码必须在不安全上下文中使用。可以通过在类型、成员或本地函数的声明中包括<code>unsafe</code>修饰符，或者使用<code>unsafe</code>语句来引入不安全上下文。</p><h4 id="2-1-1-类型声明"><a href="#2-1-1-类型声明" class="headerlink" title="2.1.1 类型声明"></a>2.1.1 类型声明</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br>    <span class="hljs-keyword">public</span> Node* Left;<br>    <span class="hljs-keyword">public</span> Node* Right;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-2-成员声明"><a href="#2-1-2-成员声明" class="headerlink" title="2.1.2 成员声明"></a>2.1.2 成员声明</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> Node* Left;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> Node* Right;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-3-本地函数"><a href="#2-1-3-本地函数" class="headerlink" title="2.1.3 本地函数"></a>2.1.3 本地函数</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">void</span>* GetPointer()<br>    &#123;<br>        <span class="hljs-keyword">return</span> &amp;Value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-4unsafe语句"><a href="#2-1-4unsafe语句" class="headerlink" title="2.1.4unsafe语句"></a>2.1.4<code>unsafe</code>语句</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAddress</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>* p = &amp;Value;<br>            Console.WriteLine(<span class="hljs-string">&quot;Address: &quot;</span> + (<span class="hljs-built_in">int</span>)p);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-指针类型"><a href="#2-2-指针类型" class="headerlink" title="2.2 指针类型"></a>2.2 指针类型</h3><p>在不安全上下文中，可以声明和操作指针类型。指针类型可以是任何值类型或引用类型，也可以是<code>void*</code>。</p><h4 id="2-2-1-声明指针"><a href="#2-2-1-声明指针" class="headerlink" title="2.2.1 声明指针"></a>2.2.1 声明指针</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>* p;<br><span class="hljs-built_in">double</span>* dp;<br><span class="hljs-built_in">char</span>* cp;<br><span class="hljs-keyword">void</span>* vp;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-指针操作"><a href="#2-2-2-指针操作" class="headerlink" title="2.2.2 指针操作"></a>2.2.2 指针操作</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> <span class="hljs-keyword">var</span> = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">int</span>* p = &amp;<span class="hljs-keyword">var</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;Data is: &#123;0&#125;&quot;</span>, *p); <span class="hljs-comment">// 输出 20</span><br>Console.WriteLine(<span class="hljs-string">&quot;Address is: &#123;0&#125;&quot;</span>, (<span class="hljs-built_in">int</span>)p); <span class="hljs-comment">// 输出地址</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-指针数组"><a href="#2-2-3-指针数组" class="headerlink" title="2.2.3 指针数组"></a>2.2.3 指针数组</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>*[] pArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>*[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>    pArray[i] = &amp;i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3fixed语句"><a href="#2-3fixed语句" class="headerlink" title="2.3fixed语句"></a>2.3<code>fixed</code>语句</h3><p><code>fixed</code>语句用于固定托管变量的地址，防止垃圾回收器移动它们。这在需要将托管变量的地址传递给不安全代码时非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAddress</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">int</span>* p = &amp;Value)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;Address: &quot;</span> + (<span class="hljs-built_in">int</span>)p);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4stackalloc操作符"><a href="#2-4stackalloc操作符" class="headerlink" title="2.4stackalloc操作符"></a>2.4<code>stackalloc</code>操作符</h3><p><code>stackalloc</code>操作符用于在栈上分配内存。从 C#7.2 开始，Microsoft 建议在可能的情况下避免在不安全上下文中使用<code>stackalloc</code>，因为它可能导致栈溢出。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintArray</span>()</span><br>&#123;<br>    <span class="hljs-keyword">unsafe</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>* array = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            array[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            Console.WriteLine(array[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-不安全代码的示例"><a href="#3-不安全代码的示例" class="headerlink" title="3.不安全代码的示例"></a>3.不安全代码的示例</h2><h3 id="3-1-指针操作"><a href="#3-1-指针操作" class="headerlink" title="3.1 指针操作"></a>3.1 指针操作</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">var</span> = <span class="hljs-number">20</span>;<br>            <span class="hljs-built_in">int</span>* p = &amp;<span class="hljs-keyword">var</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;Data is: &#123;0&#125;&quot;</span>, *p); <span class="hljs-comment">// 输出 20</span><br>            Console.WriteLine(<span class="hljs-string">&quot;Address is: &#123;0&#125;&quot;</span>, (<span class="hljs-built_in">int</span>)p); <span class="hljs-comment">// 输出地址</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-固定托管变量"><a href="#3-2-固定托管变量" class="headerlink" title="3.2 固定托管变量"></a>3.2 固定托管变量</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">var</span> = <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">int</span>* p = &amp;<span class="hljs-keyword">var</span>)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;Data is: &#123;0&#125;&quot;</span>, *p); <span class="hljs-comment">// 输出 20</span><br>                Console.WriteLine(<span class="hljs-string">&quot;Address is: &#123;0&#125;&quot;</span>, (<span class="hljs-built_in">int</span>)p); <span class="hljs-comment">// 输出地址</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-指针数组"><a href="#3-3-指针数组" class="headerlink" title="3.3 指针数组"></a>3.3 指针数组</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>*[] pArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>*[<span class="hljs-number">10</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                pArray[i] = &amp;i;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                Console.WriteLine(*pArray[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4stackalloc操作符"><a href="#3-4stackalloc操作符" class="headerlink" title="3.4stackalloc操作符"></a>3.4<code>stackalloc</code>操作符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>* array = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                array[i] = i;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                Console.WriteLine(array[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-不安全代码的使用场景"><a href="#4-不安全代码的使用场景" class="headerlink" title="4.不安全代码的使用场景"></a>4.不安全代码的使用场景</h2><h3 id="4-1-性能优化"><a href="#4-1-性能优化" class="headerlink" title="4.1 性能优化"></a>4.1 性能优化</h3><p>不安全代码可以用于性能优化，特别是在需要直接操作内存的情况下。例如，处理大型数组或图像数据时，使用指针可以显著提高性能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ImageProcessor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProcessImage</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] image</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">unsafe</span><br>        &#123;<br>            <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">byte</span>* p = image)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; image.Length; i++)<br>                &#123;<br>                    p[i] = (<span class="hljs-built_in">byte</span>)(<span class="hljs-number">255</span> - p[i]); <span class="hljs-comment">// 反色处理</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-互操作性"><a href="#4-2-互操作性" class="headerlink" title="4.2 互操作性"></a>4.2 互操作性</h3><p>不安全代码可以用于与非托管代码的互操作，例如调用 C 或 C++库中的函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethods</span><br>&#123;<br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MessageBox</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> caption, <span class="hljs-built_in">uint</span> type</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        NativeMethods.MessageBox(IntPtr.Zero, <span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-string">&quot;Title&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-低级操作"><a href="#4-3-低级操作" class="headerlink" title="4.3 低级操作"></a>4.3 低级操作</h3><p>不安全代码可以用于低级操作，例如直接访问内存映射设备或实现时间关键型算法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeviceDriver</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToDevice</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>* deviceAddress, <span class="hljs-built_in">byte</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        *deviceAddress = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-不安全代码的风险"><a href="#5-不安全代码的风险" class="headerlink" title="5.不安全代码的风险"></a>5.不安全代码的风险</h2><h3 id="5-1-内存安全"><a href="#5-1-内存安全" class="headerlink" title="5.1 内存安全"></a>5.1 内存安全</h3><p>不安全代码绕过了 C#的内存安全检查，可能导致内存泄漏、缓冲区溢出等安全问题。因此，使用不安全代码时需要非常谨慎，确保代码的正确性和安全性。</p><h3 id="5-2-代码可读性"><a href="#5-2-代码可读性" class="headerlink" title="5.2 代码可读性"></a>5.2 代码可读性</h3><p>不安全代码通常比安全代码更复杂，可读性较差。因此，应尽量避免在不必要的地方使用不安全代码，保持代码的简洁和可维护性。</p><h3 id="5-3-维护难度"><a href="#5-3-维护难度" class="headerlink" title="5.3 维护难度"></a>5.3 维护难度</h3><p>不安全代码的维护难度较高，因为它们涉及低级内存操作和指针操作。因此，应尽量减少不安全代码的使用，除非确实需要高性能或低级操作。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>不安全代码是 C#中一个非常强大的特性，允许直接操作内存和使用指针。虽然不安全代码可以提供更高的性能和更直接的内存操作能力，但也带来了更高的风险。因此，使用不安全代码时需要非常谨慎，确保代码的正确性和安全性。在实际开发中，应尽量避免在不必要的地方使用不安全代码</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#匿名方法</title>
    <link href="/posts/30874/"/>
    <url>/posts/30874/</url>
    
    <content type="html"><![CDATA[<h1 id="C-匿名方法"><a href="#C-匿名方法" class="headerlink" title="C#匿名方法"></a>C#匿名方法</h1><p>在 C#中，匿名方法（Anonymous Methods）允许你在委托实例化时直接定义方法体，而不需要提前定义一个单独的方法。匿名方法提供了一种简洁的方式来编写内联代码，特别适用于事件处理和回调函数。本文将详细介绍 C#匿名方法的各个方面，包括基本概念、语法、示例、使用场景等。</p><h2 id="1-匿名方法的基本概念"><a href="#1-匿名方法的基本概念" class="headerlink" title="1.匿名方法的基本概念"></a>1.匿名方法的基本概念</h2><p>匿名方法是一种没有名称的方法，可以在委托实例化时直接定义。它提供了一种简洁的方式来编写内联代码，特别适用于需要传递短小方法的场景。匿名方法可以访问其定义范围内的变量，这使得它们非常灵活和强大。</p><h2 id="2-匿名方法的语法"><a href="#2-匿名方法的语法" class="headerlink" title="2.匿名方法的语法"></a>2.匿名方法的语法</h2><p>匿名方法的语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">delegate</span> (参数列表) &#123; 方法体 &#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-定义匿名方法"><a href="#2-1-定义匿名方法" class="headerlink" title="2.1 定义匿名方法"></a>2.1 定义匿名方法</h3><p>以下是一个简单的匿名方法示例，该匿名方法接受一个<code>string</code>参数并打印它：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">string</span> message)<br>        &#123;<br>            Console.WriteLine(message);<br>        &#125;;<br><br>        del(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>MyDelegate</code>是一个委托类型，接受一个<code>string</code>参数并返回<code>void</code>。匿名方法直接在委托实例化时定义，无需提前定义一个单独的方法。</p><h2 id="3-匿名方法的示例"><a href="#3-匿名方法的示例" class="headerlink" title="3.匿名方法的示例"></a>3.匿名方法的示例</h2><h3 id="3-1-无参数的匿名方法"><a href="#3-1-无参数的匿名方法" class="headerlink" title="3.1 无参数的匿名方法"></a>3.1 无参数的匿名方法</h3><p>以下是一个无参数的匿名方法示例，该匿名方法打印一条固定的消息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>()</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span>()<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125;;<br><br>        del();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-带参数的匿名方法"><a href="#3-2-带参数的匿名方法" class="headerlink" title="3.2 带参数的匿名方法"></a>3.2 带参数的匿名方法</h3><p>以下是一个带参数的匿名方法示例，该匿名方法接受一个<code>int</code>参数并打印它：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> number</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> number)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;;<br><br>        del(<span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-匿名方法与事件"><a href="#3-3-匿名方法与事件" class="headerlink" title="3.3 匿名方法与事件"></a>3.3 匿名方法与事件</h3><p>匿名方法常用于事件处理，以下是一个示例，展示了如何使用匿名方法处理按钮点击事件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Button button;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainForm</span>()</span><br>    &#123;<br>        button = <span class="hljs-keyword">new</span> Button();<br>        button.Text = <span class="hljs-string">&quot;Click Me&quot;</span>;<br>        button.Click += <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">object</span> sender, EventArgs e)<br>        &#123;<br>            MessageBox.Show(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>        &#125;;<br>        Controls.Add(button);<br>    &#125;<br><br>    [<span class="hljs-meta">STAThread</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Application.EnableVisualStyles();<br>        Application.Run(<span class="hljs-keyword">new</span> MainForm());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，按钮的<code>Click</code>事件使用匿名方法处理，当按钮被点击时，会显示一个消息框。</p><h2 id="4-匿名方法的使用场景"><a href="#4-匿名方法的使用场景" class="headerlink" title="4.匿名方法的使用场景"></a>4.匿名方法的使用场景</h2><h3 id="4-1-事件处理"><a href="#4-1-事件处理" class="headerlink" title="4.1 事件处理"></a>4.1 事件处理</h3><p>匿名方法非常适合用于事件处理，特别是当事件处理程序很短时。以下是一个示例，展示了如何使用匿名方法处理定时器的<code>Tick</code>事件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Timers;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Timer timer = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 每秒触发一次</span><br>        timer.Elapsed += <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">object</span> sender, ElapsedEventArgs e)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Timer ticked at: &quot;</span> + e.SignalTime);<br>        &#125;;<br>        timer.Start();<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Press Enter to exit...&quot;</span>);<br>        Console.ReadLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-回调函数"><a href="#4-2-回调函数" class="headerlink" title="4.2 回调函数"></a>4.2 回调函数</h3><p>匿名方法也常用于回调函数，以下是一个示例，展示了如何使用匿名方法作为回调函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> result</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        CallbackDelegate callback = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> result)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Callback result: &quot;</span> + result);<br>        &#125;;<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 模拟耗时操作</span><br>            Thread.Sleep(<span class="hljs-number">2000</span>);<br>            callback(<span class="hljs-number">42</span>);<br>        &#125;);<br><br>        thread.Start();<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Doing other work...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-简化代码"><a href="#4-3-简化代码" class="headerlink" title="4.3 简化代码"></a>4.3 简化代码</h3><p>匿名方法可以简化代码，特别是当需要传递短小方法时。以下是一个示例，展示了如何使用匿名方法简化<code>Array.Sort</code>的使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] numbers = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br><br>        Array.Sort(numbers, <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> y - x; <span class="hljs-comment">// 降序排序</span><br>        &#125;);<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-匿名方法与-Lambda-表达式"><a href="#5-匿名方法与-Lambda-表达式" class="headerlink" title="5.匿名方法与 Lambda 表达式"></a>5.匿名方法与 Lambda 表达式</h2><p>Lambda 表达式是匿名方法的更简洁的语法，以下是一个示例，展示了如何使用 Lambda 表达式代替匿名方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> number</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = (<span class="hljs-built_in">int</span> number) =&gt; Console.WriteLine(number);<br><br>        del(<span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda 表达式使用<code>=&gt;</code>运算符，语法更简洁，功能更强大。在 C#3.0 及以后的版本中，推荐使用 Lambda 表达式，因为它们支持更多的功能，如表达式树和 LINQ 查询。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>匿名方法是 C#中一种非常有用的特性，允许你在委托实例化时直接定义方法体，而不需要提前定义一个单独的方法。匿名方法特别适用于事件处理和回调函数，可以简化代码并提高可读性。虽然 Lambda 表达式是匿名方法的更简洁的语法，但匿名方法在某些场景下仍然非常有用。</p><p>希望本文能帮助你更好地理解和使用 C#中的匿名方法。如果你有任何问题或建议，欢迎在评论区留言。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#泛型（Generic）</title>
    <link href="/posts/27062/"/>
    <url>/posts/27062/</url>
    
    <content type="html"><![CDATA[<h1 id="C-泛型（Generic）"><a href="#C-泛型（Generic）" class="headerlink" title="C# 泛型（Generic）"></a>C# 泛型（Generic）</h1><h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1.泛型的基本概念"></a>1.泛型的基本概念</h2><p>泛型（Generic）是 C#中一种强大的类型系统特性，允许你定义类、结构、接口、方法等，使其可以使用任意类型作为参数。泛型的主要用途包括：</p><p>• 类型安全：确保集合中的所有元素都是同一类型，避免类型转换错误。</p><p>• 代码复用：编写通用的类和方法，减少重复代码。</p><p>• 性能优化：避免装箱和拆箱操作，提高性能。</p><h2 id="2-泛型的语法"><a href="#2-泛型的语法" class="headerlink" title="2.泛型的语法"></a>2.泛型的语法</h2><h3 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1 泛型类"></a>2.1 泛型类</h3><p>泛型类是一种可以使用任意类型作为参数的类。定义泛型类时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型类时，需要指定具体的类型参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyGenericClass&lt;<span class="hljs-built_in">int</span>&gt; intClass = <span class="hljs-keyword">new</span> MyGenericClass&lt;<span class="hljs-built_in">int</span>&gt;();<br>intClass.Value = <span class="hljs-number">10</span>;<br><br>MyGenericClass&lt;<span class="hljs-built_in">string</span>&gt; stringClass = <span class="hljs-keyword">new</span> MyGenericClass&lt;<span class="hljs-built_in">string</span>&gt;();<br>stringClass.Value = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-泛型方法"><a href="#2-2-泛型方法" class="headerlink" title="2.2 泛型方法"></a>2.2 泛型方法</h3><p>泛型方法是一种可以使用任意类型作为参数的方法。定义泛型方法时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethods</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetDefault</span>&lt;<span class="hljs-title">T</span>&gt;()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型方法时，可以省略类型参数，编译器会自动推断类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyGenericMethods methods = <span class="hljs-keyword">new</span> MyGenericMethods();<br><span class="hljs-built_in">int</span> defaultValue = methods.GetDefault&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 显式指定类型</span><br><span class="hljs-built_in">string</span> stringValue = methods.GetDefault(); <span class="hljs-comment">// 编译器自动推断类型</span><br></code></pre></td></tr></table></figure><h3 id="2-3-泛型接口"><a href="#2-3-泛型接口" class="headerlink" title="2.3 泛型接口"></a>2.3 泛型接口</h3><p>泛型接口是一种可以使用任意类型作为参数的接口。定义泛型接口时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IGenericInterface</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">GetValue</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口时，需要指定具体的类型参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IGenericInterface</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetValue</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-泛型结构"><a href="#2-4-泛型结构" class="headerlink" title="2.4 泛型结构"></a>2.4 泛型结构</h3><p>泛型结构是一种可以使用任意类型作为参数的结构。定义泛型结构时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> MyGenericStruct&lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型结构时，需要指定具体的类型参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyGenericStruct&lt;<span class="hljs-built_in">int</span>&gt; intStruct = <span class="hljs-keyword">new</span> MyGenericStruct&lt;<span class="hljs-built_in">int</span>&gt;();<br>intStruct.Value = <span class="hljs-number">20</span>;<br><br>MyGenericStruct&lt;<span class="hljs-built_in">string</span>&gt; stringStruct = <span class="hljs-keyword">new</span> MyGenericStruct&lt;<span class="hljs-built_in">string</span>&gt;();<br>stringStruct.Value = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-泛型的约束"><a href="#3-泛型的约束" class="headerlink" title="3.泛型的约束"></a>3.泛型的约束</h2><p>泛型可以使用约束来限制类型参数的范围。常见的约束包括：</p><p>• 类约束：<code>where T : class</code>，限制<code>T</code>必须是引用类型。</p><p>• 结构约束：<code>where T : struct</code>，限制<code>T</code>必须是值类型。</p><p>• 构造函数约束：<code>where T : new()</code>，限制<code>T</code>必须有无参数的构造函数。</p><p>• 基类约束：<code>where T : BaseClass</code>，限制<code>T</code>必须继承自<code>BaseClass</code>。</p><p>• 接口约束：<code>where T : IInterface</code>，限制<code>T</code>必须实现<code>IInterface</code>。</p><h3 id="3-1-类约束"><a href="#3-1-类约束" class="headerlink" title="3.1 类约束"></a>3.1 类约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span><br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-结构约束"><a href="#3-2-结构约束" class="headerlink" title="3.2 结构约束"></a>3.2 结构约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span><br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-构造函数约束"><a href="#3-3-构造函数约束" class="headerlink" title="3.3 构造函数约束"></a>3.3 构造函数约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>()<br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGenericClass</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> T();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-基类约束"><a href="#3-4-基类约束" class="headerlink" title="3.4 基类约束"></a>3.4 基类约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-接口约束"><a href="#3-5-接口约束" class="headerlink" title="3.5 接口约束"></a>3.5 接口约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-keyword">public</span> T Value<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-泛型的高级用法"><a href="#4-泛型的高级用法" class="headerlink" title="4.泛型的高级用法"></a>4.泛型的高级用法</h2><h4 id="4-1-泛型委托"><a href="#4-1-泛型委托" class="headerlink" title="4.1 泛型委托"></a>4.1 泛型委托</h4><p>泛型委托是一种可以使用任意类型作为参数的委托。定义泛型委托时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> T <span class="hljs-title">MyGenericDelegate</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethods</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetDefault</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型委托时，需要指定具体的类型参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyGenericDelegate&lt;<span class="hljs-built_in">int</span>&gt; intDelegate = <span class="hljs-keyword">new</span> MyGenericDelegate&lt;<span class="hljs-built_in">int</span>&gt;(methods.GetDefault);<br><span class="hljs-built_in">int</span> defaultValue = intDelegate(<span class="hljs-number">10</span>);<br><br>MyGenericDelegate&lt;<span class="hljs-built_in">string</span>&gt; stringDelegate = <span class="hljs-keyword">new</span> MyGenericDelegate&lt;<span class="hljs-built_in">string</span>&gt;(methods.GetDefault);<br><span class="hljs-built_in">string</span> stringValue = stringDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-2-泛型事件"><a href="#4-2-泛型事件" class="headerlink" title="4.2 泛型事件"></a>4.2 泛型事件</h3><p>泛型事件是一种可以使用任意类型作为参数的事件。定义泛型事件时，使用<code>&lt;T&gt;</code>表示类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyGenericEventHandler</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, T e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyGenericEventHandler&lt;T&gt; MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>(<span class="hljs-params">T e</span>)</span><br>    &#123;<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型事件时，需要指定具体的类型参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MyEventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Event received: Message = <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher&lt;MyEventArgs&gt; publisher = <span class="hljs-keyword">new</span> MyPublisher&lt;MyEventArgs&gt;();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        MyEventArgs args = <span class="hljs-keyword">new</span> MyEventArgs &#123; Message = <span class="hljs-string">&quot;Hello, World!&quot;</span> &#125;;<br>        publisher.RaiseEvent(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-泛型方法的类型推断"><a href="#4-3-泛型方法的类型推断" class="headerlink" title="4.3 泛型方法的类型推断"></a>4.3 泛型方法的类型推断</h3><p>泛型方法的类型参数可以由编译器自动推断，无需显式指定类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethods</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetDefault</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyGenericMethods methods = <span class="hljs-keyword">new</span> MyGenericMethods();<br>        <span class="hljs-built_in">int</span> defaultValue = methods.GetDefault(<span class="hljs-number">10</span>); <span class="hljs-comment">// 编译器自动推断类型</span><br>        <span class="hljs-built_in">string</span> stringValue = methods.GetDefault(<span class="hljs-string">&quot;Hello, World!&quot;</span>); <span class="hljs-comment">// 编译器自动推断类型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-泛型的性能优势"><a href="#5-泛型的性能优势" class="headerlink" title="5.泛型的性能优势"></a>5.泛型的性能优势</h2><h3 id="5-1-避免装箱和拆箱"><a href="#5-1-避免装箱和拆箱" class="headerlink" title="5.1 避免装箱和拆箱"></a>5.1 避免装箱和拆箱</h3><p>使用泛型可以避免装箱和拆箱操作，提高性能。装箱和拆箱是值类型和引用类型之间的转换操作，会带来性能开销。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>intList.Add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 无需装箱</span><br><br>ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>arrayList.Add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 需要装箱</span><br></code></pre></td></tr></table></figure><h3 id="5-2-生成类型特定的代码"><a href="#5-2-生成类型特定的代码" class="headerlink" title="5.2 生成类型特定的代码"></a>5.2 生成类型特定的代码</h3><p>泛型在编译时生成类型特定的代码，确保类型安全，避免运行时类型转换错误。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = intList[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 无需类型转换</span><br><br>ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = (<span class="hljs-built_in">int</span>)arrayList[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 需要类型转换</span><br></code></pre></td></tr></table></figure><h2 id="6-泛型的使用场景"><a href="#6-泛型的使用场景" class="headerlink" title="6.泛型的使用场景"></a>6.泛型的使用场景</h2><h3 id="6-1-集合"><a href="#6-1-集合" class="headerlink" title="6.1 集合"></a>6.1 集合</h3><p>泛型集合是泛型最常用的场景之一。<code>List&lt;T&gt;</code>、<code>Dictionary&lt;TKey, TValue&gt;</code>、<code>Queue&lt;T&gt;</code>、<code>Stack&lt;T&gt;</code>等泛型集合提供了类型安全的集合操作</p><h3 id="6-2-方法"><a href="#6-2-方法" class="headerlink" title="6.2 方法"></a>6.2 方法</h3><p>泛型方法允许你编写通用的方法，这些方法可以处理任意类型的参数，同时保持类型安全。这在编写工具类或库时特别有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Max</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.Length == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Array cannot be null or empty.&quot;</span>);<br>        &#125;<br><br>        T max = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[i].CompareTo(max) &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                max = array[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br>        <span class="hljs-built_in">int</span> maxInt = Utility.Max(intArray);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Max int: <span class="hljs-subst">&#123;maxInt&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 5</span><br><br>        <span class="hljs-built_in">double</span>[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">5.5</span>, <span class="hljs-number">4.4</span> &#125;;<br>        <span class="hljs-built_in">double</span> maxDouble = Utility.Max(doubleArray);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Max double: <span class="hljs-subst">&#123;maxDouble&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 5.5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-类和结构"><a href="#6-3-类和结构" class="headerlink" title="6.3 类和结构"></a>6.3 类和结构</h3><p>泛型类和结构允许你创建通用的数据结构，这些结构可以处理任意类型的对象，同时保持类型安全。这在创建自定义集合或数据容器时非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 First &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T2 Second &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T1 first, T2 second</span>)</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; pair = <span class="hljs-keyword">new</span> Pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;First: <span class="hljs-subst">&#123;pair.First&#125;</span>, Second: <span class="hljs-subst">&#123;pair.Second&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 First: 1, Second: Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-接口"><a href="#6-4-接口" class="headerlink" title="6.4 接口"></a>6.4 接口</h3><p>泛型接口允许你定义通用的接口，这些接口可以处理任意类型的对象，同时保持类型安全。这在创建通用的服务或组件时非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T entity</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">T entity</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span>(<span class="hljs-params">T entity</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> : <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">User</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实现获取用户逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User &#123; Id = id, Name = <span class="hljs-string">&quot;John Doe&quot;</span> &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">User entity</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实现添加用户逻辑</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">User entity</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实现更新用户逻辑</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span>(<span class="hljs-params">User entity</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实现删除用户逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        IRepository&lt;User&gt; userRepository = <span class="hljs-keyword">new</span> UserRepository();<br>        User user = userRepository.GetById(<span class="hljs-number">1</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;User: <span class="hljs-subst">&#123;user.Name&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 User: John Doe</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-泛型的类型参数"><a href="#7-泛型的类型参数" class="headerlink" title="7.泛型的类型参数"></a>7.泛型的类型参数</h2><h3 id="7-1-类型参数的命名约定"><a href="#7-1-类型参数的命名约定" class="headerlink" title="7.1 类型参数的命名约定"></a>7.1 类型参数的命名约定</h3><p>类型参数通常使用单个大写字母来命名，常见的命名约定如下：</p><p><strong>• <code>T</code>：通用类型参数</strong></p><p><strong>• <code>TKey</code>、<code>TValue</code>：键值对中的键和值类型</strong></p><p><strong>• <code>TItem</code>、<code>TElement</code>：集合中的元素类型</strong></p><p><strong>• <code>TInput</code>、<code>TOutput</code>：输入和输出类型</strong></p><p><strong>• <code>TResult</code>：方法的返回类型</strong></p><h3 id="7-2-多个类型参数"><a href="#7-2-多个类型参数" class="headerlink" title="7.2 多个类型参数"></a>7.2 多个类型参数</h3><p>可以定义多个类型参数，以支持更复杂的泛型结构。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt;<br>&#123;<br>    <span class="hljs-comment">// 实现字典逻辑</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tuple</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 Item1 &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T2 Item2 &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T3 Item3 &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tuple</span>(<span class="hljs-params">T1 item1, T2 item2, T3 item3</span>)</span><br>    &#123;<br>        Item1 = item1;<br>        Item2 = item2;<br>        Item3 = item3;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; dictionary = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;();<br>        dictionary[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;One&quot;</span>;<br>        dictionary[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Two&quot;</span>;<br><br>        Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">double</span>&gt; tuple = <span class="hljs-keyword">new</span> Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3.14</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Item1: <span class="hljs-subst">&#123;tuple.Item1&#125;</span>, Item2: <span class="hljs-subst">&#123;tuple.Item2&#125;</span>, Item3: <span class="hljs-subst">&#123;tuple.Item3&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 Item1: 1, Item2: Hello, Item3: 3.14</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-泛型的类型推断"><a href="#8-泛型的类型推断" class="headerlink" title="8.泛型的类型推断"></a>8.泛型的类型推断</h2><h3 id="8-1-方法类型推断"><a href="#8-1-方法类型推断" class="headerlink" title="8.1 方法类型推断"></a>8.1 方法类型推断</h3><p>在调用泛型方法时，编译器可以自动推断类型参数，无需显式指定类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Max</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.Length == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Array cannot be null or empty.&quot;</span>);<br>        &#125;<br><br>        T max = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; array.Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (array[i].CompareTo(max) &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                max = array[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br>        <span class="hljs-built_in">int</span> maxInt = Utility.Max(intArray); <span class="hljs-comment">// 编译器自动推断类型</span><br><br>        <span class="hljs-built_in">double</span>[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">5.5</span>, <span class="hljs-number">4.4</span> &#125;;<br>        <span class="hljs-built_in">double</span> maxDouble = Utility.Max(doubleArray); <span class="hljs-comment">// 编译器自动推断类型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-类和结构类型推断"><a href="#8-2-类和结构类型推断" class="headerlink" title="8.2 类和结构类型推断"></a>8.2 类和结构类型推断</h3><p>在创建泛型类或结构的实例时，编译器也可以自动推断类型参数，但通常需要显式指定类型参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 First &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T2 Second &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T1 first, T2 second</span>)</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; pair = <span class="hljs-keyword">new</span> Pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 显式指定类型参数</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;First: <span class="hljs-subst">&#123;pair.First&#125;</span>, Second: <span class="hljs-subst">&#123;pair.Second&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出 First: 1, Second: Hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#集合(Collection)</title>
    <link href="/posts/60787/"/>
    <url>/posts/60787/</url>
    
    <content type="html"><![CDATA[<h1 id="C-集合（Collection）详解"><a href="#C-集合（Collection）详解" class="headerlink" title="C#集合（Collection）详解"></a>C#集合（Collection）详解</h1><p>在 C#中，集合（Collection）是一组对象的集合，用于存储、管理和操作一组数据。集合提供了灵活的方式来处理数据，支持动态大小、自动扩展、数据排序等功能。本文将详细介绍 C#集合的各个方面，包括基本概念、常用集合类型、泛型集合、非泛型集合、集合的常用操作等。</p><h2 id="1-集合的基本概念"><a href="#1-集合的基本概念" class="headerlink" title="1.集合的基本概念"></a>1.集合的基本概念</h2><p>集合是一种数据结构，用于存储一组对象。集合可以是动态的，支持自动扩展和收缩，也可以是静态的，具有固定的大小。集合的主要用途包括：</p><p>• 数据存储：存储一组对象，支持动态大小。</p><p>• 数据操作：提供方法来添加、删除、查找和排序数据。</p><p>• 数据遍历：支持遍历集合中的所有元素。</p><h2 id="2-常用集合类型"><a href="#2-常用集合类型" class="headerlink" title="2.常用集合类型"></a>2.常用集合类型</h2><h3 id="2-1-泛型集合"><a href="#2-1-泛型集合" class="headerlink" title="2.1 泛型集合"></a>2.1 泛型集合</h3><p>泛型集合提供了类型安全的集合，确保集合中的所有元素都是同一类型。常用的泛型集合包括：</p><p>• List：动态数组，支持自动扩展和收缩。</p><p>• Dictionary&lt;TKey,TValue&gt;：键值对集合，支持快速查找。</p><p>• Queue：先进先出（FIFO）队列。</p><p>• Stack：后进先出（LIFO）栈。</p><p>• HashSet：无序集合，支持快速查找和去重。</p><p>• LinkedList：双向链表，支持高效的插入和删除操作。</p><h3 id="2-2-非泛型集合"><a href="#2-2-非泛型集合" class="headerlink" title="2.2 非泛型集合"></a>2.2 非泛型集合</h3><p>非泛型集合不提供类型安全，但可以存储任何类型的对象。常用的非泛型集合包括：</p><p>• ArrayList：动态数组，支持自动扩展和收缩。</p><p>• Hashtable：键值对集合，支持快速查找。</p><p>• Queue：先进先出（FIFO）队列。</p><p>• Stack：后进先出（LIFO）栈。</p><h2 id="3-泛型集合"><a href="#3-泛型集合" class="headerlink" title="3.泛型集合"></a>3.泛型集合</h2><h3 id="3-1-List"><a href="#3-1-List" class="headerlink" title="3.1 List"></a>3.1 List</h3><p><code>List&lt;T&gt;</code>是一个动态数组，支持自动扩展和收缩。它提供了多种方法来添加、删除和查找元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>numbers.Add(<span class="hljs-number">1</span>);<br>numbers.Add(<span class="hljs-number">2</span>);<br>numbers.Add(<span class="hljs-number">3</span>);<br><br>Console.WriteLine(numbers[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 1</span><br><br>numbers.RemoveAt(<span class="hljs-number">1</span>);<br>Console.WriteLine(numbers[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><h3 id="3-2-Dictionary"><a href="#3-2-Dictionary" class="headerlink" title="3.2 Dictionary&lt;TKey,TValue&gt;"></a>3.2 Dictionary&lt;TKey,TValue&gt;</h3><p><code>Dictionary&lt;TKey, TValue&gt;</code>是一个键值对集合，支持快速查找。它提供了多种方法来添加、删除和查找键值对。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; dictionary = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;();<br>dictionary[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;One&quot;</span>;<br>dictionary[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Two&quot;</span>;<br><br>Console.WriteLine(dictionary[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出 One</span><br><br>dictionary.Remove(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="3-3-Queue"><a href="#3-3-Queue" class="headerlink" title="3.3 Queue"></a>3.3 Queue</h3><p><code>Queue&lt;T&gt;</code>是一个先进先出（FIFO）队列，支持高效的插入和删除操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Queue&lt;<span class="hljs-built_in">int</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">int</span>&gt;();<br>queue.Enqueue(<span class="hljs-number">1</span>);<br>queue.Enqueue(<span class="hljs-number">2</span>);<br>queue.Enqueue(<span class="hljs-number">3</span>);<br><br>Console.WriteLine(queue.Dequeue()); <span class="hljs-comment">// 输出 1</span><br>Console.WriteLine(queue.Peek()); <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure><h3 id="3-4-Stack"><a href="#3-4-Stack" class="headerlink" title="3.4 Stack"></a>3.4 Stack</h3><p><code>Stack&lt;T&gt;</code>是一个后进先出（LIFO）栈，支持高效的插入和删除操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();<br>stack.Push(<span class="hljs-number">1</span>);<br>stack.Push(<span class="hljs-number">2</span>);<br>stack.Push(<span class="hljs-number">3</span>);<br><br>Console.WriteLine(stack.Pop()); <span class="hljs-comment">// 输出 3</span><br>Console.WriteLine(stack.Peek()); <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure><h3 id="3-5-HashSet"><a href="#3-5-HashSet" class="headerlink" title="3.5 HashSet"></a>3.5 HashSet</h3><p><code>HashSet&lt;T&gt;</code>是一个无序集合，支持快速查找和去重。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">HashSet&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-keyword">set</span>.Add(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">set</span>.Add(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">set</span>.Add(<span class="hljs-number">3</span>);<br><br>Console.WriteLine(<span class="hljs-keyword">set</span>.Contains(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 True</span><br><br><span class="hljs-keyword">set</span>.Remove(<span class="hljs-number">2</span>);<br>Console.WriteLine(<span class="hljs-keyword">set</span>.Contains(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 False</span><br></code></pre></td></tr></table></figure><h3 id="3-6-LinkedList"><a href="#3-6-LinkedList" class="headerlink" title="3.6 LinkedList"></a>3.6 LinkedList</h3><p><code>LinkedList&lt;T&gt;</code>是一个双向链表，支持高效的插入和删除操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">LinkedList&lt;<span class="hljs-built_in">int</span>&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">int</span>&gt;();<br>linkedList.AddLast(<span class="hljs-number">1</span>);<br>linkedList.AddLast(<span class="hljs-number">2</span>);<br>linkedList.AddLast(<span class="hljs-number">3</span>);<br><br>Console.WriteLine(linkedList.First.Value); <span class="hljs-comment">// 输出 1</span><br><br>linkedList.RemoveFirst();<br>Console.WriteLine(linkedList.First.Value); <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure><h2 id="4-非泛型集合"><a href="#4-非泛型集合" class="headerlink" title="4.非泛型集合"></a>4.非泛型集合</h2><h3 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h3><p><code>ArrayList</code>是一个动态数组，支持自动扩展和收缩。它可以存储任何类型的对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-string">&quot;Two&quot;</span>);<br>list.Add(<span class="hljs-number">3.0</span>);<br><br>Console.WriteLine(list[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 1</span><br><br>list.RemoveAt(<span class="hljs-number">1</span>);<br>Console.WriteLine(list[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出 3.0</span><br></code></pre></td></tr></table></figure><h3 id="4-2-Hashtable"><a href="#4-2-Hashtable" class="headerlink" title="4.2 Hashtable"></a>4.2 Hashtable</h3><p><code>Hashtable</code>是一个键值对集合，支持快速查找。它可以存储任何类型的键和值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable();<br>hashtable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;One&quot;</span>;<br>hashtable[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Two&quot;</span>;<br><br>Console.WriteLine(hashtable[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出 One</span><br><br>hashtable.Remove(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="4-3-Queue"><a href="#4-3-Queue" class="headerlink" title="4.3 Queue"></a>4.3 Queue</h3><p><code>Queue</code>是一个先进先出（FIFO）队列，支持高效的插入和删除操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Queue queue = <span class="hljs-keyword">new</span> Queue();<br>queue.Enqueue(<span class="hljs-number">1</span>);<br>queue.Enqueue(<span class="hljs-string">&quot;Two&quot;</span>);<br>queue.Enqueue(<span class="hljs-number">3.0</span>);<br><br>Console.WriteLine(queue.Dequeue()); <span class="hljs-comment">// 输出 1</span><br>Console.WriteLine(queue.Peek()); <span class="hljs-comment">// 输出 Two</span><br></code></pre></td></tr></table></figure><h3 id="4-4-Stack"><a href="#4-4-Stack" class="headerlink" title="4.4 Stack"></a>4.4 Stack</h3><p><code>Stack</code>是一个后进先出（LIFO）栈，支持高效的插入和删除操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Stack stack = <span class="hljs-keyword">new</span> Stack();<br>stack.Push(<span class="hljs-number">1</span>);<br>stack.Push(<span class="hljs-string">&quot;Two&quot;</span>);<br>stack.Push(<span class="hljs-number">3.0</span>);<br><br>Console.WriteLine(stack.Pop()); <span class="hljs-comment">// 输出 3.0</span><br>Console.WriteLine(stack.Peek()); <span class="hljs-comment">// 输出 Two</span><br></code></pre></td></tr></table></figure><h2 id="5-集合的常用操作"><a href="#5-集合的常用操作" class="headerlink" title="5.集合的常用操作"></a>5.集合的常用操作</h2><h3 id="5-1-添加元素"><a href="#5-1-添加元素" class="headerlink" title="5.1 添加元素"></a>5.1 添加元素</h3><p>大多数集合提供了<code>Add</code>方法来添加元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-number">2</span>);<br>list.Add(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h3><p>大多数集合提供了<code>Remove</code>方法来删除元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-number">2</span>);<br>list.Add(<span class="hljs-number">3</span>);<br><br>list.Remove(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="5-3-查找元素"><a href="#5-3-查找元素" class="headerlink" title="5.3 查找元素"></a>5.3 查找元素</h3><p>大多数集合提供了<code>Contains</code>方法来查找元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-number">2</span>);<br>list.Add(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">bool</span> contains = list.Contains(<span class="hljs-number">2</span>); <span class="hljs-comment">// 输出 True</span><br></code></pre></td></tr></table></figure><h3 id="5-4-遍历集合"><a href="#5-4-遍历集合" class="headerlink" title="5.4 遍历集合"></a>5.4 遍历集合</h3><p>可以使用<code>foreach</code>循环来遍历集合中的所有元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-number">2</span>);<br>list.Add(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> list)<br>&#123;<br>    Console.WriteLine(item); <span class="hljs-comment">// 输出 1, 2, 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-排序集合"><a href="#5-5-排序集合" class="headerlink" title="5.5 排序集合"></a>5.5 排序集合</h3><p>可以使用<code>Sort</code>方法来排序集合中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>list.Add(<span class="hljs-number">3</span>);<br>list.Add(<span class="hljs-number">1</span>);<br>list.Add(<span class="hljs-number">2</span>);<br><br>list.Sort();<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> list)<br>&#123;<br>    Console.WriteLine(item); <span class="hljs-comment">// 输出 1, 2, 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-集合的高级用法"><a href="#6-集合的高级用法" class="headerlink" title="6.集合的高级用法"></a>6.集合的高级用法</h2><h3 id="6-1-自定义集合"><a href="#6-1-自定义集合" class="headerlink" title="6.1 自定义集合"></a>6.1 自定义集合</h3><p>可以创建自定义集合类，继承自<code>Collection&lt;T&gt;</code>或<code>KeyedCollection&lt;TKey, TValue&gt;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span> : <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">int</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddRange</span>(<span class="hljs-params">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; items</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> items)<br>        &#123;<br>            Add(item);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyCollection collection = <span class="hljs-keyword">new</span> MyCollection();<br>        collection.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> collection)<br>        &#123;<br>            Console.WriteLine(item); <span class="hljs-comment">// 输出 1, 2, 3</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-线程安全集合"><a href="#6-2-线程安全集合" class="headerlink" title="6.2 线程安全集合"></a>6.2 线程安全集合</h3><p>可以使用<code>ConcurrentBag&lt;T&gt;</code>、<code>ConcurrentQueue&lt;T&gt;</code>和<code>ConcurrentStack&lt;T&gt;</code>等线程安全集合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections.Concurrent;<br><br>ConcurrentQueue&lt;<span class="hljs-built_in">int</span>&gt; queue = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;<span class="hljs-built_in">int</span>&gt;();<br>queue.Enqueue(<span class="hljs-number">1</span>);<br>queue.Enqueue(<span class="hljs-number">2</span>);<br>queue.Enqueue(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">int</span> result;<br>queue.TryDequeue(<span class="hljs-keyword">out</span> result);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h3 id="6-3-异步集合"><a href="#6-3-异步集合" class="headerlink" title="6.3 异步集合"></a>6.3 异步集合</h3><p>可以使用<code>Channel&lt;T&gt;</code>来实现异步集合操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Threading.Tasks.Channels;<br><br><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MainAsync</span>()</span><br>&#123;<br>    Channel&lt;<span class="hljs-built_in">int</span>&gt; channel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>    Task producer = Task.Run(<span class="hljs-keyword">async</span> () =&gt;<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">await</span> channel.Writer.WriteAsync(i);<br>        &#125;<br>        channel.Writer.Complete();<br>    &#125;);<br><br>    Task consumer = Task.Run(<span class="hljs-keyword">async</span> () =&gt;<br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">await</span> channel.Reader.WaitToReadAsync())<br>        &#123;<br>            <span class="hljs-built_in">int</span> item;<br>            <span class="hljs-keyword">if</span>(channel.Reader.TryRead(<span class="hljs-keyword">out</span> item))<br>            &#123;<br>                onsole.WriteLine(item);<span class="hljs-comment">//输出 1,2,3</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">await</span> Task.WhenAll(producer, consumer);<br>&#125;<br>MainAsync().Wait();<br></code></pre></td></tr></table></figure><h2 id="7-集合的性能考虑"><a href="#7-集合的性能考虑" class="headerlink" title="7. 集合的性能考虑"></a>7. 集合的性能考虑</h2><h3 id="7-1-选择合适的集合类型"><a href="#7-1-选择合适的集合类型" class="headerlink" title="7.1 选择合适的集合类型"></a>7.1 选择合适的集合类型</h3><p>不同的集合类型有不同的性能特点。选择合适的集合类型可以显著提高程序的性能。</p><ul><li>**List<T>**：适用于频繁的读取操作，但插入和删除操作较慢。</T></li><li>**LinkedList<T>**：适用于频繁的插入和删除操作，但读取操作较慢。</T></li><li>**Dictionary&lt;TKey, TValue&gt;**：适用于需要快速查找的键值对数据。</li><li>**HashSet<T>**：适用于需要快速查找和去重的无序数据。</T></li><li><strong>Queue<T></T></strong> 和 **Stack<T>**：适用于需要先进先出或后进先出的数据结构。</T></li></ul><h3 id="7-2-预分配容量"><a href="#7-2-预分配容量" class="headerlink" title="7.2 预分配容量"></a>7.2 预分配容量</h3><p>对于 <code>List&lt;T&gt;</code> 和 <code>Dictionary&lt;TKey, TValue&gt;</code> 等集合，预分配容量可以减少动态扩展的开销。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 预分配容量为 1000</span><br>Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; dictionary = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 预分配容量为 1000</span><br></code></pre></td></tr></table></figure><h3 id="7-3-使用线程安全集合"><a href="#7-3-使用线程安全集合" class="headerlink" title="7.3 使用线程安全集合"></a>7.3 使用线程安全集合</h3><p>在多线程环境中，使用线程安全集合可以避免数据竞争和同步问题。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections.Concurrent;<br><br>ConcurrentBag&lt;<span class="hljs-built_in">int</span>&gt; bag = <span class="hljs-keyword">new</span> ConcurrentBag&lt;<span class="hljs-built_in">int</span>&gt;();<br>bag.Add(<span class="hljs-number">1</span>);<br>bag.Add(<span class="hljs-number">2</span>);<br>bag.Add(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">int</span> result;<br>bag.TryTake(<span class="hljs-keyword">out</span> result);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h3 id="7-4-使用异步集合"><a href="#7-4-使用异步集合" class="headerlink" title="7.4 使用异步集合"></a>7.4 使用异步集合</h3><p>在异步编程中，使用异步集合可以提高程序的响应性和性能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Threading.Tasks.Channels;<br><br><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MainAsync</span>()</span><br>&#123;<br>    Channel&lt;<span class="hljs-built_in">int</span>&gt; channel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>    Task producer = Task.Run(<span class="hljs-keyword">async</span> () =&gt;<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">await</span> channel.Writer.WriteAsync(i);<br>        &#125;<br>        channel.Writer.Complete();<br>    &#125;);<br><br>    Task consumer = Task.Run(<span class="hljs-keyword">async</span> () =&gt;<br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">await</span> channel.Reader.WaitToReadAsync())<br>        &#123;<br>            <span class="hljs-built_in">int</span> item;<br>            <span class="hljs-keyword">if</span> (channel.Reader.TryRead(<span class="hljs-keyword">out</span> item))<br>            &#123;<br>                Console.WriteLine(item); <span class="hljs-comment">// 输出 1, 2, 3</span><br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">await</span> Task.WhenAll(producer, consumer);<br>&#125;<br><br>MainAsync().Wait();<br></code></pre></td></tr></table></figure><h2 id="8-集合的实用技巧"><a href="#8-集合的实用技巧" class="headerlink" title="8.集合的实用技巧"></a>8.集合的实用技巧</h2><h4 id="8-1-使用-LINQ-查询集合"><a href="#8-1-使用-LINQ-查询集合" class="headerlink" title="8.1 使用 LINQ 查询集合"></a>8.1 使用 LINQ 查询集合</h4><p>LINQ（Language-Integrated Query）提供了一种强大的查询语法，可以用于查询和操作集合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> evenNumbers)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出 2, 4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-使用集合的扩展方法"><a href="#8-2-使用集合的扩展方法" class="headerlink" title="8.2 使用集合的扩展方法"></a>8.2 使用集合的扩展方法</h3><p>.NET 提供了许多集合的扩展方法，可以用于简化集合的操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-built_in">bool</span> contains = numbers.Any(n =&gt; n &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 True</span><br><span class="hljs-built_in">int</span> sum = numbers.Sum(); <span class="hljs-comment">// 输出 15</span><br></code></pre></td></tr></table></figure><h3 id="8-3-使用集合的转换方法"><a href="#8-3-使用集合的转换方法" class="headerlink" title="8.3 使用集合的转换方法"></a>8.3 使用集合的转换方法</h3><p>可以使用集合的转换方法，将一种集合类型转换为另一种集合类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-built_in">int</span>[] array = numbers.ToArray();<br>Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; dictionary = numbers.ToDictionary(n =&gt; n, n =&gt; n.ToString());<br></code></pre></td></tr></table></figure><h3 id="8-4-使用集合的并行操作"><a href="#8-4-使用集合的并行操作" class="headerlink" title="8.4 使用集合的并行操作"></a>8.4 使用集合的并行操作</h3><p>可以使用并行操作来提高集合的处理速度。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br>Parallel.ForEach(numbers, (number) =&gt;<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 并行输出 1, 2, 3, 4, 5</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><table><thead><tr><th>集合类型</th><th>插入速度</th><th>删除速度</th><th>查找速度</th><th>内存占用</th><th>适用场景</th></tr></thead><tbody><tr><td><code>List&lt;T&gt;</code></td><td>中</td><td>中（尾部快，头部慢）</td><td>快</td><td>低</td><td>需要快速访问和遍历的有序集合</td></tr><tr><td><code>Dictionary&lt;TKey, TValue&gt;</code></td><td>快</td><td>快</td><td>快</td><td>中</td><td>需要快速查找的键值对数据</td></tr><tr><td><code>HashSet&lt;T&gt;</code></td><td>快</td><td>快</td><td>快</td><td>中</td><td>需要快速去重和检查元素是否存在</td></tr><tr><td><code>LinkedList&lt;T&gt;</code></td><td>快</td><td>快</td><td>慢</td><td>中</td><td>需要频繁插入和删除操作的无序集合</td></tr><tr><td><code>Queue&lt;T&gt;</code></td><td>快</td><td>快</td><td>慢</td><td>低</td><td>需要先进先出（FIFO）操作的集合</td></tr><tr><td><code>Stack&lt;T&gt;</code></td><td>快</td><td>快</td><td>慢</td><td>低</td><td>需要后进先出（LIFO）操作的集合</td></tr><tr><td><code>SortedList&lt;TKey, TValue&gt;</code></td><td>中</td><td>中</td><td>快</td><td>高</td><td>需要自动排序且经常进行快速访问的集合</td></tr><tr><td><code>SortedSet&lt;T&gt;</code></td><td>中</td><td>中</td><td>快</td><td>高</td><td>需要自动排序且经常进行快速访问的集合</td></tr><tr><td><code>ArrayList</code></td><td>中</td><td>中（尾部快，头部慢）</td><td>慢</td><td>低</td><td>需要动态大小但不关心类型安全的集合</td></tr><tr><td><code>Hashtable</code></td><td>快</td><td>快</td><td>快</td><td>中</td><td>需要快速查找的键值对数据，不关心类型安全</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件(Event)</title>
    <link href="/posts/20217/"/>
    <url>/posts/20217/</url>
    
    <content type="html"><![CDATA[<h1 id="C-事件（Event）详解"><a href="#C-事件（Event）详解" class="headerlink" title="C#事件（Event）详解"></a>C#事件（Event）详解</h1><p>在 C#中，事件（Event）是一种用于实现发布-订阅模式的机制，允许对象在特定情况下通知其他对象。事件通常用于 GUI 编程（如按钮点击事件）和异步编程（如任务完成事件）。本文将详细介绍 C#事件的各个方面，包括基本概念、语法、示例、事件的发布和订阅、事件的多播、以及事件的使用场景等。</p><h2 id="1-事件的基本概念"><a href="#1-事件的基本概念" class="headerlink" title="1.事件的基本概念"></a>1.事件的基本概念</h2><p>事件是一种特殊的委托，用于在特定条件下通知订阅者。事件的发布者（Publisher）定义事件，而订阅者（Subscriber）注册事件处理程序来响应事件。事件的主要用途包括：</p><p>• GUI 编程：处理用户界面中的各种交互，如按钮点击、文本输入等。</p><p>• 异步编程：在异步操作完成时通知调用者。</p><p>• 多播：允许多个订阅者响应同一个事件。</p><h2 id="2-事件的语法"><a href="#2-事件的语法" class="headerlink" title="2.事件的语法"></a>2.事件的语法</h2><p>事件的声明语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> 委托类型 事件名称;<br></code></pre></td></tr></table></figure><h3 id="2-1-定义一个事件"><a href="#2-1-定义一个事件" class="headerlink" title="2.1 定义一个事件"></a>2.1 定义一个事件</h3><p>以下是一个简单的事件定义示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyEventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>()</span><br>    &#123;<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>MyPublisher</code>类定义了一个事件<code>MyEvent</code>，使用<code>MyEventHandler</code>委托类型。<code>RaiseEvent</code>方法用于触发事件。</p><h3 id="2-2-订阅和处理事件"><a href="#2-2-订阅和处理事件" class="headerlink" title="2.2 订阅和处理事件"></a>2.2 订阅和处理事件</h3><p>定义事件后，可以创建一个订阅者类，并注册事件处理程序来响应事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.RaiseEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>MySubscriber</code>类中的<code>OnMyEvent</code>方法被注册为<code>MyEvent</code>事件的处理程序。调用<code>publisher.RaiseEvent()</code>时，<code>OnMyEvent</code>方法会被调用。</p><h2 id="3-事件的多播"><a href="#3-事件的多播" class="headerlink" title="3.事件的多播"></a>3.事件的多播</h2><p>事件允许多个订阅者响应同一个事件。可以通过<code>+=</code>运算符添加多个事件处理程序，通过<code>-=</code>运算符移除事件处理程序。</p><h3 id="3-1-多播事件示例"><a href="#3-1-多播事件示例" class="headerlink" title="3.1 多播事件示例"></a>3.1 多播事件示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyEventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>()</span><br>    &#123;<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Subscriber 1: Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Subscriber 2: Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber1 subscriber1 = <span class="hljs-keyword">new</span> MySubscriber1();<br>        MySubscriber2 subscriber2 = <span class="hljs-keyword">new</span> MySubscriber2();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber1.OnMyEvent;<br>        publisher.MyEvent += subscriber2.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.RaiseEvent();<br><br>        <span class="hljs-comment">// 移除一个订阅者</span><br>        publisher.MyEvent -= subscriber1.OnMyEvent;<br><br>        <span class="hljs-comment">// 再次触发事件</span><br>        publisher.RaiseEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">1</span>: Event received!<br><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">2</span>: Event received!<br><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">2</span>: Event received!<br></code></pre></td></tr></table></figure><h2 id="4-事件的注意事项"><a href="#4-事件的注意事项" class="headerlink" title="4.事件的注意事项"></a>4.事件的注意事项</h2><h3 id="4-1-事件的线程安全"><a href="#4-1-事件的线程安全" class="headerlink" title="4.1 事件的线程安全"></a>4.1 事件的线程安全</h3><p>事件的发布和订阅操作通常是线程安全的，但触发事件时需要确保线程安全。可以使用<code>Invoke</code>方法的线程安全版本<code>BeginInvoke</code>和<code>EndInvoke</code>来异步触发事件。</p><h3 id="4-2-事件的解耦"><a href="#4-2-事件的解耦" class="headerlink" title="4.2 事件的解耦"></a>4.2 事件的解耦</h3><p>事件机制允许发布者和订阅者之间解耦，发布者不需要知道订阅者的具体实现，订阅者也不需要知道发布者的具体实现。这使得代码更加模块化和可维护。</p><h3 id="4-3-事件的默认处理"><a href="#4-3-事件的默认处理" class="headerlink" title="4.3 事件的默认处理"></a>4.3 事件的默认处理</h3><p>如果事件没有订阅者，触发事件时不会抛出异常。可以使用<code>?.Invoke</code>或<code>Invoke</code>方法来触发事件，确保在没有订阅者时不会抛出<code>NullReferenceException</code>。</p><h3 id="4-4-使用EventArgs传递自定义数据"><a href="#4-4-使用EventArgs传递自定义数据" class="headerlink" title="4.4 使用EventArgs传递自定义数据"></a>4.4 使用<code>EventArgs</code>传递自定义数据</h3><p><code>EventArgs</code>是一个基类，用于传递事件数据。你可以根据需要扩展<code>EventArgs</code>类，以传递更多自定义数据。如果事件不需要传递任何额外的数据，可以直接使用<code>EventArgs.Empty</code>。</p><h4 id="4-4-1-创建自定义EventArgs类"><a href="#4-4-1-创建自定义EventArgs类" class="headerlink" title="4.4.1 创建自定义EventArgs类"></a>4.4.1 创建自定义<code>EventArgs</code>类</h4><p>假设你有一个事件，需要传递一些特定的数据，比如一个字符串和一个整数。你可以创建一个继承自<code>EventArgs</code>的自定义类来实现这一点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Message = message;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-定义事件和触发事件"><a href="#4-4-2-定义事件和触发事件" class="headerlink" title="4.4.2 定义事件和触发事件"></a>4.4.2 定义事件和触发事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MyEventArgs e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyEventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        MyEventArgs args = <span class="hljs-keyword">new</span> MyEventArgs(message, <span class="hljs-keyword">value</span>);<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-订阅和处理事件"><a href="#4-4-3-订阅和处理事件" class="headerlink" title="4.4.3 订阅和处理事件"></a>4.4.3 订阅和处理事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MyEventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Event received: Message = <span class="hljs-subst">&#123;e.Message&#125;</span>, Value = <span class="hljs-subst">&#123;e.Value&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.RaiseEvent(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Event</span> received: Message = Hello, World!, Value = <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h2 id="5-事件的使用场景"><a href="#5-事件的使用场景" class="headerlink" title="5.事件的使用场景"></a>5.事件的使用场景</h2><h3 id="5-1-GUI-编程"><a href="#5-1-GUI-编程" class="headerlink" title="5.1 GUI 编程"></a>5.1 GUI 编程</h3><p>在 GUI 编程中，事件用于处理用户界面中的各种交互，如按钮点击、文本输入等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Button</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler Click;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClick</span>()</span><br>    &#123;<br>        Click?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Button button = <span class="hljs-keyword">new</span> Button();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form</span>()</span><br>    &#123;<br>        button.Click += Button_Click;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Form form = <span class="hljs-keyword">new</span> Form();<br>        form.button.OnClick(); <span class="hljs-comment">// 模拟按钮点击</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Button</span> clicked!<br></code></pre></td></tr></table></figure><h3 id="5-2-异步编程"><a href="#5-2-异步编程" class="headerlink" title="5.2 异步编程"></a>5.2 异步编程</h3><p>在异步编程中，事件用于在异步操作完成时通知调用者。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncOperation</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler Completed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartOperation</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 模拟异步操作</span><br>        Task.Run(() =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 模拟长时间运行的任务</span><br>            Thread.Sleep(<span class="hljs-number">2000</span>);<br><br>            <span class="hljs-comment">// 操作完成，触发事件</span><br>            Completed?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnOperationCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Operation completed!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        AsyncOperation operation = <span class="hljs-keyword">new</span> AsyncOperation();<br>        Client client = <span class="hljs-keyword">new</span> Client();<br><br>        operation.Completed += client.OnOperationCompleted;<br><br>        operation.StartOperation();<br><br>        <span class="hljs-comment">// 继续执行其他操作</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Doing other work...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Doing</span></span> other work...<br>Operation completed!<br></code></pre></td></tr></table></figure><h3 id="5-3-多播"><a href="#5-3-多播" class="headerlink" title="5.3 多播"></a>5.3 多播</h3><p>事件允许多个订阅者响应同一个事件，特别适用于多线程编程和多用户交互。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyEventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>()</span><br>    &#123;<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Subscriber 1: Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Subscriber 2: Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber1 subscriber1 = <span class="hljs-keyword">new</span> MySubscriber1();<br>        MySubscriber2 subscriber2 = <span class="hljs-keyword">new</span> MySubscriber2();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber1.OnMyEvent;<br>        publisher.MyEvent += subscriber2.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.RaiseEvent();<br><br>        <span class="hljs-comment">// 移除一个订阅者</span><br>        publisher.MyEvent -= subscriber1.OnMyEvent;<br><br>        <span class="hljs-comment">// 再次触发事件</span><br>        publisher.RaiseEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">1</span>: Event received!<br><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">2</span>: Event received!<br><span class="hljs-attribute">Subscriber</span> <span class="hljs-number">2</span>: Event received!<br></code></pre></td></tr></table></figure><h2 id="6-使用EventArgs传递自定义数据"><a href="#6-使用EventArgs传递自定义数据" class="headerlink" title="6.使用EventArgs传递自定义数据"></a>6.使用<code>EventArgs</code>传递自定义数据</h2><p><code>EventArgs</code>是一个基类，用于传递事件数据。你可以根据需要扩展<code>EventArgs</code>类，以传递更多自定义数据。如果事件不需要传递任何额外的数据，可以直接使用<code>EventArgs.Empty</code>。</p><h3 id="6-1-创建自定义EventArgs类"><a href="#6-1-创建自定义EventArgs类" class="headerlink" title="6.1 创建自定义EventArgs类"></a>6.1 创建自定义<code>EventArgs</code>类</h3><p>假设你有一个事件，需要传递一些特定的数据，比如一个字符串和一个整数。你可以创建一个继承自<code>EventArgs</code>的自定义类来实现这一点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Message = message;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-定义事件和触发事件"><a href="#6-2-定义事件和触发事件" class="headerlink" title="6.2 定义事件和触发事件"></a>6.2 定义事件和触发事件</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MyEventArgs e</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> MyEventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        MyEventArgs args = <span class="hljs-keyword">new</span> MyEventArgs(message, <span class="hljs-keyword">value</span>);<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-订阅和处理事件"><a href="#6-3-订阅和处理事件" class="headerlink" title="6.3 订阅和处理事件"></a>6.3 订阅和处理事件</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MyEventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Event received: Message = <span class="hljs-subst">&#123;e.Message&#125;</span>, Value = <span class="hljs-subst">&#123;e.Value&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.RaiseEvent(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Event</span> received: Message = Hello, World!, Value = <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h2 id="7-事件的高级用法"><a href="#7-事件的高级用法" class="headerlink" title="7.事件的高级用法"></a>7.事件的高级用法</h2><h3 id="7-1-异步事件处理"><a href="#7-1-异步事件处理" class="headerlink" title="7.1 异步事件处理"></a>7.1 异步事件处理</h3><p>在某些情况下，事件处理程序可能需要执行耗时的操作。为了不阻塞主线程，可以使用异步方法来处理事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Func&lt;MyEventArgs, Task&gt; MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RaiseEventAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        MyEventArgs args = <span class="hljs-keyword">new</span> MyEventArgs(message, <span class="hljs-keyword">value</span>);<br>        <span class="hljs-keyword">if</span> (MyEvent != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">await</span> MyEvent(args);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params">MyEventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Event received: Message = <span class="hljs-subst">&#123;e.Message&#125;</span>, Value = <span class="hljs-subst">&#123;e.Value&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        <span class="hljs-keyword">await</span> publisher.RaiseEventAsync(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Event</span> received: Message = Hello, World!, Value = <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h3 id="7-2-事件的取消"><a href="#7-2-事件的取消" class="headerlink" title="7.2 事件的取消"></a>7.2 事件的取消</h3><p>在某些情况下，你可能需要允许订阅者取消事件的进一步处理。可以通过传递一个<code>CancellationToken</code>来实现这一点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> CancellationToken CancellationToken &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        Message = message;<br>        Value = <span class="hljs-keyword">value</span>;<br>        CancellationToken = cancellationToken;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPublisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Func&lt;MyEventArgs, Task&gt; MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RaiseEventAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        MyEventArgs args = <span class="hljs-keyword">new</span> MyEventArgs(message, <span class="hljs-keyword">value</span>, cancellationToken);<br>        <span class="hljs-keyword">if</span> (MyEvent != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">await</span> MyEvent(args);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnMyEvent</span>(<span class="hljs-params">MyEventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 检查是否被取消</span><br>        <span class="hljs-keyword">if</span> (e.CancellationToken.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Event processing was canceled.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Event received: Message = <span class="hljs-subst">&#123;e.Message&#125;</span>, Value = <span class="hljs-subst">&#123;e.Value&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyPublisher publisher = <span class="hljs-keyword">new</span> MyPublisher();<br>        MySubscriber subscriber = <span class="hljs-keyword">new</span> MySubscriber();<br>        CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.MyEvent += subscriber.OnMyEvent;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        Task eventTask = publisher.RaiseEventAsync(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">42</span>, cts.Token);<br><br>        <span class="hljs-comment">// 取消事件处理</span><br>        cts.Cancel();<br><br>        <span class="hljs-keyword">await</span> eventTask;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Event processing was canceled.<br></code></pre></td></tr></table></figure><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>事件是 C#中一个非常强大的特性，用于实现发布-订阅模式，允许对象在特定条件下通知其他对象。事件的主要用途包括 GUI 编程、异步编程和多播。通过本文的介绍和示例，希望读者能够理解并掌握 C#中事件的使用方法和基本原理，从而能够在实际项目中灵活运用。</p><p>如果你有任何问题或建议，欢迎在评论区留言。希望本文对你有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#委托(Delegate)</title>
    <link href="/posts/16170/"/>
    <url>/posts/16170/</url>
    
    <content type="html"><![CDATA[<h1 id="C-委托（Delegate）"><a href="#C-委托（Delegate）" class="headerlink" title="C#委托（Delegate）"></a>C#委托（Delegate）</h1><h2 id="1-委托的基本概念"><a href="#1-委托的基本概念" class="headerlink" title="1.委托的基本概念"></a>1.委托的基本概念</h2><p>委托（Delegate）是一种特殊的类型，用于封装对具有特定参数列表和返回类型的方法的引用。委托在 C#中扮演着重要的角色，特别是在事件处理、回调函数和多播等方面。委托的主要用途包括：</p><p>• 事件处理：用于定义事件的处理程序。</p><p>• 回调函数：用于在方法执行完成后调用其他方法。</p><p>• 多播：允许多个方法响应同一个事件或调用。</p><h2 id="2-委托的语法"><a href="#2-委托的语法" class="headerlink" title="2.委托的语法"></a>2.委托的语法</h2><p>委托的声明语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> 返回类型 委托名称(参数列表);<br></code></pre></td></tr></table></figure><h3 id="2-1-定义一个委托"><a href="#2-1-定义一个委托" class="headerlink" title="2.1 定义一个委托"></a>2.1 定义一个委托</h3><p>以下是一个简单的委托定义示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个委托可以指向任何返回类型为<code>void</code>且接受一个<code>string</code>参数的方法。</p><h3 id="2-2-实现委托"><a href="#2-2-实现委托" class="headerlink" title="2.2 实现委托"></a>2.2 实现委托</h3><p>定义委托后，可以创建一个与委托签名匹配的方法，并使用委托类型创建一个实例来引用该方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-keyword">new</span> MyDelegate(<span class="hljs-keyword">new</span> MyClass().MyMethod);<br>        del(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>MyDelegate</code>委托被实例化并指向<code>MyClass</code>类中的<code>MyMethod</code>方法。调用<code>del(&quot;Hello, World!&quot;)</code>时，实际上调用了<code>MyMethod</code>方法。</p><h2 id="3-委托的类型"><a href="#3-委托的类型" class="headerlink" title="3.委托的类型"></a>3.委托的类型</h2><h3 id="3-1-单播委托"><a href="#3-1-单播委托" class="headerlink" title="3.1 单播委托"></a>3.1 单播委托</h3><p>单播委托只能指向一个方法。这是最常见的委托类型，用于封装单个方法调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method 1: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-keyword">new</span> MyDelegate(<span class="hljs-keyword">new</span> MyClass().MyMethod);<br>        del(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-多播委托"><a href="#3-2-多播委托" class="headerlink" title="3.2 多播委托"></a>3.2 多播委托</h3><p>多播委托允许多个方法响应同一个委托调用。多播委托通过<code>+</code>运算符组合多个委托实例，通过<code>-</code>运算符移除委托实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method 1: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method 2: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del1 = <span class="hljs-keyword">new</span> MyDelegate(<span class="hljs-keyword">new</span> MyClass().MyMethod1);<br>        MyDelegate del2 = <span class="hljs-keyword">new</span> MyDelegate(<span class="hljs-keyword">new</span> MyClass().MyMethod2);<br><br>        <span class="hljs-comment">// 组合多个委托</span><br>        MyDelegate multiDel = del1 + del2;<br><br>        <span class="hljs-comment">// 调用多播委托</span><br>        multiDel(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>        <span class="hljs-comment">// 移除一个委托</span><br>        multiDel -= del1;<br><br>        <span class="hljs-comment">// 再次调用多播委托</span><br>        multiDel(<span class="hljs-string">&quot;Hello again!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Method</span> 1: Hello, World!<br><span class="hljs-keyword">Method</span> 2: Hello, World!<br><span class="hljs-keyword">Method</span> 2: Hello again!<br></code></pre></td></tr></table></figure><h3 id="3-3-泛型委托"><a href="#3-3-泛型委托" class="headerlink" title="3.3 泛型委托"></a>3.3 泛型委托</h3><p>泛型委托允许你定义委托时指定类型参数，使得委托更加灵活和类型安全。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> T <span class="hljs-title">ResultDelegate</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T input</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> number * number;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        ResultDelegate&lt;<span class="hljs-built_in">int</span>&gt; del = <span class="hljs-keyword">new</span> ResultDelegate&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">new</span> MyClass().Square);<br>        <span class="hljs-built_in">int</span> result = del(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-匿名方法"><a href="#3-4-匿名方法" class="headerlink" title="3.4 匿名方法"></a>3.4 匿名方法</h3><p>匿名方法允许在委托实例化时直接定义方法体，而不需要提前定义一个方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">string</span> message)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Anonymous method: &quot;</span> + message);<br>        &#125;;<br><br>        del(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Lambda-表达式"><a href="#3-5-Lambda-表达式" class="headerlink" title="3.5 Lambda 表达式"></a>3.5 Lambda 表达式</h3><p>Lambda 表达式是一种更简洁的匿名方法语法，广泛用于 LINQ 查询和其他需要委托的地方。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = (message) =&gt; Console.WriteLine(<span class="hljs-string">&quot;Lambda expression: &quot;</span> + message);<br><br>        del(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-预定义泛型委托"><a href="#3-6-预定义泛型委托" class="headerlink" title="3.6 预定义泛型委托"></a>3.6 预定义泛型委托</h3><p>C#提供了一些预定义的泛型委托，如<code>Action</code>、<code>Func</code>和<code>Predicate</code>，这些委托使得代码更加简洁和通用。</p><h4 id="3-6-1-Action"><a href="#3-6-1-Action" class="headerlink" title="3.6.1 Action"></a>3.6.1 Action</h4><p><code>Action</code>委托代表不返回值的方法。可以接受最多 16 个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; printMessage = Console.WriteLine;<br>printMessage(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-6-2-Func"><a href="#3-6-2-Func" class="headerlink" title="3.6.2 Func"></a>3.6.2 Func</h4><p><code>Func</code>委托代表有返回值的方法。最多接受 16 个参数，第一个参数是输入参数，最后一个参数是返回值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br>Console.WriteLine(<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h4 id="3-6-3-Predicate"><a href="#3-6-3-Predicate" class="headerlink" title="3.6.3 Predicate"></a>3.6.3 Predicate</h4><p><code>Predicate</code>委托代表返回<code>bool</code>值的方法，通常用于条件判断。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Predicate&lt;<span class="hljs-built_in">int</span>&gt; isEven = x =&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>Console.WriteLine(isEven(<span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出 True</span><br></code></pre></td></tr></table></figure><h2 id="4-委托的注意事项"><a href="#4-委托的注意事项" class="headerlink" title="4.委托的注意事项"></a>4.委托的注意事项</h2><h3 id="4-1-类型安全"><a href="#4-1-类型安全" class="headerlink" title="4.1 类型安全"></a>4.1 类型安全</h3><p>委托是类型安全的，这意味着只有签名匹配的方法才能赋值给委托。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br>Console.WriteLine(<span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 8</span><br></code></pre></td></tr></table></figure><h3 id="4-2-匿名方法和-Lambda-表达式"><a href="#4-2-匿名方法和-Lambda-表达式" class="headerlink" title="4.2 匿名方法和 Lambda 表达式"></a>4.2 匿名方法和 Lambda 表达式</h3><p>你可以使用匿名方法或 Lambda 表达式来创建委托实例，简化代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br>Console.WriteLine(<span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 8</span><br></code></pre></td></tr></table></figure><h3 id="4-3-异步调用"><a href="#4-3-异步调用" class="headerlink" title="4.3 异步调用"></a>4.3 异步调用</h3><p>可以将委托与<code>BeginInvoke</code>和<code>EndInvoke</code>方法一起使用，进行异步调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method 1: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-keyword">new</span> MyDelegate(<span class="hljs-keyword">new</span> MyClass().MyMethod);<br><br>        <span class="hljs-comment">// 异步调用</span><br>        IAsyncResult result = del.BeginInvoke(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 继续执行其他操作</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Doing other work...&quot;</span>);<br><br>        <span class="hljs-comment">// 等待异步调用完成</span><br>        del.EndInvoke(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Doing other work...<br><span class="hljs-keyword">Method</span> 1: Hello, World!<br></code></pre></td></tr></table></figure><h2 id="5-委托的使用场景"><a href="#5-委托的使用场景" class="headerlink" title="5.委托的使用场景"></a>5.委托的使用场景</h2><h3 id="5-1-事件处理"><a href="#5-1-事件处理" class="headerlink" title="5.1 事件处理"></a>5.1 事件处理</h3><p>委托在事件处理中非常常见。事件通常使用委托来定义，事件处理程序则是委托的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Button</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个事件委托</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClickEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>;<br><br>    <span class="hljs-comment">// 定义一个事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> ClickEventHandler Click;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClick</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件</span><br>        Click?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Button button = <span class="hljs-keyword">new</span> Button();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 注册事件处理程序</span><br>        button.Click += Button_Click;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Form form = <span class="hljs-keyword">new</span> Form();<br>        form.button.OnClick(); <span class="hljs-comment">// 模拟按钮点击</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Button</span> clicked!<br></code></pre></td></tr></table></figure><h3 id="5-2-回调函数"><a href="#5-2-回调函数" class="headerlink" title="5.2 回调函数"></a>5.2 回调函数</h3><p>委托可以用于实现回调函数，允许一个方法在执行完成后调用另一个方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> result</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Compute</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, CallbackDelegate callback</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> result = a + b;<br>        callback(result);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        CallbackDelegate callback = (result) =&gt; Console.WriteLine(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br><br>        Calculator calculator = <span class="hljs-keyword">new</span> Calculator();<br>        calculator.Compute(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, callback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#索引器(Indexer)</title>
    <link href="/posts/54367/"/>
    <url>/posts/54367/</url>
    
    <content type="html"><![CDATA[<h1 id="C-索引器（Indexer）"><a href="#C-索引器（Indexer）" class="headerlink" title="C#索引器（Indexer）"></a>C#索引器（Indexer）</h1><p>在 C#中，索引器（Indexer）是一种特殊的属性，允许类的实例像数组一样通过索引访问。索引器使得可以定义类似于数组的访问方式，但是访问的对象可以是类的实例，而不仅限于数组。本文将详细介绍 C#索引器的各个方面，包括基本概念、语法、示例、进阶用法、注意事项和使用场景等。</p><h2 id="1-索引器的基本概念"><a href="#1-索引器的基本概念" class="headerlink" title="1.索引器的基本概念"></a>1.索引器的基本概念</h2><p>索引器允许通过类实例的索引来访问该类的实例成员。它的声明类似于属性，但具有参数。通常情况下，索引器用于允许类的实例像数组一样通过索引进行访问。</p><h2 id="2-索引器的语法"><a href="#2-索引器的语法" class="headerlink" title="2.索引器的语法"></a>2.索引器的语法</h2><p>索引器的语法如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">// 声明一个索引器</span><br>    <span class="hljs-keyword">public</span> returnType <span class="hljs-keyword">this</span>[indexType index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-comment">// 返回索引位置的值</span><br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-comment">// 设置索引位置的值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>• <code>returnType</code>：</strong>索引器返回的数据类型，可以是任意有效的 C#数据类型。</p><p><strong>• <code>indexType</code>：</strong>索引的参数类型，可以是整数、字符串或其他合法类型。</p><p><strong>• <code>get</code>：</strong>获取索引位置的值的访问器。</p><p><strong>• <code>set</code>：</strong>设置索引位置的值的访问器。</p><h2 id="3-索引器示例"><a href="#3-索引器示例" class="headerlink" title="3.索引器示例"></a>3.索引器示例</h2><h3 id="3-1-定义一个简单的索引器"><a href="#3-1-定义一个简单的索引器" class="headerlink" title="3.1 定义一个简单的索引器"></a>3.1 定义一个简单的索引器</h3><p>首先，我们定义一个名为<code>MyCollection</code>的类，包含一个私有的数组和一个索引器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; items.Length)<br>            &#123;<br>                <span class="hljs-keyword">return</span> items[index];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;index&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; items.Length)<br>            &#123;<br>                items[index] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;index&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-使用索引器"><a href="#3-2-使用索引器" class="headerlink" title="3.2 使用索引器"></a>3.2 使用索引器</h3><p>接下来，我们创建<code>MyCollection</code>类的实例，并通过索引器访问和修改内部数组元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyCollection collection = <span class="hljs-keyword">new</span> MyCollection();<br>        <span class="hljs-comment">// 通过索引器设置元素值</span><br>        collection[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        collection[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        collection[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 通过索引器获取元素值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            Console.WriteLine(collection[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，输出结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br></code></pre></td></tr></table></figure><h2 id="4-索引器进阶"><a href="#4-索引器进阶" class="headerlink" title="4.索引器进阶"></a>4.索引器进阶</h2><h3 id="4-1-多维索引器"><a href="#4-1-多维索引器" class="headerlink" title="4.1 多维索引器"></a>4.1 多维索引器</h3><p>C#索引器可以支持多维索引，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[,] items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> row, <span class="hljs-built_in">int</span> col]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; <span class="hljs-number">3</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; <span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> items[row, col];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;row or col&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; <span class="hljs-number">3</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; <span class="hljs-number">3</span>)<br>            &#123;<br>                items[row, col] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;row or col&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-索引器重载"><a href="#4-2-索引器重载" class="headerlink" title="4.2 索引器重载"></a>4.2 索引器重载</h3><p>C#允许对索引器进行重载，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] strings = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; items.Length)<br>            &#123;<br>                <span class="hljs-keyword">return</span> items[index];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;index&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; items.Length)<br>            &#123;<br>                items[index] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;index&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">string</span> key]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; key.Length &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> strings[Array.IndexOf(strings, key)];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Key cannot be null or empty.&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; key.Length &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                strings[Array.IndexOf(strings, key)] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Key cannot be null or empty.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-索引器的注意事项"><a href="#5-索引器的注意事项" class="headerlink" title="5.索引器的注意事项"></a>5.索引器的注意事项</h2><p>• 索引器的参数可以是值类型或引用类型。</p><p>• 可以根据需要只声明<code>get</code>或<code>set</code>访问器，但至少必须实现其中一个。</p><h2 id="6-索引器的使用场景"><a href="#6-索引器的使用场景" class="headerlink" title="6.索引器的使用场景"></a>6.索引器的使用场景</h2><h3 id="6-1-自定义集合类"><a href="#6-1-自定义集合类" class="headerlink" title="6.1 自定义集合类"></a>6.1 自定义集合类</h3><p>当你需要创建一个自定义集合类（如自定义字典或列表）时，索引器允许你通过索引来访问集合中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDictionary</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] keys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">string</span> key]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> index = Array.IndexOf(keys, key);<br>            <span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> values[index];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeyNotFoundException(<span class="hljs-string">$&quot;Key &#x27;<span class="hljs-subst">&#123;key&#125;</span>&#x27; not found.&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> index = Array.IndexOf(keys, key);<br>            <span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)<br>            &#123;<br>                values[index] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeyNotFoundException(<span class="hljs-string">$&quot;Key &#x27;<span class="hljs-subst">&#123;key&#125;</span>&#x27; not found.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-字符串索引访问"><a href="#6-2-字符串索引访问" class="headerlink" title="6.2 字符串索引访问"></a>6.2 字符串索引访问</h3><p>在某些情况下，你可能需要创建一个类，其内部存储了字符串或其他类型的数据，并希望通过字符串键来访问这些数据。索引器在这种情况下非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DayCollection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] days = &#123; <span class="hljs-string">&quot;Sun&quot;</span>, <span class="hljs-string">&quot;Mon&quot;</span>, <span class="hljs-string">&quot;Tues&quot;</span>, <span class="hljs-string">&quot;Wed&quot;</span>, <span class="hljs-string">&quot;Thurs&quot;</span>, <span class="hljs-string">&quot;Fri&quot;</span>, <span class="hljs-string">&quot;Sat&quot;</span> &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">string</span> day]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; days.Length; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (days[i] == day)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-keyword">nameof</span>(day), <span class="hljs-string">$&quot;Day &#x27;<span class="hljs-subst">&#123;day&#125;</span>&#x27; is not supported. Day input must be in the form &#x27;Sun&#x27;, &#x27;Mon&#x27;, etc.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-复杂数据结构"><a href="#6-3-复杂数据结构" class="headerlink" title="6.3 复杂数据结构"></a>6.3 复杂数据结构</h3><p>对于更复杂的数据结构（如矩阵、稀疏矩阵、树等），索引器可以提供一种直观的方式来访问和修改数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[,] items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> row, <span class="hljs-built_in">int</span> col]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; <span class="hljs-number">3</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; <span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> items[row, col];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;row or col&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; <span class="hljs-number">3</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; <span class="hljs-number">3</span>)<br>            &#123;<br>                items[row, col] = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-string">&quot;row or col&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>索引器是 C#中一个强大且灵活的特性，允许类的实例像数组一样通过索引来访问。它提供了一种简洁、直观的方式来管理类的实例数据，特别适用于需要按照索引方式进行访问和修改的场景。通过本文的介绍和示例，希望读者能够理解并掌握 C#中索引器的使用方法和基本原理，从而能够在实际项目中灵活运用。</p><p>如果你有任何问题或建议，欢迎在评论区留言。希望本文对你有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#属性(Property)</title>
    <link href="/posts/39070/"/>
    <url>/posts/39070/</url>
    
    <content type="html"><![CDATA[<h1 id="C-属性（Property）详解"><a href="#C-属性（Property）详解" class="headerlink" title="C#属性（Property）详解"></a>C#属性（Property）详解</h1><p>在 C#中，属性（Property）是一种成员，它提供了一种灵活的机制来读取、写入或计算私有成员变量的值。属性可以让你将数据封装在类中，同时提供对数据的受控访问。本文将详细介绍 C#属性的各个方面，包括基本概念、语法、不同类型、访问修饰符、索引器、自动实现的属性、表达式体定义、属性与字段的区别、属性的继承和多态、以及属性的使用场景等。</p><h2 id="1-属性的基本概念"><a href="#1-属性的基本概念" class="headerlink" title="1.属性的基本概念"></a>1.属性的基本概念</h2><p>属性是类或结构的成员，用于表示对象的状态。它提供了一种方法来访问私有成员变量，同时可以添加额外的逻辑来验证数据的合法性、触发事件或执行其他操作。属性通常用于封装字段，提供对字段的受控访问。</p><h2 id="2-属性的语法"><a href="#2-属性的语法" class="headerlink" title="2.属性的语法"></a>2.属性的语法</h2><p>属性的语法通常包括一个<code>get</code>访问器和一个<code>set</code>访问器。<code>get</code>访问器用于返回属性的值，<code>set</code>访问器用于设置属性的值。</p><h3 id="2-1-基本属性"><a href="#2-1-基本属性" class="headerlink" title="2.1 基本属性"></a>2.1 基本属性</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name; <span class="hljs-comment">// 私有字段</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name <span class="hljs-comment">// 属性</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125; <span class="hljs-comment">// 获取属性值</span><br>        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 设置属性值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Name</code>属性封装了<code>name</code>字段，提供了对<code>name</code>字段的受控访问。</p><h3 id="2-2-只读和只写属性"><a href="#2-2-只读和只写属性" class="headerlink" title="2.2 只读和只写属性"></a>2.2 只读和只写属性</h3><p>• 只读属性：只有<code>get</code>访问器，没有<code>set</code>访问器。</p><p>• 只写属性：只有<code>set</code>访问器，没有<code>get</code>访问器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125; <span class="hljs-comment">// 只读属性</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 只写属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-自动实现的属性"><a href="#2-3-自动实现的属性" class="headerlink" title="2.3 自动实现的属性"></a>2.3 自动实现的属性</h3><p>自动实现的属性是一种简化的属性语法，编译器会自动创建一个私有备份字段来存储属性的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">// 自动实现的属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">// 自动实现的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自动实现的属性在不需要在<code>get</code>或<code>set</code>访问器中添加额外逻辑时非常方便。</p><h3 id="2-4-表达式体定义"><a href="#2-4-表达式体定义" class="headerlink" title="2.4 表达式体定义"></a>2.4 表达式体定义</h3><p>表达式体定义是一种更简洁的属性语法，适用于简单的<code>get</code>和<code>set</code>访问器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-comment">// 表达式体定义</span><br>        <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 表达式体定义</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-属性的访问修饰符"><a href="#3-属性的访问修饰符" class="headerlink" title="3.属性的访问修饰符"></a>3.属性的访问修饰符</h2><p>属性可以使用不同的访问修饰符来控制其访问权限，如<code>public</code>、<code>protected</code>、<code>internal</code>和<code>private</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name <span class="hljs-comment">// 公有属性</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 私有设置器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Name</code>属性的<code>get</code>访问器是公有的，而<code>set</code>访问器是私有的，这意味着外部代码可以读取<code>Name</code>属性的值，但不能直接设置它。</p><h2 id="4-索引器"><a href="#4-索引器" class="headerlink" title="4.索引器"></a>4.索引器</h2><p>索引器允许类或结构的实例像数组一样进行索引。索引器使用<code>this</code>关键字定义，并可以有多个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Collection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] <span class="hljs-comment">// 索引器</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> items[index]; &#125;<br>        <span class="hljs-keyword">set</span> &#123; items[index] = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用索引器的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Collection collection = <span class="hljs-keyword">new</span> Collection();<br>collection[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Item1&quot;</span>;<br><span class="hljs-built_in">string</span> item = collection[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><h2 id="5-属性与字段的区别"><a href="#5-属性与字段的区别" class="headerlink" title="5.属性与字段的区别"></a>5.属性与字段的区别</h2><p>• 字段：直接存储数据的变量，可以是公有的或私有的。</p><p>• 属性：提供对字段的受控访问，可以添加额外的逻辑，如数据验证、触发事件等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> NameField; <span class="hljs-comment">// 字段</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> NameProperty <span class="hljs-comment">// 属性</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">value</span>.Length &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Name cannot be null or empty.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>NameField</code>是一个公有字段，直接暴露给外部代码，而<code>NameProperty</code>是一个属性，提供了对<code>name</code>字段的受控访问，并添加了数据验证逻辑。</p><h2 id="6-属性的继承和多态"><a href="#6-属性的继承和多态" class="headerlink" title="6.属性的继承和多态"></a>6.属性的继承和多态</h2><p>属性可以被继承，子类可以重写父类的属性。通过使用<code>virtual</code>、<code>override</code>和<code>new</code>关键字，可以实现属性的多态。</p><h3 id="6-1-虚拟属性"><a href="#6-1-虚拟属性" class="headerlink" title="6.1 虚拟属性"></a>6.1 虚拟属性</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Animal</code>类中的<code>Name</code>属性被标记为<code>virtual</code>，<code>Dog</code>类重写了<code>Name</code>属性。</p><h3 id="6-2-新属性"><a href="#6-2-新属性" class="headerlink" title="6.2 新属性"></a>6.2 新属性</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Dog</code>类使用<code>new</code>关键字隐藏了<code>Animal</code>类中的<code>Name</code>属性。</p><h2 id="7-属性的使用场景"><a href="#7-属性的使用场景" class="headerlink" title="7.属性的使用场景"></a>7.属性的使用场景</h2><h3 id="7-1-数据封装"><a href="#7-1-数据封装" class="headerlink" title="7.1 数据封装"></a>7.1 数据封装</h3><p>属性用于封装类的内部数据，提供对数据的受控访问，确保数据的完整性和安全性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">value</span>.Length &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Name cannot be null or empty.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-触发事件"><a href="#7-2-触发事件" class="headerlink" title="7.2 触发事件"></a>7.2 触发事件</h3><p>属性可以在设置值时触发事件，通知其他部分的代码数据已更改。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler NameChanged;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">value</span>)<br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>                NameChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-与数据绑定"><a href="#7-3-与数据绑定" class="headerlink" title="7.3 与数据绑定"></a>7.3 与数据绑定</h3><p>属性常用于数据绑定，特别是在 UI 开发中，属性可以与控件绑定，实现数据的自动更新。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">INotifyPropertyChanged</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">value</span>)<br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>                OnPropertyChanged(<span class="hljs-keyword">nameof</span>(Name));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPropertyChanged</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> propertyName</span>)</span><br>    &#123;<br>        PropertyChanged?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> PropertyChangedEventArgs(propertyName));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>属性是 C#中非常重要的一个概念，它提供了一种灵活的机制来封装类的内部数据，同时提供对数据的受控访问。通过使用属性，可以添加额外的逻辑，如数据验证、触发事件等，确保数据的完整性和安全性。属性的继承和多态特性使得属性在面向对象编程中更加灵活和强大。在实际开发中，合理使用属性可以提高代码的可维护性和可扩展性。</p><p>希望本文对你理解 C#属性有所帮助。如果有任何问题或建议，欢迎在评论区留言。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#反射(Reflection)</title>
    <link href="/posts/7558/"/>
    <url>/posts/7558/</url>
    
    <content type="html"><![CDATA[<h1 id="C-反射：深入解析与应用实践"><a href="#C-反射：深入解析与应用实践" class="headerlink" title="C#反射：深入解析与应用实践"></a>C#反射：深入解析与应用实践</h1><p>在 C#编程中，反射（Reflection）是一项强大而灵活的技术，它允许程序在运行时检查和操作类型信息。本文将详细介绍 C#反射的基本概念、核心功能、使用方法以及实际应用场景，帮助开发者更好地理解和运用这一技术。</p><h2 id="一、反射概述"><a href="#一、反射概述" class="headerlink" title="一、反射概述"></a>一、反射概述</h2><p>反射是.NET 框架中一个重要的特性，它使得程序能够在运行时获取类型信息、创建对象、调用方法、访问属性等。通过反射，程序可以突破编译时的类型限制，实现动态类型检查和操作。</p><h3 id="（一）反射的用途"><a href="#（一）反射的用途" class="headerlink" title="（一）反射的用途"></a>（一）反射的用途</h3><p>• 动态类型检查：在运行时检查对象的类型，确定其是否具有特定的属性或方法。</p><p>• 动态创建对象：根据类型名称在运行时创建对象实例。</p><p>• 动态调用方法：调用对象的方法，无需在编译时知道方法的具体名称和参数。</p><p>• 访问私有成员：访问类的私有成员，这在某些特殊场景下非常有用，比如单元测试。</p><p>• 插件架构：实现插件式架构，程序可以在运行时加载和使用外部插件。</p><h3 id="（二）反射的基本概念"><a href="#（二）反射的基本概念" class="headerlink" title="（二）反射的基本概念"></a>（二）反射的基本概念</h3><p>在 C#中，反射主要涉及以下几个核心类：</p><p>• System.Type：表示类型的信息，是反射的核心。每个类型在运行时都有一个对应的 Type 对象。</p><p>• System.Reflection.Assembly：表示程序集，程序集是.NET 程序的编译单元，包含类型定义和资源。</p><p>• System.Reflection.Module：表示模块，模块是程序集的一部分，包含类型和资源。</p><p>• System.Reflection.MemberInfo：表示成员信息，如类的字段、属性、方法等。</p><h2 id="二、获取-Type-对象"><a href="#二、获取-Type-对象" class="headerlink" title="二、获取 Type 对象"></a>二、获取 Type 对象</h2><p>要使用反射，首先需要获取 Type 对象。有多种方式可以获取 Type 对象：</p><h3 id="（一）通过-typeof-运算符"><a href="#（一）通过-typeof-运算符" class="headerlink" title="（一）通过 typeof 运算符"></a>（一）通过 typeof 运算符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>);<br></code></pre></td></tr></table></figure><p>这种方式适用于已知类型的场景，直接通过类型名称获取 Type 对象。</p><h3 id="（二）通过对象的-GetType-方法"><a href="#（二）通过对象的-GetType-方法" class="headerlink" title="（二）通过对象的 GetType 方法"></a>（二）通过对象的 GetType 方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>Type type = str.GetType();<br></code></pre></td></tr></table></figure><p>这种方式通过对象实例获取其 Type 对象，适用于运行时不确定类型的场景。</p><h2 id="三、反射的核心功能"><a href="#三、反射的核心功能" class="headerlink" title="三、反射的核心功能"></a>三、反射的核心功能</h2><h3 id="（一）获取类型信息"><a href="#（一）获取类型信息" class="headerlink" title="（一）获取类型信息"></a>（一）获取类型信息</h3><p>通过 Type 对象，可以获取类型的各种信息，如类型名称、基类、接口、字段、属性、方法等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><br><span class="hljs-comment">// 获取类型名称</span><br><span class="hljs-built_in">string</span> typeName = type.Name;<br><br><span class="hljs-comment">// 获取基类</span><br>Type baseType = type.BaseType;<br><br><span class="hljs-comment">// 获取接口</span><br>Type[] interfaces = type.GetInterfaces();<br><br><span class="hljs-comment">// 获取字段</span><br>FieldInfo[] fields = type.GetFields();<br><br><span class="hljs-comment">// 获取属性</span><br>PropertyInfo[] properties = type.GetProperties();<br><br><span class="hljs-comment">// 获取方法</span><br>MethodInfo[] methods = type.GetMethods();<br></code></pre></td></tr></table></figure><h3 id="（二）创建对象"><a href="#（二）创建对象" class="headerlink" title="（二）创建对象"></a>（二）创建对象</h3><p>可以使用 Type 对象的<code>Activator.CreateInstance</code>方法动态创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type);<br></code></pre></td></tr></table></figure><p>如果类型有参数化的构造函数，可以传递参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type, param1, param2);<br></code></pre></td></tr></table></figure><h3 id="（三）调用方法"><a href="#（三）调用方法" class="headerlink" title="（三）调用方法"></a>（三）调用方法</h3><p>通过 MethodInfo 对象可以调用对象的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type);<br><br>MethodInfo method = type.GetMethod(<span class="hljs-string">&quot;MyMethod&quot;</span>);<br>method.Invoke(obj, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; param1, param2 &#125;);<br></code></pre></td></tr></table></figure><h3 id="（四）访问属性"><a href="#（四）访问属性" class="headerlink" title="（四）访问属性"></a>（四）访问属性</h3><p>通过 PropertyInfo 对象可以访问对象的属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type);<br><br>PropertyInfo property = type.GetProperty(<span class="hljs-string">&quot;MyProperty&quot;</span>);<br><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span> = property.GetValue(obj);<br><br>property.SetValue(obj, newValue);<br></code></pre></td></tr></table></figure><h3 id="（五）访问字段"><a href="#（五）访问字段" class="headerlink" title="（五）访问字段"></a>（五）访问字段</h3><p>通过 FieldInfo 对象可以访问对象的字段。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type);<br><br>FieldInfo field = type.GetField(<span class="hljs-string">&quot;myField&quot;</span>);<br><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span> = field.GetValue(obj);<br><br>field.SetValue(obj, newValue);<br></code></pre></td></tr></table></figure><h2 id="四、反射的性能注意事项"><a href="#四、反射的性能注意事项" class="headerlink" title="四、反射的性能注意事项"></a>四、反射的性能注意事项</h2><p>反射虽然功能强大，但性能开销相对较大。每次使用反射时，都需要进行类型信息的查找和解析，这比直接编译时的类型操作要慢得多。因此，在性能敏感的应用中，应谨慎使用反射。</p><h3 id="（一）缓存-Type-对象"><a href="#（一）缓存-Type-对象" class="headerlink" title="（一）缓存 Type 对象"></a>（一）缓存 Type 对象</h3><p>如果多次使用同一个类型的反射操作，可以缓存 Type 对象，避免重复获取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Dictionary&lt;Type, Type&gt; typeCache = <span class="hljs-keyword">new</span> Dictionary&lt;Type, Type&gt;();<br><br><span class="hljs-keyword">if</span> (!typeCache.TryGetValue(<span class="hljs-keyword">typeof</span>(MyClass), <span class="hljs-keyword">out</span> Type type))<br>&#123;<br>    type = <span class="hljs-keyword">typeof</span>(MyClass);<br>    typeCache[<span class="hljs-keyword">typeof</span>(MyClass)] = type;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（二）使用表达式树优化"><a href="#（二）使用表达式树优化" class="headerlink" title="（二）使用表达式树优化"></a>（二）使用表达式树优化</h3><p>在某些场景下，可以使用表达式树来优化反射调用，减少性能开销。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;MyClass, <span class="hljs-built_in">string</span>&gt; getPropertyFunc = (MyClass obj) =&gt; obj.MyProperty;<br><br><span class="hljs-comment">// 使用表达式树生成委托</span><br>Expression&lt;Func&lt;MyClass, <span class="hljs-built_in">string</span>&gt;&gt; expression = (MyClass obj) =&gt; obj.MyProperty;<br>Func&lt;MyClass, <span class="hljs-built_in">string</span>&gt; compiledFunc = expression.Compile();<br><br><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span> = compiledFunc(myClassInstance);<br></code></pre></td></tr></table></figure><h2 id="五、实际应用场景"><a href="#五、实际应用场景" class="headerlink" title="五、实际应用场景"></a>五、实际应用场景</h2><h3 id="（一）插件架构"><a href="#（一）插件架构" class="headerlink" title="（一）插件架构"></a>（一）插件架构</h3><p>反射可以用于实现插件式架构，程序可以在运行时加载和使用外部插件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Assembly pluginAssembly = Assembly.LoadFrom(<span class="hljs-string">&quot;Plugin.dll&quot;</span>);<br>Type pluginType = pluginAssembly.GetType(<span class="hljs-string">&quot;Plugin.MyPlugin&quot;</span>);<br><br><span class="hljs-built_in">object</span> pluginInstance = Activator.CreateInstance(pluginType);<br>MethodInfo method = pluginType.GetMethod(<span class="hljs-string">&quot;Execute&quot;</span>);<br>method.Invoke(pluginInstance, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; &#125;);<br></code></pre></td></tr></table></figure><h3 id="（二）序列化和反序列化"><a href="#（二）序列化和反序列化" class="headerlink" title="（二）序列化和反序列化"></a>（二）序列化和反序列化</h3><p>反射可以用于自定义序列化和反序列化，动态读取和设置对象的属性值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj, Stream stream</span>)</span><br>&#123;<br>    Type type = obj.GetType();<br>    <span class="hljs-keyword">foreach</span> (PropertyInfo property <span class="hljs-keyword">in</span> type.GetProperties())<br>    &#123;<br>        <span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span> = property.GetValue(obj);<br>        <span class="hljs-comment">// 将值写入流</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params">Type type, Stream stream</span>)</span><br>&#123;<br>    <span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type);<br>    <span class="hljs-keyword">foreach</span> (PropertyInfo property <span class="hljs-keyword">in</span> type.GetProperties())<br>    &#123;<br>        <span class="hljs-comment">// 从流中读取值</span><br>        property.SetValue(obj, <span class="hljs-keyword">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（三）单元测试"><a href="#（三）单元测试" class="headerlink" title="（三）单元测试"></a>（三）单元测试</h3><p>反射可以用于访问类的私有成员，方便进行单元测试。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type type = <span class="hljs-keyword">typeof</span>(MyClass);<br><span class="hljs-built_in">object</span> obj = Activator.CreateInstance(type, <span class="hljs-literal">true</span>);<br><br>FieldInfo field = type.GetField(<span class="hljs-string">&quot;myPrivateField&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span> = field.GetValue(obj);<br><br>MethodInfo method = type.GetMethod(<span class="hljs-string">&quot;MyPrivateMethod&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br>method.Invoke(obj, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; &#125;);<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>C#反射是一项非常强大的技术，它允许程序在运行时动态检查和操作类型信息。通过反射，可以实现动态类型检查、创建对象、调用方法、访问属性和字段等功能。虽然反射的性能开销较大，但在一些特殊场景下，如插件架构、序列化和反序列化、单元测试等，反射提供了极大的灵活性和便利性。开发者应根据具体需求合理使用反射，避免不必要的性能损耗。</p><p>希望本文对您理解和应用 C#反射有所帮助。如果您有任何疑问或建议，欢迎在评论区留言交流。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#特性（Attribute）</title>
    <link href="/posts/33129/"/>
    <url>/posts/33129/</url>
    
    <content type="html"><![CDATA[<h1 id="C-特性（Attribute）深入讲解"><a href="#C-特性（Attribute）深入讲解" class="headerlink" title="C#特性（Attribute）深入讲解"></a>C#特性（Attribute）深入讲解</h1><p>特性（Attribute）是 C#中一种非常强大的功能，它为程序提供了丰富的元数据，能够在编译和运行时向程序中各种元素（如类、方法、结构、枚举、组件等）注入行为或信息，从而提高代码的可维护性和可扩展性。本文将深入探讨 C#特性的相关知识，包括预定义特性、自定义特性的创建与应用，以及其他常见特性的使用场景等。</p><h2 id="特性（Attribute）概述"><a href="#特性（Attribute）概述" class="headerlink" title="特性（Attribute）概述"></a>特性（Attribute）概述</h2><p>特性是用于在运行时传递程序中各种元素行为信息的声明性标签。通过使用特性，我们可以向程序添加声明性信息，这些信息以方括号（[]）的形式放置在它所应用的元素前面。特性主要用于添加元数据，如编译器指令、注释、描述、方法、类等其他信息。在.NET 框架中，特性分为预定义特性和自定义特性两大类。</p><p>预定义特性</p><h3 id="1-1-AttributeUsage-特性"><a href="#1-1-AttributeUsage-特性" class="headerlink" title="1.1 AttributeUsage 特性"></a>1.1 AttributeUsage 特性</h3><p>作用：描述了如何使用一个自定义特性类，规定了特性可应用到的项目类型。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">AttributeUsage(validon, AllowMultiple = allowmultiple, Inherited = inherited)</span>]<br></code></pre></td></tr></table></figure><p><strong>• <code>validon</code>：</strong>指定特性可以应用于的元素类型，如<code>AttributeTargets.Class</code>表示可应用于类，<code>AttributeTargets.Method</code>表示可应用于方法等，还可以通过位运算符“|”组合多个值。</p><p><strong>• <code>AllowMultiple</code>：</strong>如果为<code>true</code>，则特性可以应用于多个元素。默认值是<code>false</code>。</p><p><strong>• <code>Inherited</code>：</strong>如果为<code>true</code>，则特性可以被派生类继承。默认值是<code>false</code>。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomAttribute</span> : <span class="hljs-title">Attribute</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCustomAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> description</span>)</span><br>    &#123;<br>        Description = description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>MyCustomAttribute</code>特性可以应用于类和方法，并且可以多次应用于同一个元素。</p><h3 id="1-2-Obsolete-特性"><a href="#1-2-Obsolete-特性" class="headerlink" title="1.2 Obsolete 特性"></a>1.2 Obsolete 特性</h3><p>作用：标记一个不推荐使用的元素，编译器会生成警告或错误，提示开发者该元素已过时。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;Message&quot;</span>, true/false)</span>]<br></code></pre></td></tr></table></figure><p><strong>• <code>Message</code>：</strong>显示给开发者的提示信息，用于说明为什么该元素不推荐使用，以及推荐使用的替代元素等。</p><p><strong>• <code>isError</code>：</strong>如果为<code>true</code>，编译器会将其视为错误；默认值为<code>false</code>，则为警告。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    [<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;Use NewMethod instead&quot;</span>, true)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is the old method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NewMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is the new method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        OldMethod(); <span class="hljs-comment">// 编译时会报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">编译时错误：<span class="hljs-string">&#x27;OldMethod&#x27;</span> <span class="hljs-keyword">is</span> obsolete: <span class="hljs-string">&#x27;Use NewMethod instead&#x27;</span><br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 提醒开发者避免使用过时的 API 或方法，强制迁移到新的 API。</p><p>• 用于 API 版本控制时标记不推荐使用的功能。</p><h3 id="1-3-Serializable-特性"><a href="#1-3-Serializable-特性" class="headerlink" title="1.3 Serializable 特性"></a>1.3 Serializable 特性</h3><p>作用：标记一个类可以被序列化。序列化是将对象转换为可存储或传输的格式，以便可以将其保存到文件、数据库或通过网络传输等。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 用于对象持久化，将对象的状态保存到文件或数据库中，以便后续可以恢复对象的状态。</p><p>• 用于网络传输，将对象转换为字节流后通过网络发送到其他系统或应用程序。</p><p>• 用于缓存系统，能够将对象序列化并存储在磁盘中，提高系统的性能。</p><h3 id="1-4-STAThread-特性"><a href="#1-4-STAThread-特性" class="headerlink" title="1.4 STAThread 特性"></a>1.4 STAThread 特性</h3><p>作用：标记线程为单线程单元（STA）。该特性常用于 Windows 窗体应用程序，它确保线程遵循单线程模式，避免多线程操作时产生的线程同步问题。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">STAThread</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Single Threaded Apartment (STA) model&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 用于 Windows Forms 和 WPF 应用程序中的主线程，确保应用程序的 UI 组件在单线程环境下正常工作。</p><p>• 用于确保与 COM 组件交互时遵循 STA 模型，因为许多 COM 组件要求在 STA 环境下运行。</p><h3 id="1-5-Conditional-特性"><a href="#1-5-Conditional-特性" class="headerlink" title="1.5 Conditional 特性"></a>1.5 Conditional 特性</h3><p>作用：标记一个方法为条件编译的方法，只有在指定的预处理器符号存在时才会调用该方法。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;CONDITION&quot;</span>)</span>]<br></code></pre></td></tr></table></figure><p>• <code>CONDITION</code>：指定的预处理器符号，如果该符号在编译时被定义，则会调用该方法；否则，该方法调用将被忽略。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Diagnostics;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DebugMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span><br>    &#123;<br>        Console.WriteLine(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass.DebugMessage(<span class="hljs-string">&quot;This will print only in DEBUG mode.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">This will <span class="hljs-built_in">print</span> only <span class="hljs-keyword">in</span> <span class="hljs-built_in">DEBUG</span> mode.<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 在调试阶段记录详细日志，通过定义不同的预处理器符号来控制日志的输出，方便开发者进行调试和问题排查。</p><p>• 控制日志输出的条件编译，根据不同的编译配置输出不同级别的日志信息。</p><h3 id="1-6-DllImport-特性"><a href="#1-6-DllImport-特性" class="headerlink" title="1.6 DllImport 特性"></a>1.6 DllImport 特性</h3><p>作用：用于调用外部 DLL 中的函数。它将 C#方法与外部库中的函数关联，从而使得 C#可以调用该函数，实现与非托管代码（如 C 或 C++）的交互。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Auto)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MessageBox</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> caption, <span class="hljs-built_in">uint</span> type</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MessageBox(IntPtr.Zero, <span class="hljs-string">&quot;Hello from external DLL!&quot;</span>, <span class="hljs-string">&quot;External DLL Call&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：调用<code>MessageBox</code>函数时会弹出 Windows 的消息框。</p><p>应用场景：</p><p>• 用于与非托管代码（如 C 或 C++）进行交互，调用非托管库中提供的功能，如系统级别的 API 或第三方库提供的函数。</p><p>• 用于实现一些在.NET 框架中没有直接提供，但可以通过调用外部 DLL 来实现的功能，如特定的硬件操作、复杂的数学计算等。</p><h3 id="1-7-NonSerialized-特性"><a href="#1-7-NonSerialized-特性" class="headerlink" title="1.7 NonSerialized 特性"></a>1.7 NonSerialized 特性</h3><p>作用：标记某个字段不应该被序列化。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;<br>    [<span class="hljs-meta">NonSerialized</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 用于标记某些敏感信息或不需要持久化的字段，避免在序列化过程中被包含进去，从而保护数据的安全性和减少不必要的序列化开销。</p><h3 id="1-8-ComVisible-特性"><a href="#1-8-ComVisible-特性" class="headerlink" title="1.8 ComVisible 特性"></a>1.8 ComVisible 特性</h3><p>作用：控制程序集中的类型是否可以被 COM 组件可见。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">ComVisible(true/false)</span>]<br></code></pre></td></tr></table></figure><p><strong>• <code>true</code>：</strong>类型可以被 COM 组件可见。</p><p><strong>• <code>false</code>：</strong>类型对 COM 组件不可见。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br>[<span class="hljs-meta">ComVisible(true)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This method is visible to COM components.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 用于在.NET 与 COM 之间进行互操作，将.NET 类型暴露给 COM 组件，以便可以在 COM 环境中使用这些类型。</p><p>• 用于控制哪些类型可以被 COM 组件使用，哪些类型隐藏起来，避免不必要的类型暴露，提高系统的安全性和稳定性。</p><h3 id="1-9-WebMethod-特性"><a href="#1-9-WebMethod-特性" class="headerlink" title="1.9 WebMethod 特性"></a>1.9 WebMethod 特性</h3><p>作用：标记一个方法为 Web 服务方法，使其可以通过 HTTP 协议被远程调用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Web.Services;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyWebService</span> : <span class="hljs-title">WebService</span><br>&#123;<br>    [<span class="hljs-meta">WebMethod</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">HelloWorld</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>• 用于创建 Web 服务，将方法暴露为 Web 服务操作，客户端可以通过 HTTP 请求调用这些方法，实现分布式系统的远程调用。</p><p>• 用于构建基于 SOAP 协议的 Web 服务，提供跨平台、跨语言的互操作性。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 类与面向对象编程</title>
    <link href="/posts/61982/"/>
    <url>/posts/61982/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类与面向对象编程"><a href="#C-类与面向对象编程" class="headerlink" title="C# 类与面向对象编程"></a>C# 类与面向对象编程</h1><p>C# 是一门强大的面向对象编程语言，其核心理念是通过类和对象来组织和抽象程序代码。在本文中，我们将深入探讨 C# 类的相关概念，包括继承、多态、接口、虚函数、析构函数、构造函数、抽象类、命名空间，以及虚表与虚指针的实现机制。这些特性是 C# 面向对象编程的基石，也是理解 C# 程序设计的核心。</p><hr><h2 id="类与对象的基本概念"><a href="#类与对象的基本概念" class="headerlink" title="类与对象的基本概念"></a><strong>类与对象的基本概念</strong></h2><p>在 C# 中，类（<code>class</code>）是面向对象编程的核心单位，定义了一种数据结构，可以包含字段（<code>field</code>）、属性（<code>property</code>）、方法（<code>method</code>）和事件（<code>event</code>）等成员。</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello, my name is <span class="hljs-subst">&#123;Name&#125;</span> and I am <span class="hljs-subst">&#123;Age&#125;</span> years old.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><strong>对象的创建</strong></h3><p>通过类创建对象：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Person person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>person.Age = <span class="hljs-number">25</span>;<br>person.SayHello(); <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 25 years old.</span><br></code></pre></td></tr></table></figure><hr><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a><strong>构造函数与析构函数</strong></h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>构造函数用于在创建对象时初始化对象的状态。构造函数的名称与类名相同，并且无需返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用构造函数</span><br>Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>Console.WriteLine(person.Name); <span class="hljs-comment">// 输出：Alice</span><br></code></pre></td></tr></table></figure><p>构造函数可以被重载：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>() <span class="hljs-comment">// 无参数构造函数</span></span><br>&#123;<br>    Name = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>    Age = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a><strong>析构函数</strong></h3><p>析构函数用于清理对象使用的资源，在垃圾回收（GC）回收对象时自动调用。析构函数的语法是 <code>~类名</code>，且不能重载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ResourceHandler</span><br>&#123;<br>    ~ResourceHandler()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Object is being finalized.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>C# 的垃圾回收机制自动管理内存，通常无需显式使用析构函数。</li><li>若需释放非托管资源，应实现 <code>IDisposable</code> 接口。</li></ul><hr><h2 id="继承与多态性"><a href="#继承与多态性" class="headerlink" title="继承与多态性"></a><strong>继承与多态性</strong></h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>继承（<code>Inheritance</code>）是面向对象编程的核心特性之一，允许一个类从另一个类继承属性和方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Method implementation</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnotherMethod</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Accessing base class method</span><br>        <span class="hljs-keyword">base</span>.SomeMethod();<br>        <br>        <span class="hljs-comment">// Method implementation</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C# 支持单继承，不支持多继承，但可以通过接口弥补多继承的不足。</strong></p><p><strong>派生类会继承基类的成员（字段、方法、属性等），除非它们被明确地标记为私有（private）。</strong></p><p><strong>派生类可以通过关键字base来调用基类的构造函数和方法。</strong></p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a><strong>多态性</strong></h3><p>多态性允许对象表现出多种形式，主要通过方法重载和方法重写实现。</p><h4 id="方法重载（编译时多态性）"><a href="#方法重载（编译时多态性）" class="headerlink" title="方法重载（编译时多态性）"></a><strong>方法重载（编译时多态性）</strong></h4><p>方法重载是同一类中定义多个方法，名称相同但参数不同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> =&gt; a + b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)</span> =&gt; a + b;<br>&#125;<br><br>Calculator calc = <span class="hljs-keyword">new</span> Calculator();<br>Console.WriteLine(calc.Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出：3</span><br>Console.WriteLine(calc.Add(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>)); <span class="hljs-comment">// 输出：4.0</span><br></code></pre></td></tr></table></figure><h4 id="虚方法（运行时多态性）"><a href="#虚方法（运行时多态性）" class="headerlink" title="虚方法（运行时多态性）"></a><strong>虚方法（运行时多态性）</strong></h4><p>通过在基类方法上添加 <code>virtual</code> 修饰符，允许子类重写该方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Some generic animal sound.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br><br>Animal animal = <span class="hljs-keyword">new</span> Dog();<br>animal.MakeSound(); <span class="hljs-comment">// 输出：Woof!</span><br></code></pre></td></tr></table></figure><ul><li><p><strong><code>virtual</code>：声明基类方法可被重写。</strong></p></li><li><p><strong><code>override</code>：重写基类方法。</strong></p><p>虚方法通过虚表来实现动态绑定，c#中每个含有虚方法的类都会有一个虚表。该类创建的实例对象会包含一个虚指针，他会指向对应的虚表。然后去通过虚表调用实际对象对应的方法。而不是赋值类型对应的类里的方法。</p></li></ul><hr><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a><strong>接口与抽象类</strong></h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h3><p>接口定义了类必须实现的成员，是行为的契约。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFlyable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-title">IFlyable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Bird is flying.&quot;</span>);<br>    &#125;<br>&#125;<br><br>IFlyable bird = <span class="hljs-keyword">new</span> Bird();<br>bird.Fly(); <span class="hljs-comment">// 输出：Bird is flying.</span><br></code></pre></td></tr></table></figure><p>接口的特性：</p><ul><li>可以多继承。</li><li>只能包含方法签名（C# 8 起支持默认实现）。</li><li>提供行为约束。</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><p>抽象类是不能直接实例化的类，必须通过派生类实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span>; <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br>&#125;<br><br>Shape circle = <span class="hljs-keyword">new</span> Circle &#123; Radius = <span class="hljs-number">5</span> &#125;;<br>Console.WriteLine(circle.GetArea()); <span class="hljs-comment">// 输出圆的面积</span><br></code></pre></td></tr></table></figure><p>抽象类的特点：</p><ul><li>可包含抽象方法和非抽象方法。</li><li>提供部分实现，派生类需补充完整。</li></ul><hr><h2 id="虚表与虚指针"><a href="#虚表与虚指针" class="headerlink" title="虚表与虚指针"></a><strong>虚表与虚指针</strong></h2><h3 id="虚表的原理"><a href="#虚表的原理" class="headerlink" title="虚表的原理"></a><strong>虚表的原理</strong></h3><p>虚表（VTable）是一种动态调度机制，用于实现多态。每个包含虚方法的类都会生成一张虚表，记录方法的实际实现。</p><ol><li><strong>虚表结构</strong>：<ul><li>虚表存储在内存中，是一个指针数组，每个指针指向实际方法的入口地址。</li><li>如果子类重写了父类的虚方法，虚表会更新为子类的实现。</li></ul></li><li><strong>虚表的意义</strong>：<ul><li>实现运行时多态。</li><li>支持动态方法分派。</li></ul></li></ol><h3 id="虚指针的作用"><a href="#虚指针的作用" class="headerlink" title="虚指针的作用"></a><strong>虚指针的作用</strong></h3><p>虚指针（VPTR）是每个对象中隐含的指针，指向类的虚表。</p><ul><li>每个对象都有一个虚指针，指向所属类的虚表。</li><li>调用虚方法时，C# 编译器会通过虚指针查询虚表，从而找到方法的实际实现。</li></ul><h3 id="虚表的运行示例"><a href="#虚表的运行示例" class="headerlink" title="虚表的运行示例"></a><strong>虚表的运行示例</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base Print&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived Print&quot;</span>);<br>    &#125;<br>&#125;<br><br>Base obj = <span class="hljs-keyword">new</span> Derived();<br>obj.Print(); <span class="hljs-comment">// 输出：Derived Print</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>编译时 <code>obj</code> 的类型是 <code>Base</code>，但运行时通过虚表确定实际调用 <code>Derived.Print</code>。</li><li>虚表和虚指针机制使得运行时能够正确分派方法调用。</li></ul><hr><h2 id="为什么需要这些设计？"><a href="#为什么需要这些设计？" class="headerlink" title="为什么需要这些设计？"></a><strong>为什么需要这些设计？</strong></h2><ol><li><strong>多态性</strong>：通过虚表和虚指针实现运行时多态，提高代码的灵活性和可扩展性。</li><li><strong>抽象与接口</strong>：解耦代码逻辑，实现模块化设计。</li><li><strong>析构函数</strong>：帮助开发者释放非托管资源。</li><li><strong>继承与重用</strong>：通过继承复用代码，减少重复。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>C# 的类和对象模型通过继承、多态、接口和虚表等特性，实现了强大的面向对象编程能力。这些设计不仅增强了代码的灵活性，还为复杂项目提供了良好的扩展性。理解这些原理能够帮助开发者编写更高效、健壮的代码。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#中new关键字的用法</title>
    <link href="/posts/2252/"/>
    <url>/posts/2252/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中new关键字的用法"><a href="#C-中new关键字的用法" class="headerlink" title="C#中new关键字的用法"></a>C#中new关键字的用法</h1><p>在 C# 编程中，<code>new</code> 关键字是一个非常重要的工具，它不仅用于创建对象实例，还在许多不同的场景中扮演着特殊角色。本文将详细探讨 <code>new</code> 关键字的多种用法，包括隐藏父类成员、泛型约束、以及常规的对象实例化等场景。</p><h3 id="1-new-关键字用于隐藏父类成员"><a href="#1-new-关键字用于隐藏父类成员" class="headerlink" title="1. new 关键字用于隐藏父类成员"></a>1. <code>new</code> 关键字用于隐藏父类成员</h3><p>在面向对象编程中，继承是一个常见的概念，子类可以继承父类的属性和方法。有时，子类可能希望重新定义父类的方法，以便提供不同的实现。然而，如果子类只是定义了一个与父类同名的方法，而没有明确使用 <code>override</code>，则会产生一个“隐藏”行为。</p><h4 id="隐藏父类成员"><a href="#隐藏父类成员" class="headerlink" title="隐藏父类成员"></a>隐藏父类成员</h4><p>C# 允许通过 <code>new</code> 关键字来明确告诉编译器，你希望在子类中隐藏父类的成员。这种做法通常出现在你希望子类实现与父类相同名称但不同实现的成员时。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;这是父类的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>() <span class="hljs-comment">// 使用 new 隐藏父类的方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;这是子类的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Shape shape = <span class="hljs-keyword">new</span> Shape();<br>        shape.Print();  <span class="hljs-comment">// 输出 &quot;这是父类的方法&quot;</span><br><br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br>        circle.Print();  <span class="hljs-comment">// 输出 &quot;这是子类的方法&quot;</span><br><br>        Shape shapeCircle = <span class="hljs-keyword">new</span> Circle();<br>        shapeCircle.Print();  <span class="hljs-comment">// 输出 &quot;这是父类的方法&quot; 由隐式调用父类方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Circle</code> 类中的 <code>Print</code> 方法使用 <code>new</code> 关键字来隐藏 <code>Shape</code> 类中的 <code>Print</code> 方法。这意味着，虽然 <code>Circle</code> 类定义了一个 <code>Print</code> 方法，但当我们通过父类引用（如 <code>Shape shapeCircle = new Circle();</code>）调用时，仍然会调用父类的 <code>Print</code> 方法。</p><h4 id="为什么要使用-new-关键字？"><a href="#为什么要使用-new-关键字？" class="headerlink" title="为什么要使用 new 关键字？"></a>为什么要使用 <code>new</code> 关键字？</h4><ul><li><strong>明确意图</strong>：使用 <code>new</code> 可以清晰地表明你有意隐藏父类的成员，而不是不小心重写或覆盖它。</li><li><strong>避免潜在错误</strong>：如果你没有使用 <code>new</code>，编译器会给出警告，提示你隐藏了一个父类成员。这可以避免一些潜在的运行时问题，特别是在父类引用指向子类对象时。</li></ul><h3 id="2-泛型中-new-约束"><a href="#2-泛型中-new-约束" class="headerlink" title="2. 泛型中 new 约束"></a>2. 泛型中 <code>new</code> 约束</h3><p>在 C# 中，<code>new</code> 关键字可以用作泛型类型的约束，要求类型参数必须具有一个无参数的构造函数。这样，编译器可以确保该类型能够通过 <code>new</code> 关键字进行实例化。</p><h4 id="示例：泛型类与-new-约束"><a href="#示例：泛型类与-new-约束" class="headerlink" title="示例：泛型类与 new 约束"></a>示例：泛型类与 <code>new</code> 约束</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须有一个无参数的构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 通过无参数构造函数创建实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass&lt;SomeClass&gt; myClass = <span class="hljs-keyword">new</span> MyClass&lt;SomeClass&gt;();<br>        SomeClass instance = myClass.CreateInstance(); <span class="hljs-comment">// 创建 SomeClass 的实例</span><br>        Console.WriteLine(instance.GetType().Name);  <span class="hljs-comment">// 输出 &quot;SomeClass&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeClass</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SomeClass 构造函数&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>MyClass&lt;T&gt;</code> 类要求 <code>T</code> 类型必须具有一个无参数的构造函数（由 <code>where T : new()</code> 约束）。这使得我们能够在 <code>CreateInstance</code> 方法中调用 <code>new T()</code> 来创建类型 <code>T</code> 的实例。</p><p>这种约束对于需要动态创建对象并且无法事先知道类型的情况非常有用，尤其是在反射和工厂模式中。</p><h3 id="3-使用-new-创建对象实例"><a href="#3-使用-new-创建对象实例" class="headerlink" title="3. 使用 new 创建对象实例"></a>3. 使用 <code>new</code> 创建对象实例</h3><p>这是 <code>new</code> 最常见的用途，即用于实例化一个类或结构体的对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Introduce</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;你好，我是 <span class="hljs-subst">&#123;Name&#125;</span>, <span class="hljs-subst">&#123;Age&#125;</span> 岁。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 new 创建 Person 对象</span><br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>);<br>        person.Introduce();  <span class="hljs-comment">// 输出 &quot;你好，我是 张三, 25 岁。&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>new</code> 关键字用于创建 <code>Person</code> 类的实例。通过 <code>new</code> 关键字，我们可以调用类的构造函数，并为新对象分配内存空间。</p><h3 id="4-new-用于隐藏构造函数"><a href="#4-new-用于隐藏构造函数" class="headerlink" title="4. new 用于隐藏构造函数"></a>4. <code>new</code> 用于隐藏构造函数</h3><p>C# 允许子类通过 <code>new</code> 隐藏父类的构造函数。虽然这种做法不常见，但在某些特殊情况下，你可能需要隐藏父类构造函数来创建自定义的初始化逻辑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseClass</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;BaseClass 构造函数&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-title">DerivedClass</span>() <span class="hljs-comment">// 隐藏父类构造函数</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DerivedClass 构造函数&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        DerivedClass derived = <span class="hljs-keyword">new</span> DerivedClass();  <span class="hljs-comment">// 输出 &quot;DerivedClass 构造函数&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>new</code> 关键字在 C# 中具有多种用途，包括：</p><ol><li><strong>隐藏父类成员</strong>：通过使用 <code>new</code>，你可以明确表示你有意在子类中隐藏父类的成员，而不是无意中覆盖。</li><li><strong>泛型约束</strong>：<code>new</code> 可以用作泛型约束，要求类型参数具有无参数构造函数。</li><li><strong>实例化对象</strong>：<code>new</code> 是创建对象实例时最常用的关键字。</li><li><strong>隐藏构造函数</strong>：虽然不常见，但在某些情况下，<code>new</code> 可以用来隐藏父类的构造函数。</li></ol><p>通过理解和正确使用 <code>new</code> 关键字，你可以使你的 C# 代码更加灵活和清晰。特别是在继承和泛型等复杂的面向对象编程场景中，<code>new</code> 可以帮助你避免不必要的错误，并提供更多的控制权。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 泛型类型约束</title>
    <link href="/posts/1568/"/>
    <url>/posts/1568/</url>
    
    <content type="html"><![CDATA[<h2 id="C-泛型类型约束"><a href="#C-泛型类型约束" class="headerlink" title="C# 泛型类型约束"></a>C# 泛型类型约束</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在 C# 中，泛型提供了强大的灵活性，让你能够编写更加通用、可复用的代码。然而，在实际开发中，我们往往需要对泛型类型参数施加一些限制，以确保泛型类型在特定的上下文中能够正常工作。为了实现这一点，C# 提供了类型约束（Type Constraints），使你能够指定泛型类型参数必须满足的条件。</p><p>本文将介绍 C# 中几种常见的泛型类型约束，帮助你更精确地控制泛型类型的行为，包括如何要求类型实现接口、继承自某个基类、具有特定的构造函数，甚至结合多个约束。</p><h3 id="1-new-约束：要求类型具有无参数构造函数"><a href="#1-new-约束：要求类型具有无参数构造函数" class="headerlink" title="1. new() 约束：要求类型具有无参数构造函数"></a>1. <code>new()</code> 约束：要求类型具有无参数构造函数</h3><p>最基本的泛型类型约束之一就是 <code>new()</code>。它要求类型参数必须有一个公共的无参数构造函数。这通常用于创建泛型类型的实例。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>()  <span class="hljs-comment">// T 必须有一个无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T();  <span class="hljs-comment">// 通过无参构造函数创建实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T&gt;</code> 类有一个 <code>CreateInstance</code> 方法，要求 <code>T</code> 类型必须有一个无参数构造函数。通过 <code>new()</code> 约束，我们能够在代码中安全地使用 <code>new T()</code> 来创建类型 <code>T</code> 的实例。</p><h3 id="2-接口约束：要求类型实现特定接口"><a href="#2-接口约束：要求类型实现特定接口" class="headerlink" title="2. 接口约束：要求类型实现特定接口"></a>2. 接口约束：要求类型实现特定接口</h3><p>你可以使用 <code>where T : IInterface</code> 来要求类型参数 <code>T</code> 实现某个接口。接口约束非常适用于确保泛型类型具备特定的方法和属性。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICustomInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">ICustomInterface</span>, <span class="hljs-title">new</span>()  <span class="hljs-comment">// T 必须实现 ICustomInterface 接口并有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallMethod</span>()</span><br>    &#123;<br>        T instance = <span class="hljs-keyword">new</span> T();  <span class="hljs-comment">// 通过无参构造函数创建实例</span><br>        instance.MyMethod();   <span class="hljs-comment">// 调用 MyMethod 方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassImpl</span> : <span class="hljs-title">ICustomInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MyMethod 被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass&lt;MyClassImpl&gt; myClass = <span class="hljs-keyword">new</span> MyClass&lt;MyClassImpl&gt;();<br>        myClass.CallMethod();  <span class="hljs-comment">// 输出 &quot;MyMethod 被调用&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T&gt;</code> 要求 <code>T</code> 类型必须实现 <code>ICustomInterface</code> 接口，并且必须有无参构造函数。通过接口约束，我们可以确保 <code>T</code> 类型具备 <code>MyMethod</code> 方法，并在代码中安全调用。</p><h3 id="3-继承约束：要求类型继承某个基类"><a href="#3-继承约束：要求类型继承某个基类" class="headerlink" title="3. 继承约束：要求类型继承某个基类"></a>3. 继承约束：要求类型继承某个基类</h3><p>C# 允许你使用 <code>where T : BaseClass</code> 来要求类型参数 <code>T</code> 必须继承自某个基类。继承约束确保了类型 <code>T</code> 继承了基类的方法和属性，允许你在泛型类中调用这些方法。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;打印消息&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">new</span>()  <span class="hljs-comment">// T 必须继承自 BaseClass 且有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallBaseMethod</span>()</span><br>    &#123;<br>        T instance = <span class="hljs-keyword">new</span> T();  <span class="hljs-comment">// 通过无参构造函数创建实例</span><br>        instance.PrintMessage();  <span class="hljs-comment">// 调用基类方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassImpl</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// 继承自 BaseClass 的实现</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass&lt;MyClassImpl&gt; myClass = <span class="hljs-keyword">new</span> MyClass&lt;MyClassImpl&gt;();<br>        myClass.CallBaseMethod();  <span class="hljs-comment">// 输出 &quot;打印消息&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T&gt;</code> 要求 <code>T</code> 类型必须继承自 <code>BaseClass</code> 并且有无参构造函数。这样，<code>T</code> 类型自动具备 <code>BaseClass</code> 中定义的 <code>PrintMessage</code> 方法，代码中可以直接调用。</p><h3 id="4-接口-构造函数约束：要求类型具备特定方法"><a href="#4-接口-构造函数约束：要求类型具备特定方法" class="headerlink" title="4. 接口 + 构造函数约束：要求类型具备特定方法"></a>4. 接口 + 构造函数约束：要求类型具备特定方法</h3><p>你可以结合使用接口约束和构造函数约束，要求类型实现接口，并且具有特定的方法。比如，要求类型实现一个接口，并提供一个特定的构造函数。</p><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICanPrint</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span>;  <span class="hljs-comment">// 类型 T 必须实现 Print 方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">ICanPrint</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须实现 ICanPrint 接口</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallPrintMethod</span>()</span><br>    &#123;<br>        T instance = <span class="hljs-keyword">new</span> T();  <span class="hljs-comment">// 通过无参构造函数创建实例</span><br>        instance.Print();      <span class="hljs-comment">// 调用 Print 方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassImpl</span> : <span class="hljs-title">ICanPrint</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;打印信息&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass&lt;MyClassImpl&gt; myClass = <span class="hljs-keyword">new</span> MyClass&lt;MyClassImpl&gt;();<br>        myClass.CallPrintMethod();  <span class="hljs-comment">// 输出 &quot;打印信息&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T&gt;</code> 要求 <code>T</code> 类型实现 <code>ICanPrint</code> 接口，并且有一个无参构造函数。通过这种约束，确保 <code>T</code> 类型具备 <code>Print</code> 方法，可以在泛型方法中调用。</p><h3 id="5-多重约束：组合多个约束"><a href="#5-多重约束：组合多个约束" class="headerlink" title="5. 多重约束：组合多个约束"></a>5. 多重约束：组合多个约束</h3><p>你还可以组合多个约束，要求类型参数同时满足多个条件。例如，可以要求类型 <code>T</code> 实现某个接口，继承自某个基类，并且具有无参数构造函数。</p><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPrint</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BaseMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;BaseMethod 被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IPrint</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须继承自 BaseClass，实现 IPrint 接口，并具有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallMethods</span>()</span><br>    &#123;<br>        T instance = <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 通过无参构造函数创建实例</span><br>        instance.BaseMethod(); <span class="hljs-comment">// 调用基类方法</span><br>        instance.Print();      <span class="hljs-comment">// 调用接口方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassImpl</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IPrint</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Print 被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass&lt;MyClassImpl&gt; myClass = <span class="hljs-keyword">new</span> MyClass&lt;MyClassImpl&gt;();<br>        myClass.CallMethods();  <span class="hljs-comment">// 输出 &quot;BaseMethod 被调用&quot; 和 &quot;Print 被调用&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T&gt;</code> 要求 <code>T</code> 类型继承自 <code>BaseClass</code>，实现 <code>IPrint</code> 接口，并且具备无参数构造函数。通过多个约束的组合，我们可以更加精确地控制 <code>T</code> 类型的行为。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C# 中的泛型类型约束为我们提供了强大的灵活性，能够确保泛型类型在使用时具备特定的功能。常见的类型约束包括：</p><ul><li><strong><code>new()</code> 约束</strong>：要求类型具有无参数构造函数。</li><li><strong>接口约束</strong>：要求类型实现特定的接口，确保类型具备某些方法。</li><li><strong>继承约束</strong>：要求类型继承自某个基类，继承该类的方法和属性。</li><li><strong>组合约束</strong>：通过多个约束，确保类型同时满足多个条件。</li></ul><p>通过合理使用这些约束，我们能够编写出更加健壮、可控的泛型代码，提高代码的复用性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#结构体(Struct)</title>
    <link href="/posts/17473/"/>
    <url>/posts/17473/</url>
    
    <content type="html"><![CDATA[<h1 id="C-结构体（Struct）"><a href="#C-结构体（Struct）" class="headerlink" title="C# 结构体（Struct）"></a>C# 结构体（Struct）</h1><p><strong>在 C# 中，结构体（struct）是一种值类型（value type）</strong>，用于组织和存储相关数据。</p><p>在 C# 中，结构体是值类型数据结构，这样使得一个单一变量可以存储各种数据类型的相关数据。</p><p><strong>struct</strong> 关键字用于创建结构体。</p><p>结构体是用来代表一个记录，假设您想跟踪图书馆中书的动态，您可能想跟踪每本书的以下属性：</p><ul><li>Title</li><li>Author</li><li>Subject</li><li>Book ID</li></ul><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>为了定义一个结构体，您必须使用 <strong>struct</strong> 语句。</p><p><strong>struct</strong> 语句为程序定义了一个带有多个成员的新的数据类型。</p><p>例如，您可以按照如下的方式声明 Book 结构：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Books<br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> title;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> author;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> subject;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> book_id;<br>&#125;;  <br></code></pre></td></tr></table></figure><p>下面的程序演示了结构的用法：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br>     <br><span class="hljs-keyword">struct</span> Books<br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> title;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> author;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> subject;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> book_id;<br>&#125;;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">testStructure</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>   &#123;<br><br>      Books Book1;        <span class="hljs-comment">/* 声明 Book1，类型为 Books */</span><br>      Books Book2;        <span class="hljs-comment">/* 声明 Book2，类型为 Books */</span><br><br>      <span class="hljs-comment">/* book 1 详述 */</span><br>      Book1.title = <span class="hljs-string">&quot;C Programming&quot;</span>;<br>      Book1.author = <span class="hljs-string">&quot;Nuha Ali&quot;</span>; <br>      Book1.subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span>;<br>      Book1.book_id = <span class="hljs-number">6495407</span>;<br><br>      <span class="hljs-comment">/* book 2 详述 */</span><br>      Book2.title = <span class="hljs-string">&quot;Telecom Billing&quot;</span>;<br>      Book2.author = <span class="hljs-string">&quot;Zara Ali&quot;</span>;<br>      Book2.subject =  <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span>;<br>      Book2.book_id = <span class="hljs-number">6495700</span>;<br><br>      <span class="hljs-comment">/* 打印 Book1 信息 */</span><br>      Console.WriteLine( <span class="hljs-string">&quot;Book 1 title : &#123;0&#125;&quot;</span>, Book1.title);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 1 author : &#123;0&#125;&quot;</span>, Book1.author);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 1 subject : &#123;0&#125;&quot;</span>, Book1.subject);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 1 book_id :&#123;0&#125;&quot;</span>, Book1.book_id);<br><br>      <span class="hljs-comment">/* 打印 Book2 信息 */</span><br>      Console.WriteLine(<span class="hljs-string">&quot;Book 2 title : &#123;0&#125;&quot;</span>, Book2.title);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 2 author : &#123;0&#125;&quot;</span>, Book2.author);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 2 subject : &#123;0&#125;&quot;</span>, Book2.subject);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book 2 book_id : &#123;0&#125;&quot;</span>, Book2.book_id);       <br><br>      Console.ReadKey();<br><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Book </span><span class="hljs-number">1</span> title : C Programming<br><span class="hljs-keyword">Book </span><span class="hljs-number">1</span> author : Nuha Ali<br><span class="hljs-keyword">Book </span><span class="hljs-number">1</span> <span class="hljs-keyword">subject </span>: C Programming Tutorial<br><span class="hljs-keyword">Book </span><span class="hljs-number">1</span> <span class="hljs-keyword">book_id </span>: <span class="hljs-number">6495407</span><br><span class="hljs-keyword">Book </span><span class="hljs-number">2</span> title : Telecom <span class="hljs-keyword">Billing</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Book </span><span class="hljs-number">2</span> author : Zara Ali<br><span class="hljs-keyword">Book </span><span class="hljs-number">2</span> <span class="hljs-keyword">subject </span>: Telecom <span class="hljs-keyword">Billing </span>Tutorial<br><span class="hljs-keyword">Book </span><span class="hljs-number">2</span> <span class="hljs-keyword">book_id </span>: <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="C-结构的特点"><a href="#C-结构的特点" class="headerlink" title="C# 结构的特点"></a>C# 结构的特点</h2><p>结构提供了一种轻量级的数据类型，适用于表示简单的数据结构，具有较好的性能特性和值语义：</p><ul><li>结构可带有方法、字段、索引、属性、运算符方法和事件，适用于表示轻量级数据的情况，如坐标、范围、日期、时间等。</li><li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。</li><li>与类不同，结构不能继承其他的结构或类。</li><li>结构不能作为其他结构或类的基础结构。</li><li>结构可实现一个或多个接口。</li><li>结构成员不能指定为 abstract、virtual 或 protected。</li><li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li><li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li><li>结构变量通常分配在栈上，这使得它们的创建和销毁速度更快。但是，如果将结构用作类的字段，且这个类是引用类型，那么结构将存储在堆上。</li><li>结构默认情况下是可变的，这意味着你可以修改它们的字段。但是，如果结构定义为只读，那么它的字段将是不可变的。</li></ul><h2 id="类-vs-结构"><a href="#类-vs-结构" class="headerlink" title="类 vs 结构"></a>类 vs 结构</h2><p>类和结构在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。</p><p>类和结构有以下几个基本的不同点：</p><p><strong>值类型 vs 引用类型：</strong></p><ul><li><strong>结构是值类型（Value Type）：</strong> 结构是值类型，它们在栈上分配内存，而不是在堆上。当将结构实例传递给方法或赋值给另一个变量时，将复制整个结构的内容。</li><li><strong>类是引用类型（Reference Type）：</strong> 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p><strong>继承和多态性：</strong></p><ul><li><strong>结构不能继承：</strong> 结构不能继承其他结构或类，也不能作为其他结构或类的基类。</li><li><strong>类支持继承：</strong> 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。</li></ul><p><strong>默认构造函数：</strong></p><ul><li><strong>结构不能有无参数的构造函数：</strong> 结构不能包含无参数的构造函数。</li><li><strong>类可以有无参数的构造函数：</strong> 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。</li></ul><p><strong>赋值行为：</strong></p><ul><li>类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。</li><li>结构变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。</li></ul><p><strong>传递方式：</strong></p><ul><li>类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。</li><li>结构对象通常通过值传递，这意味着传递的是结构的副本，而不是原始结构对象本身。因此，在方法中对结构所做的更改不会影响到原始对象。</li></ul><p><strong>可空性：</strong></p><ul><li>**结构体是值类型，不能直接设置为 **null**：**因为 <strong>null</strong> 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 <strong>Nullable<T></T></strong> 或称为 <strong>T?</strong> 的可空类型。</li><li><strong>类默认可为null：</strong> 类的实例默认可以为 <code>null</code>，因为它们是引用类型。</li></ul><p><strong>性能和内存分配：</strong></p><ul><li><strong>结构通常更轻量：</strong> 由于结构是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。</li><li><strong>类可能有更多开销：</strong> 由于类是引用类型，可能涉及更多的内存开销和管理。</li></ul><p>以下实例中，MyStruct 是一个结构，而 MyClass 是一个类。</p><p>注释部分演示了结构不能包含无参数的构造函数、不能继承以及结构的实例复制是复制整个结构的内容。与之相反，类可以包含无参数的构造函数，可以继承，并且实例复制是复制引用。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 结构声明</span><br><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br><br>    <span class="hljs-comment">// 结构不能有无参数的构造函数</span><br>    <span class="hljs-comment">// public MyStruct()</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 有参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStruct</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        X = x;<br>        Y = y;<br>    &#125;<br><br>    <span class="hljs-comment">// 结构不能继承</span><br>    <span class="hljs-comment">// struct MyDerivedStruct : MyBaseStruct</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><br><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br><br>    <span class="hljs-comment">// 类可以有无参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 有参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        X = x;<br>        Y = y;<br>    &#125;<br><br>    <span class="hljs-comment">// 类支持继承</span><br>    <span class="hljs-comment">// class MyDerivedClass : MyBaseClass</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 结构是值类型，分配在栈上</span><br>        MyStruct structInstance1 = <span class="hljs-keyword">new</span> MyStruct(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        MyStruct structInstance2 = structInstance1; <span class="hljs-comment">// 复制整个结构</span><br><br>        <span class="hljs-comment">// 类是引用类型，分配在堆上</span><br>        MyClass classInstance1 = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        MyClass classInstance2 = classInstance1; <span class="hljs-comment">// 复制引用，指向同一个对象</span><br><br>        <span class="hljs-comment">// 修改结构实例不影响其他实例</span><br>        structInstance1.X = <span class="hljs-number">5</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Struct: <span class="hljs-subst">&#123;structInstance1.X&#125;</span>, <span class="hljs-subst">&#123;structInstance2.X&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 修改类实例会影响其他实例</span><br>        classInstance1.X = <span class="hljs-number">6</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Class: <span class="hljs-subst">&#123;classInstance1.X&#125;</span>, <span class="hljs-subst">&#123;classInstance2.X&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上述讨论，让我们重写前面的实例：</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br>     <br><span class="hljs-keyword">struct</span> Books<br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> title;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> author;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> subject;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> book_id;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValues</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> t, <span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> id</span>)</span><br>   &#123;<br>      title = t;<br>      author = a;<br>      subject = s;<br>      book_id =id; <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span><br>   &#123;<br>      Console.WriteLine(<span class="hljs-string">&quot;Title : &#123;0&#125;&quot;</span>, title);<br>      Console.WriteLine(<span class="hljs-string">&quot;Author : &#123;0&#125;&quot;</span>, author);<br>      Console.WriteLine(<span class="hljs-string">&quot;Subject : &#123;0&#125;&quot;</span>, subject);<br>      Console.WriteLine(<span class="hljs-string">&quot;Book_id :&#123;0&#125;&quot;</span>, book_id);<br>   &#125;<br><br>&#125;;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">testStructure</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>   &#123;<br><br>      Books Book1 = <span class="hljs-keyword">new</span> Books(); <span class="hljs-comment">/* 声明 Book1，类型为 Books */</span><br>      Books Book2 = <span class="hljs-keyword">new</span> Books(); <span class="hljs-comment">/* 声明 Book2，类型为 Books */</span><br><br>      <span class="hljs-comment">/* book 1 详述 */</span><br>      Book1.setValues(<span class="hljs-string">&quot;C Programming&quot;</span>,<br>      <span class="hljs-string">&quot;Nuha Ali&quot;</span>, <span class="hljs-string">&quot;C Programming Tutorial&quot;</span>,<span class="hljs-number">6495407</span>);<br><br>      <span class="hljs-comment">/* book 2 详述 */</span><br>      Book2.setValues(<span class="hljs-string">&quot;Telecom Billing&quot;</span>,<br>      <span class="hljs-string">&quot;Zara Ali&quot;</span>, <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span>, <span class="hljs-number">6495700</span>);<br><br>      <span class="hljs-comment">/* 打印 Book1 信息 */</span><br>      Book1.display();<br><br>      <span class="hljs-comment">/* 打印 Book2 信息 */</span><br>      Book2.display(); <br><br>      Console.ReadKey();<br><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">Title : <span class="hljs-type">C</span> Programming<br>Author : <span class="hljs-type">Nuha</span> Ali<br>Subject : <span class="hljs-type">C</span> Programming Tutorial<br>Book_id : 6495407<br>Title : <span class="hljs-type">Telecom</span> Billing<br>Author : <span class="hljs-type">Zara</span> Ali<br>Subject : <span class="hljs-type">Telecom</span> Billing Tutorial<br>Book_id : 6495700<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 字符串</title>
    <link href="/posts/27756/"/>
    <url>/posts/27756/</url>
    
    <content type="html"><![CDATA[<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C# 字符串"></a>C# 字符串</h1><p>在 C# 编程中，字符串（<code>string</code>）是最常用的数据类型之一。无论是用户界面、日志记录还是数据处理，字符串都扮演着重要角色。本文将全面讲解 C# 中字符串的用法、操作技巧及其背后的技术原理，帮助你掌握字符串的使用。</p><hr><h2 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a><strong>什么是字符串？</strong></h2><p>在 C# 中，字符串是一种引用类型（<code>System.String</code>），用来表示一系列 Unicode 字符。字符串是不可变的，这意味着字符串一旦创建，其内容就无法更改。</p><h3 id="字符串不可变性"><a href="#字符串不可变性" class="headerlink" title="字符串不可变性"></a><strong>字符串不可变性</strong></h3><p>不可变性是字符串的一个核心特性。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str += <span class="hljs-string">&quot; World&quot;</span>;  <span class="hljs-comment">// 实际上会创建一个新的字符串对象</span><br>Console.WriteLine(str); <span class="hljs-comment">// 输出：Hello World</span><br></code></pre></td></tr></table></figure><p>上述代码中，<code>str += &quot; World&quot;</code> 会生成一个新的字符串对象，原来的字符串并未修改。</p><h3 id="字符串赋值与引用特性"><a href="#字符串赋值与引用特性" class="headerlink" title="字符串赋值与引用特性"></a><strong>字符串赋值与引用特性</strong></h3><p>虽然字符串是引用类型，但由于其不可变特性，当将一个字符串赋值给另一个字符串时，新的字符串变量会独立于原有变量。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = str1;<br>str2 = <span class="hljs-string">&quot;World&quot;</span>;<br>Console.WriteLine(str1); <span class="hljs-comment">// 输出：Hello</span><br>Console.WriteLine(str2); <span class="hljs-comment">// 输出：World</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>str2</code> 的值被修改后，<code>str1</code> 的值并未受到影响。这是因为字符串的不可变性使得修改操作实际上创建了一个新的字符串对象，而不是更改原有的对象。</p><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a><strong>字符串的存储</strong></h3><p>字符串是以 Unicode 格式存储的，这使得 C# 能够支持多语言字符。</p><hr><h2 id="字符串的基本声明与创建"><a href="#字符串的基本声明与创建" class="headerlink" title="字符串的基本声明与创建"></a><strong>字符串的基本声明与创建</strong></h2><h3 id="1-普通字符串"><a href="#1-普通字符串" class="headerlink" title="1. 普通字符串"></a><strong>1. 普通字符串</strong></h3><p>普通字符串用双引号包裹：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> normalString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-转义字符串"><a href="#2-转义字符串" class="headerlink" title="2. 转义字符串"></a><strong>2. 转义字符串</strong></h3><p>可以通过反斜杠 <code>\</code> 来表示特殊字符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> escapedString = <span class="hljs-string">&quot;Hello,\nWorld!&quot;</span>; <span class="hljs-comment">// 输出时会换行</span><br></code></pre></td></tr></table></figure><p>常见转义字符：</p><ul><li><code>\n</code>：换行</li><li><code>\t</code>：制表符</li><li><code>\\</code>：反斜杠</li><li><code>\&quot;</code>：双引号</li></ul><h3 id="3-逐字字符串"><a href="#3-逐字字符串" class="headerlink" title="3. 逐字字符串"></a><strong>3. 逐字字符串</strong></h3><p>逐字字符串以 <code>@</code> 开头，忽略转义符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> rawString = <span class="hljs-string">@&quot;C:\\Program Files\\MyApp&quot;</span>;<br></code></pre></td></tr></table></figure><p>适用于文件路径等场景。</p><h3 id="4-多行字符串"><a href="#4-多行字符串" class="headerlink" title="4. 多行字符串"></a><strong>4. 多行字符串</strong></h3><p>C# 11 引入了多行字符串字面量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> multiLineString = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">Line 1</span><br><span class="hljs-string">    Line 2 (Indented)</span><br><span class="hljs-string">Line 3</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span>;<br>Console.WriteLine(multiLineString);<br></code></pre></td></tr></table></figure><hr><h2 id="字符串的操作方式"><a href="#字符串的操作方式" class="headerlink" title="字符串的操作方式"></a><strong>字符串的操作方式</strong></h2><h3 id="1-字符串连接"><a href="#1-字符串连接" class="headerlink" title="1. 字符串连接"></a><strong>1. 字符串连接</strong></h3><ul><li><p>使用 <code>+</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-built_in">string</span> lastName = <span class="hljs-string">&quot;Doe&quot;</span>;<br><span class="hljs-built_in">string</span> fullName = firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;<br>Console.WriteLine(fullName); <span class="hljs-comment">// 输出：John Doe</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>String.Concat</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> fullName = <span class="hljs-built_in">string</span>.Concat(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>String.Join</code>（适合拼接数组）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>[] words = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br><span class="hljs-built_in">string</span> sentence = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot; &quot;</span>, words);<br>Console.WriteLine(sentence); <span class="hljs-comment">// 输出：Hello World</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>StringBuilder</code>（推荐用于频繁拼接）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Text;<br><br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.Append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;, &quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;World&quot;</span>);<br>Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出：Hello, World</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-字符串插值"><a href="#2-字符串插值" class="headerlink" title="2. 字符串插值"></a><strong>2. 字符串插值</strong></h3><p>字符串插值从 C# 6 引入，是更直观的字符串构建方式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-built_in">string</span> interpolatedString = <span class="hljs-string">$&quot;My name is <span class="hljs-subst">&#123;name&#125;</span> and I am <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span>;<br>Console.WriteLine(interpolatedString);<br></code></pre></td></tr></table></figure><h3 id="3-格式化字符串"><a href="#3-格式化字符串" class="headerlink" title="3. 格式化字符串"></a><strong>3. 格式化字符串</strong></h3><p>传统的格式化方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-built_in">string</span> formattedString = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;My name is &#123;0&#125; and I am &#123;1&#125; years old.&quot;</span>, name, age);<br>Console.WriteLine(formattedString);<br></code></pre></td></tr></table></figure><p>现代开发中更推荐字符串插值。</p><h3 id="4-子字符串"><a href="#4-子字符串" class="headerlink" title="4. 子字符串"></a><strong>4. 子字符串</strong></h3><p>从字符串中提取部分内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> substring = str.Substring(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 7 开始，长度为 5</span><br>Console.WriteLine(substring); <span class="hljs-comment">// 输出：World</span><br></code></pre></td></tr></table></figure><h3 id="5-替换字符串"><a href="#5-替换字符串" class="headerlink" title="5. 替换字符串"></a><strong>5. 替换字符串</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> replacedStr = str.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C#&quot;</span>);<br>Console.WriteLine(replacedStr); <span class="hljs-comment">// 输出：Hello, C#!</span><br></code></pre></td></tr></table></figure><h3 id="6-字符串拆分"><a href="#6-字符串拆分" class="headerlink" title="6. 字符串拆分"></a><strong>6. 字符串拆分</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,cherry&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-去除空白"><a href="#7-去除空白" class="headerlink" title="7. 去除空白"></a><strong>7. 去除空白</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;   Hello, World!   &quot;</span>;<br>Console.WriteLine(str.Trim());    <span class="hljs-comment">// 去除前后空白</span><br>Console.WriteLine(str.TrimStart()); <span class="hljs-comment">// 去除前空白</span><br>Console.WriteLine(str.TrimEnd());   <span class="hljs-comment">// 去除后空白</span><br></code></pre></td></tr></table></figure><h3 id="8-判断字符串是否匹配模式"><a href="#8-判断字符串是否匹配模式" class="headerlink" title="8. 判断字符串是否匹配模式"></a><strong>8. 判断字符串是否匹配模式</strong></h3><ul><li><p>使用 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">StartsWith</span><br></code></pre></td></tr></table></figure><p> 和 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">EndsWith</span><br></code></pre></td></tr></table></figure><p>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>Console.WriteLine(str.StartsWith(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// 输出：True</span><br>Console.WriteLine(str.EndsWith(<span class="hljs-string">&quot;World!&quot;</span>)); <span class="hljs-comment">// 输出：True</span><br></code></pre></td></tr></table></figure></li><li><p>使用 </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Contains</span><br></code></pre></td></tr></table></figure><p> 检查子字符串：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>Console.WriteLine(str.Contains(<span class="hljs-string">&quot;World&quot;</span>)); <span class="hljs-comment">// 输出：True</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a><strong>字符串的比较</strong></h2><h3 id="1-区分大小写的比较"><a href="#1-区分大小写的比较" class="headerlink" title="1. 区分大小写的比较"></a><strong>1. 区分大小写的比较</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>Console.WriteLine(str1 == str2); <span class="hljs-comment">// 输出：False</span><br></code></pre></td></tr></table></figure><h3 id="2-忽略大小写的比较"><a href="#2-忽略大小写的比较" class="headerlink" title="2. 忽略大小写的比较"></a><strong>2. 忽略大小写的比较</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">bool</span> areEqual = <span class="hljs-built_in">string</span>.Equals(str1, str2, StringComparison.OrdinalIgnoreCase);<br>Console.WriteLine(areEqual); <span class="hljs-comment">// 输出：True</span><br></code></pre></td></tr></table></figure><hr><h2 id="常用字符串方法"><a href="#常用字符串方法" class="headerlink" title="常用字符串方法"></a><strong>常用字符串方法</strong></h2><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>Length</code></td><td>获取字符串长度</td><td><code>str.Length</code></td></tr><tr><td><code>ToUpper</code></td><td>转换为大写</td><td><code>str.ToUpper()</code></td></tr><tr><td><code>ToLower</code></td><td>转换为小写</td><td><code>str.ToLower()</code></td></tr><tr><td><code>Contains</code></td><td>检查是否包含子字符串</td><td><code>str.Contains(&quot;World&quot;)</code></td></tr><tr><td><code>StartsWith</code></td><td>检查是否以某字符串开头</td><td><code>str.StartsWith(&quot;Hello&quot;)</code></td></tr><tr><td><code>EndsWith</code></td><td>检查是否以某字符串结尾</td><td><code>str.EndsWith(&quot;!&quot;)</code></td></tr><tr><td><code>IndexOf</code></td><td>获取子字符串的索引位置</td><td><code>str.IndexOf(&quot;World&quot;)</code></td></tr><tr><td><code>LastIndexOf</code></td><td>获取最后一次出现的索引位置</td><td><code>str.LastIndexOf(&quot;o&quot;)</code></td></tr><tr><td><code>IsNullOrEmpty</code></td><td>检查是否为空或空字符串</td><td><code>string.IsNullOrEmpty(str)</code></td></tr><tr><td><code>IsNullOrWhiteSpace</code></td><td>检查是否为空或仅包含空白字符</td><td><code>string.IsNullOrWhiteSpace(str)</code></td></tr><tr><td><code>Split</code></td><td>按指定分隔符拆分字符串</td><td><code>str.Split(&#39;,&#39;)</code></td></tr><tr><td><code>Replace</code></td><td>替换子字符串</td><td><code>str.Replace(&quot;old&quot;, &quot;new&quot;)</code></td></tr><tr><td><code>Substring</code></td><td>提取子字符串</td><td><code>str.Substring(0, 5)</code></td></tr><tr><td><code>Trim</code></td><td>去除空白</td><td><code>str.Trim()</code></td></tr></tbody></table><hr><h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a><strong>性能优化建议</strong></h2><ol><li><strong>频繁拼接字符串时使用 <code>StringBuilder</code></strong><ul><li>普通拼接会创建多个字符串对象，增加内存占用。</li></ul></li><li><strong>避免重复调用不可变方法</strong><ul><li>例如：<code>str.ToUpper()</code> 会返回新的字符串，多次调用可能影响性能。</li></ul></li><li><strong>选择合适的比较方式</strong><ul><li>使用 <code>StringComparison</code> 来避免不必要的大小写敏感比较。</li></ul></li><li><strong>善用缓存</strong><ul><li>对于频繁使用的字符串结果，可以进行缓存。</li></ul></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>C# 的字符串处理功能非常强大，从基础的声明到高级的操作应有尽有。在日常开发中，理解字符串的不可变性、合理选择操作方式，并关注性能优化，能够让你的代码更加高效优雅。希望本文能帮助你全面掌握 C# 字符串的使用技巧！</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#可空类型(Nullable)</title>
    <link href="/posts/38509/"/>
    <url>/posts/38509/</url>
    
    <content type="html"><![CDATA[<h1 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h1><h2 id="C-单问号-与-双问号"><a href="#C-单问号-与-双问号" class="headerlink" title="C# 单问号 ? 与 双问号 ??"></a>C# 单问号 ? 与 双问号 ??</h2><p><strong>?</strong> 单问号用于对 <strong>int、double、bool</strong> 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>? i = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Nullable&lt;<span class="hljs-type">int</span>&gt; i = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Nullable</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-type">int</span> i; <span class="hljs-comment">//默认值0</span><br><span class="hljs-type">int</span>? ii; <span class="hljs-comment">//默认值null</span><br></code></pre></td></tr></table></figure><p><strong>??</strong> 双问号用于判断一个变量在为 null 的时候返回一个指定的值。</p><p>接下来我们详细说明。</p><h2 id="C-可空类型（Nullable）-1"><a href="#C-可空类型（Nullable）-1" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h2><p>C# 提供了一个特殊的数据类型，<strong>nullable</strong> 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p>例如，Nullable&lt; Int32 &gt;，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable&lt; bool &gt; 变量可以被赋值为 true 或 false 或 null。</p><p>在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。</p><p>声明一个 <strong>nullable</strong> 类型（可空类型）的语法如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt; data_type&gt;</span> ? <span class="hljs-attribute">&lt;variable_name&gt;</span> = null;<br></code></pre></td></tr></table></figure><p>下面的实例演示了可空数据类型的用法：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">NullablesAtShow</span><br>   &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <span class="hljs-built_in">int</span>? num1 = <span class="hljs-literal">null</span>;<br>         <span class="hljs-built_in">int</span>? num2 = <span class="hljs-number">45</span>;<br>         <span class="hljs-built_in">double</span>? num3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>?();<br>         <span class="hljs-built_in">double</span>? num4 = <span class="hljs-number">3.14157</span>;<br>         <br>         <span class="hljs-built_in">bool</span>? boolval = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>?();<br><br>         <span class="hljs-comment">// 显示值</span><br>         <br>         Console.WriteLine(<span class="hljs-string">&quot;显示可空类型的值： &#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;</span>, <br>                            num1, num2, num3, num4);<br>         Console.WriteLine(<span class="hljs-string">&quot;一个可空的布尔值： &#123;0&#125;&quot;</span>, boolval);<br>         Console.ReadLine();<br><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">显示可空类型的值： , <span class="hljs-number">45</span>,  , <span class="hljs-number">3.14157</span><br>一个可空的布尔值：<br></code></pre></td></tr></table></figure><h2 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h2><p>Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。</p><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">NullablesAtShow</span><br>   &#123;<br>         <br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <br>         <span class="hljs-built_in">double</span>? num1 = <span class="hljs-literal">null</span>;<br>         <span class="hljs-built_in">double</span>? num2 = <span class="hljs-number">3.14157</span>;<br>         <span class="hljs-built_in">double</span> num3;<br>         num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br>         Console.WriteLine(<span class="hljs-string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);<br>         num3 = num2 ?? <span class="hljs-number">5.34</span>;<br>         Console.WriteLine(<span class="hljs-string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);<br>         Console.ReadLine();<br><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">num3</span> 的值： <span class="hljs-number">5</span>.<span class="hljs-number">34</span><br><span class="hljs-attribute">num3</span> 的值： <span class="hljs-number">3</span>.<span class="hljs-number">14157</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 类型转换</title>
    <link href="/posts/18967/"/>
    <url>/posts/18967/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C# 类型转换"></a>C# 类型转换</h1><p>在 C# 中，类型转换是将一个数据类型的值转换为另一个数据类型的过程。</p><p>C# 中的类型转换可以分为两种：<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>（也称为强制类型转换）。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式转换是不需要编写代码来指定的转换，编译器会自动进行。</p><p>隐式转换是指将一个较小范围的数据类型转换为较大范围的数据类型时，编译器会自动完成类型转换，这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。</p><p>例如，从 int 到 long，从 float 到 double 等。</p><p>从小的整数类型转换为大的整数类型，从派生类转换为基类。将一个 byte 类型的变量赋值给 int 类型的变量，编译器会自动将 byte 类型转换为 int 类型，不需要显示转换。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">byte</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> i = b; <span class="hljs-comment">// 隐式转换，不需要显式转换</span><br></code></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">long</span> longValue = intValue; <span class="hljs-comment">// 隐式转换，从 int 到 long</span><br></code></pre></td></tr></table></figure><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>显式类型转换，即强制类型转换，需要程序员在代码中明确指定。</p><p>显式转换是指将一个较大范围的数据类型转换为较小范围的数据类型时，或者将一个对象类型转换为另一个对象类型时，需要使用强制类型转换符号进行显示转换，强制转换会造成数据丢失。</p><p>例如，将一个 int 类型的变量赋值给 byte 类型的变量，需要显示转换。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">byte</span> b = (<span class="hljs-built_in">byte</span>)i; <span class="hljs-comment">// 显式转换，需要使用强制类型转换符号</span><br></code></pre></td></tr></table></figure><p>强制转换为整数类型：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">double</span> doubleValue = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">int</span> intValue = (<span class="hljs-built_in">int</span>)doubleValue; <span class="hljs-comment">// 强制从 double 到 int，数据可能损失小数部分</span><br></code></pre></td></tr></table></figure><p>强制转换为浮点数类型：</p><h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">float</span> floatValue = (<span class="hljs-built_in">float</span>)intValue; <span class="hljs-comment">// 强制从 int 到 float，数据可能损失精度</span><br></code></pre></td></tr></table></figure><p>强制转换为字符串类型：</p><h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> stringValue = intValue.ToString(); <span class="hljs-comment">// 将 int 转换为字符串</span><br></code></pre></td></tr></table></figure><p>下面的实例显示了一个显式的类型转换：</p><h2 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">TypeConversionApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ExplicitConversion</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">double</span> d = <span class="hljs-number">5673.74</span>;<br>            <span class="hljs-built_in">int</span> i;<br><br>            <span class="hljs-comment">// 强制转换 double 为 int</span><br>            i = (<span class="hljs-built_in">int</span>)d;<br>            Console.WriteLine(i);<br>            Console.ReadKey();<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5673</span><br></code></pre></td></tr></table></figure><h2 id="C-类型转换方法"><a href="#C-类型转换方法" class="headerlink" title="C# 类型转换方法"></a>C# 类型转换方法</h2><p>C# 提供了下列内置的类型转换方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>ToBoolean</strong> 如果可能的话，把类型转换为布尔型。</td></tr><tr><td align="left">2</td><td align="left"><strong>ToByte</strong> 把类型转换为字节类型。</td></tr><tr><td align="left">3</td><td align="left"><strong>ToChar</strong> 如果可能的话，把类型转换为单个 Unicode 字符类型。</td></tr><tr><td align="left">4</td><td align="left"><strong>ToDateTime</strong> 把类型（整数或字符串类型）转换为 日期-时间 结构。</td></tr><tr><td align="left">5</td><td align="left"><strong>ToDecimal</strong> 把浮点型或整数类型转换为十进制类型。</td></tr><tr><td align="left">6</td><td align="left"><strong>ToDouble</strong> 把类型转换为双精度浮点型。</td></tr><tr><td align="left">7</td><td align="left"><strong>ToInt16</strong> 把类型转换为 16 位整数类型。</td></tr><tr><td align="left">8</td><td align="left"><strong>ToInt32</strong> 把类型转换为 32 位整数类型。</td></tr><tr><td align="left">9</td><td align="left"><strong>ToInt64</strong> 把类型转换为 64 位整数类型。</td></tr><tr><td align="left">10</td><td align="left"><strong>ToSbyte</strong> 把类型转换为有符号字节类型。</td></tr><tr><td align="left">11</td><td align="left"><strong>ToSingle</strong> 把类型转换为小浮点数类型。</td></tr><tr><td align="left">12</td><td align="left"><strong>ToString</strong> 把类型转换为字符串类型。</td></tr><tr><td align="left">13</td><td align="left"><strong>ToType</strong> 把类型转换为指定类型。</td></tr><tr><td align="left">14</td><td align="left"><strong>ToUInt16</strong> 把类型转换为 16 位无符号整数类型。</td></tr><tr><td align="left">15</td><td align="left"><strong>ToUInt32</strong> 把类型转换为 32 位无符号整数类型。</td></tr><tr><td align="left">16</td><td align="left"><strong>ToUInt64</strong> 把类型转换为 64 位无符号整数类型。</td></tr></tbody></table><p>这些方法都定义在 System.Convert 类中，使用时需要包含 System 命名空间。它们提供了一种安全的方式来执行类型转换，因为它们可以处理 null值，并且会抛出异常，如果转换不可能进行。</p><p>例如，使用 Convert.ToInt32 方法将字符串转换为整数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-built_in">int</span> number = Convert.ToInt32(str); <span class="hljs-comment">// 转换成功，number为123</span><br></code></pre></td></tr></table></figure><p>如果字符串不是有效的整数表示，Convert.ToInt32 将抛出 FormatException。</p><p>下面的实例把不同值的类型转换为字符串类型：</p><h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">TypeConversionApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">StringConversion</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 定义一个整型变量</span><br>            <span class="hljs-built_in">int</span> i = <span class="hljs-number">75</span>;<br>            <br>            <span class="hljs-comment">// 定义一个浮点型变量</span><br>            <span class="hljs-built_in">float</span> f = <span class="hljs-number">53.005f</span>;<br>            <br>            <span class="hljs-comment">// 定义一个双精度浮点型变量</span><br>            <span class="hljs-built_in">double</span> d = <span class="hljs-number">2345.7652</span>;<br>            <br>            <span class="hljs-comment">// 定义一个布尔型变量</span><br>            <span class="hljs-built_in">bool</span> b = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 将整型变量转换为字符串并输出</span><br>            Console.WriteLine(i.ToString());<br>            <br>            <span class="hljs-comment">// 将浮点型变量转换为字符串并输出</span><br>            Console.WriteLine(f.ToString());<br>            <br>            <span class="hljs-comment">// 将双精度浮点型变量转换为字符串并输出</span><br>            Console.WriteLine(d.ToString());<br>            <br>            <span class="hljs-comment">// 将布尔型变量转换为字符串并输出</span><br>            Console.WriteLine(b.ToString());<br><br>            <span class="hljs-comment">// 等待用户按键后关闭控制台窗口</span><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">75</span><br><span class="hljs-attribute">53</span>.<span class="hljs-number">005</span><br><span class="hljs-attribute">2345</span>.<span class="hljs-number">7652</span><br><span class="hljs-attribute">True</span><br></code></pre></td></tr></table></figure><p>在进行类型转换时需要注意以下几点：</p><ul><li>隐式转换只能将较小范围的数据类型转换为较大范围的数据类型，不能将较大范围的数据类型转换为较小范围的数据类型；</li><li>显式转换可能会导致数据丢失或精度降低，需要进行数据类型的兼容性检查；</li><li>对于对象类型的转换，需要进行类型转换的兼容性检查和类型转换的安全性检查。</li></ul><hr><h2 id="类型转换方法"><a href="#类型转换方法" class="headerlink" title="类型转换方法"></a>类型转换方法</h2><p>C# 提供了多种类型转换方法，例如使用 Convert 类、Parse 方法和 TryParse 方法，这些方法可以帮助处理不同的数据类型之间的转换。</p><h3 id="使用-Convert-类"><a href="#使用-Convert-类" class="headerlink" title="使用 Convert 类"></a>使用 Convert 类</h3><p>Convert 类提供了一组静态方法，可以在各种基本数据类型之间进行转换。</p><h2 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-built_in">int</span> num = Convert.ToInt32(str);<br></code></pre></td></tr></table></figure><h3 id="使用-Parse-方法"><a href="#使用-Parse-方法" class="headerlink" title="使用 Parse 方法"></a>使用 Parse 方法</h3><p>Parse 方法用于将字符串转换为对应的数值类型，如果转换失败会抛出异常。</p><h2 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-built_in">double</span> d = <span class="hljs-built_in">double</span>.Parse(str);<br></code></pre></td></tr></table></figure><h3 id="使用-TryParse-方法"><a href="#使用-TryParse-方法" class="headerlink" title="使用 TryParse 方法"></a>使用 TryParse 方法</h3><p>TryParse 方法类似于 Parse，但它不会抛出异常，而是返回一个布尔值指示转换是否成功。</p><h2 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-built_in">double</span> d;<br><span class="hljs-built_in">bool</span> success = <span class="hljs-built_in">double</span>.TryParse(str, <span class="hljs-keyword">out</span> d);<br><br><span class="hljs-keyword">if</span> (success) &#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;转换成功: &quot;</span> + d);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;转换失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h2><p>C# 还允许你定义自定义类型转换操作，通过在类型中定义 implicit 或 explicit 关键字。</p><h2 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Fahrenheit</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Degrees &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fahrenheit</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> degrees</span>)</span><br>    &#123;<br>        Degrees = degrees;<br>    &#125;<br><br>    <span class="hljs-comment">// 隐式转换从Fahrenheit到double</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span>(<span class="hljs-params">Fahrenheit f</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> f.Degrees;<br>    &#125;<br><br>    <span class="hljs-comment">// 显式转换从double到Fahrenheit</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">Fahrenheit</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> d</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fahrenheit(d);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Fahrenheit f = <span class="hljs-keyword">new</span> Fahrenheit(<span class="hljs-number">98.6</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Fahrenheit object: &quot;</span> + f.Degrees + <span class="hljs-string">&quot; degrees&quot;</span>);<br><br>        <span class="hljs-built_in">double</span> temp = f; <span class="hljs-comment">// 隐式转换</span><br>        Console.WriteLine(<span class="hljs-string">&quot;After implicit conversion to double: &quot;</span> + temp + <span class="hljs-string">&quot; degrees&quot;</span>);<br><br>        Fahrenheit newF = (Fahrenheit)temp; <span class="hljs-comment">// 显式转换</span><br>        Console.WriteLine(<span class="hljs-string">&quot;After explicit conversion back to Fahrenheit: &quot;</span> + newF.Degrees + <span class="hljs-string">&quot; degrees&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上例子中，我们定义了一个 Fahrenheit 类，并实现了从 Fahrenheit 到 double 的隐式转换和从 double 到 Fahrenheit 的显式转换。</p><p>输出结果将显示如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Fahrenheit <span class="hljs-keyword">object</span>: <span class="hljs-number">98.6</span> degrees<br><span class="hljs-keyword">After</span> implicit <span class="hljs-keyword">conversion</span> <span class="hljs-keyword">to</span> <span class="hljs-type">double</span>: <span class="hljs-number">98.6</span> degrees<br><span class="hljs-keyword">After</span> explicit <span class="hljs-keyword">conversion</span> back <span class="hljs-keyword">to</span> Fahrenheit: <span class="hljs-number">98.6</span> degrees<br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 C# 中，内置的类型转换方法主要通过以下几种方式实现：隐式转换、显式转换（强制转换）、使用 Convert 类的方法、Parse 方法和 TryParse 方法，这些方法广泛应用于不同数据类型之间的转换。</p><p>以下是 C# 内置类型转换方法的表格：</p><table><thead><tr><th align="left"><strong>方法类别</strong></th><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">隐式转换</td><td align="left">自动进行的转换</td><td align="left">无需显式指定，通常用于安全的类型转换，如从较小类型到较大类型</td></tr><tr><td align="left">显式转换（强制转换）</td><td align="left"><code>(type)value</code></td><td align="left">需要显式指定，通常用于可能导致数据丢失或转换失败的情况</td></tr><tr><td align="left"><code>Convert</code> 类方法</td><td align="left"><code>Convert.ToBoolean(value)</code></td><td align="left">将指定类型转换为 <code>Boolean</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToByte(value)</code></td><td align="left">将指定类型转换为 <code>Byte</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToChar(value)</code></td><td align="left">将指定类型转换为 <code>Char</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToDateTime(value)</code></td><td align="left">将指定类型转换为 <code>DateTime</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToDecimal(value)</code></td><td align="left">将指定类型转换为 <code>Decimal</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToDouble(value)</code></td><td align="left">将指定类型转换为 <code>Double</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToInt16(value)</code></td><td align="left">将指定类型转换为 <code>Int16</code>（短整型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToInt32(value)</code></td><td align="left">将指定类型转换为 <code>Int32</code>（整型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToInt64(value)</code></td><td align="left">将指定类型转换为 <code>Int64</code>（长整型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToSByte(value)</code></td><td align="left">将指定类型转换为 <code>SByte</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToSingle(value)</code></td><td align="left">将指定类型转换为 <code>Single</code>（单精度浮点型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToString(value)</code></td><td align="left">将指定类型转换为 <code>String</code></td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToUInt16(value)</code></td><td align="left">将指定类型转换为 <code>UInt16</code>（无符号短整型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToUInt32(value)</code></td><td align="left">将指定类型转换为 <code>UInt32</code>（无符号整型）</td></tr><tr><td align="left"></td><td align="left"><code>Convert.ToUInt64(value)</code></td><td align="left">将指定类型转换为 <code>UInt64</code>（无符号长整型）</td></tr><tr><td align="left"><code>Parse</code> 方法</td><td align="left"><code>Boolean.Parse(string)</code></td><td align="left">将字符串解析为 <code>Boolean</code></td></tr><tr><td align="left"></td><td align="left"><code>Byte.Parse(string)</code></td><td align="left">将字符串解析为 <code>Byte</code></td></tr><tr><td align="left"></td><td align="left"><code>Char.Parse(string)</code></td><td align="left">将字符串解析为 <code>Char</code></td></tr><tr><td align="left"></td><td align="left"><code>DateTime.Parse(string)</code></td><td align="left">将字符串解析为 <code>DateTime</code></td></tr><tr><td align="left"></td><td align="left"><code>Decimal.Parse(string)</code></td><td align="left">将字符串解析为 <code>Decimal</code></td></tr><tr><td align="left"></td><td align="left"><code>Double.Parse(string)</code></td><td align="left">将字符串解析为 <code>Double</code></td></tr><tr><td align="left"></td><td align="left"><code>Int16.Parse(string)</code></td><td align="left">将字符串解析为 <code>Int16</code></td></tr><tr><td align="left"></td><td align="left"><code>Int32.Parse(string)</code></td><td align="left">将字符串解析为 <code>Int32</code></td></tr><tr><td align="left"></td><td align="left"><code>Int64.Parse(string)</code></td><td align="left">将字符串解析为 <code>Int64</code></td></tr><tr><td align="left"></td><td align="left"><code>SByte.Parse(string)</code></td><td align="left">将字符串解析为 <code>SByte</code></td></tr><tr><td align="left"></td><td align="left"><code>Single.Parse(string)</code></td><td align="left">将字符串解析为 <code>Single</code></td></tr><tr><td align="left"></td><td align="left"><code>UInt16.Parse(string)</code></td><td align="left">将字符串解析为 <code>UInt16</code></td></tr><tr><td align="left"></td><td align="left"><code>UInt32.Parse(string)</code></td><td align="left">将字符串解析为 <code>UInt32</code></td></tr><tr><td align="left"></td><td align="left"><code>UInt64.Parse(string)</code></td><td align="left">将字符串解析为 <code>UInt64</code></td></tr><tr><td align="left"><code>TryParse</code> 方法</td><td align="left"><code>Boolean.TryParse(string, out bool)</code></td><td align="left">尝试将字符串解析为 <code>Boolean</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Byte.TryParse(string, out byte)</code></td><td align="left">尝试将字符串解析为 <code>Byte</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Char.TryParse(string, out char)</code></td><td align="left">尝试将字符串解析为 <code>Char</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>DateTime.TryParse(string, out DateTime)</code></td><td align="left">尝试将字符串解析为 <code>DateTime</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Decimal.TryParse(string, out decimal)</code></td><td align="left">尝试将字符串解析为 <code>Decimal</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Double.TryParse(string, out double)</code></td><td align="left">尝试将字符串解析为 <code>Double</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Int16.TryParse(string, out short)</code></td><td align="left">尝试将字符串解析为 <code>Int16</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Int32.TryParse(string, out int)</code></td><td align="left">尝试将字符串解析为 <code>Int32</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Int64.TryParse(string, out long)</code></td><td align="left">尝试将字符串解析为 <code>Int64</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>SByte.TryParse(string, out sbyte)</code></td><td align="left">尝试将字符串解析为 <code>SByte</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>Single.TryParse(string, out float)</code></td><td align="left">尝试将字符串解析为 <code>Single</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>UInt16.TryParse(string, out ushort)</code></td><td align="left">尝试将字符串解析为 <code>UInt16</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>UInt32.TryParse(string, out uint)</code></td><td align="left">尝试将字符串解析为 <code>UInt32</code>，返回布尔值表示是否成功</td></tr><tr><td align="left"></td><td align="left"><code>UInt64.TryParse(string, out ulong)</code></td><td align="left">尝试将字符串解析为 <code>UInt64</code>，返回布尔值表示是否成功</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#数据类型</title>
    <link href="/posts/33099/"/>
    <url>/posts/33099/</url>
    
    <content type="html"><![CDATA[<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C# 数据类型"></a>C# 数据类型</h1><p>在 C# 中，变量分为以下几种类型：</p><ul><li>值类型（Value types）</li><li>引用类型（Reference types）</li><li>指针类型（Pointer types）</li></ul><h2 id="值类型（Value-types）"><a href="#值类型（Value-types）" class="headerlink" title="值类型（Value types）"></a>值类型（Value types）</h2><p>值类型变量可以直接分配给一个值。它们是从类 <strong>System.ValueType</strong> 中派生的。</p><p>值类型直接包含数据。比如 <strong>int、char、float</strong>，它们分别存储数字、字符、浮点数。当您声明一个 <strong>int</strong> 类型时，系统分配内存来存储值。</p><p>下表列出了 C# 2010 中可用的值类型：</p><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+&#x2F;-)5.0 x 10-324 到 (+&#x2F;-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><p>如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 <strong>sizeof</strong> 方法。表达式 <em>sizeof(type)</em> 产生以字节为单位存储对象或类型的存储尺寸。下面举例获取任何机器上 <em>int</em> 类型的存储尺寸：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DataTypeApplication</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>   &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         Console.WriteLine(<span class="hljs-string">&quot;Size of int: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>));<br>         Console.ReadLine();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Size of <span class="hljs-built_in">int</span>: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="引用类型（Reference-types）"><a href="#引用类型（Reference-types）" class="headerlink" title="引用类型（Reference types）"></a>引用类型（Reference types）</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> obj;<br>obj = <span class="hljs-number">100</span>; <span class="hljs-comment">// 这是装箱</span><br></code></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">String str = <span class="hljs-string">&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-string">@&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;C:\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;C:\\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="hljs-string">    &lt;!--</span><br><span class="hljs-string">    --&gt;</span><br><span class="hljs-string">&lt;/script&gt;&quot;</span>;<br></code></pre></td></tr></table></figure><p>用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（Pointer-types）"><a href="#指针类型（Pointer-types）" class="headerlink" title="指针类型（Pointer types）"></a>指针类型（Pointer types）</h2><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span>* identifier;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">char</span>* cptr;<br><span class="hljs-built_in">int</span>* iptr;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在 Cocos Creator 中优化 Spine 动画</title>
    <link href="/posts/59850/"/>
    <url>/posts/59850/</url>
    
    <content type="html"><![CDATA[<h3 id="如何在-Cocos-Creator-中优化-Spine-动画：针对-MMORPG-游戏的实践"><a href="#如何在-Cocos-Creator-中优化-Spine-动画：针对-MMORPG-游戏的实践" class="headerlink" title="如何在 Cocos Creator 中优化 Spine 动画：针对 MMORPG 游戏的实践"></a><strong>如何在 Cocos Creator 中优化 Spine 动画：针对 MMORPG 游戏的实践</strong></h3><p>在开发 <strong>MMORPG</strong> 游戏时，角色的动画效果往往由 <strong>Spine</strong> 动画控制。随着游戏角色和场景的增多，动画的数量也会迅速增加，如何优化大量 <strong>Spine 动画</strong> 的性能，成为开发过程中亟待解决的问题。</p><p>本文将探讨在 <strong>Cocos Creator</strong> 中如何优化 <strong>Spine 动画</strong>，包括资源共享、动态加载、减少纹理分辨率、动画更新频率降低、剔除不可见动画以及其他优化手段，以提高游戏性能和流畅度。</p><hr><h3 id="1-资源共享与动态加载"><a href="#1-资源共享与动态加载" class="headerlink" title="1. 资源共享与动态加载"></a><strong>1. 资源共享与动态加载</strong></h3><p>动态加载和卸载资源是减少内存占用和避免资源浪费的重要手段。在 <strong>MMORPG</strong> 游戏中，不可能在一开始就加载所有 <strong>Spine</strong> 动画，动态加载和卸载 <strong>Spine 动画资源</strong> 是必不可少的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 动态加载 Spine 动画资源</span><br>cc.<span class="hljs-property">resources</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;spine/character_animation&#x27;</span>, cc.<span class="hljs-property">sp</span>.<span class="hljs-property">SkeletonData</span>, <span class="hljs-function">(<span class="hljs-params">err, skeletonData</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to load Spine resource:&#x27;</span>, err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> skeletonNode = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character&#x27;</span>);<br>    <span class="hljs-keyword">let</span> spine = skeletonNode.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br>    spine.<span class="hljs-property">skeletonData</span> = skeletonData;<br>    <br>    <span class="hljs-comment">// 设置动画播放</span><br>    spine.<span class="hljs-title function_">setAnimation</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;run&#x27;</span>, <span class="hljs-literal">true</span>);<br>    <br>    <span class="hljs-comment">// 将角色添加到场景中</span><br>    cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode);<br>&#125;);<br><br><span class="hljs-comment">// 在场景中卸载不再需要的 Spine 动画</span><br>cc.<span class="hljs-property">resources</span>.<span class="hljs-title function_">release</span>(<span class="hljs-string">&#x27;spine/character_animation&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-减少纹理分辨率与打包"><a href="#2-减少纹理分辨率与打包" class="headerlink" title="2. 减少纹理分辨率与打包"></a><strong>2. 减少纹理分辨率与打包</strong></h3><p>在 <strong>Cocos Creator</strong> 中，我们可以通过将多个 <strong>Spine 动画</strong> 的纹理打包成 <strong>SpriteAtlas</strong> 来减少纹理切换，提高渲染性能。这对于 <strong>MMORPG</strong> 游戏尤其重要，因为角色数量庞大，减少纹理切换会显著提升游戏性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 加载纹理图集</span><br>cc.<span class="hljs-property">resources</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;spine/character_atlas&#x27;</span>, cc.<span class="hljs-property">SpriteAtlas</span>, <span class="hljs-function">(<span class="hljs-params">err, atlas</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to load texture atlas:&#x27;</span>, err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> skeletonNode = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character&#x27;</span>);<br>    <span class="hljs-keyword">let</span> spine = skeletonNode.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br>    <br>    <span class="hljs-comment">// 设置纹理图集</span><br>    spine.<span class="hljs-title function_">setAttachment</span>(<span class="hljs-string">&#x27;body&#x27;</span>, atlas.<span class="hljs-title function_">getSpriteFrame</span>(<span class="hljs-string">&#x27;body&#x27;</span>));<br>    spine.<span class="hljs-title function_">setAttachment</span>(<span class="hljs-string">&#x27;head&#x27;</span>, atlas.<span class="hljs-title function_">getSpriteFrame</span>(<span class="hljs-string">&#x27;head&#x27;</span>));<br><br>    cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-减少骨骼数量与精简动画"><a href="#3-减少骨骼数量与精简动画" class="headerlink" title="3. 减少骨骼数量与精简动画"></a><strong>3. 减少骨骼数量与精简动画</strong></h3><p>减少每个角色的骨骼数量可以大大减少渲染负担。精简动画中不必要的骨骼节点，或许可以通过隐藏不必要的骨骼来提高性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 动态设置骨骼节点（例如仅启用少数几个关键骨骼）</span><br><span class="hljs-keyword">let</span> spine = skeletonNode.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br>spine.<span class="hljs-property">skeletonData</span> = skeletonData;<br><br><span class="hljs-comment">// 禁用一些不必要的骨骼</span><br>spine.<span class="hljs-property">skeleton</span>.<span class="hljs-title function_">setSlotVisible</span>(<span class="hljs-string">&#x27;extra_bone&#x27;</span>, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 隐藏不必要的骨骼</span><br></code></pre></td></tr></table></figure><h3 id="4-动画更新频率降低"><a href="#4-动画更新频率降低" class="headerlink" title="4. 动画更新频率降低"></a><strong>4. 动画更新频率降低</strong></h3><p>如果某些动画不需要每帧更新，降低动画的更新频率也是优化性能的一种手段。可以通过降低动画的 <code>timeScale</code> 或定时更新动画来减少性能开销。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 控制 Spine 动画的更新频率（例如：每 2 帧更新一次）</span><br><span class="hljs-keyword">let</span> spine = skeletonNode.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br>spine.<span class="hljs-property">skeletonData</span> = skeletonData;<br>spine.<span class="hljs-title function_">setAnimation</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;idle&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置更新间隔（比如每两帧更新一次）</span><br>cc.<span class="hljs-property">game</span>.<span class="hljs-title function_">on</span>(cc.<span class="hljs-property">game</span>.<span class="hljs-property">EVENT_HIDE</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    spine.<span class="hljs-property">timeScale</span> = <span class="hljs-number">0.5</span>;  <span class="hljs-comment">// 减慢更新频率</span><br>&#125;);<br><br>cc.<span class="hljs-property">game</span>.<span class="hljs-title function_">on</span>(cc.<span class="hljs-property">game</span>.<span class="hljs-property">EVENT_SHOW</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    spine.<span class="hljs-property">timeScale</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 恢复正常更新频率</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-剔除不可见的-Spine-动画"><a href="#5-剔除不可见的-Spine-动画" class="headerlink" title="5. 剔除不可见的 Spine 动画"></a><strong>5. 剔除不可见的 Spine 动画</strong></h3><p>为了减少不必要的计算和渲染，可以根据角色是否在视野内来动态控制 <strong>Spine 动画</strong> 的启用与禁用。如果角色不在视野内，则暂停或销毁该动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 检查角色是否在视野内</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkIfInView</span>(<span class="hljs-params">characterNode</span>) &#123;<br>    <span class="hljs-keyword">let</span> camera = cc.<span class="hljs-property">Camera</span>.<span class="hljs-property">main</span>;<br>    <span class="hljs-keyword">let</span> worldPos = characterNode.<span class="hljs-title function_">convertToWorldSpaceAR</span>(cc.<span class="hljs-title function_">v2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> viewRect = cc.<span class="hljs-property">view</span>.<span class="hljs-title function_">getVisibleSize</span>();<br>    <br>    <span class="hljs-comment">// 假设角色范围在视野矩形范围内</span><br>    <span class="hljs-keyword">if</span> (worldPos.<span class="hljs-property">x</span> &lt; <span class="hljs-number">0</span> || worldPos.<span class="hljs-property">x</span> &gt; viewRect.<span class="hljs-property">width</span> || worldPos.<span class="hljs-property">y</span> &lt; <span class="hljs-number">0</span> || worldPos.<span class="hljs-property">y</span> &gt; viewRect.<span class="hljs-property">height</span>) &#123;<br>        characterNode.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 不在视野内，禁用动画</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        characterNode.<span class="hljs-property">active</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 在视野内，启用动画</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-异步加载和缓存动画数据"><a href="#6-异步加载和缓存动画数据" class="headerlink" title="6. 异步加载和缓存动画数据"></a><strong>6. 异步加载和缓存动画数据</strong></h3><p>通过异步加载和缓存已经加载的 <strong>Spine 动画资源</strong>，避免重复加载资源，提升效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异步加载 Spine 动画资源</span><br>cc.<span class="hljs-property">resources</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;spine/character_animation&#x27;</span>, cc.<span class="hljs-property">sp</span>.<span class="hljs-property">SkeletonData</span>, <span class="hljs-function">(<span class="hljs-params">err, skeletonData</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to load Spine resource:&#x27;</span>, err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 缓存加载的数据</span><br>    <span class="hljs-keyword">let</span> cachedSkeletonData = skeletonData;<br>    <br>    <span class="hljs-comment">// 创建并播放 Spine 动画</span><br>    <span class="hljs-keyword">let</span> skeletonNode = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character&#x27;</span>);<br>    <span class="hljs-keyword">let</span> spine = skeletonNode.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br>    spine.<span class="hljs-property">skeletonData</span> = cachedSkeletonData;<br>    spine.<span class="hljs-title function_">setAnimation</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;attack&#x27;</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 添加到场景中</span><br>    cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode);<br>&#125;);<br><br><span class="hljs-comment">// 卸载不再需要的 Spine 资源</span><br>cc.<span class="hljs-property">resources</span>.<span class="hljs-title function_">release</span>(<span class="hljs-string">&#x27;spine/character_animation&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="7-合并多个-Spine-动画的渲染"><a href="#7-合并多个-Spine-动画的渲染" class="headerlink" title="7. 合并多个 Spine 动画的渲染"></a><strong>7. 合并多个 Spine 动画的渲染</strong></h3><p>如果多个 <strong>Spine 动画</strong> 使用相同的资源，可以通过合并多个动画的渲染来减少渲染调用，从而提高性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过批量渲染合并多个角色的 Spine 动画</span><br><span class="hljs-keyword">let</span> skeletonNode1 = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character1&#x27;</span>);<br><span class="hljs-keyword">let</span> skeletonNode2 = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character2&#x27;</span>);<br><span class="hljs-keyword">let</span> skeletonNode3 = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">Node</span>(<span class="hljs-string">&#x27;Character3&#x27;</span>);<br><br><span class="hljs-comment">// 添加 Spine 组件</span><br><span class="hljs-keyword">let</span> spine1 = skeletonNode1.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br><span class="hljs-keyword">let</span> spine2 = skeletonNode2.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br><span class="hljs-keyword">let</span> spine3 = skeletonNode3.<span class="hljs-title function_">addComponent</span>(cc.<span class="hljs-property">sp</span>.<span class="hljs-property">Skeleton</span>);<br><br><span class="hljs-comment">// 设置相同的 SkeletonData（可以复用相同的资源）</span><br>spine1.<span class="hljs-property">skeletonData</span> = skeletonData1;<br>spine2.<span class="hljs-property">skeletonData</span> = skeletonData2;<br>spine3.<span class="hljs-property">skeletonData</span> = skeletonData3;<br><br>cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode1);<br>cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode2);<br>cc.<span class="hljs-property">director</span>.<span class="hljs-title function_">getScene</span>().<span class="hljs-title function_">addChild</span>(skeletonNode3);<br></code></pre></td></tr></table></figure><h3 id="8-利用-Cocos-Creator-的性能工具"><a href="#8-利用-Cocos-Creator-的性能工具" class="headerlink" title="8. 利用 Cocos Creator 的性能工具"></a><strong>8. 利用 Cocos Creator 的性能工具</strong></h3><p>使用 <strong>Cocos Creator</strong> 内置的 <strong>性能调试工具</strong>（Profiler）来分析和优化 <strong>Spine 动画</strong> 的性能瓶颈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 启用性能分析</span><br>cc.<span class="hljs-property">game</span>.<span class="hljs-title function_">setFPS</span>(<span class="hljs-number">60</span>);  <span class="hljs-comment">// 设置帧率</span><br>cc.<span class="hljs-property">profiler</span>.<span class="hljs-title function_">enable</span>();<br><br><span class="hljs-comment">// 在调试时查看性能数据</span><br>cc.<span class="hljs-property">profiler</span>.<span class="hljs-title function_">printStats</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <strong>资源共享</strong>、<strong>动态加载</strong>、<strong>减少纹理分辨率</strong>、<strong>减少骨骼和更新频率</strong>、<strong>剔除不可见动画</strong> 等优化手段，开发者可以在 <strong>Cocos Creator</strong> 中有效优化 <strong>Spine 动画</strong> 的性能，特别是在 <strong>MMORPG</strong> 游戏中，确保流畅的游戏体验。使用合适的技术手段和工具可以大大提升游戏的帧率，并减少因大量动画资源加载而带来的性能瓶颈。</p><p>希望本文的内容能够帮助你在开发 <strong>MMORPG</strong> 游戏时，提高 <strong>Spine 动画</strong> 的渲染效率和游戏性能，打造更加流畅和高效的游戏体验！</p>]]></content>
    
    
    <categories>
      
      <category>Cocos Creator</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos Creator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameFramework界面（UI）</title>
    <link href="/posts/3278/"/>
    <url>/posts/3278/</url>
    
    <content type="html"><![CDATA[<h2 id="UI模块结构"><a href="#UI模块结构" class="headerlink" title="UI模块结构"></a>UI模块结构</h2><p><img src="/posts/3278/1.jpg" alt="1"></p><h2 id="UIGroup"><a href="#UIGroup" class="headerlink" title="UIGroup"></a>UIGroup</h2><p>UIGroup是GF的UI模块的一大功能，它提供了游戏中常见的<strong>UI栈</strong>。当不同的UIForm实例处于同一个UIGroup中时，会以栈的形式维护它们的层级和生命周期。在一个UIGroup中，永远只有一个UIForm处于最上层，已存在的界面会被新打开的界面覆盖，并且会收到被覆盖事件。UIGroup内部通过链表的方式管理，表头代表栈顶，表尾代表栈底。这样的设计允许激活任意界面到最上层，增加业务的灵活性。</p><p>当一系列相关联的UI需要在<strong>同一时刻只有一个处于最上层</strong>，并且需要感知相互间的打开关闭状态时，可以将它们归到同一个UIGroup中。</p><p>UIGroup直接由UIManager管理，各个UIGroup管理各自的UIForm。</p><h3 id="对外属性"><a href="#对外属性" class="headerlink" title="对外属性"></a>对外属性</h3><ul><li><strong>Name</strong>：UIGroup的名字</li><li><strong>Depth</strong>：UIGroup的深度（可动态设置）</li><li><strong>Pause</strong>：UIGroup的暂停状态（可动态设置）</li><li><strong>UIFormCount</strong>：包含的界面数量</li><li><strong>CurrentUIForm</strong>：当前最上层的界面</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><strong>GetUIForm</strong>、<strong>GetUIForms</strong>、<strong>GetAllUIForms</strong>：获取UIGroup中的UIForm。</li><li><strong>AddUIForm</strong>、<strong>RemoveUIForm</strong>：在打开和关闭界面时，把UIForm从UIGroup中添加或移除。</li><li><strong>RefocusUIForm</strong>：激活UIGroup中任意界面到最上层。</li><li><strong>Refresh</strong>：UIGroup的核心逻辑，根据链表顺序及UIForm的属性，调用UIForm的<code>OnDepthChanged</code>、<code>OnCover</code>、<code>OnReveal</code>、<code>OnPause</code>、<code>OnResume</code>等方法。</li></ul><h3 id="UIFormInfo"><a href="#UIFormInfo" class="headerlink" title="UIFormInfo"></a>UIFormInfo</h3><p>UIGroup的内部类。UIGroup不直接引用UIForm，而是引用UIFormInfo。UIFormInfo包含了UIForm的引用，以及<code>Paused</code>和<code>Covered</code>两个状态。这些状态通过UIFormInfo包装，方便在Refresh操作时知道UIForm的状态。</p><h2 id="UIForm"><a href="#UIForm" class="headerlink" title="UIForm"></a>UIForm</h2><p>UIForm是UI窗口类，被UIGroup直接管理，每个UI窗口都会有一个UIForm实例。</p><h3 id="类内信息"><a href="#类内信息" class="headerlink" title="类内信息"></a>类内信息</h3><ul><li><strong>SerialId：</strong>该UI实例的序列ID，每个界面被打开之后，关闭之前都有一个唯一的序列ID，主要是作为相同UI面板的不同实例、界面关闭被对象池回收后又取出来作为新界面打开等情况下的唯一标识。</li><li><strong>UIFormAssetName：</strong>界面预制体的资源路径。</li><li><strong>Handle：</strong>界面的GameObject对象，Handle返回的是Object类型，因为GameObject对象需要被UIManager内部的对象池回收，而UIManager处于GF层，是不会对Unity的类型“GameObject”感知的，所以这里以Object类型来持有。</li><li><strong>UIGroup：</strong>所属的UIGroup。</li><li><strong>DepthInUIGroup：</strong>这个界面在UIGroup中的深度。</li><li><strong>PauseCoveredUIForm：</strong>当这个值为True的时候，打开这个界面，在UIGroup的<a href="https://zhida.zhihu.com/search?content_id=184605643&content_type=Article&match_order=2&q=%E6%A0%88%E7%BB%93%E6%9E%84&zhida_source=entity">栈结构</a>中，比这个界面低（更接近栈底）的UIForm，会被调用OnPause，而关闭这个界面时，比这个界面低（更接近栈底）的UIForm，会被调用OnResume。</li><li><strong>Logic：</strong>该UI的具体逻辑类UIFormLogic</li></ul><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><a href="https://zhida.zhihu.com/search?content_id=184605643&content_type=Article&match_order=1&q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95&zhida_source=entity">生命周期方法</a></h3><ul><li><p>OnInit &amp; OnRecycle</p></li><li><ul><li>OnInit：调用UIManager的OpenUIForm初次打开UI时被调用</li><li>OnRecycle：调用UIManager的CloseUIForm关闭UI时被调用</li></ul></li><li><p>OnOpen &amp; OnClose</p></li><li><ul><li>OnOpen：调用UIManager的OpenUIForm初次打开UI时被调用，在OnInit之后</li><li>OnClose：调用UIManager的CloseUIForm关闭UI时被调用，在OnRecycle之前</li></ul></li><li><p>OnCover &amp; OnReveal</p></li><li><ul><li>OnCover：同一个UIGroup中，有其他界面覆盖到这个界面后，被调用</li><li>OnReveal：同一个UIGroup中，这个界面从被覆盖的状态恢复到处于最上层后，被调用</li></ul></li><li><p>OnPause &amp; OnResume</p></li><li><ul><li>OnPause：当UIGroup的Pause属性被设置为True时，UIGroup中的所有UIForm的OnPause都被调用，或者当界面被另一个属性PauseCoveredUIForm为True的界面覆盖且当前界面Pause状态为False时，OnPause被调用</li><li>OnResume：当界面Pause状态为True时，从被其他属性PauseCoveredUIForm为True的界面取消覆盖，且所属UIGroup的Pause属性也为False的时候，OnResume被调用</li></ul></li><li><p>OnUpdate：界面打开后，只要不处于Pause状态，就会被每帧调用</p></li></ul><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul><li>OnDepthChanged：当界面在当前的UIGroup中的深度发生变化时，被调用</li><li>OnRefocus：当界面被强制（不遵循栈的规则，从不靠近栈顶的位置，直接回到栈顶）聚焦时，会被调用</li></ul><h2 id="UIFormLogic"><a href="#UIFormLogic" class="headerlink" title="UIFormLogic"></a>UIFormLogic</h2><p><img src="/posts/3278/2.jpg" alt="2"></p><p>UIFormLogic为UI界面的具体逻辑类，类内有UIForm的所有生命周期方法，与之一一对应，框架将会调用到UIForm里的生命周期方法，而UIForm再调用到UIFormLogic中对应的方法，游戏业务层不对UIForm做扩展，而是对UIFormLogic继承进行扩展，可以根据具体使用的UI方案（ugui或ngui或其他）来继承UIFormLogic实现相应的UguiForm类等，而游戏中各个具体窗口再继承这个UI方案类，实现界面的具体逻辑。</p><h2 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h2><p>UIManager是外部访问框架UI模块的入口。</p><h3 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h3><p>提供HasUIGroup、GetUIGroup、GetAllUIGroups、HasUIForm、GetUIForm、GetUIForms、GetAllLoadedUIForms、GetAllLoadingUIFormSerialIds、IsLoadingUIForm、IsValidUIForm方法以对UIGroup和UIForm进行查询。</p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>提供AddUIGroup、OpenUIForm、CloseUIForm、CloseAllLoadedUIForms、CloseAllLoadingUIForms、RefocusUIForm对UIGroup和UIForm进行操作。</p><h3 id="UIGroup的管理"><a href="#UIGroup的管理" class="headerlink" title="UIGroup的管理"></a>UIGroup的管理</h3><p>UIManager内部以Dictionary字典结构来储存所有UIGroup，UIManager的Update方法中会遍历这个字典，调用所有UIGroup的Update方法，而UIGroup的Update方法再调用UIForm的Update方法。</p><p>UIManager对外提供的UIForm相关的查询方法，都会遍历这个字典，从所有UIGroup找出一个或所有符合条件的UIForm。</p><h3 id="UIManager的资源管理"><a href="#UIManager的资源管理" class="headerlink" title="UIManager的资源管理"></a>UIManager的资源管理</h3><p>UIManager内部会用GF的对象池模块创建一个对象池，用于缓存UIForm对象的GameObject实例，外部调用OpenUIForm来打开UI时，会先尝试从对象池获取该界面，若对象池中有同类型的空闲实例，则直接取出使用，若没有则从资源模块加载，加载成功后，会注册到对象池中，再交给UIManager使用。而调用CloseUIForm来关闭UI时，UIForm会被加到Queue类型的字段m_RecycleQueue中，在下一次Update时，会把队列所有元素取出，回收到对象池中。</p><h3 id="UIManager中的m-Serial"><a href="#UIManager中的m-Serial" class="headerlink" title="UIManager中的m_Serial"></a>UIManager中的m_Serial</h3><p>UIManager内维护了一个私有字段m_Serial，每次调用OpenUIForm的时候，m_Serial都会自增1，他表示了每个UIForm在其生命周期内的唯一<a href="https://zhida.zhihu.com/search?content_id=184605643&content_type=Article&match_order=1&q=%E6%A0%87%E8%AF%86%E7%AC%A6&zhida_source=entity">标识符</a>，即使是同一个UIForm实例，被关闭后放回对象池，再被取出来使用，其m_Serial也会发生变化，而且m_Serial在调用OpenUIForm时立刻生成，不需要等资源加载完毕。</p><h3 id="OpenUIForm流程"><a href="#OpenUIForm流程" class="headerlink" title="OpenUIForm流程"></a>OpenUIForm流程</h3><p><img src="/posts/3278/3.jpg" alt="3"></p><ol><li>调用UIManager的OpenUIForm接口</li><li>尝试从对象池生成对应的UIForm的GameObject</li></ol><ul><li>若从对象池取出成功，则直接跳至步骤5</li><li>若失败，则到步骤3</li></ul><ol><li>把这次加载UIForm的序列Id记得到m_UIFormsBeingLoaded中</li><li>通过资源模块加载UIForm的资源</li></ol><ul><li>若加载成功，从m_UIFormsBeingLoaded移除这次加载的UIForm的序列Id，把加载出来的资源注册到对象池中，跳到步骤5</li><li>若加载失败，从m_UIFormsBeingLoaded移除这次加载的UIForm的序列Id，并抛出错误，终止流程</li></ul><ol><li>调用UIManager的InternalOpenUIForm，先调用UIForm的OnInit，然后找到把UIForm加入对应的UIGroup中，再调用UIForm的Open，然后调用UIGroup的Refresh，Refresh内部再调用UIForm的OnReveal、OnResume</li></ol><h3 id="CloseUIForm流程"><a href="#CloseUIForm流程" class="headerlink" title="CloseUIForm流程"></a>CloseUIForm流程</h3><p><img src="/posts/3278/4.jpg" alt="4"></p><ol><li>调用UIManager的CloseUIForm接口</li><li>判断这个UIForm是否处于加载中（只有通过序列Id来关闭，才会有这个步骤，若通过UIForm关闭，则直接走步骤3）</li></ol><ul><li>正在加载中：m_UIFormsToReleaseOnLoad和m_UIFormsBeingLoaded都加入UIForm的序列Id，终止流程</li><li>不在加载中：跳到步骤3</li></ul><ol><li>从UIGroup中移除该UIForm，并调用UIForm的OnClose后，调用UIGroup的Refresh，Refresh内部再调用UIForm的OnCover、OnPause</li><li>把UIForm进队m_RecycleQueue</li><li>再下一次Update，会把m_RecycleQueue中所有UIForm出队，并调用OnRecycle方法</li><li>把UIForm归还给<a href="https://zhida.zhihu.com/search?content_id=184605643&content_type=Article&match_order=13&q=%E5%AF%B9%E8%B1%A1%E6%B1%A0&zhida_source=entity">对象池</a></li></ol><h3 id="关闭正在加载的UIForm"><a href="#关闭正在加载的UIForm" class="headerlink" title="关闭正在加载的UIForm"></a>关闭正在加载的UIForm</h3><p>在游戏业务中，如果加载资源方式是<a href="https://zhida.zhihu.com/search?content_id=184605643&content_type=Article&match_order=1&q=%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD&zhida_source=entity">异步加载</a>，那么我们可能会遇到在打开UI后，需要等待一段时间去加载，而在这期间又触发了特定逻辑，需要取消这个界面的打开，GF对这种情况也提供了很好的支持，只需要在调用OpenUIForm时，保存返回的序列Id，调用CloseUIForm传入这个Id，即可在资源加载完成后销毁这个资源（Unity并不支持取消加载，只能在加载后销毁）。</p><p>上文OpenUIForm和CloseUIForm流程中，可以看到有两个特殊字段m_UIFormsBeingLoaded和m_UIFormsToReleaseOnLoad，m_UIFormsBeingLoaded记录了正在加载的Id，而m_UIFormsToReleaseOnLoad记录了需要在加载完毕直接销毁的Id，在CloseUIForm时，会去判断传入的Id是否在m_UIFormsBeingLoaded中，如果是则从其中移除，然后把Id加入到m_UIFormsToReleaseOnLoad中，在资源加载后的回调中，会判断m_UIFormsToReleaseOnLoad是否包含加载的UIForm的Id，若包含则直接销毁，不会走InternalOpenUIForm流程。</p><h2 id="打开单一UIForm的生命周期流程"><a href="#打开单一UIForm的生命周期流程" class="headerlink" title="打开单一UIForm的生命周期流程"></a>打开单一UIForm的生命周期流程</h2><p><img src="/posts/3278/5.jpg" alt="5"></p><h2 id="在同一个UIGroup中相继打开两个UIForm的生命周期流程"><a href="#在同一个UIGroup中相继打开两个UIForm的生命周期流程" class="headerlink" title="在同一个UIGroup中相继打开两个UIForm的生命周期流程"></a>在同一个UIGroup中相继打开两个UIForm的生命周期流程</h2><p><img src="/posts/3278/6.jpg" alt="6"></p><h2 id="UIGroup中刷新UI流程"><a href="#UIGroup中刷新UI流程" class="headerlink" title="UIGroup中刷新UI流程"></a>UIGroup中刷新UI流程</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 刷新界面组。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Refresh</span>()</span><br>&#123;<br>    LinkedListNode&lt;UIFormInfo&gt; current = m_UIFormInfos.First;<br>    <span class="hljs-built_in">bool</span> pause = m_Pause;<br>    <span class="hljs-built_in">bool</span> cover = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">int</span> depth = UIFormCount;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.Value != <span class="hljs-literal">null</span>)<br>    &#123;<br>        LinkedListNode&lt;UIFormInfo&gt; next = current.Next;<br>        current.Value.UIForm.OnDepthChanged(Depth, depth--);<br>        <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pause)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!current.Value.Covered)<br>            &#123;<br>                current.Value.Covered = <span class="hljs-literal">true</span>;<br>                current.Value.UIForm.OnCover();<br>                <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!current.Value.Paused)<br>            &#123;<br>                current.Value.Paused = <span class="hljs-literal">true</span>;<br>                current.Value.UIForm.OnPause();<br>                <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (current.Value.Paused)<br>            &#123;<br>                current.Value.Paused = <span class="hljs-literal">false</span>;<br>                current.Value.UIForm.OnResume();<br>                <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (current.Value.UIForm.PauseCoveredUIForm)<br>            &#123;<br>                pause = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cover)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!current.Value.Covered)<br>                &#123;<br>                    current.Value.Covered = <span class="hljs-literal">true</span>;<br>                    current.Value.UIForm.OnCover();<br>                    <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (current.Value.Covered)<br>                &#123;<br>                    current.Value.Covered = <span class="hljs-literal">false</span>;<br>                    current.Value.UIForm.OnReveal();<br>                    <span class="hljs-keyword">if</span> (current.Value == <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br><br>                cover = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        current = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts/3278/7.jpg" alt="7"></p><p>UIGroup中的Refresh方法的具体实现，个人认为是UI模块中最值得拿出来细读的一段代码，该方法以正序遍历内部链表结构，也就是从层级最高的界面逐个迭代到层级最低的界面，并根据实际情况调用UIForm的生命周期方法。</p><p>注意上面流程图中条件判断包括有Covered、Paused和cover、pause，Covered、Paused是指当前正在迭代的UIForm的状态，根据其状态决定是否需要执行OnCover、OnPause、OnReveal、OnResume，而cover和pause是记录着从第一次迭代开始就记录着的状态，只要迭代过程中出现过一次true，则后面的迭代中cover或pause肯定为true，因为上面的界面处于Covered或Paused状态时，下面的界面必然也处于Covered或Paused状态，所以cover或pause肯定为true时，不会执行OnReveal或OnResume。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity游戏框架</category>
      
      <category>GameFramework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameFramework简介</title>
    <link href="/posts/1966/"/>
    <url>/posts/1966/</url>
    
    <content type="html"><![CDATA[<h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><p>官方博客：<a href="https://link.zhihu.com/?target=https://gameframework.cn/">https://gameframework.cn</a><br>        Github地址：<a href="https://github.com/EllanJiang/GameFramework/">https://github.com/EllanJiang/GameFramework/</a></p><ul><li><strong>English</strong> - Coming soon.</li><li><strong>简体中文</strong> - <a href="https://gameframework.cn/">https://gameframework.cn/</a><ul><li><strong>QQ 讨论群</strong> 216332935</li></ul></li></ul><hr><p><img src="https://gameframework.cn/image/gameframework.png" alt="Game Framework"></p><hr><h2 id="Game-Framework-简介"><a href="#Game-Framework-简介" class="headerlink" title="Game Framework 简介"></a>Game Framework 简介</h2><p>Game Framework 是一个基于 Unity 引擎的游戏框架，主要对游戏开发过程中常用模块进行了封装，很大程度地规范开发过程、加快开发速度并保证产品质量。</p><p>在最新的 Game Framework 版本中，包含以下 19 个内置模块，后续我们还将开发更多的扩展模块供开发者使用。</p><ol><li><p><strong>全局配置 (Config)</strong> - 存储一些全局的只读的游戏配置，如玩家初始速度、游戏初始音量等。</p></li><li><p><strong>数据结点 (Data Node)</strong> - 将任意类型的数据以树状结构的形式进行保存，用于管理游戏运行时的各种数据。</p></li><li><p><strong>数据表 (Data Table)</strong> - 可以将游戏数据以表格（如 Microsoft Excel）的形式进行配置后，使用此模块使用这些数据表。数据表的格式是可以自定义的。</p></li><li><p><strong>调试器 (Debugger)</strong> - 当游戏在 Unity 编辑器中运行或者以 Development 方式发布运行时，将出现调试器窗口，便于查看运行时日志、调试信息等。用户还可以方便地将自己的功能注册到调试器窗口上并使用。</p></li><li><p><strong>下载 (Download)</strong> - 提供下载文件的功能，支持断点续传，并可指定允许几个下载器进行同时下载。更新资源时会主动调用此模块。</p></li><li><p><strong>实体 (Entity)</strong> - 我们将游戏场景中，动态创建的一切物体定义为实体。此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。实体使用结束后可以不立刻销毁，从而等待下一次重新使用。</p></li><li><p><strong>事件 (Event)</strong> - 游戏逻辑监听、抛出事件的机制。Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。用户也可以定义自己的游戏逻辑事件。</p></li><li><p><strong>文件系统 (File System)</strong> - 虚拟文件系统使用类似磁盘的概念对零散文件进行集中管理，优化资源加载时产生的内存分配，甚至可以对资源进行局部片段加载，这些都将极大提升资源加载时的性能。</p></li><li><p><strong>有限状态机 (FSM)</strong> - 提供创建、使用和销毁有限状态机的功能，一些适用于有限状态机机制的游戏逻辑，使用此模块将是一个不错的选择。</p></li><li><p><strong>本地化 (Localization)</strong> - 提供本地化功能，也就是我们平时所说的多语言。Game Framework 在本地化方面，不但支持文本的本地化，还支持任意资源的本地化，比如游戏中释放烟花特效也可以做出几个多国语言的版本，使得中文版里是“新年好”字样的特效，而英文版里是“Happy New Year”字样的特效。</p></li><li><p><strong>网络 (Network)</strong> - 提供使用 Socket 长连接的功能，当前我们支持 TCP 协议，同时兼容 IPv4 和 IPv6 两个版本。用户可以同时建立多个连接与多个服务器同时进行通信，比如除了连接常规的游戏服务器，还可以连接语音聊天服务器。如果想接入 ProtoBuf 之类的协议库，只要派生自 Packet 类并实现自己的消息包类即可使用。</p></li><li><p><strong>对象池 (Object Pool)</strong> - 提供对象缓存池的功能，避免频繁地创建和销毁各种游戏对象，提高游戏性能。除了 Game Framework 自身使用了对象池，用户还可以很方便地创建和管理自己的对象池。</p></li><li><p><strong>流程 (Procedure)</strong> - 是贯穿游戏运行时整个生命周期的有限状态机。通过流程，将不同的游戏状态进行解耦将是一个非常好的习惯。对于网络游戏，你可能需要如检查资源流程、更新资源流程、检查服务器列表流程、选择服务器流程、登录服务器流程、创建角色流程等流程，而对于单机游戏，你可能需要在游戏选择菜单流程和游戏实际玩法流程之间做切换。如果想增加流程，只要派生自 ProcedureBase 类并实现自己的流程类即可使用。</p></li><li><p><strong>资源 (Resource)</strong> - 为了保证玩家的体验，我们不推荐再使用同步的方式加载资源，由于 Game Framework 自身使用了一套完整的异步加载资源体系，因此只提供了异步加载资源的接口。不论简单的数据表、本地化字典，还是复杂的实体、场景、界面，我们都将使用异步加载。同时，Game Framework 提供了默认的内存管理策略（当然，你也可以定义自己的内存管理策略）。多数情况下，在使用 GameObject 的过程中，你甚至可以不需要自行进行 Instantiate 或者是 Destroy 操作。</p></li><li><p><strong>场景 (Scene)</strong> - 提供场景管理的功能，可以同时加载多个场景，也可以随时卸载任何一个场景，从而很容易地实现场景的分部加载。</p></li><li><p><strong>配置 (Setting)</strong> - 以键值对的形式存储玩家数据，对 UnityEngine.PlayerPrefs 进行封装，也可以将这些数据直接存储在磁盘上。</p></li><li><p><strong>声音 (Sound)</strong> - 提供管理声音和声音组的功能，用户可以自定义一个声音的音量、是 2D 声音还是 3D 声音，甚至是直接绑定到某个实体上跟随实体移动。</p></li><li><p><strong>界面 (UI)</strong> - 提供管理界面和界面组的功能，如显示隐藏界面、激活界面、改变界面层级等。不论是 Unity 内置的 uGUI 还是其它类型的 UI 插件（如 NGUI），只要派生自 UIFormLogic 类并实现自己的界面类即可使用。界面使用结束后可以不立刻销毁，从而等待下一次重新使用。</p></li><li><p><strong>Web 请求 (Web Request)</strong> - 提供使用短连接的功能，可以用 Get 或者 Post 方法向服务器发送请求并获取响应数据，可指定允许几个 Web 请求器进行同时请求。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity游戏框架</category>
      
      <category>GameFramework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 基础知识</title>
    <link href="/posts/27814/"/>
    <url>/posts/27814/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Unity-基础知识"><a href="#1-Unity-基础知识" class="headerlink" title="1. Unity 基础知识"></a><a href="https://yonghengshikong.github.io/posts/39444"><strong>1. Unity 基础知识</strong></a></h3><ul><li><strong>Unity 引擎的架构与工作原理</strong> 介绍 Unity 引擎的架构和工作原理，了解 Unity 的核心模块和功能，包括编辑器、脚本、物理引擎、渲染管线等。<br><strong>子主题：</strong> Unity 编辑器、脚本与组件、GameObject 与 Scene。</li><li><strong>Unity 的生命周期：从初始化到销毁</strong> 讲解 Unity 中的生命周期，如何理解 <code>Awake</code>、<code>Start</code>、<code>Update</code>、<code>LateUpdate</code> 等函数的执行顺序，何时调用它们以及如何使用这些生命周期函数。</li></ul><hr><h3 id="2-Unity-脚本与编程"><a href="#2-Unity-脚本与编程" class="headerlink" title="2. Unity 脚本与编程"></a><a href="https://yonghengshikong.github.io/posts/62789/"><strong>2. Unity 脚本与编程</strong></a></h3><ul><li><strong>Unity 脚本的生命周期与组件化设计</strong> 深入讲解如何在 Unity 中设计可复用的脚本组件，如何管理和调试 Unity 脚本，以及如何使用 C# 编写高效的游戏逻辑。</li><li><strong>Unity 中的事件系统与消息传递</strong> 讲解 Unity 的事件系统，如何实现不同对象间的通信，如何使用 Unity 的消息传递机制（如 <code>SendMessage</code>、<code>BroadcastMessage</code>、<code>Event</code> 等）。</li><li><strong>协程与异步操作的使用</strong> 深入探讨协程（Coroutine）的工作原理，以及如何通过协程进行延时操作、异步加载等任务的管理，提升游戏性能和体验。</li><li><strong>Unity 中的脚本组件化设计与组织</strong> 讲解如何在 Unity 中设计可复用和高效的脚本结构，如何组织项目中的脚本模块，如如何划分游戏逻辑、控制器、视图等职责，保持代码的清晰和易维护性。<br><strong>子主题：</strong> 单例模式、组件化设计、依赖注入。</li><li><strong>脚本性能优化与内存管理</strong> 如何优化脚本中的内存使用，减少 GC（垃圾回收）频率，避免性能瓶颈。通过合理使用对象池、优化循环、减少频繁的内存分配等手段来提升游戏性能。</li></ul><hr><h3 id="3-Unity-渲染与图形"><a href="#3-Unity-渲染与图形" class="headerlink" title="3. Unity 渲染与图形"></a><a href="https://yonghengshikong.github.io/posts/28561/"><strong>3. Unity 渲染与图形</strong></a></h3><ul><li><strong>Unity 渲染管线的原理与优化</strong> 深入讲解 Unity 渲染管线（如 Forward 和 Deferred 渲染），以及如何优化游戏中的渲染性能。<br><strong>子主题：</strong> 渲染队列、材质与 Shader、光照与阴影。</li><li><strong>使用 Shader 实现自定义效果</strong> 介绍如何使用 Shader 编写自定义效果，从基础的顶点着色器到复杂的像素着色器，如何利用 Shader 实现光照、反射、折射等效果。</li></ul><hr><h3 id="4-Unity-动画系统"><a href="#4-Unity-动画系统" class="headerlink" title="4. Unity 动画系统"></a><a href="https://yonghengshikong.github.io/posts/43010/"><strong>4. Unity 动画系统</strong></a></h3><ul><li><strong>Unity 动画系统原理：从动画控制器到动画状态机</strong> 讲解 Unity 动画系统的基础，如何使用 Animator 控制角色动画，如何通过状态机和过渡来管理动画的切换。<br><strong>子主题：</strong> 动画事件、Blend Tree、动态调整动画。</li><li><strong>骨骼动画与物体动画的区别与应用</strong> 深入分析骨骼动画与物体动画的区别，何时使用它们，以及如何在 Unity 中使用这些动画技术进行角色与物体的动画处理。</li></ul><hr><h3 id="5-Unity-UI-与用户体验"><a href="#5-Unity-UI-与用户体验" class="headerlink" title="5. Unity UI 与用户体验"></a><a href="https://yonghengshikong.github.io/posts/63931/"><strong>5. Unity UI 与用户体验</strong></a></h3><ul><li><strong>Unity UI 系统的工作原理与使用技巧</strong> 详细讲解 Unity 的 UI 系统，包括 Canvas、Text、Button、Image 等 UI 组件的使用方法，以及如何通过布局管理器来组织 UI。<br><strong>子主题：</strong> 动态 UI 更新、UI 性能优化、触摸与手势识别。</li><li><strong>UI 动画与交互：提升用户体验</strong> 如何通过动画和交互设计提升游戏 UI 的可用性与美观性，如何利用 <code>Animator</code> 和 <code>CanvasGroup</code> 实现动态 UI 效果。</li></ul><hr><h3 id="6-Unity-物理引擎"><a href="#6-Unity-物理引擎" class="headerlink" title="6. Unity 物理引擎"></a><a href="https://yonghengshikong.github.io/posts/61900/"><strong>6. Unity 物理引擎</strong></a></h3><ul><li><strong>Unity 物理引擎的工作原理与优化</strong> 详细讲解 Unity 中的物理引擎原理，包括碰撞检测、刚体模拟、力和重力等。并讨论如何优化物理计算，提升游戏性能。<br><strong>子主题：</strong> <code>Rigidbody</code>、<code>Collider</code>、<code>OnCollisionEnter</code>、<code>OnTriggerEnter</code>。</li><li><strong>使用力与物理材料实现真实感物理效果</strong> 介绍如何使用物理力、摩擦力、弹性等物理材料，来模拟更加真实的物理效果，如物体的滑动、跳跃、碰撞等。</li></ul><hr><h3 id="7-Unity-网络与多人游戏"><a href="#7-Unity-网络与多人游戏" class="headerlink" title="7. Unity 网络与多人游戏"></a><a href="https://yonghengshikong.github.io/posts/41458/"><strong>7. Unity 网络与多人游戏</strong></a></h3><ul><li><strong>Unity 网络基础：从 Unity Networking 到 Mirror</strong> 讲解 Unity 的网络架构和相关 API，如何使用 Unity Networking 或 Mirror 框架来实现多人在线游戏。<br><strong>子主题：</strong> 网络同步、RPC、服务器与客户端架构。</li><li><strong>Unity 中的 WebSocket 与实时通信</strong> 讲解如何在 Unity 中使用 WebSocket 实现实时通信，如何处理客户端与服务器之间的实时数据传输。</li></ul><hr><h3 id="8-Unity-资源管理与优化"><a href="#8-Unity-资源管理与优化" class="headerlink" title="8. Unity 资源管理与优化"></a><a href="https://yonghengshikong.github.io/posts/58560/"><strong>8. Unity 资源管理与优化</strong></a></h3><ul><li><strong>Unity 资源管理：AssetBundle 与 Addressable</strong> 讲解如何使用 <code>AssetBundle</code> 和 <code>Addressable</code> 系统来优化资源的加载与卸载，如何管理大型项目中的资源。<br><strong>子主题：</strong> 异步加载、资源缓存、内存优化。</li><li><strong>Unity 性能优化：从 CPU 到 GPU</strong> 介绍 Unity 中如何进行性能优化，如何使用 Profiler 工具分析和优化游戏的 CPU 和 GPU 性能。</li></ul><hr><h3 id="9-Unity-存档与数据管理"><a href="#9-Unity-存档与数据管理" class="headerlink" title="9. Unity 存档与数据管理"></a><a href="https://yonghengshikong.github.io/posts/24463/"><strong>9. Unity 存档与数据管理</strong></a></h3><ul><li><strong>Unity 存档系统的设计与实现</strong> 讲解如何设计和实现游戏的存档系统，包括如何保存玩家的进度、物品、关卡等数据，如何使用 <code>PlayerPrefs</code> 和文件系统。</li><li><strong>Unity 中的本地化与国际化支持</strong> 如何通过 Unity 的 Localization Package 来支持多语言和区域设置，如何管理游戏中的文本、图片、音效等多语言资源。</li></ul><hr><h3 id="10-Unity-音频系统"><a href="#10-Unity-音频系统" class="headerlink" title="10. Unity 音频系统"></a><a href="https://yonghengshikong.github.io/posts/63726/"><strong>10. Unity 音频系统</strong></a></h3><ul><li><strong>Unity 音频系统的基础与使用</strong> 介绍 Unity 音频系统的基本原理，如何在游戏中加载和播放音频文件，如何通过 <code>AudioSource</code> 和 <code>AudioClip</code> 进行音频管理。<br><strong>子主题：</strong> 音频播放控制、音效与背景音乐、音量调节、循环播放。</li><li><strong>音频效果与处理：3D 音效与混响</strong> 讲解如何使用 Unity 实现 3D 音效的空间化，包括如何通过 <code>AudioListener</code> 和 <code>AudioSource</code> 实现立体声效和定位音效，如何使用混响、延迟等音频效果来提升沉浸感。</li><li><strong>Unity 中的音频优化技巧</strong> 讨论音频文件的优化，如何使用压缩格式、调整音频质量、控制音频加载和播放的时机，避免音频资源的浪费导致性能问题。</li></ul><hr><h3 id="11-Unity-跨平台与多平台适配"><a href="#11-Unity-跨平台与多平台适配" class="headerlink" title="11. Unity 跨平台与多平台适配"></a><a href="https://yonghengshikong.github.io/posts/4184/"><strong>11. Unity 跨平台与多平台适配</strong></a></h3><ul><li><strong>跨平台开发与构建流程</strong> 如何在 Unity 中开发跨平台游戏，如何处理不同平台之间的差异（如输入、分辨率、性能、内存等），确保游戏在 Android、iOS、PC、Console 等多个平台的兼容性。<br><strong>子主题：</strong> 平台特有 API、平台间差异适配、设备性能优化。</li><li><strong>Unity 中的多分辨率与屏幕适配</strong> 讲解如何使用 Unity 中的 <code>CanvasScaler</code> 和屏幕分辨率适配技术，确保游戏在不同尺寸和分辨率的屏幕上都能有良好的显示效果。</li></ul><hr><h3 id="12-Unity-性能优化与调试"><a href="#12-Unity-性能优化与调试" class="headerlink" title="12. Unity 性能优化与调试"></a><a href="https://yonghengshikong.github.io/posts/16666/"><strong>12. Unity 性能优化与调试</strong></a></h3><ul><li><strong>Unity 性能调试与优化工具</strong> 介绍如何使用 Unity Profiler 进行性能调试，如何通过分析 CPU、GPU、内存和网络的性能来发现和解决性能瓶颈。<br><strong>子主题：</strong> 渲染优化、内存优化、异步加载与对象池。</li><li><strong>常见性能问题与优化策略</strong> 讨论 Unity 中常见的性能问题，如过多的 Draw Call、内存泄漏、频繁的 GC 等，以及如何通过对象池、合批、减小物体多样性等方法进行优化。</li><li><strong>Unity 内存管理与垃圾回收（GC）</strong> 深入讲解 Unity 中的内存管理机制，如何避免 GC 引发的性能问题，如何合理管理资源加载和卸载，使用对象池来减少内存分配。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity TextMeshPro使用中文字体</title>
    <link href="/posts/45197/"/>
    <url>/posts/45197/</url>
    
    <content type="html"><![CDATA[<h1 id="TextMeshPro"><a href="#TextMeshPro" class="headerlink" title="TextMeshPro"></a>TextMeshPro</h1><p>TextMeshPro 是 Unity 新一代字体绘制器，是 Unity 的最终文本解决方案，可完美代替 Unity UI Text 和旧版 Text Mesh。这个字体绘制器功能强大，易于使用，并且性能优秀。目前，TextMeshPro 对中文的支持也较好，但默认状态下不能直接使用，需要自行生成中文字体文件。</p><p>本文就展开 TextMeshPro 中文字体文件的生成方法，并分析可能出现中文乱码的原因。</p><h2 id="中文字体生成方法"><a href="#中文字体生成方法" class="headerlink" title="中文字体生成方法"></a>中文字体生成方法</h2><h3 id="准备字体文件"><a href="#准备字体文件" class="headerlink" title="准备字体文件"></a>准备字体文件</h3><p>首先，准备一个原生的中文字体文件（.ttf、.ttc 格式等）。在 Windows10 操作系统下，可以在 <code>C:\Windows\Fonts</code> 目录中找到许多自带字体文件。找到一个带有中文的字体，按 <code>Ctrl+C</code> 和 <code>Ctrl+V</code> 复制至桌面，就能看到字体文件。</p><p>双击字体文件，可以预览字体。右键选择字体文件属性，如果看到文件大小不到1MB，大概率是没有中文字体的，即使可以预览中文，也是通过其他字体回选（Fallback）完成的。</p><p>下面是一个易于用于 TextMeshPro 生成中文字体的实例：</p><p><img src="/posts/45197/Snipaste_2024-12-27_11-12-11.png"></p><p>上图为微软雅黑常规字体，可用于生成 TextMeshPro 字体。将该字体文件添加到 Unity 中，然后右键选择 <code>Create &gt; TextMeshPro &gt; Font Asset</code>，就能生成 TextMeshPro 动态字体。</p><h3 id="动态字体的不足"><a href="#动态字体的不足" class="headerlink" title="动态字体的不足"></a>动态字体的不足</h3><p>动态字体根据实际需要存储字符，生成的文件小而简单（例如：用到几个字就只包含这几个字），但性能较差，并容易出现乱码。例如：没有加入的字符无法正确显示。</p><p>为解决这些问题，推荐使用静态字体。</p><h2 id="静态字体生成方法"><a href="#静态字体生成方法" class="headerlink" title="静态字体生成方法"></a>静态字体生成方法</h2><ol><li><p>在 Unity 中，打开顶部菜单栏，选择 <code>Window &gt; TextMeshPro &gt; Font Asset Creator</code>，打开字体生成面板。</p><p><img src="/posts/45197/Snipaste_2024-12-27_11-19-50.png" alt="Snipaste_2024-12-27_11-19-50"></p></li><li><p>安装 TextMeshPro 包，否则无法正确显示文字。</p><p><img src="/posts/45197/725008a3817565d5bdde97791a54e068.png" alt="725008a3817565d5bdde97791a54e068"></p></li><li><p>将原生字体文件拖入到 <code>Source Font File</code>。</p><p><img src="/posts/45197/Snipaste_2024-12-27_11-26-59.png" alt="Snipaste_2024-12-27_11-26-59"></p></li><li><p>设置各参数：</p><ul><li><strong>Character Set：</strong>选择 <code>Characters from File</code>，并指定一个中文字符文件。<ul><li>可使用 所有中文字符文件：右键“网页另存为”，将文件保存为 <a href="http://8.141.161.164/udacity/chinese.txt">zh-cn.txt</a>，然后拖入面板。</li></ul></li><li><strong>Atlas Resolution：</strong>设置为实现字体清晰度的最大值（如 4096x4096）。</li><li><strong>Sampling Point Size：</strong>选择为较小的值，以减少乱码问题。</li><li><strong>Padding：</strong>设置为 Sampling Point Size 值的 1&#x2F;10 。</li></ul></li><li><p>生成成功后，点击保存，将生成的字体文件拖入 TextMeshPro 文字中就可以使用了。</p><p><img src="/posts/45197/Snipaste_2024-12-27_11-27-59.png" alt="Snipaste_2024-12-27_11-27-59"></p></li></ol><p>以下是字体效果图：</p><p>​<img src="/posts/45197/Snipaste_2024-12-27_11-29-57.png" alt="Snipaste_2024-12-27_11-29-57"></p><p>无论怎样放大，字体都保持高清不失真。</p><p>通过上述方法，可以在 Unity 中生成静态中文字体，解决中文乱码和效率问题，使用 TextMeshPro 进一步增强项目的文本显示效果。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity 基础操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 资源管理：Resources、AssetBundle 和 Addressable 的对比详解</title>
    <link href="/posts/12109/"/>
    <url>/posts/12109/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-资源管理：Resources、AssetBundle-和-Addressable-的对比详解"><a href="#Unity-资源管理：Resources、AssetBundle-和-Addressable-的对比详解" class="headerlink" title="Unity 资源管理：Resources、AssetBundle 和 Addressable 的对比详解"></a>Unity 资源管理：Resources、AssetBundle 和 Addressable 的对比详解</h1><p>在 Unity 开发中，资源的管理和加载是一个非常重要的环节，直接影响到游戏的性能、加载时间和开发效率。Unity 提供了三种主流的资源管理方式：<strong>Resources</strong>、<strong>AssetBundle</strong> 和 <strong>Addressable</strong>。本文将从用法、原理和热更新实现等方面深入探讨它们的特点和适用场景。</p><h2 id="1-Resources"><a href="#1-Resources" class="headerlink" title="1. Resources"></a>1. Resources</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>Resources 是 Unity 内置的一种资源加载方式，将资源放在 <code>Assets/Resources</code> 文件夹下，可以通过代码运行时直接加载。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject prefab = Resources.Load&lt;GameObject&gt;(<span class="hljs-string">&quot;PrefabName&quot;</span>);<br>Instantiate(prefab);<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>优点</strong>：<ul><li>简单易用，无需额外配置。</li><li>适合小型项目或简单场景。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>全量打包</strong>：<code>Resources</code> 中的所有资源会打包到一个文件，导致包体增大。</li><li><strong>难以管理</strong>：缺乏分组和引用跟踪机制。</li><li><strong>不可增量更新</strong>：无法单独更新某些资源。</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>Resources 使用 Unity 的内置序列化机制，将资源预先打包到 <code>Resources.assets</code> 文件中。运行时通过路径查找资源，在内存中加载。</p><h3 id="热更新实现"><a href="#热更新实现" class="headerlink" title="热更新实现"></a><strong>热更新实现</strong></h3><p>由于 Resources 打包方式的局限性，通常不适合直接用于热更新。如果需要实现热更新，可以结合 <code>WWW</code> 或 <code>UnityWebRequest</code> 动态加载外部资源。</p><h2 id="2-AssetBundle"><a href="#2-AssetBundle" class="headerlink" title="2. AssetBundle"></a>2. AssetBundle</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>AssetBundle 是 Unity 提供的一种资源打包方式，可以将指定资源打包成独立的文件，在运行时加载。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="资源打包："><a href="#资源打包：" class="headerlink" title="资源打包："></a>资源打包：</h4><p>使用 Unity 提供的工具或脚本打包资源：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">BuildPipeline.BuildAssetBundles(<span class="hljs-string">&quot;Assets/AssetBundles&quot;</span>, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);<br></code></pre></td></tr></table></figure><h4 id="加载资源："><a href="#加载资源：" class="headerlink" title="加载资源："></a>加载资源：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">AssetBundle bundle = AssetBundle.LoadFromFile(<span class="hljs-string">&quot;path/to/assetbundle&quot;</span>);<br>GameObject prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="hljs-string">&quot;PrefabName&quot;</span>);<br>Instantiate(prefab);<br></code></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>按需加载</strong>：可以加载特定资源，减少内存占用。</li><li><strong>支持热更新</strong>：通过网络下载新的 AssetBundle 文件，实现资源更新。</li></ul></li><li><strong>缺点</strong>：<ul><li>管理复杂：需要自行处理资源依赖。</li><li>打包配置繁琐：需要额外的打包工具和流程。</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>AssetBundle 是一种二进制文件，包含 Unity 对资源的序列化数据。运行时通过 Unity 的加载 API 将资源反序列化为内存对象。</p><h3 id="热更新实现-1"><a href="#热更新实现-1" class="headerlink" title="热更新实现"></a><strong>热更新实现</strong></h3><ol><li><strong>资源打包</strong>：将需要更新的资源单独打包为 AssetBundle 文件。</li><li><strong>版本控制</strong>：使用文件哈希或版本号管理更新。</li><li><strong>下载更新</strong>：通过服务器下载新的 AssetBundle 文件。</li><li><strong>加载资源</strong>：运行时使用 <code>AssetBundle.LoadFromFile</code> 或 <code>UnityWebRequestAssetBundle.GetAssetBundle</code> 加载。</li></ol><h2 id="3-Addressable"><a href="#3-Addressable" class="headerlink" title="3. Addressable"></a>3. Addressable</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>Addressable 是 Unity 官方推荐的现代资源管理系统，基于 AssetBundle，但简化了管理和使用流程。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="配置资源："><a href="#配置资源：" class="headerlink" title="配置资源："></a>配置资源：</h4><p>通过 Unity Editor 标记资源为 Addressable。</p><h4 id="加载资源：-1"><a href="#加载资源：-1" class="headerlink" title="加载资源："></a>加载资源：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Addressables.LoadAssetAsync&lt;GameObject&gt;(<span class="hljs-string">&quot;PrefabName&quot;</span>).Completed += handle =&gt; &#123;<br>    Instantiate(handle.Result);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>自动化管理</strong>：简化了依赖关系处理。</li><li><strong>异步加载</strong>：提供异步 API，避免主线程卡顿。</li><li><strong>跨平台支持</strong>：适配各种平台的加载需求。</li><li><strong>支持增量更新</strong>：内置版本控制和资源更新机制。</li></ul></li><li><strong>缺点</strong>：<ul><li>初始学习成本较高。</li><li>对小型项目可能显得过于复杂。</li></ul></li></ul><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>Addressable 使用 AssetBundle 作为底层实现，通过配置文件生成资源定位信息。运行时根据定位信息动态加载资源。</p><h3 id="热更新实现-2"><a href="#热更新实现-2" class="headerlink" title="热更新实现"></a><strong>热更新实现</strong></h3><ol><li><strong>配置资源</strong>：在 Unity Editor 中将资源标记为 Addressable，并设置 <code>RemoteLoadPath</code>。</li><li><strong>构建资源</strong>：通过 Addressable 的 <code>Build</code> 工具生成资源包和配置文件。</li><li><strong>更新资源</strong>：将资源包上传至远程服务器。</li><li><strong>加载和更新</strong>：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Addressables.CheckForCatalogUpdates().Completed += handle =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (handle.Result.Count &gt; <span class="hljs-number">0</span>) &#123;<br>        Addressables.UpdateCatalogs().Completed += updateHandle =&gt; &#123;<br>            Debug.Log(<span class="hljs-string">&quot;Resources updated successfully.&quot;</span>);<br>        &#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-三者对比"><a href="#4-三者对比" class="headerlink" title="4. 三者对比"></a>4. 三者对比</h2><table><thead><tr><th>特性</th><th>Resources</th><th>AssetBundle</th><th>Addressable</th></tr></thead><tbody><tr><td>易用性</td><td>简单</td><td>较复杂</td><td>较简单</td></tr><tr><td>内存占用</td><td>较高</td><td>较低</td><td>较低</td></tr><tr><td>打包灵活性</td><td>无法灵活选择</td><td>高</td><td>高</td></tr><tr><td>热更新支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>异步加载</td><td>不支持</td><td>部分支持</td><td>完全支持</td></tr></tbody></table><h2 id="5-选择建议"><a href="#5-选择建议" class="headerlink" title="5. 选择建议"></a>5. 选择建议</h2><ul><li><strong>Resources</strong>：适合小型项目或快速开发，不建议用于需要热更新的项目。</li><li><strong>AssetBundle</strong>：适合中大型项目，尤其是对资源加载有较高自定义需求的场景。</li><li><strong>Addressable</strong>：推荐用于现代 Unity 项目，特别是需要高效管理资源和支持热更新的项目。</li></ul><p>通过对 Resources、AssetBundle 和 Addressable 的深入对比，可以根据项目需求选择合适的资源管理方式。在现代游戏开发中，Addressable 的优势使其成为首选，但理解 AssetBundle 的原理和使用场景仍然非常重要，以应对特定需求。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12、Unity 跨平台与多平台适配：开发、构建与优化</title>
    <link href="/posts/16666/"/>
    <url>/posts/16666/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-性能优化与调试：工具、常见问题与优化策略"><a href="#Unity-性能优化与调试：工具、常见问题与优化策略" class="headerlink" title="Unity 性能优化与调试：工具、常见问题与优化策略"></a>Unity 性能优化与调试：工具、常见问题与优化策略</h1><p>Unity 是一款功能强大的游戏开发引擎，但随着项目的逐渐增大和复杂度的提升，性能问题往往成为开发者面临的重要挑战。无论是 FPS（帧率）过低，还是内存占用过高，都会严重影响游戏体验。本篇博客将详细介绍 Unity 的性能调试与优化工具，常见的性能瓶颈以及解决方案，帮助开发者提升游戏性能，避免常见的性能陷阱。</p><h2 id="1-Unity-性能调试与优化工具"><a href="#1-Unity-性能调试与优化工具" class="headerlink" title="1. Unity 性能调试与优化工具"></a><strong>1. Unity 性能调试与优化工具</strong></h2><h3 id="1-1-Unity-Profiler：性能调试的利器"><a href="#1-1-Unity-Profiler：性能调试的利器" class="headerlink" title="1.1 Unity Profiler：性能调试的利器"></a><strong>1.1 Unity Profiler：性能调试的利器</strong></h3><p>Unity Profiler 是 Unity 内置的一款强大的性能分析工具，能够帮助开发者全面分析游戏的性能瓶颈，找出 CPU、GPU、内存、网络等方面的问题。</p><h4 id="如何使用-Unity-Profiler"><a href="#如何使用-Unity-Profiler" class="headerlink" title="如何使用 Unity Profiler"></a><strong>如何使用 Unity Profiler</strong></h4><ol><li>打开 <strong>Window &gt; Analysis &gt; Profiler</strong>。</li><li>在 Profiler 窗口中，点击不同的模块（如 <strong>CPU Usage</strong>、<strong>GPU Usage</strong>、<strong>Memory</strong>）来查看具体的性能数据。</li><li>使用 <strong>Record</strong> 按钮开始记录性能数据，运行游戏时，Profiler 会实时显示性能数据的变化。</li></ol><h4 id="Profiler-中的关键指标"><a href="#Profiler-中的关键指标" class="headerlink" title="Profiler 中的关键指标"></a><strong>Profiler 中的关键指标</strong></h4><ul><li><strong>CPU Usage</strong>：显示 CPU 在各个阶段的使用情况，帮助开发者分析 CPU 性能瓶颈。</li><li><strong>GPU Usage</strong>：显示 GPU 在渲染图形时的负载，帮助发现 GPU 性能问题。</li><li><strong>Memory</strong>：显示内存使用情况，包括已分配的内存、GC 的活动等，帮助发现内存泄漏或内存溢出问题。</li><li><strong>Rendering</strong>：显示渲染管线的各个阶段，帮助识别渲染性能问题，如 Draw Call 数量、Shader 使用情况等。</li></ul><p>通过 Profiler 的实时数据，你可以明确识别到哪些部分消耗了最多的资源，从而进行针对性的优化。</p><h3 id="1-2-深入分析渲染性能"><a href="#1-2-深入分析渲染性能" class="headerlink" title="1.2 深入分析渲染性能"></a><strong>1.2 深入分析渲染性能</strong></h3><p>Unity 提供了 <strong>Rendering</strong> 选项卡，可以帮助你分析游戏的渲染性能，了解每一帧的渲染细节，包括 Draw Calls 和批处理信息。</p><ul><li><p><strong>Draw Calls</strong>：每一个渲染调用（Draw Call）都需要一定的 CPU 和 GPU 时间。如果 Draw Call 数量过多，会导致游戏帧率下降。通过减少材质和模型的数量、使用合批技术，可以有效减少 Draw Call 数量。</p></li><li><p>Batching</p><p>：合批技术可以将多个渲染请求合并为一个，以减少 CPU 和 GPU 的负载。Unity 支持两种合批方式：静态批处理（Static Batching）和动态批处理（Dynamic Batching）。</p><ul><li><strong>静态批处理</strong>：适用于不移动的静态物体。</li><li><strong>动态批处理</strong>：适用于频繁移动的物体。</li></ul></li></ul><h3 id="1-3-内存优化与垃圾回收（GC）"><a href="#1-3-内存优化与垃圾回收（GC）" class="headerlink" title="1.3 内存优化与垃圾回收（GC）"></a><strong>1.3 内存优化与垃圾回收（GC）</strong></h3><p>Unity 中的垃圾回收机制（GC）是自动管理内存的重要机制，但频繁的垃圾回收会导致游戏卡顿、性能波动。通过 Profiler 的 <strong>Memory</strong> 面板，你可以观察内存的使用情况，查找内存分配和回收的瓶颈。</p><h2 id="2-常见性能问题与优化策略"><a href="#2-常见性能问题与优化策略" class="headerlink" title="2. 常见性能问题与优化策略"></a><strong>2. 常见性能问题与优化策略</strong></h2><h3 id="2-1-Draw-Call-过多"><a href="#2-1-Draw-Call-过多" class="headerlink" title="2.1 Draw Call 过多"></a><strong>2.1 Draw Call 过多</strong></h3><p>Draw Call 是渲染图形时必须的调用，每增加一个物体，通常就会增加一次 Draw Call。大量的 Draw Call 会增加 CPU 和 GPU 的负担，导致帧率降低。</p><h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a><strong>优化策略</strong></h4><ol><li><strong>合并网格和材质</strong>：将多个物体合并为一个网格，或者将多个材质合并为一个材质，减少 Draw Call 的数量。</li><li><strong>使用合批技术</strong>：如上所述，使用静态批处理和动态批处理可以减少 Draw Call。</li><li><strong>动态合批</strong>：对于动态物体，可以启用 Unity 的动态合批功能，将多个物体合并为一个 Draw Call。</li><li><strong>简化模型和材质</strong>：通过优化模型的顶点数量，减少复杂的材质和纹理，降低渲染的复杂度。</li></ol><h3 id="2-2-内存泄漏"><a href="#2-2-内存泄漏" class="headerlink" title="2.2 内存泄漏"></a><strong>2.2 内存泄漏</strong></h3><p>内存泄漏通常是因为资源没有及时释放或无用对象仍然占用内存，导致内存不断增加。频繁的内存泄漏会导致游戏崩溃或性能降低。</p><h4 id="优化策略-1"><a href="#优化策略-1" class="headerlink" title="优化策略"></a><strong>优化策略</strong></h4><ol><li><strong>手动卸载不再使用的资源</strong>：通过调用 <code>Resources.UnloadUnusedAssets()</code> 或使用对象池来回收资源，避免内存泄漏。</li><li><strong>使用对象池</strong>：对象池能够重复使用已经创建的对象，避免频繁的内存分配和垃圾回收，从而减少内存泄漏的可能性。</li><li><strong>减少内存分配</strong>：避免每帧创建和销毁大量的对象，减少内存分配的压力。</li></ol><h3 id="2-3-频繁的垃圾回收（GC）"><a href="#2-3-频繁的垃圾回收（GC）" class="headerlink" title="2.3 频繁的垃圾回收（GC）"></a><strong>2.3 频繁的垃圾回收（GC）</strong></h3><p>垃圾回收（GC）会在某些情况下导致性能问题，尤其是在大型游戏中，频繁的垃圾回收会导致帧率下降，甚至出现卡顿现象。</p><h4 id="优化策略-2"><a href="#优化策略-2" class="headerlink" title="优化策略"></a><strong>优化策略</strong></h4><ol><li><strong>减少内存分配</strong>：通过减少每帧创建和销毁的对象，避免触发垃圾回收。可以使用对象池来复用对象，避免频繁的内存分配。</li><li><strong>手动控制内存分配</strong>：使用 <code>ArrayPool&lt;T&gt;</code> 或 <code>List&lt;T&gt;</code> 来管理对象的内存，避免频繁的 GC 调用。</li><li><strong>减少临时对象的创建</strong>：在游戏中，避免在每帧中频繁创建临时对象（如字符串、数组等），这些对象会增加垃圾回收的频率。</li></ol><h3 id="2-4-异常的脚本性能"><a href="#2-4-异常的脚本性能" class="headerlink" title="2.4 异常的脚本性能"></a><strong>2.4 异常的脚本性能</strong></h3><p>有时候，游戏性能问题并不是由于渲染或内存引起的，而是由脚本性能瓶颈引起的。</p><h4 id="优化策略-3"><a href="#优化策略-3" class="headerlink" title="优化策略"></a><strong>优化策略</strong></h4><ol><li><strong>避免在 Update 中进行大量运算</strong>：<code>Update()</code> 每帧调用一次，如果在 <code>Update()</code> 中进行大量计算，可能会影响帧率。可以将一些计算移到 <code>FixedUpdate()</code> 或 <code>LateUpdate()</code> 中，或者使用事件系统来处理。</li><li><strong>使用 Coroutine 或异步加载</strong>：通过使用协程（Coroutine）或异步加载（如 <code>AsyncOperation</code>）来处理耗时操作，避免阻塞主线程。</li><li><strong>减少不必要的计算</strong>：避免在每帧中重复计算已经计算过的值，使用缓存值或标记来减少计算量。</li></ol><h2 id="3-Unity-内存管理与垃圾回收（GC）"><a href="#3-Unity-内存管理与垃圾回收（GC）" class="headerlink" title="3. Unity 内存管理与垃圾回收（GC）"></a><strong>3. Unity 内存管理与垃圾回收（GC）</strong></h2><h3 id="3-1-内存管理机制"><a href="#3-1-内存管理机制" class="headerlink" title="3.1 内存管理机制"></a><strong>3.1 内存管理机制</strong></h3><p>Unity 使用托管堆和非托管堆来管理内存，GC 会周期性地回收不再使用的托管对象。每当 GC 执行时，会暂停主线程的执行，造成一定的性能开销。因此，合理的内存管理是优化性能的重要手段。</p><h4 id="内存优化技巧"><a href="#内存优化技巧" class="headerlink" title="内存优化技巧"></a><strong>内存优化技巧</strong></h4><ul><li><strong>使用对象池</strong>：对象池能避免频繁创建和销毁对象，从而减少内存分配。</li><li><strong>资源加载与卸载</strong>：使用异步加载来避免长时间的阻塞，同时使用 <code>Resources.UnloadUnusedAssets()</code> 来释放不再使用的资源。</li></ul><h3 id="3-2-减少-GC-影响"><a href="#3-2-减少-GC-影响" class="headerlink" title="3.2 减少 GC 影响"></a><strong>3.2 减少 GC 影响</strong></h3><p>频繁的 GC 会导致游戏卡顿和性能波动。为了减少 GC 的影响，可以采取以下措施：</p><ol><li><strong>避免临时对象的创建</strong>：避免在游戏中频繁创建临时对象，尤其是在游戏的每一帧中。</li><li><strong>使用对象池</strong>：对象池可以有效地复用对象，避免频繁的内存分配和垃圾回收。</li><li><strong>优化内存分配模式</strong>：减少数组、列表等集合的大小变化，避免每次使用时重新分配内存。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>性能优化是游戏开发过程中不可忽视的一部分。Unity 提供了多种工具，如 Profiler、对象池等，帮助开发者调试和优化游戏性能。通过分析常见的性能问题，如 Draw Call 过多、内存泄漏、频繁的垃圾回收等，结合合适的优化策略，可以显著提升游戏的运行效率，减少卡顿和内存溢出的现象。</p><p>掌握 Unity 的性能调试工具，了解常见的性能问题，并采用有效的优化策略，将帮助你在游戏开发过程中更好地管理和提升游戏性能，确保最终玩家能够体验到流畅且稳定的游戏性能。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11、Unity 跨平台与多平台适配：开发、构建与优化</title>
    <link href="/posts/4184/"/>
    <url>/posts/4184/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-跨平台与多平台适配：开发、构建与优化"><a href="#Unity-跨平台与多平台适配：开发、构建与优化" class="headerlink" title="Unity 跨平台与多平台适配：开发、构建与优化"></a>Unity 跨平台与多平台适配：开发、构建与优化</h1><p>随着游戏市场的多样化，开发跨平台游戏变得越来越重要。Unity 提供了一套强大的跨平台开发框架，支持 Android、iOS、PC、Console 等多个平台。然而，不同平台之间存在许多差异，如输入方式、屏幕分辨率、性能和内存等，开发者需要在这些差异中找到合适的解决方案，确保游戏在各个平台上的兼容性和流畅运行。本篇博客将介绍 Unity 中的跨平台开发与构建流程，如何处理平台间的差异，确保游戏在多个平台上良好适配。</p><h2 id="1-跨平台开发与构建流程"><a href="#1-跨平台开发与构建流程" class="headerlink" title="1. 跨平台开发与构建流程"></a><strong>1. 跨平台开发与构建流程</strong></h2><h3 id="1-1-跨平台开发的挑战与策略"><a href="#1-1-跨平台开发的挑战与策略" class="headerlink" title="1.1 跨平台开发的挑战与策略"></a><strong>1.1 跨平台开发的挑战与策略</strong></h3><p>跨平台开发意味着你的游戏需要在多个操作系统和设备上运行，虽然 Unity 提供了统一的开发环境和 API，但不同平台的差异仍然是一个挑战。平台特有的输入方式、分辨率、性能、内存和功能限制等，都需要在开发过程中进行适配。</p><p>开发时需要考虑的主要问题包括：</p><ul><li><strong>输入方式差异</strong>：PC 使用鼠标和键盘，而移动设备使用触摸屏，游戏主机则有专门的游戏手柄。</li><li><strong>分辨率差异</strong>：不同平台的设备具有不同的屏幕尺寸和分辨率，需要适配。</li><li><strong>性能差异</strong>：PC 的性能通常优于移动设备和游戏主机，开发时需要优化游戏性能，确保流畅运行。</li><li><strong>内存差异</strong>：不同平台的设备内存大小差异较大，开发时需要注意内存的优化。</li></ul><h3 id="1-2-Unity-的平台适配机制"><a href="#1-2-Unity-的平台适配机制" class="headerlink" title="1.2 Unity 的平台适配机制"></a><strong>1.2 Unity 的平台适配机制</strong></h3><p>Unity 提供了一些方法和工具，帮助开发者在不同平台之间实现适配。以下是一些常用的跨平台开发工具和技术：</p><h4 id="平台特有的-API"><a href="#平台特有的-API" class="headerlink" title="平台特有的 API"></a><strong>平台特有的 API</strong></h4><p>Unity 支持通过平台条件编译指令（如 <code>#if UNITY_ANDROID</code>）来编写特定于平台的代码。当你需要调用某些特定平台的 API 时，可以在代码中使用这些条件编译指令，以便在不同平台上调用不同的 API。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANDROID</span><br>    Debug.Log(<span class="hljs-string">&quot;Running on Android&quot;</span>);<br>    <span class="hljs-comment">// 调用 Android 特有的 API</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_IOS</span><br>    Debug.Log(<span class="hljs-string">&quot;Running on iOS&quot;</span>);<br>    <span class="hljs-comment">// 调用 iOS 特有的 API</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>通过这种方式，你可以在不同平台上执行不同的代码，避免平台间的兼容性问题。</p><h4 id="平台差异适配"><a href="#平台差异适配" class="headerlink" title="平台差异适配"></a><strong>平台差异适配</strong></h4><p>平台差异不仅限于 API，还有输入方式、图形处理等。例如，Unity 提供了 <code>Input</code> 类来处理输入，你可以根据平台的不同设置不同的输入方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_IOS</span><br>        <span class="hljs-comment">// 触摸输入</span><br>        <span class="hljs-keyword">if</span> (Input.touchCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Vector2 touchPosition = Input.GetTouch(<span class="hljs-number">0</span>).position;<br>            <span class="hljs-comment">// 处理触摸输入</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_STANDALONE</span><br>        <span class="hljs-comment">// 鼠标输入</span><br>        <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">0</span>))<br>        &#123;<br>            Vector3 mousePosition = Input.mousePosition;<br>            <span class="hljs-comment">// 处理鼠标输入</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们根据平台的不同，使用触摸输入（iOS）或鼠标输入（PC）来控制游戏。</p><h4 id="性能与内存优化"><a href="#性能与内存优化" class="headerlink" title="性能与内存优化"></a><strong>性能与内存优化</strong></h4><p>不同平台的设备有不同的性能和内存限制，开发者需要根据平台的性能调整游戏的图形质量、特效、材质等，以确保游戏的流畅运行。例如，在移动设备上，可以降低画面质量、关闭一些高性能特效等，以提升性能。</p><h3 id="1-3-构建和发布跨平台游戏"><a href="#1-3-构建和发布跨平台游戏" class="headerlink" title="1.3 构建和发布跨平台游戏"></a><strong>1.3 构建和发布跨平台游戏</strong></h3><p>Unity 的构建设置（Build Settings）允许你为不同平台生成不同版本的游戏。你可以通过选择目标平台进行构建，并在构建时调整一些平台特有的设置。</p><ul><li>打开 <strong>File &gt; Build Settings</strong>，选择目标平台（如 Android、iOS、Windows 等），然后点击 <strong>Build</strong> 按钮进行构建。</li><li>在构建之前，可以通过 <strong>Player Settings</strong> 调整各个平台的特定设置，如分辨率、图形质量、输入方式等。</li></ul><h2 id="2-Unity-中的多分辨率与屏幕适配"><a href="#2-Unity-中的多分辨率与屏幕适配" class="headerlink" title="2. Unity 中的多分辨率与屏幕适配"></a><strong>2. Unity 中的多分辨率与屏幕适配</strong></h2><h3 id="2-1-适配不同屏幕分辨率"><a href="#2-1-适配不同屏幕分辨率" class="headerlink" title="2.1 适配不同屏幕分辨率"></a><strong>2.1 适配不同屏幕分辨率</strong></h3><p>现代游戏需要适配不同尺寸和分辨率的屏幕，特别是在移动设备上，屏幕尺寸差异较大。Unity 提供了 <strong>CanvasScaler</strong> 组件，可以帮助我们处理多分辨率的适配。</p><h4 id="CanvasScaler-的使用"><a href="#CanvasScaler-的使用" class="headerlink" title="CanvasScaler 的使用"></a><strong>CanvasScaler 的使用</strong></h4><p><code>CanvasScaler</code> 组件用于控制 UI 元素在不同分辨率下的缩放行为，它能够根据屏幕的分辨率自动调整 UI 元素的大小。</p><ul><li><p>UI Scale Mode</p><p>：控制如何缩放 UI 元素。</p><ul><li><strong>Constant Pixel Size</strong>：UI 元素的大小保持固定，不受分辨率影响。</li><li><strong>Scale With Screen Size</strong>：根据屏幕的分辨率来缩放 UI 元素，适用于多分辨率适配。</li><li><strong>Constant Physical Size</strong>：UI 元素的物理大小保持固定（不常用）。</li></ul></li></ul><h4 id="Scale-With-Screen-Size-适配"><a href="#Scale-With-Screen-Size-适配" class="headerlink" title="Scale With Screen Size 适配"></a><strong>Scale With Screen Size 适配</strong></h4><p>最常用的适配方式是 <strong>Scale With Screen Size</strong>。它会根据屏幕的分辨率自动缩放 UI 元素的大小，确保 UI 在不同设备上都能呈现良好的显示效果。</p><ol><li>选中 Canvas 组件，在 <strong>Inspector</strong> 面板中找到 <strong>CanvasScaler</strong> 组件。</li><li>将 <strong>UI Scale Mode</strong> 设置为 <strong>Scale With Screen Size</strong>。</li><li>在 <strong>Reference Resolution</strong> 中设置参考分辨率，通常选择一个常见的分辨率（如 1920x1080）。</li><li>选择 <strong>Screen Match Mode</strong>，可以选择根据宽度或高度来匹配屏幕分辨率。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">CanvasScaler canvasScaler = GetComponent&lt;CanvasScaler&gt;();<br>canvasScaler.referenceResolution = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>); <span class="hljs-comment">// 设置参考分辨率</span><br>canvasScaler.screenMatchMode = CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;<br>canvasScaler.matchWidthOrHeight = <span class="hljs-number">0.5f</span>; <span class="hljs-comment">// 使宽高匹配</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们通过设置参考分辨率为 1920x1080，并设置屏幕匹配模式，使得 UI 元素根据不同分辨率自适应缩放。</p><h3 id="2-2-处理纵横比差异"><a href="#2-2-处理纵横比差异" class="headerlink" title="2.2 处理纵横比差异"></a><strong>2.2 处理纵横比差异</strong></h3><p>不同设备的纵横比（例如 16:9、4:3、21:9）也会影响 UI 的显示。为了适应不同的纵横比，可以使用以下方法：</p><ul><li><strong>Anchors（锚点）</strong>：锚点可以控制 UI 元素相对于父容器的位置和大小，确保 UI 元素能够根据屏幕尺寸进行自适应。</li><li><strong>Aspect Ratio Fitter</strong>：这个组件可以根据屏幕的纵横比调整 UI 元素的尺寸，确保它们在不同设备上保持正确的比例。</li></ul><h4 id="Aspect-Ratio-Fitter-示例"><a href="#Aspect-Ratio-Fitter-示例" class="headerlink" title="Aspect Ratio Fitter 示例"></a><strong>Aspect Ratio Fitter 示例</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AspectRatioExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AspectRatioFitter aspectRatioFitter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 设置为 16:9 的比例</span><br>        aspectRatioFitter.aspectMode = AspectRatioFitter.AspectMode.WidthControlsHeight;<br>        aspectRatioFitter.aspectRatio = <span class="hljs-number">16f</span> / <span class="hljs-number">9f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码展示了如何使用 <code>AspectRatioFitter</code> 来保持 UI 元素的纵横比，确保它们在不同的屏幕上正确显示。</p><h2 id="3-Unity-跨平台开发的优化建议"><a href="#3-Unity-跨平台开发的优化建议" class="headerlink" title="3. Unity 跨平台开发的优化建议"></a><strong>3. Unity 跨平台开发的优化建议</strong></h2><h3 id="3-1-性能优化"><a href="#3-1-性能优化" class="headerlink" title="3.1 性能优化"></a><strong>3.1 性能优化</strong></h3><ul><li><strong>图形质量设置</strong>：根据平台的性能，调整游戏的图形质量。对于高性能平台（如 PC），可以开启高质量的纹理、特效等；而对于低性能平台（如移动设备），可以降低图形质量。</li><li><strong>内存优化</strong>：避免过多的纹理和资源占用内存，使用资源压缩、异步加载等方式优化内存使用。</li></ul><h3 id="3-2-输入优化"><a href="#3-2-输入优化" class="headerlink" title="3.2 输入优化"></a><strong>3.2 输入优化</strong></h3><p>在多个平台上，输入设备的差异会影响游戏的体验。合理设计输入系统，可以使游戏在各种平台上都能提供流畅的操作体验。</p><ul><li>在移动平台上使用触摸输入，而在 PC 和游戏主机上使用鼠标和键盘或手柄输入。</li><li>使用 Unity 的 <strong>Input Manager</strong> 来处理跨平台输入。</li></ul><h3 id="3-3-流程与构建优化"><a href="#3-3-流程与构建优化" class="headerlink" title="3.3 流程与构建优化"></a><strong>3.3 流程与构建优化</strong></h3><ul><li>使用 <strong>Asset Bundles</strong> 或 <strong>Addressables</strong> 来管理和加载资源，提高构建效率和资源管理效率。</li><li>使用 <strong>Profiler</strong> 工具分析不同平台上的性能瓶颈，针对性地优化游戏。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Unity 提供了强大的跨平台开发支持，使得游戏开发者可以轻松地在不同平台之间进行适配。在开发过程中，我们需要关注平台间的差异，如输入方式、性能、内存和分辨率等，并采取相应的适配策略。此外，Unity 提供了丰富的工具和 API，如 <code>CanvasScaler</code>、<code>AspectRatioFitter</code>、<code>Input</code> 等，帮助我们在不同设备上实现良好的显示效果和操作体验。通过合理的优化策略，我们可以确保游戏在多个平台上流畅运行，提升玩家的游戏体验。</p><p>通过学习并应用这些跨平台开发技巧，你将能够在 Unity 中开发出兼容多平台、性能优化的游戏。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10、Unity 音频系统：基础、效果与优化</title>
    <link href="/posts/63726/"/>
    <url>/posts/63726/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-音频系统：基础、效果与优化"><a href="#Unity-音频系统：基础、效果与优化" class="headerlink" title="Unity 音频系统：基础、效果与优化"></a>Unity 音频系统：基础、效果与优化</h1><p>在游戏开发中，音频是不可或缺的一部分，它能够极大地增强玩家的沉浸感和游戏体验。Unity 提供了强大的音频系统，可以让开发者轻松地加载、播放、控制音频文件，并且支持复杂的音效和空间化处理。本篇博客将深入讲解 Unity 音频系统的使用，包括音频的基础操作、3D 音效、混响效果的实现，以及如何进行音频优化。</p><h2 id="1-Unity-音频系统的基础与使用"><a href="#1-Unity-音频系统的基础与使用" class="headerlink" title="1. Unity 音频系统的基础与使用"></a><strong>1. Unity 音频系统的基础与使用</strong></h2><p>Unity 提供的音频系统由 <code>AudioSource</code> 和 <code>AudioClip</code> 组件组成，它们分别用于播放音频和存储音频数据。通过这两个组件，你可以轻松地在游戏中加载和播放音频文件。</p><h3 id="1-1-加载和播放音频文件"><a href="#1-1-加载和播放音频文件" class="headerlink" title="1.1 加载和播放音频文件"></a><strong>1.1 加载和播放音频文件</strong></h3><h4 id="AudioClip：音频文件的载体，通常你会将音频文件拖入到-Unity-编辑器的资源面板，生成一个-AudioClip-对象。"><a href="#AudioClip：音频文件的载体，通常你会将音频文件拖入到-Unity-编辑器的资源面板，生成一个-AudioClip-对象。" class="headerlink" title="AudioClip：音频文件的载体，通常你会将音频文件拖入到 Unity 编辑器的资源面板，生成一个 AudioClip 对象。"></a><strong>AudioClip</strong>：音频文件的载体，通常你会将音频文件拖入到 Unity 编辑器的资源面板，生成一个 <code>AudioClip</code> 对象。</h4><h4 id="AudioSource：是播放音频的组件，你需要将它附加到一个游戏对象上。通过-AudioSource-控制音频的播放、暂停、停止等操作。"><a href="#AudioSource：是播放音频的组件，你需要将它附加到一个游戏对象上。通过-AudioSource-控制音频的播放、暂停、停止等操作。" class="headerlink" title="AudioSource：是播放音频的组件，你需要将它附加到一个游戏对象上。通过 AudioSource 控制音频的播放、暂停、停止等操作。"></a><strong>AudioSource</strong>：是播放音频的组件，你需要将它附加到一个游戏对象上。通过 <code>AudioSource</code> 控制音频的播放、暂停、停止等操作。</h4><h4 id="示例代码：播放背景音乐"><a href="#示例代码：播放背景音乐" class="headerlink" title="示例代码：播放背景音乐"></a><strong>示例代码：播放背景音乐</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioSource; <span class="hljs-comment">// 引用 AudioSource 组件</span><br>    <span class="hljs-keyword">public</span> AudioClip backgroundMusic; <span class="hljs-comment">// 背景音乐的 AudioClip</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 播放背景音乐</span><br>        audioSource.clip = backgroundMusic;<br>        audioSource.Play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>AudioSource</code> 组件用于播放 <code>AudioClip</code> 中的音频文件。我们将 <code>backgroundMusic</code> 赋值给 <code>AudioSource</code> 的 <code>clip</code> 属性，并调用 <code>Play()</code> 方法来播放音频。</p><h3 id="1-2-音频播放控制"><a href="#1-2-音频播放控制" class="headerlink" title="1.2 音频播放控制"></a><strong>1.2 音频播放控制</strong></h3><p><code>AudioSource</code> 组件提供了许多有用的方法和属性来控制音频播放，比如：</p><ul><li>**Play()**：开始播放音频。</li><li>**Pause()**：暂停音频播放。</li><li>**Stop()**：停止音频播放。</li><li><strong>volume</strong>：设置音量，范围是 0 到 1。</li><li><strong>loop</strong>：设置是否循环播放音频。</li></ul><h4 id="控制音频播放"><a href="#控制音频播放" class="headerlink" title="控制音频播放"></a><strong>控制音频播放</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 播放音频</span><br>        audioSource.Play();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 按下空格键暂停音频</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (audioSource.isPlaying)<br>                audioSource.Pause();<br>            <span class="hljs-keyword">else</span><br>                audioSource.Play();<br>        &#125;<br><br>        <span class="hljs-comment">// 按下停止键停止音频</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.S))<br>        &#123;<br>            audioSource.Stop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了 <code>Play()</code>、<code>Pause()</code> 和 <code>Stop()</code> 方法来控制音频的播放。</p><h3 id="1-3-音效与背景音乐的管理"><a href="#1-3-音效与背景音乐的管理" class="headerlink" title="1.3 音效与背景音乐的管理"></a><strong>1.3 音效与背景音乐的管理</strong></h3><p>通常，游戏中会有两种类型的音频：背景音乐和音效。背景音乐通常是循环播放的，而音效通常是一次性的。</p><h4 id="音效播放示例"><a href="#音效播放示例" class="headerlink" title="音效播放示例"></a><strong>音效播放示例</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioSource;<br>    <span class="hljs-keyword">public</span> AudioClip clickSound; <span class="hljs-comment">// 点击音效</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayClickSound</span>()</span><br>    &#123;<br>        audioSource.PlayOneShot(clickSound); <span class="hljs-comment">// 播放一次性的音效</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>audioSource.PlayOneShot()</code> 方法，我们可以播放一次性的音效而不会打断当前正在播放的背景音乐。</p><h3 id="1-4-音量调节"><a href="#1-4-音量调节" class="headerlink" title="1.4 音量调节"></a><strong>1.4 音量调节</strong></h3><p>音频的音量可以通过 <code>AudioSource.volume</code> 属性进行调整。你可以根据游戏的需求，控制音效和背景音乐的音量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource backgroundMusicSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 按下箭头键增加音量</span><br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.UpArrow) &amp;&amp; backgroundMusicSource.volume &lt; <span class="hljs-number">1f</span>)<br>        &#123;<br>            backgroundMusicSource.volume += <span class="hljs-number">0.1f</span> * Time.deltaTime;<br>        &#125;<br><br>        <span class="hljs-comment">// 按下箭头键减小音量</span><br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.DownArrow) &amp;&amp; backgroundMusicSource.volume &gt; <span class="hljs-number">0f</span>)<br>        &#123;<br>            backgroundMusicSource.volume -= <span class="hljs-number">0.1f</span> * Time.deltaTime;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码使用箭头键动态调整背景音乐的音量。</p><h2 id="2-音频效果与处理：3D-音效与混响"><a href="#2-音频效果与处理：3D-音效与混响" class="headerlink" title="2. 音频效果与处理：3D 音效与混响"></a><strong>2. 音频效果与处理：3D 音效与混响</strong></h2><h3 id="2-1-3D-音效与空间化"><a href="#2-1-3D-音效与空间化" class="headerlink" title="2.1 3D 音效与空间化"></a><strong>2.1 3D 音效与空间化</strong></h3><p>在 3D 游戏中，音频不仅需要播放，还需要根据玩家的位置和场景中的其他元素进行空间化处理。Unity 通过 <code>AudioSource</code> 和 <code>AudioListener</code> 实现了空间化音效，使音频能够根据玩家的位置和声音来源的距离进行调整。</p><h4 id="3D-音效的设置"><a href="#3D-音效的设置" class="headerlink" title="3D 音效的设置"></a><strong>3D 音效的设置</strong></h4><ol><li><strong>设置 AudioSource 的 spatialBlend</strong>：将 <code>AudioSource</code> 组件的 <code>spatialBlend</code> 属性设置为 1，表示完全的 3D 音效。</li><li><strong>设置 AudioListener 的位置</strong>：<code>AudioListener</code> 通常附加在主摄像机上，它会根据摄像机的位置计算声音的传播。</li></ol><h4 id="示例：播放-3D-音效"><a href="#示例：播放-3D-音效" class="headerlink" title="示例：播放 3D 音效"></a><strong>示例：播放 3D 音效</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioSource;<br>    <span class="hljs-keyword">public</span> AudioClip explosionSound; <span class="hljs-comment">// 爆炸音效</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 设置为 3D 音效</span><br>        audioSource.spatialBlend = <span class="hljs-number">1.0f</span>;<br>        audioSource.clip = explosionSound;<br>        audioSource.Play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-使用混响、延迟等音效"><a href="#2-2-使用混响、延迟等音效" class="headerlink" title="2.2 使用混响、延迟等音效"></a><strong>2.2 使用混响、延迟等音效</strong></h3><p>为了增强音频的沉浸感，Unity 提供了混响、延迟等效果。你可以使用 <code>AudioReverbFilter</code> 来添加混响效果，或者使用 <code>AudioEchoFilter</code> 来添加延迟效果。</p><h4 id="混响效果"><a href="#混响效果" class="headerlink" title="混响效果"></a><strong>混响效果</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioReverbFilter reverbFilter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 设置混响效果</span><br>        reverbFilter.reverbLevel = <span class="hljs-number">0.5f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延迟效果"><a href="#延迟效果" class="headerlink" title="延迟效果"></a><strong>延迟效果</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioEchoFilter echoFilter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 设置延迟效果</span><br>        echoFilter.wetMix = <span class="hljs-number">0.6f</span>; <span class="hljs-comment">// 控制回响效果的强度</span><br>        echoFilter.delay = <span class="hljs-number">0.5f</span>;  <span class="hljs-comment">// 控制回响的时间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Unity-中的音频优化技巧"><a href="#3-Unity-中的音频优化技巧" class="headerlink" title="3. Unity 中的音频优化技巧"></a><strong>3. Unity 中的音频优化技巧</strong></h2><p>在开发过程中，音频文件的管理和优化至关重要，尤其是当你的游戏包含大量音效和背景音乐时。以下是一些音频优化技巧：</p><h3 id="3-1-使用压缩格式"><a href="#3-1-使用压缩格式" class="headerlink" title="3.1 使用压缩格式"></a><strong>3.1 使用压缩格式</strong></h3><p>音频文件的大小可能会影响游戏的加载时间和内存占用。使用适当的压缩格式（如 MP3 或 OGG）来减少音频文件的体积。</p><h4 id="设置压缩格式"><a href="#设置压缩格式" class="headerlink" title="设置压缩格式"></a><strong>设置压缩格式</strong></h4><ol><li>选择音频文件。</li><li>在 Inspector 面板中，设置 <strong>Compression Format</strong> 为 <code>MP3</code> 或 <code>OGG</code>。</li><li>调整 <strong>Quality</strong> 选项，选择合适的音频质量和压缩比。</li></ol><h3 id="3-2-控制音频加载和播放时机"><a href="#3-2-控制音频加载和播放时机" class="headerlink" title="3.2 控制音频加载和播放时机"></a><strong>3.2 控制音频加载和播放时机</strong></h3><p>音频资源的加载和播放时机对于性能的影响很大。避免一次性加载过多的音频文件，可以使用异步加载和流式加载来优化性能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AudioManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioSource;<br><br>    <span class="hljs-comment">// 异步加载音频</span><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        ResourceRequest load = Resources.LoadAsync&lt;AudioClip&gt;(<span class="hljs-string">&quot;Audio/BackgroundMusic&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> load;<br><br>        audioSource.clip = (AudioClip)load.asset;<br>        audioSource.Play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-音频质量与优化"><a href="#3-3-音频质量与优化" class="headerlink" title="3.3 音频质量与优化"></a><strong>3.3 音频质量与优化</strong></h3><p>适当降低音频的采样率和位深度可以减少内存消耗和提升加载速度。同时，确保没有过多的音效同时播放，这可能导致性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Unity 提供了强大的音频系统，可以帮助开发者管理和控制音效和背景音乐。通过 <code>AudioSource</code> 和 <code>AudioClip</code>，你可以轻松实现音频的播放、暂停、停止等基本操作。对于 3D 游戏，Unity 的空间化音效和混响效果可以大大增强玩家的沉浸感。此外，合理的音频优化策略，如使用压缩格式、异步加载和控制音频质量，能够帮助提升游戏性能，避免音频资源的浪费。</p><p>这些基础知识和技巧为你实现丰富的音频效果奠定了基础，掌握这些内容后，你可以为游戏增加更加生</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09、Unity 存档与数据管理：设计与实现</title>
    <link href="/posts/24463/"/>
    <url>/posts/24463/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-存档与数据管理：设计与实现"><a href="#Unity-存档与数据管理：设计与实现" class="headerlink" title="Unity 存档与数据管理：设计与实现"></a>Unity 存档与数据管理：设计与实现</h1><p>在游戏开发中，存档和数据管理是至关重要的一部分。它确保玩家在游戏过程中能够保存他们的进度、物品、关卡等信息，避免重新开始的困扰。对于多语言和国际化支持，Unity 提供了 Localization Package 来处理文本、图片、音效等多语言资源，使游戏可以支持不同语言和地区的玩家。本文将详细讲解 Unity 中如何实现存档系统和多语言支持。</p><h2 id="1-Unity-存档系统的设计与实现"><a href="#1-Unity-存档系统的设计与实现" class="headerlink" title="1. Unity 存档系统的设计与实现"></a><strong>1. Unity 存档系统的设计与实现</strong></h2><p>在 Unity 中设计一个存档系统，主要目的是保存和加载玩家的游戏数据。这些数据包括玩家的进度、物品、关卡状态等。为了实现这些功能，Unity 提供了多种方法，如 <code>PlayerPrefs</code>、文件系统（JSON&#x2F;XML）等。</p><h3 id="1-1-使用-PlayerPrefs-保存简单数据"><a href="#1-1-使用-PlayerPrefs-保存简单数据" class="headerlink" title="1.1 使用 PlayerPrefs 保存简单数据"></a><strong>1.1 使用 PlayerPrefs 保存简单数据</strong></h3><p><code>PlayerPrefs</code> 是 Unity 提供的一个简单方式，用于存储玩家的设置、分数或其他简单的游戏数据。它非常适合存储一些基本数据，比如游戏设置、玩家得分、游戏进度等。</p><h4 id="使用-PlayerPrefs-存储数据"><a href="#使用-PlayerPrefs-存储数据" class="headerlink" title="使用 PlayerPrefs 存储数据"></a><strong>使用 PlayerPrefs 存储数据</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 保存玩家得分</span><br>PlayerPrefs.SetInt(<span class="hljs-string">&quot;PlayerScore&quot;</span>, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 获取玩家得分</span><br><span class="hljs-built_in">int</span> playerScore = PlayerPrefs.GetInt(<span class="hljs-string">&quot;PlayerScore&quot;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果没有找到数据，则默认返回 0</span><br><br><span class="hljs-comment">// 保存玩家是否完成某个关卡</span><br>PlayerPrefs.SetBool(<span class="hljs-string">&quot;Level1Complete&quot;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 获取关卡是否完成</span><br><span class="hljs-built_in">bool</span> level1Complete = PlayerPrefs.GetBool(<span class="hljs-string">&quot;Level1Complete&quot;</span>, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 如果没有找到数据，则默认返回 false</span><br></code></pre></td></tr></table></figure><p><code>PlayerPrefs</code> 适合存储一些简单的小数据，但不适合存储复杂的数据结构。如果需要存储更复杂的对象，建议使用文件系统（如 JSON 或 XML）来进行保存。</p><h3 id="1-2-使用文件系统保存复杂数据"><a href="#1-2-使用文件系统保存复杂数据" class="headerlink" title="1.2 使用文件系统保存复杂数据"></a><strong>1.2 使用文件系统保存复杂数据</strong></h3><p>对于更复杂的游戏存档（如玩家物品、关卡状态等），使用文件系统（如 JSON）来保存数据更加灵活。Unity 支持通过文件读取和写入来保存这些信息。</p><h4 id="使用-JSON-保存和加载数据"><a href="#使用-JSON-保存和加载数据" class="headerlink" title="使用 JSON 保存和加载数据"></a><strong>使用 JSON 保存和加载数据</strong></h4><p>首先，定义一个存档数据类，用于保存玩家的详细信息：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> playerName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> playerScore;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> level1Complete;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">string</span>&gt; inventoryItems;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，使用 JSON 序列化和反序列化来保存和加载数据：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveLoadManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> filePath;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        filePath = Application.persistentDataPath + <span class="hljs-string">&quot;/playerData.json&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 保存数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SavePlayerData</span>(<span class="hljs-params">PlayerData data</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> jsonData = JsonUtility.ToJson(data);<br>        File.WriteAllText(filePath, jsonData);<br>        Debug.Log(<span class="hljs-string">&quot;Player data saved to &quot;</span> + filePath);<br>    &#125;<br><br>    <span class="hljs-comment">// 加载数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerData <span class="hljs-title">LoadPlayerData</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (File.Exists(filePath))<br>        &#123;<br>            <span class="hljs-built_in">string</span> jsonData = File.ReadAllText(filePath);<br>            PlayerData playerData = JsonUtility.FromJson&lt;PlayerData&gt;(jsonData);<br>            <span class="hljs-keyword">return</span> playerData;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;No save file found.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>SavePlayerData</code> 将 <code>PlayerData</code> 对象序列化为 JSON 格式并保存到文件。</li><li><code>LoadPlayerData</code> 读取文件中的 JSON 数据并反序列化为 <code>PlayerData</code> 对象。</li><li>使用 <code>Application.persistentDataPath</code> 来获得设备上用于保存数据的路径，这样可以保证不同平台上的文件存储路径正确。</li></ul><h4 id="存档系统的优化"><a href="#存档系统的优化" class="headerlink" title="存档系统的优化"></a><strong>存档系统的优化</strong></h4><ul><li><strong>压缩数据</strong>：可以通过压缩存档文件来减少存储空间，特别是在移动设备上，存档文件的大小可能会影响游戏的加载速度。</li><li><strong>定期保存</strong>：在重要的游戏节点（如过关、获得新物品时）保存数据，避免玩家丢失进度。</li><li><strong>加密存档</strong>：为了防止作弊，可以对存档文件进行加密处理。</li></ul><h2 id="2-Unity-中的本地化与国际化支持"><a href="#2-Unity-中的本地化与国际化支持" class="headerlink" title="2. Unity 中的本地化与国际化支持"></a><strong>2. Unity 中的本地化与国际化支持</strong></h2><p>Unity 提供了 <code>Localization Package</code>，用于处理游戏中的多语言支持和区域设置。通过这个工具，您可以轻松管理游戏的文本、图片、音效等多语言资源，并且支持不同地区的设置（如货币、日期格式等）。</p><h3 id="2-1-安装-Localization-Package"><a href="#2-1-安装-Localization-Package" class="headerlink" title="2.1 安装 Localization Package"></a><strong>2.1 安装 Localization Package</strong></h3><ol><li>打开 Unity 编辑器。</li><li>在 <strong>Window</strong> 菜单中选择 <strong>Package Manager</strong>。</li><li>在 <strong>Unity Registry</strong> 中搜索 <code>Localization</code>。</li><li>点击 <strong>Install</strong> 安装 <code>Localization Package</code>。</li></ol><h3 id="2-2-配置-Localization-系统"><a href="#2-2-配置-Localization-系统" class="headerlink" title="2.2 配置 Localization 系统"></a><strong>2.2 配置 Localization 系统</strong></h3><ol><li><p>安装完 <code>Localization Package</code> 后，您会在 <strong>Window &gt; Asset Management</strong> 中看到一个新的选项：<strong>Localization</strong>。</p></li><li><p>在 <strong>Localization</strong> 面板中，选择 <strong>Create Localization Settings</strong> 来创建一个新的本地化设置。</p></li><li><p>选择 <strong>Create &gt; Localization Tables</strong>，并为每种语言创建不同的表格（如 <code>English</code>、<code>Chinese</code>）。</p></li><li><p>在每个表格中添加需要本地化的文本键值对，例如：</p><table><thead><tr><th>Key</th><th>English Text</th><th>Chinese Text</th></tr></thead><tbody><tr><td><code>start_btn</code></td><td>Start Game</td><td>开始游戏</td></tr><tr><td><code>exit_btn</code></td><td>Exit Game</td><td>退出游戏</td></tr></tbody></table></li></ol><h3 id="2-3-使用-Localization-进行动态文本切换"><a href="#2-3-使用-Localization-进行动态文本切换" class="headerlink" title="2.3 使用 Localization 进行动态文本切换"></a><strong>2.3 使用 Localization 进行动态文本切换</strong></h3><p>一旦配置了 Localization Tables，就可以在代码中使用本地化的文本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Localization;<br><span class="hljs-keyword">using</span> UnityEngine.Localization.Components;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LocalizedTextExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LocalizedTextMeshPro localizedText; <span class="hljs-comment">// 连接到 TextMeshPro 组件</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        localizedText.SetLocalizedString(<span class="hljs-string">&quot;start_btn&quot;</span>); <span class="hljs-comment">// 动态加载文本</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="本地化图片和音效"><a href="#本地化图片和音效" class="headerlink" title="本地化图片和音效"></a><strong>本地化图片和音效</strong></h4><p>除了文本之外，<code>Localization Package</code> 还支持本地化图片和音效。您可以为每种语言版本设置不同的图片资源，例如为中文版本使用中文字体，为英文版本使用英文字体。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Localization;<br><span class="hljs-keyword">using</span> UnityEngine.Localization.Components;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LocalizedImageExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LocalizedSprite localizedSprite; <span class="hljs-comment">// 连接到 Sprite 组件</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        localizedSprite.SetLocalizedSprite(<span class="hljs-string">&quot;start_btn_image&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-区域设置和货币支持"><a href="#2-4-区域设置和货币支持" class="headerlink" title="2.4 区域设置和货币支持"></a><strong>2.4 区域设置和货币支持</strong></h3><p>Unity 的 <code>Localization</code> 也可以帮助处理不同地区的设置，例如货币、日期格式等。您可以为每个地区设置不同的货币符号、日期格式等，并根据玩家的区域自动调整显示内容。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Localization;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LocalizedCurrencyExample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LocalizedString currencyFormat;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        Debug.Log(currencyFormat.GetLocalizedString());  <span class="hljs-comment">// 根据玩家区域显示正确的货币格式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过本文的讲解，你应该能够理解如何在 Unity 中实现以下功能：</p><ul><li><strong>存档系统的设计与实现：</strong> 通过 <code>PlayerPrefs</code> 存储简单数据，通过文件系统（如 JSON）保存更复杂的游戏数据。存档系统的设计应注重数据的压缩、定期保存和加密处理。</li><li><strong>本地化与国际化支持：</strong> 使用 Unity 的 <code>Localization Package</code> 来处理多语言文本、图片和音效资源，并且能够支持根据区域设置显示不同的货币、日期等信息。</li></ul><p>这些功能是现代游戏开发中的基础，能够帮助你在游戏中实现更好的玩家体验，尤其是在多语言支持和存档管理方面。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08、Unity 资源管理与优化：AssetBundle 和 Addressable 系统</title>
    <link href="/posts/58560/"/>
    <url>/posts/58560/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-资源管理与优化：AssetBundle-和-Addressable-系统"><a href="#Unity-资源管理与优化：AssetBundle-和-Addressable-系统" class="headerlink" title="Unity 资源管理与优化：AssetBundle 和 Addressable 系统"></a>Unity 资源管理与优化：AssetBundle 和 Addressable 系统</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发大型 Unity 游戏时，资源管理和性能优化是至关重要的部分。随着项目规模的扩大，如何高效管理和加载资源，确保游戏运行流畅，避免出现性能瓶颈，成为了开发者必须面对的挑战。本文将深入讲解 Unity 中的资源管理方案，包括 <code>AssetBundle</code> 和 <code>Addressable</code> 系统，以及如何进行性能优化，提升 CPU 和 GPU 的运行效率。</p><h2 id="1-Unity-资源管理：AssetBundle-与-Addressable"><a href="#1-Unity-资源管理：AssetBundle-与-Addressable" class="headerlink" title="1. Unity 资源管理：AssetBundle 与 Addressable"></a><strong>1. Unity 资源管理：AssetBundle 与 Addressable</strong></h2><h3 id="1-1-AssetBundle-概述"><a href="#1-1-AssetBundle-概述" class="headerlink" title="1.1 AssetBundle 概述"></a><strong>1.1 AssetBundle 概述</strong></h3><p><code>AssetBundle</code> 是 Unity 提供的一个资源打包系统，用于将游戏中的资源打包成一个独立的文件，在需要时进行加载。它主要用于优化游戏资源的管理，特别是在需要按需加载的情况下。通过使用 AssetBundle，可以避免将所有资源一次性加载到内存中，从而提高游戏的启动速度并节省内存使用。</p><h4 id="创建和使用-AssetBundle"><a href="#创建和使用-AssetBundle" class="headerlink" title="创建和使用 AssetBundle"></a><strong>创建和使用 AssetBundle</strong></h4><ol><li><p><strong>创建 AssetBundle</strong></p><ul><li><p>首先，在 Unity 编辑器中选择需要打包的资源（如纹理、模型、音频等）。</p></li><li><p>在资源的 Inspector 窗口中，选择 <strong>AssetBundle</strong> 标签，并为资源分配一个 AssetBundle 名称。</p></li></ul></li><li><p><strong>打包 AssetBundle</strong></p><p>在 Unity 编辑器中使用脚本打包资源，执行以下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildAssetBundles</span><br>&#123;<br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Assets/Build AssetBundles&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildAllAssetBundles</span>()</span><br>    &#123;<br>        BuildPipeline.BuildAssetBundles(<span class="hljs-string">&quot;Assets/AssetBundles&quot;</span>, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过运行这段代码，Unity 会将选择的资源打包成 AssetBundle 文件。</p></li><li><p><strong>加载 AssetBundle</strong></p><p>使用 AssetBundle 加载资源的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssetBundleLoader</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> AssetBundle assetBundle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(LoadAssetBundle(<span class="hljs-string">&quot;Assets/AssetBundles/mybundle&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadAssetBundle</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> bundlePath</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 异步加载 AssetBundle</span><br>        AssetBundleCreateRequest bundleRequest = AssetBundle.LoadFromFileAsync(bundlePath);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> bundleRequest;<br><br>        assetBundle = bundleRequest.assetBundle;<br><br>        <span class="hljs-keyword">if</span> (assetBundle != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">// 加载资源</span><br>            AssetBundleRequest assetRequest = assetBundle.LoadAssetAsync&lt;GameObject&gt;(<span class="hljs-string">&quot;MyPrefab&quot;</span>);<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> assetRequest;<br><br>            GameObject prefab = assetRequest.asset <span class="hljs-keyword">as</span> GameObject;<br>            Instantiate(prefab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码展示了如何异步加载 AssetBundle，并从中加载一个资源。</p></li></ol><h4 id="AssetBundle-的优缺点"><a href="#AssetBundle-的优缺点" class="headerlink" title="AssetBundle 的优缺点"></a><strong>AssetBundle 的优缺点</strong></h4><ul><li><strong>优点：</strong><ul><li>按需加载资源，减少内存占用。</li><li>提高游戏启动速度。</li><li>支持跨平台使用，资源可以针对不同平台进行优化。</li></ul></li><li><strong>缺点：</strong><ul><li>需要额外的管理，打包和加载的逻辑比较复杂。</li><li>资源更新后需要重新生成和分发 AssetBundle 文件。</li></ul></li></ul><h3 id="1-2-Addressable-系统概述"><a href="#1-2-Addressable-系统概述" class="headerlink" title="1.2 Addressable 系统概述"></a><strong>1.2 Addressable 系统概述</strong></h3><p><code>Addressable</code> 是 Unity 引入的新的资源管理系统，它在功能上扩展了 AssetBundle 的能力，提供了更高效、更灵活的资源管理方式。Addressable 系统通过给资源分配一个“地址”，可以在运行时轻松加载资源，并支持异步加载、资源缓存和卸载。</p><h4 id="使用-Addressable-系统"><a href="#使用-Addressable-系统" class="headerlink" title="使用 Addressable 系统"></a><strong>使用 Addressable 系统</strong></h4><ol><li><p><strong>设置 Addressable</strong></p><ul><li>在 Unity 中，首先需要安装 Addressable Asset System 包。在 <strong>Package Manager</strong> 中搜索 <code>Addressable</code> 并安装。</li><li>然后，打开 <strong>Window &gt; Asset Management &gt; Addressables</strong>，会弹出 Addressable 资源管理窗口。</li><li>选中需要管理的资源，并在 Inspector 中为其分配一个 Addressable 地址。</li></ul></li><li><p><strong>构建 Addressable 资源</strong></p><p>使用以下代码构建 Addressable 资源：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.AddressableAssets;<br><span class="hljs-keyword">using</span> UnityEngine.ResourceManagement.AsyncOperations;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AddressableLoader</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AssetReference assetReference;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        LoadAddressableAsset();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadAddressableAsset</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 异步加载 Addressable 资源</span><br>        AsyncOperationHandle handle = assetReference.LoadAssetAsync&lt;GameObject&gt;();<br>        handle.Completed += OnAssetLoaded;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnAssetLoaded</span>(<span class="hljs-params">AsyncOperationHandle handle</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (handle.Status == AsyncOperationStatus.Succeeded)<br>        &#123;<br>            GameObject prefab = handle.Result <span class="hljs-keyword">as</span> GameObject;<br>            Instantiate(prefab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>AssetReference</code> 来引用 Addressable 资源，并在运行时异步加载它。</p></li></ol><h4 id="Addressable-的优缺点"><a href="#Addressable-的优缺点" class="headerlink" title="Addressable 的优缺点"></a><strong>Addressable 的优缺点</strong></h4><ul><li><strong>优点：</strong><ul><li>更简单的资源管理方式，支持自动化管理和资源打包。</li><li>强大的异步加载和卸载支持，可以避免游戏卡顿。</li><li>支持远程加载资源，适合进行热更新。</li><li>支持资源缓存和动态分配，减少内存占用。</li></ul></li><li><strong>缺点：</strong><ul><li>需要对 Addressable 系统有一定的了解，涉及的概念较多。</li><li>初期配置和调试可能有一些复杂。</li></ul></li></ul><h2 id="2-Unity-性能优化：从-CPU-到-GPU"><a href="#2-Unity-性能优化：从-CPU-到-GPU" class="headerlink" title="2. Unity 性能优化：从 CPU 到 GPU"></a><strong>2. Unity 性能优化：从 CPU 到 GPU</strong></h2><p>性能优化是游戏开发中的重要任务，尤其是当你的游戏变得越来越复杂时，如何保证它在各种设备上都能流畅运行尤为关键。Unity 提供了多种工具和方法来优化游戏的性能，下面我们将介绍如何进行 CPU 和 GPU 的性能优化。</p><h3 id="2-1-CPU-性能优化"><a href="#2-1-CPU-性能优化" class="headerlink" title="2.1 CPU 性能优化"></a><strong>2.1 CPU 性能优化</strong></h3><h4 id="Profiler-工具"><a href="#Profiler-工具" class="headerlink" title="Profiler 工具"></a><strong>Profiler 工具</strong></h4><p>Unity 的 <strong>Profiler</strong> 工具是分析性能瓶颈的重要工具。它可以帮助你找出游戏中最耗费 CPU 资源的部分，并给出优化建议。</p><ul><li>打开 <strong>Window &gt; Analysis &gt; Profiler</strong>，进入 Profiler 面板。</li><li>在 Profiler 面板中，选择 <strong>CPU Usage</strong> 视图，查看各个函数的 CPU 使用情况。</li><li>找出占用 CPU 资源最多的函数和方法，针对性地进行优化。</li></ul><h4 id="常见的-CPU-优化方法"><a href="#常见的-CPU-优化方法" class="headerlink" title="常见的 CPU 优化方法"></a><strong>常见的 CPU 优化方法</strong></h4><ol><li><p><strong>避免频繁的 GC（垃圾回收）</strong></p><p>在 Unity 中，频繁的垃圾回收会导致游戏卡顿。你可以通过减少内存分配、避免在 <code>Update</code> 中频繁创建临时对象来减少 GC 的调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 优化前：在 Update 中创建临时对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    GameObject temp = <span class="hljs-keyword">new</span> GameObject();<br>&#125;<br><br><span class="hljs-comment">// 优化后：避免在 Update 中频繁创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 仅创建一次，不再频繁创建</span><br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>    &#123;<br>        temp = <span class="hljs-keyword">new</span> GameObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>减少不必要的 <code>Update</code> 调用</strong></p><p>如果某些脚本不需要在每帧更新时执行，可以通过条件判断来避免频繁调用 <code>Update</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (shouldUpdate)<br>    &#123;<br>        <span class="hljs-comment">// 执行更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-GPU-性能优化"><a href="#2-2-GPU-性能优化" class="headerlink" title="2.2 GPU 性能优化"></a><strong>2.2 GPU 性能优化</strong></h3><h4 id="GPU-Profiler"><a href="#GPU-Profiler" class="headerlink" title="GPU Profiler"></a><strong>GPU Profiler</strong></h4><p>通过 Profiler 的 <strong>GPU Usage</strong> 视图，你可以查看 GPU 渲染管线的性能。关注每个渲染阶段的时间消耗，找出渲染性能瓶颈。</p><h4 id="常见的-GPU-优化方法"><a href="#常见的-GPU-优化方法" class="headerlink" title="常见的 GPU 优化方法"></a><strong>常见的 GPU 优化方法</strong></h4><ol><li><p><strong>减少 Draw Call 数量</strong></p><p>Draw Call 是渲染过程中发送到 GPU 的命令。每个 Draw Call 都会消耗 GPU 资源，因此减少 Draw Call 的数量可以显著提高性能。你可以通过合并静态物体、使用 GPU 实现的批处理技术来减少 Draw Call 数量。</p></li><li><p><strong>优化材质和纹理</strong></p><p>使用合适的材质和纹理格式可以显著降低 GPU 渲染的负担。例如，使用压缩纹理格式（如 DXT1）可以减少纹理内存的占用，减少 GPU 的处理时间。</p></li><li><p><strong>使用 GPU Instancing</strong></p><p>GPU Instancing 是一个允许你在渲染过程中多次使用相同材质和网格的技术，减少了渲染批次，提高了渲染效率。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong>资源管理：</strong> 使用 <code>AssetBundle</code> 和 <code>Addressable</code> 系统，可以实现资源的按需加载、缓存和卸载，从而有效减少内存占用和提高游戏性能。对于大型项目，建议使用 Addressable 系统，它提供了更强大的功能和更灵活的资源管理。</li><li><strong>性能优化：</strong> 利用 Unity 的 Profiler 工具分析 CPU 和 GPU 的性能瓶颈，减少不必要的资源分配、优化渲染管线，提升游戏的流畅度。通过减少 Draw Call、优化材质和纹理、使用 GPU Instancing 等技术，可以提高 GPU 渲染性能。</li></ul><p>通过本文的讲解，你应该能够在实际项目中应用这些优化技术，实现高效的资源管理和流畅的游戏性能。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07、Unity 网络与多人游戏开发：从 Unity Networking 到 Mirror 框架</title>
    <link href="/posts/41458/"/>
    <url>/posts/41458/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-网络与多人游戏开发：从-Unity-Networking-到-Mirror-框架"><a href="#Unity-网络与多人游戏开发：从-Unity-Networking-到-Mirror-框架" class="headerlink" title="Unity 网络与多人游戏开发：从 Unity Networking 到 Mirror 框架"></a>Unity 网络与多人游戏开发：从 Unity Networking 到 Mirror 框架</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在游戏开发中，网络和多人游戏的实现是一个重要且复杂的部分。Unity 提供了多种网络解决方案，从早期的 Unity Networking 到后来的 Mirror 框架，都为开发者提供了不同的功能和性能选择。本文将详细讲解如何使用 Unity 网络基础知识进行多人游戏开发，包括网络同步、RPC（远程过程调用）、服务器与客户端架构等基本概念，并深入介绍如何使用 WebSocket 实现实时通信。</p><h2 id="1-Unity-网络基础：从-Unity-Networking-到-Mirror"><a href="#1-Unity-网络基础：从-Unity-Networking-到-Mirror" class="headerlink" title="1. Unity 网络基础：从 Unity Networking 到 Mirror"></a><strong>1. Unity 网络基础：从 Unity Networking 到 Mirror</strong></h2><h3 id="1-1-Unity-Networking（UNet）概述"><a href="#1-1-Unity-Networking（UNet）概述" class="headerlink" title="1.1 Unity Networking（UNet）概述"></a><strong>1.1 Unity Networking（UNet）概述</strong></h3><p>Unity Networking（UNet）是 Unity 提供的一套网络通信解决方案，旨在简化多人游戏的开发。它通过客户端-服务器模型，让开发者能够轻松地同步玩家数据并进行实时通信。UNet 提供了以下基本功能：</p><ul><li><strong>网络连接与传输</strong>：客户端和服务器之间的连接与数据传输。</li><li><strong>网络同步</strong>：让多个客户端共享游戏状态，保证各个客户端看到的世界一致。</li><li><strong>RPC</strong>：远程过程调用，用于在客户端和服务器之间传递消息。</li></ul><p>然而，UNet 已在 Unity 2018.2 版本后停止更新和支持，Unity 官方推荐使用 Mirror 作为替代方案。</p><h3 id="1-2-Mirror-框架：Unity-Networking-的继承者"><a href="#1-2-Mirror-框架：Unity-Networking-的继承者" class="headerlink" title="1.2 Mirror 框架：Unity Networking 的继承者"></a><strong>1.2 Mirror 框架：Unity Networking 的继承者</strong></h3><p>Mirror 是一个开源的高效网络库，它继承了 UNet 的设计并进行优化，具有更好的性能和扩展性。Mirror 与 UNet 的主要区别在于其更强的社区支持、持续的更新和更高效的网络同步。</p><h4 id="Mirror-的核心概念"><a href="#Mirror-的核心概念" class="headerlink" title="Mirror 的核心概念"></a><strong>Mirror 的核心概念</strong></h4><ul><li><strong>网络行为（NetworkBehaviour）</strong>：与 UNet 中的 <code>NetworkBehaviour</code> 类似，Mirror 也提供了 <code>NetworkBehaviour</code> 类，用于实现网络同步功能。</li><li><strong>网络同步（Network Sync）</strong>：通过 <code>SyncVar</code> 特性和 <code>NetworkTransform</code> 组件，Mirror 可以自动同步物体的位置、旋转、状态等数据。</li><li><strong>远程过程调用（RPC）</strong>：通过 <code>Command</code> 和 <code>ClientRpc</code>，Mirror 使客户端和服务器可以相互调用函数进行通信。</li></ul><h3 id="1-3-网络同步"><a href="#1-3-网络同步" class="headerlink" title="1.3 网络同步"></a><strong>1.3 网络同步</strong></h3><p>网络同步是多人游戏中至关重要的一部分。它保证了各个客户端之间的状态一致性。常见的同步方式包括：</p><ul><li><p><strong>同步变量（SyncVar）</strong>：在 Mirror 中，使用 <code>SyncVar</code> 特性标记需要同步的变量。当服务器端变量值发生变化时，Mirror 会自动将其同步到所有客户端。</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">NetworkBehaviour</span><br>&#123;<br>    [<span class="hljs-meta">SyncVar</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> health;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个变量 <code>health</code> 会在服务器更新时自动同步到所有客户端。</p></li><li><p><strong>同步组件（NetworkTransform）</strong>：<code>NetworkTransform</code> 组件用于同步物体的位置信息，确保玩家在所有客户端上的位置保持一致。</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 将 NetworkTransform 组件挂到 Player 对象上</span><br>playerObject.AddComponent&lt;NetworkTransform&gt;();<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-4-远程过程调用（RPC）"><a href="#1-4-远程过程调用（RPC）" class="headerlink" title="1.4 远程过程调用（RPC）"></a><strong>1.4 远程过程调用（RPC）</strong></h3><p>RPC 是一种客户端和服务器之间进行通信的机制。在 Mirror 中，通过 <code>Command</code> 和 <code>ClientRpc</code> 可以实现远程过程调用。</p><ul><li><strong>Command</strong>：由客户端发起，执行服务器端函数。</li><li><strong>ClientRpc</strong>：由服务器发起，执行客户端函数。</li></ul><h4 id="使用-Command-和-ClientRpc-示例"><a href="#使用-Command-和-ClientRpc-示例" class="headerlink" title="使用 Command 和 ClientRpc 示例"></a><strong>使用 Command 和 ClientRpc 示例</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">NetworkBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Command：客户端调用，执行服务器端函数</span><br>    [<span class="hljs-meta">Command</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CmdTakeDamage</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> amount</span>)</span><br>    &#123;<br>        health -= amount;<br>        RpcUpdateHealth();<br>    &#125;<br><br>    <span class="hljs-comment">// ClientRpc：服务器调用，执行客户端函数</span><br>    [<span class="hljs-meta">ClientRpc</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RpcUpdateHealth</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 更新客户端UI</span><br>        healthText.text = <span class="hljs-string">&quot;Health: &quot;</span> + health;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，客户端调用 <code>CmdTakeDamage</code> 告诉服务器减血，服务器通过 <code>RpcUpdateHealth</code> 更新客户端的 UI。</p><h2 id="2-Unity-中的-WebSocket-与实时通信"><a href="#2-Unity-中的-WebSocket-与实时通信" class="headerlink" title="2. Unity 中的 WebSocket 与实时通信"></a><strong>2. Unity 中的 WebSocket 与实时通信</strong></h2><p>在 Unity 中，除了 Mirror 以外，使用 WebSocket 实现实时通信也是一种常见的方式。WebSocket 允许在客户端和服务器之间建立持久的双向连接，适用于需要实时交换数据的应用场景，如在线多人游戏、实时聊天、数据流等。</p><h3 id="2-1-WebSocket-基础"><a href="#2-1-WebSocket-基础" class="headerlink" title="2.1 WebSocket 基础"></a><strong>2.1 WebSocket 基础</strong></h3><p>WebSocket 是一种网络协议，允许客户端和服务器之间建立全双工通信通道。这意味着客户端和服务器可以随时互相发送数据，而无需重新建立连接。WebSocket 适用于高频数据交换，特别适用于实时游戏和多人互动应用。</p><h4 id="如何在-Unity-中使用-WebSocket"><a href="#如何在-Unity-中使用-WebSocket" class="headerlink" title="如何在 Unity 中使用 WebSocket"></a><strong>如何在 Unity 中使用 WebSocket</strong></h4><p>为了在 Unity 中使用 WebSocket，你需要借助第三方库，如 <a href="https://github.com/sta/websocket-sharp">WebSocketSharp</a> 或 BestHTTP 等。</p><p>以下是如何使用 WebSocketSharp 在 Unity 中创建客户端与服务器的通信：</p><ol><li><p><strong>安装 WebSocketSharp</strong></p><p>将 WebSocketSharp 库添加到 Unity 项目中。你可以从 GitHub 上下载或通过 Unity Asset Store 获取。</p></li><li><p><strong>创建 WebSocket 客户端</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> WebSocketSharp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketClient</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> WebSocket ws;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);<br>        ws.OnMessage += OnMessageReceived;<br>        ws.Connect();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMessageReceived</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, MessageEventArgs e</span>)</span><br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Received: &quot;</span> + e.Data);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))<br>        &#123;<br>            ws.Send(<span class="hljs-string">&quot;Hello, Server!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        ws.Close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，WebSocket 客户端连接到服务器并监听消息。当按下空格键时，客户端向服务器发送消息。</p></li><li><p><strong>创建 WebSocket 服务器</strong></p><p>服务器端通常是 Node.js 或其他语言的服务器，示例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">javascript复制代码<span class="hljs-keyword">const</span> WebSocket = require(<span class="hljs-string">&#x27;ws&#x27;</span>);<br><br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> WebSocket.Server(&#123; port: <span class="hljs-number">8080</span> &#125;);<br><br>wss.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">function <span class="hljs-title">connection</span>(<span class="hljs-params">ws</span>)</span> &#123;<br>  ws.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">function <span class="hljs-title">incoming</span>(<span class="hljs-params">message</span>)</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;received: %s&#x27;</span>, message);<br>  &#125;);<br><br>  ws.send(<span class="hljs-string">&#x27;Hello from server&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这个 WebSocket 服务器监听 <code>8080</code> 端口，并处理客户端发来的消息。</p></li></ol><h3 id="2-2-使用-WebSocket-实现实时游戏数据同步"><a href="#2-2-使用-WebSocket-实现实时游戏数据同步" class="headerlink" title="2.2 使用 WebSocket 实现实时游戏数据同步"></a><strong>2.2 使用 WebSocket 实现实时游戏数据同步</strong></h3><p>在多人游戏中，WebSocket 可以用于实时传输游戏数据，例如玩家位置、状态、事件等。例如，多个玩家之间的动作可以实时同步到所有玩家客户端：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 假设我们已经建立了 WebSocket 连接</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ws.IsAlive)<br>    &#123;<br>        <span class="hljs-comment">// 发送玩家位置到服务器</span><br>        Vector3 position = transform.position;<br>        <span class="hljs-built_in">string</span> message = JsonUtility.ToJson(<span class="hljs-keyword">new</span> &#123; x = position.x, y = position.y, z = position.z &#125;);<br>        ws.Send(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在服务器端，收到位置数据后，可以将其广播给其他玩家：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">connection</span>(<span class="hljs-params">ws</span>) &#123;<br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">incoming</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-comment">// 广播位置数据给其他所有客户端</span><br>    wss.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">each</span>(<span class="hljs-params">client</span>) &#123;<br>      <span class="hljs-keyword">if</span> (client !== ws &amp;&amp; client.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>        client.<span class="hljs-title function_">send</span>(message);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，所有玩家的游戏状态可以通过 WebSocket 实时同步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong>Mirror</strong> 框架是 Unity 官方推荐的多人游戏开发框架，它简化了服务器与客户端的通信和同步，提供了强大的功能，如网络同步、RPC、Command 和 ClientRpc 等。</li><li><strong>WebSocket</strong> 提供了一种高效的实时通信机制，适用于多人游戏中的实时数据传输。通过 WebSocket，客户端和服务器之间可以实现低延迟、持久连接的双向通信。</li><li>对于多人游戏的开发，使用 Mirror 可以快速实现网络同步和多人联机功能，而 WebSocket 适用于需要高频实时更新的游戏场景。</li></ul><p>通过本文介绍的内容，你可以搭建一个基本的 Unity 网络框架，使用 Mirror 实现游戏同步，使用 WebSocket 实现实时通信，进一步扩展为一个完整的多人在线游戏。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06、Unity 物理引擎：原理、优化与真实感物理效果实现</title>
    <link href="/posts/61900/"/>
    <url>/posts/61900/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-物理引擎：原理、优化与真实感物理效果实现"><a href="#Unity-物理引擎：原理、优化与真实感物理效果实现" class="headerlink" title="Unity 物理引擎：原理、优化与真实感物理效果实现"></a>Unity 物理引擎：原理、优化与真实感物理效果实现</h1><p>在 Unity 中，物理引擎是实现真实世界物理效果的重要工具，它通过模拟碰撞、力、重力等物理现象，使得游戏世界中的物体行为更加自然和可信。Unity 的物理引擎基于 <strong>NVIDIA PhysX</strong>，它提供了多种功能来帮助开发者构建符合现实物理规律的互动体验。在本篇博客中，我们将深入探讨 Unity 物理引擎的工作原理，如何使用 <code>Rigidbody</code> 和 <code>Collider</code> 进行物体的物理模拟，并讨论如何通过物理优化提升游戏性能。此外，我们还会介绍如何利用物理材料来模拟更真实的物理效果。</p><hr><h2 id="1-Unity-物理引擎的工作原理与优化"><a href="#1-Unity-物理引擎的工作原理与优化" class="headerlink" title="1. Unity 物理引擎的工作原理与优化"></a>1. Unity 物理引擎的工作原理与优化</h2><h3 id="1-1-物理引擎的基本原理"><a href="#1-1-物理引擎的基本原理" class="headerlink" title="1.1 物理引擎的基本原理"></a>1.1 <strong>物理引擎的基本原理</strong></h3><p>Unity 的物理引擎使用刚体（<code>Rigidbody</code>）和碰撞体（<code>Collider</code>）来模拟物体之间的相互作用。以下是 Unity 物理引擎的几个基本概念：</p><ul><li><strong>Rigidbody</strong>：<code>Rigidbody</code> 组件使得物体可以在物理引擎的控制下移动和旋转。它受重力、力和扭矩等物理现象的影响。</li><li><strong>Collider</strong>：<code>Collider</code> 组件定义了物体的碰撞形状（如球形、盒形、胶囊形等）。它用于检测物体间的碰撞。</li><li><strong>Force</strong>：力是推动物体运动的原因。Unity 提供了多种力（如推力、重力、摩擦力等）来改变物体的速度和加速度。</li></ul><p>Unity 物理引擎通过计算物体之间的碰撞和相互作用，动态更新物体的位置和旋转。</p><h3 id="1-2-碰撞检测"><a href="#1-2-碰撞检测" class="headerlink" title="1.2 碰撞检测"></a>1.2 <strong>碰撞检测</strong></h3><p>碰撞检测是物理引擎的核心部分，用于检测物体是否相互接触。Unity 提供了两种类型的碰撞检测：</p><ul><li><strong>碰撞（Collision）</strong>：当两个物体发生接触时，会触发 <code>OnCollisionEnter</code>、<code>OnCollisionStay</code> 和 <code>OnCollisionExit</code> 事件。</li><li><strong>触发器（Trigger）</strong>：当物体进入或离开触发器区域时，会触发 <code>OnTriggerEnter</code>、<code>OnTriggerStay</code> 和 <code>OnTriggerExit</code> 事件。与普通碰撞不同，触发器不会引发物理响应，只会触发事件。</li></ul><h4 id="1-2-1-使用-Rigidbody-和-Collider-组件"><a href="#1-2-1-使用-Rigidbody-和-Collider-组件" class="headerlink" title="1.2.1 使用 Rigidbody 和 Collider 组件"></a>1.2.1 <strong>使用 <code>Rigidbody</code> 和 <code>Collider</code> 组件</strong></h4><p>通过给物体添加 <code>Rigidbody</code> 和 <code>Collider</code> 组件，Unity 就能自动处理物体之间的碰撞检测。以下是基本使用方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 示例：添加刚体和碰撞体</span><br>Rigidbody rb = gameObject.AddComponent&lt;Rigidbody&gt;();<br>Collider col = gameObject.AddComponent&lt;BoxCollider&gt;();<br></code></pre></td></tr></table></figure><h3 id="1-3-物理优化"><a href="#1-3-物理优化" class="headerlink" title="1.3 物理优化"></a>1.3 <strong>物理优化</strong></h3><p>物理计算是一个相对昂贵的过程，尤其是在游戏中有大量物体时。为了确保游戏性能，我们需要优化物理计算：</p><ul><li><strong>减少物理更新频率</strong>：物理引擎在每个固定时间步长中更新一次。通过减小 <code>Fixed Timestep</code>（在 <strong>Edit -&gt; Project Settings -&gt; Time</strong> 中调整），可以减少物理更新的频率，从而减少计算量。</li><li><strong>使用简单的碰撞体</strong>：尽量避免使用复杂的碰撞体（如网格碰撞体）。使用简单的碰撞体（如球体、盒子和胶囊）会更高效。</li><li><strong>禁用不必要的物理计算</strong>：例如，对于静止的物体，可以禁用 <code>Rigidbody</code> 的 <code>useGravity</code> 或将其设置为 Kinematic（通过设置 <code>isKinematic</code> 为 <code>true</code>），避免物理引擎计算其运动。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：禁用不必要的物理计算</span><br>Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();<br>rb.isKinematic = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 禁用物理计算</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-使用力与物理材料实现真实感物理效果"><a href="#2-使用力与物理材料实现真实感物理效果" class="headerlink" title="2. 使用力与物理材料实现真实感物理效果"></a>2. 使用力与物理材料实现真实感物理效果</h2><h3 id="2-1-力与重力的使用"><a href="#2-1-力与重力的使用" class="headerlink" title="2.1 力与重力的使用"></a>2.1 <strong>力与重力的使用</strong></h3><p>力是物体运动的关键因素。Unity 提供了多种方式来施加力，包括：</p><ul><li><strong>AddForce</strong>：用于施加持续的力，改变物体的速度。</li><li><strong>AddTorque</strong>：用于施加扭矩，改变物体的旋转速度。</li></ul><h4 id="2-1-1-施加力"><a href="#2-1-1-施加力" class="headerlink" title="2.1.1 施加力"></a>2.1.1 <strong>施加力</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：施加一个向上的力</span><br>Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();<br>rb.AddForce(Vector3.up * <span class="hljs-number">10f</span>, ForceMode.Impulse);  <span class="hljs-comment">// 施加一个瞬时向上的力</span><br></code></pre></td></tr></table></figure><ul><li><strong>ForceMode</strong>：可以选择不同的力模式，如 <code>ForceMode.Force</code>（持续力），<code>ForceMode.Impulse</code>（瞬时力）等。</li></ul><h4 id="2-1-2-重力"><a href="#2-1-2-重力" class="headerlink" title="2.1.2 重力"></a>2.1.2 <strong>重力</strong></h4><p>Unity 中的物体会自动受重力影响。如果不想让物体受重力影响，可以通过设置 <code>useGravity</code> 为 <code>false</code> 来禁用重力。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：禁用重力</span><br>Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();<br>rb.useGravity = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-物理材料与摩擦力、弹性"><a href="#2-2-物理材料与摩擦力、弹性" class="headerlink" title="2.2 物理材料与摩擦力、弹性"></a>2.2 <strong>物理材料与摩擦力、弹性</strong></h3><p><strong>物理材料（Physics Materials）</strong> 可以用来控制物体的摩擦力和弹性等属性，进而模拟更真实的物理效果。</p><ul><li><strong>摩擦力</strong>：<code>Friction</code> 控制物体与其他表面接触时的摩擦强度。</li><li><strong>弹性</strong>：<code>Bounciness</code> 控制物体碰撞后的反弹程度。</li></ul><h4 id="2-2-1-创建物理材料"><a href="#2-2-1-创建物理材料" class="headerlink" title="2.2.1 创建物理材料"></a>2.2.1 <strong>创建物理材料</strong></h4><p>在 Unity 中，你可以通过创建 <code>Physics Material</code> 来调整物体的物理属性。通过设置摩擦力和弹性，可以实现各种物理效果。</p><ol><li>创建一个新的 <code>Physic Material</code>，并调整它的摩擦力和弹性属性。</li><li>将其应用于物体的 <code>Collider</code> 组件。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：创建并应用物理材料</span><br>PhysicMaterial material = <span class="hljs-keyword">new</span> PhysicMaterial();<br>material.dynamicFriction = <span class="hljs-number">0.5f</span>;  <span class="hljs-comment">// 动态摩擦力</span><br>material.staticFriction = <span class="hljs-number">0.6f</span>;   <span class="hljs-comment">// 静态摩擦力</span><br>material.bounciness = <span class="hljs-number">0.8f</span>;       <span class="hljs-comment">// 弹性</span><br><br>Collider col = gameObject.GetComponent&lt;Collider&gt;();<br>col.material = material;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-实现真实的物理效果"><a href="#2-2-2-实现真实的物理效果" class="headerlink" title="2.2.2 实现真实的物理效果"></a>2.2.2 <strong>实现真实的物理效果</strong></h4><p>通过调整摩擦力和弹性，可以让物体的滑动、碰撞和反弹效果更加真实。例如，你可以创建一个滑动物体，调整摩擦力来模拟不同材质的摩擦效果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：通过物理材料模拟滑动物体</span><br>PhysicMaterial slideMaterial = <span class="hljs-keyword">new</span> PhysicMaterial();<br>slideMaterial.dynamicFriction = <span class="hljs-number">0.1f</span>;  <span class="hljs-comment">// 低摩擦，物体更容易滑动</span><br>slideMaterial.staticFriction = <span class="hljs-number">0.1f</span>;<br>slideMaterial.bounciness = <span class="hljs-number">0.5f</span>;<br><br>Collider col = gameObject.GetComponent&lt;Collider&gt;();<br>col.material = slideMaterial;<br></code></pre></td></tr></table></figure><h3 id="2-3-碰撞与触发事件的响应"><a href="#2-3-碰撞与触发事件的响应" class="headerlink" title="2.3 碰撞与触发事件的响应"></a>2.3 <strong>碰撞与触发事件的响应</strong></h3><p>Unity 中的物理事件包括 <code>OnCollisionEnter</code>、<code>OnCollisionStay</code> 和 <code>OnCollisionExit</code> 事件（用于碰撞），以及 <code>OnTriggerEnter</code>、<code>OnTriggerStay</code> 和 <code>OnTriggerExit</code> 事件（用于触发器）。这些事件可以帮助你检测物体之间的碰撞和触发器交互，并根据需要做出响应。</p><h4 id="2-3-1-碰撞事件"><a href="#2-3-1-碰撞事件" class="headerlink" title="2.3.1 碰撞事件"></a>2.3.1 <strong>碰撞事件</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 当与另一个物体碰撞时</span><br>    <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Player hit the object!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-触发器事件"><a href="#2-3-2-触发器事件" class="headerlink" title="2.3.2 触发器事件"></a>2.3.2 <strong>触发器事件</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 当物体进入触发器区域时</span><br>    <span class="hljs-keyword">if</span> (other.gameObject.CompareTag(<span class="hljs-string">&quot;Enemy&quot;</span>))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Enemy entered the trigger zone!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Unity 物理引擎提供了强大的功能来模拟现实世界中的物理现象。通过合理使用 <code>Rigidbody</code>、<code>Collider</code> 组件以及施加力和使用物理材料，可以创建逼真的物理效果，如物体的滑动、碰撞、跳跃等。同时，通过优化物理计算，减少不必要的物理更新，可以有效提升游戏性能。</p><p>在实际开发中，了解并应用这些物理引擎的基本原理和优化技巧，将帮助你构建更流畅、真实的游戏体验。通过本文介绍的示例代码，你可以轻松实现物理效果并优化性能，让游戏中的物体行为更加自然和生动。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05、Unity UI 与用户体验：系统原理、交互设计与性能优化</title>
    <link href="/posts/63931/"/>
    <url>/posts/63931/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-UI-与用户体验：系统原理、交互设计与性能优化"><a href="#Unity-UI-与用户体验：系统原理、交互设计与性能优化" class="headerlink" title="Unity UI 与用户体验：系统原理、交互设计与性能优化"></a>Unity UI 与用户体验：系统原理、交互设计与性能优化</h1><p>在游戏开发中，用户界面（UI）是与玩家互动的重要方式。Unity 提供了强大的 UI 系统，可以帮助开发者实现各种 UI 功能和交互效果。从基本的 UI 组件到动态更新和优化，Unity 的 UI 系统具有很高的灵活性和扩展性。在本篇博客中，我们将深入探讨 Unity UI 系统的工作原理、使用技巧以及如何通过 UI 动画和交互提升用户体验，并提供基于实际使用情况的实现方法。</p><hr><h2 id="1-Unity-UI-系统的工作原理与使用技巧"><a href="#1-Unity-UI-系统的工作原理与使用技巧" class="headerlink" title="1. Unity UI 系统的工作原理与使用技巧"></a>1. Unity UI 系统的工作原理与使用技巧</h2><h3 id="1-1-UI-组件的基本介绍"><a href="#1-1-UI-组件的基本介绍" class="headerlink" title="1.1 UI 组件的基本介绍"></a>1.1 <strong>UI 组件的基本介绍</strong></h3><p>Unity 的 UI 系统基于 Canvas（画布）来绘制和管理 UI 元素。Canvas 作为 UI 元素的根组件，所有 UI 元素都必须是 Canvas 的子对象。常见的 UI 组件包括：</p><ul><li><strong>Text</strong>：显示文本内容。</li><li><strong>Button</strong>：按钮，用于接收用户点击事件。</li><li><strong>Image</strong>：显示图像或精灵。</li><li><strong>Slider</strong>：滑动条，用于选择数值。</li><li><strong>Toggle</strong>：切换按钮，用于选择或取消选择。</li></ul><h3 id="1-2-Canvas-的工作原理"><a href="#1-2-Canvas-的工作原理" class="headerlink" title="1.2 Canvas 的工作原理"></a>1.2 <strong>Canvas 的工作原理</strong></h3><p>Canvas 是所有 UI 元素的容器，负责处理所有 UI 元素的渲染。根据 Canvas 的渲染模式（<strong>Screen Space - Overlay</strong> 或 <strong>Screen Space - Camera</strong>），它会决定 UI 渲染的方式：</p><ul><li><strong>Screen Space - Overlay</strong>：UI 元素直接覆盖在屏幕上，不受摄像机影响，适用于大多数 UI 场景。</li><li><strong>Screen Space - Camera</strong>：UI 元素渲染在摄像机视口内，适用于需要 UI 与3D场景融合的情况。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 示例：创建一个按钮并添加点击事件</span><br>Button myButton = GameObject.Find(<span class="hljs-string">&quot;MyButton&quot;</span>).GetComponent&lt;Button&gt;();<br>myButton.onClick.AddListener(OnButtonClick);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonClick</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-动态-UI-更新与布局管理"><a href="#1-3-动态-UI-更新与布局管理" class="headerlink" title="1.3 动态 UI 更新与布局管理"></a>1.3 <strong>动态 UI 更新与布局管理</strong></h3><p>Unity 提供了多种方式来动态更新 UI 和组织布局：</p><ul><li><strong>Layout Group</strong>：通过 <code>HorizontalLayoutGroup</code>、<code>VerticalLayoutGroup</code> 和 <code>GridLayoutGroup</code> 管理 UI 元素的排列方式。</li><li><strong>ContentSizeFitter</strong>：根据内容大小自动调整 UI 元素的大小。</li><li><strong>Mask</strong>：用于显示或隐藏 UI 元素的特定区域。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：动态调整 Text 内容</span><br>Text myText = GameObject.Find(<span class="hljs-string">&quot;MyText&quot;</span>).GetComponent&lt;Text&gt;();<br>myText.text = <span class="hljs-string">&quot;Hello, Unity!&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="1-4-UI-性能优化"><a href="#1-4-UI-性能优化" class="headerlink" title="1.4 UI 性能优化"></a>1.4 <strong>UI 性能优化</strong></h4><p>UI 性能是开发中不可忽视的一部分，尤其是在处理大量动态 UI 元素时，优化尤为重要。以下是一些常用的 UI 性能优化技巧：</p><ul><li><strong>避免频繁的 Canvas 重绘</strong>：每次更改 UI 时，Canvas 可能会重绘所有子元素，尤其是在复杂的 UI 中，频繁的重绘会影响性能。尽量减少对 Canvas 的修改，或者使用多个 Canvas 分区。</li><li><strong>使用 Object Pooling</strong>：对于频繁创建和销毁的 UI 元素（例如动态生成的按钮、列表项等），可以使用对象池技术来避免频繁的内存分配和回收。</li><li><strong>减少过多的 UI 元素</strong>：通过合并多个 UI 元素或者使用图像拼接，减少场景中 UI 元素的数量。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：禁用 Canvas 重绘</span><br>Canvas myCanvas = GameObject.Find(<span class="hljs-string">&quot;MyCanvas&quot;</span>).GetComponent&lt;Canvas&gt;();<br>myCanvas.renderMode = RenderMode.WorldSpace; <span class="hljs-comment">// 切换为世界空间渲染，避免频繁重绘</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-UI-动画与交互：提升用户体验"><a href="#2-UI-动画与交互：提升用户体验" class="headerlink" title="2. UI 动画与交互：提升用户体验"></a>2. UI 动画与交互：提升用户体验</h2><p>UI 动画和交互设计对于提升用户体验非常重要。合理使用动画和交互可以让 UI 更加生动，提升玩家的沉浸感和参与感。Unity 提供了强大的动画控制系统和事件机制，帮助开发者在 UI 中实现动态效果。</p><h3 id="2-1-使用-Animator-控制-UI-动画"><a href="#2-1-使用-Animator-控制-UI-动画" class="headerlink" title="2.1 使用 Animator 控制 UI 动画"></a>2.1 <strong>使用 <code>Animator</code> 控制 UI 动画</strong></h3><p><code>Animator</code> 组件可以让你为 UI 元素创建复杂的动画效果，包含位置、透明度、缩放等变化。通过控制 Animator 参数，可以实现各种 UI 动画效果。</p><h4 id="2-1-1-基础动画设置"><a href="#2-1-1-基础动画设置" class="headerlink" title="2.1.1 基础动画设置"></a>2.1.1 <strong>基础动画设置</strong></h4><p>可以通过 Animation 窗口创建 UI 动画。例如，创建一个淡入淡出的效果：</p><ol><li>在 Animation 窗口中创建动画，并设置 <code>CanvasGroup</code> 的 <code>alpha</code> 值。</li><li>通过 <code>Animator</code> 控制动画播放。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：使用 Animator 淡入 UI</span><br>Animator animator = GameObject.Find(<span class="hljs-string">&quot;MyPanel&quot;</span>).GetComponent&lt;Animator&gt;();<br>animator.SetTrigger(<span class="hljs-string">&quot;FadeIn&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="2-1-2-使用-CanvasGroup-控制透明度"><a href="#2-1-2-使用-CanvasGroup-控制透明度" class="headerlink" title="2.1.2 使用 CanvasGroup 控制透明度"></a>2.1.2 <strong>使用 <code>CanvasGroup</code> 控制透明度</strong></h4><p><code>CanvasGroup</code> 组件允许你控制 UI 元素的透明度、交互性以及是否启用遮罩。它是实现 UI 动画（如淡入、淡出、交互禁用等）的一个重要工具。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：通过 CanvasGroup 控制透明度</span><br>CanvasGroup canvasGroup = GameObject.Find(<span class="hljs-string">&quot;MyPanel&quot;</span>).GetComponent&lt;CanvasGroup&gt;();<br>canvasGroup.alpha = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 完全透明</span><br>canvasGroup.alpha = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 完全不透明</span><br></code></pre></td></tr></table></figure><h3 id="2-2-UI-动画的动态控制"><a href="#2-2-UI-动画的动态控制" class="headerlink" title="2.2 UI 动画的动态控制"></a>2.2 <strong>UI 动画的动态控制</strong></h3><p>在实际开发中，我们可能需要动态地控制 UI 元素的动画。例如，当玩家触发某个事件时（如点击按钮、达到某个游戏进度），可以通过脚本来控制 UI 动画。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：根据游戏进度动态触发 UI 动画</span><br><span class="hljs-keyword">if</span> (gameProgress &gt;= <span class="hljs-number">50</span>)<br>&#123;<br>    animator.SetTrigger(<span class="hljs-string">&quot;UnlockPanel&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-触摸与手势识别"><a href="#2-3-触摸与手势识别" class="headerlink" title="2.3 触摸与手势识别"></a>2.3 <strong>触摸与手势识别</strong></h3><p>随着移动设备的普及，触摸和手势识别成为提升用户交互体验的关键。Unity 提供了多种方式来实现触摸事件的响应。常用的触摸事件包括单点触摸、多点触摸、滑动、缩放等。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：检测触摸并响应</span><br><span class="hljs-keyword">if</span> (Input.touchCount &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    Touch touch = Input.GetTouch(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Began)<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Touch started at: &quot;</span> + touch.position);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Moved)<br>    &#123;<br>        <span class="hljs-comment">// 处理滑动事件</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Ended)<br>    &#123;<br>        <span class="hljs-comment">// 处理触摸结束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-UI-与用户交互：按钮点击与反馈"><a href="#2-4-UI-与用户交互：按钮点击与反馈" class="headerlink" title="2.4 UI 与用户交互：按钮点击与反馈"></a>2.4 <strong>UI 与用户交互：按钮点击与反馈</strong></h3><p>按钮是 UI 中最常用的交互组件。Unity 提供了灵活的按钮点击事件管理机制，可以让你轻松响应玩家的点击操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例：按钮点击响应</span><br>Button myButton = GameObject.Find(<span class="hljs-string">&quot;MyButton&quot;</span>).GetComponent&lt;Button&gt;();<br>myButton.onClick.AddListener(OnButtonClick);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonClick</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>    animator.SetTrigger(<span class="hljs-string">&quot;ButtonClicked&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Unity 的 UI 系统强大且灵活，适用于各类游戏开发。通过合理使用 UI 组件、布局管理、动态更新以及动画控制，开发者可以创建出既美观又高效的用户界面。在本篇博客中，我们深入探讨了 Unity UI 系统的工作原理、性能优化技巧、UI 动画的实现方法以及如何通过触摸和手势提升用户体验。希望这篇博客能帮助你在实际开发中更好地利用 Unity UI 系统，提升游戏的用户体验。</p><p>通过灵活运用 <code>Animator</code>、<code>CanvasGroup</code> 和手势识别等技术，你可以为玩家提供更加流畅、直观和互动的 UI 体验。通过本文的知识点，你不仅可以实现动态的 UI 动画，还能优化游戏 UI 的性能，并提升玩家的操作体验。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04、Unity 动画系统：动画控制、状态机与骨骼动画</title>
    <link href="/posts/43010/"/>
    <url>/posts/43010/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-动画系统：动画控制、状态机与骨骼动画的实际使用与-API-调用"><a href="#Unity-动画系统：动画控制、状态机与骨骼动画的实际使用与-API-调用" class="headerlink" title="Unity 动画系统：动画控制、状态机与骨骼动画的实际使用与 API 调用"></a>Unity 动画系统：动画控制、状态机与骨骼动画的实际使用与 API 调用</h1><p>Unity 提供了强大的动画系统，可以帮助开发者制作和管理游戏中的各种动画效果。在实际的开发过程中，我们不仅需要理解动画控制器、状态机和骨骼动画的基础概念，还需要通过 API 调用来控制和操作动画的播放、暂停、状态切换等。本篇博客将结合实际使用，深入讲解 Unity 动画系统的 API 调用，帮助开发者更好地在项目中使用动画。</p><hr><h3 id="1-Unity-动画系统原理：从动画控制器到动画状态机"><a href="#1-Unity-动画系统原理：从动画控制器到动画状态机" class="headerlink" title="1. Unity 动画系统原理：从动画控制器到动画状态机"></a><strong>1. Unity 动画系统原理：从动画控制器到动画状态机</strong></h3><h4 id="1-1-动画控制器与-Animator-组件"><a href="#1-1-动画控制器与-Animator-组件" class="headerlink" title="1.1 动画控制器与 Animator 组件"></a>1.1 <strong>动画控制器与 Animator 组件</strong></h4><p>在 Unity 中，<strong>Animator</strong> 组件是管理和控制角色动画的核心组件，通常附加到带有模型的 GameObject 上。通过 Animator 控制器，可以实现动画的播放、切换和过渡。以下是一些常用的 Animator API：</p><ul><li><code>Animator.Play(string stateName)</code>：直接播放指定的动画状态。</li><li><code>Animator.SetTrigger(string triggerName)</code>：设置触发器，通常用于控制动画的过渡。</li><li><code>Animator.SetBool(string parameterName, bool value)</code>：设置布尔值参数，用于控制状态机中的过渡条件。</li><li><code>Animator.SetFloat(string parameterName, float value)</code>：设置浮动值参数，例如角色的速度。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 播放指定的动画状态</span><br>Animator animator = GetComponent&lt;Animator&gt;();<br>animator.Play(<span class="hljs-string">&quot;Run&quot;</span>);<br><br><span class="hljs-comment">// 设置布尔参数触发动画过渡</span><br>animator.SetBool(<span class="hljs-string">&quot;IsJumping&quot;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置触发器以激活某个动作</span><br>animator.SetTrigger(<span class="hljs-string">&quot;Attack&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-2-动画状态机与过渡"><a href="#1-2-动画状态机与过渡" class="headerlink" title="1.2 动画状态机与过渡"></a>1.2 <strong>动画状态机与过渡</strong></h4><p>动画状态机是通过 <strong>Animator Controller</strong> 创建的，它定义了多个动画状态和状态之间的过渡条件。在代码中，我们可以通过动态设置 Animator 参数来控制动画的切换。</p><p>以下是一些控制动画过渡的常用 API：</p><ul><li><code>Animator.CrossFade(string stateName, float transitionDuration)</code>：跨越淡入到指定动画状态，适用于平滑过渡。</li><li><code>Animator.IsInTransition(int layerIndex)</code>：判断当前是否处于动画过渡状态。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 跨越淡入到“Jump”动画，持续 0.3 秒</span><br>animator.CrossFade(<span class="hljs-string">&quot;Jump&quot;</span>, <span class="hljs-number">0.3f</span>);<br><br><span class="hljs-comment">// 判断是否处于过渡状态</span><br><span class="hljs-keyword">if</span> (animator.IsInTransition(<span class="hljs-number">0</span>))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Currently transitioning between states.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-动画事件与动态控制"><a href="#2-动画事件与动态控制" class="headerlink" title="2. 动画事件与动态控制"></a><strong>2. 动画事件与动态控制</strong></h3><p>动画事件是 Unity 中的一种机制，允许在动画播放过程中在指定的时间点触发函数。通过动画事件，可以实现在动画的特定帧上触发音效、执行脚本或调用其他游戏逻辑。</p><h4 id="2-1-如何添加动画事件"><a href="#2-1-如何添加动画事件" class="headerlink" title="2.1 如何添加动画事件"></a>2.1 <strong>如何添加动画事件</strong></h4><ol><li>打开 Animation 窗口，选择需要添加事件的动画片段。</li><li>在时间轴上选择事件的触发点，右键点击并选择 <strong>Add Event</strong>。</li><li>在 Inspector 窗口中为事件选择对应的函数。</li></ol><h4 id="2-2-通过代码调用动画事件"><a href="#2-2-通过代码调用动画事件" class="headerlink" title="2.2 通过代码调用动画事件"></a>2.2 <strong>通过代码调用动画事件</strong></h4><p>虽然动画事件一般是在编辑器中设置的，但你也可以通过代码动态地控制动画事件的触发。通过 <code>AnimationEvent</code> 类，你可以在代码中添加和修改动画事件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">AnimationClip clip = animator.runtimeAnimatorController.animationClips[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 创建一个动画事件</span><br>AnimationEvent animationEvent = <span class="hljs-keyword">new</span> AnimationEvent();<br>animationEvent.time = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// 设置触发时间</span><br>animationEvent.functionName = <span class="hljs-string">&quot;OnAttack&quot;</span>; <span class="hljs-comment">// 设置调用的函数名称</span><br><br><span class="hljs-comment">// 将动画事件添加到动画片段</span><br>clip.AddEvent(animationEvent);<br><br><span class="hljs-comment">// 在目标脚本中实现 OnAttack 函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnAttack</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Attack animation triggered!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-Blend-Tree（混合树）与动画平滑过渡"><a href="#3-Blend-Tree（混合树）与动画平滑过渡" class="headerlink" title="3. Blend Tree（混合树）与动画平滑过渡"></a><strong>3. Blend Tree（混合树）与动画平滑过渡</strong></h3><p>Blend Tree 是 Unity 动画系统中的一个重要工具，它允许你根据参数（如速度、方向等）在多个动画片段之间平滑过渡。在实际开发中，我们通常使用 Blend Tree 来处理复杂的动画效果，如角色的移动状态。</p><h4 id="3-1-使用-Blend-Tree-动态调整动画"><a href="#3-1-使用-Blend-Tree-动态调整动画" class="headerlink" title="3.1 使用 Blend Tree 动态调整动画"></a>3.1 <strong>使用 Blend Tree 动态调整动画</strong></h4><p>Blend Tree 通过混合多个动画来实现平滑过渡，例如通过角色的速度和方向来切换跑步、行走或站立动画。以下是通过 API 动态控制 Blend Tree 的示例：</p><ul><li><code>Animator.SetFloat(string parameterName, float value)</code>：通过设置浮动值参数来影响 Blend Tree 的权重。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 假设我们有一个 Blend Tree 参数 Speed 来控制角色的移动状态</span><br>Animator animator = GetComponent&lt;Animator&gt;();<br><span class="hljs-built_in">float</span> speed = <span class="hljs-number">5.0f</span>; <span class="hljs-comment">// 角色的移动速度</span><br>animator.SetFloat(<span class="hljs-string">&quot;Speed&quot;</span>, speed);<br></code></pre></td></tr></table></figure><h4 id="3-2-动态调整-Blend-Tree-的参数"><a href="#3-2-动态调整-Blend-Tree-的参数" class="headerlink" title="3.2 动态调整 Blend Tree 的参数"></a>3.2 <strong>动态调整 Blend Tree 的参数</strong></h4><p>在实际开发中，你可能会根据游戏中的实时情况动态调整 Blend Tree 的参数。例如，根据角色的速度动态调整角色的行走和跑步动画。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 假设角色通过输入控制其移动</span><br>    <span class="hljs-built_in">float</span> speed = Mathf.Abs(Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>)) + Mathf.Abs(Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>));<br>    animator.SetFloat(<span class="hljs-string">&quot;Speed&quot;</span>, speed);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-骨骼动画与物体动画的区别与应用"><a href="#4-骨骼动画与物体动画的区别与应用" class="headerlink" title="4. 骨骼动画与物体动画的区别与应用"></a><strong>4. 骨骼动画与物体动画的区别与应用</strong></h3><p>在 Unity 中，骨骼动画和物体动画的使用场景各不相同。骨骼动画主要用于角色或复杂物体的动画，而物体动画则常用于 UI 元素和简单物体的动画。</p><h4 id="4-1-骨骼动画的-API-调用"><a href="#4-1-骨骼动画的-API-调用" class="headerlink" title="4.1 骨骼动画的 API 调用"></a>4.1 <strong>骨骼动画的 API 调用</strong></h4><p>骨骼动画通常用于控制角色的动作。Unity 提供了多种 API 来控制骨骼动画的播放和混合。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取骨骼动画的某个具体部位（如手臂）</span><br>Transform leftArm = animator.GetBoneTransform(HumanBodyBones.LeftUpperArm);<br>leftArm.Rotate(Vector3.up, <span class="hljs-number">30f</span> * Time.deltaTime); <span class="hljs-comment">// 让左臂旋转</span><br></code></pre></td></tr></table></figure><h4 id="4-2-物体动画的-API-调用"><a href="#4-2-物体动画的-API-调用" class="headerlink" title="4.2 物体动画的 API 调用"></a>4.2 <strong>物体动画的 API 调用</strong></h4><p>物体动画通常通过 <code>Transform</code> 控制物体的位置、旋转和缩放。以下是控制物体动画的常用 API：</p><ul><li><code>Transform.Translate(Vector3 translation)</code>：平移物体。</li><li><code>Transform.Rotate(Vector3 eulerAngles)</code>：旋转物体。</li><li><code>Transform.Scale(Vector3 scale)</code>：缩放物体。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 控制物体位置移动</span><br>transform.Translate(Vector3.forward * Time.deltaTime * <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 控制物体旋转</span><br>transform.Rotate(Vector3.up, <span class="hljs-number">90</span> * Time.deltaTime);<br></code></pre></td></tr></table></figure><hr><h3 id="5-动画性能优化与最佳实践"><a href="#5-动画性能优化与最佳实践" class="headerlink" title="5. 动画性能优化与最佳实践"></a><strong>5. 动画性能优化与最佳实践</strong></h3><p>在大型游戏中，动画的性能可能会成为瓶颈。以下是一些常见的动画性能优化技巧：</p><ul><li><strong>避免频繁的动画切换</strong>：频繁的动画切换会增加计算量，尽量避免不必要的状态变化。</li><li>**使用 Animator Controller 的 <strong>Layer</strong> 和 <strong>Sub-State Machine</strong> 来隔离不同类型的动画，减少冗余的状态机计算。</li><li><strong>动态加载与卸载动画</strong>：当不需要某些动画时，动态地卸载 Animator Controller，避免占用内存。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 动态加载 Animator Controller</span><br>animator.runtimeAnimatorController = Resources.Load&lt;RuntimeAnimatorController&gt;(<span class="hljs-string">&quot;Animators/CharacterRun&quot;</span>);<br><br><span class="hljs-comment">// 动态卸载不需要的 Animator Controller</span><br>animator.runtimeAnimatorController = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Unity 的动画系统不仅强大且灵活，通过掌握 Animator Controller、动画状态机、Blend Tree 和动画事件，你可以为游戏中的角色和物体创建丰富的动画效果。在实际开发中，合理使用 API 来控制动画播放、切换和优化性能，将使你的项目更加流畅和高效。希望本篇博客能帮助你更好地理解 Unity 动画系统的实际使用，并在开发中充分利用其强大的功能。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03、Unity 渲染与图形：渲染管线、优化与自定义 Shader</title>
    <link href="/posts/28561/"/>
    <url>/posts/28561/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-渲染与图形：渲染管线、优化与自定义-Shader"><a href="#Unity-渲染与图形：渲染管线、优化与自定义-Shader" class="headerlink" title="Unity 渲染与图形：渲染管线、优化与自定义 Shader"></a>Unity 渲染与图形：渲染管线、优化与自定义 Shader</h1><p>在 Unity 中，渲染是游戏表现和性能的核心。游戏中的每一帧都涉及到大量的渲染计算，包括物体的显示、光照计算、阴影投射等。这些渲染任务的性能直接影响游戏的流畅度和画面质量。因此，了解 Unity 渲染管线的原理、如何优化渲染性能，以及如何通过 Shader 创建自定义效果，对于每个开发者都是必不可少的技能。</p><p>本篇博客将深入探讨 Unity 渲染管线的原理与优化方法，如何使用 Shader 编写自定义效果，并介绍如何利用渲染队列、材质、光照与阴影来提升游戏的图形表现。</p><hr><h3 id="1-Unity-渲染管线的原理与优化"><a href="#1-Unity-渲染管线的原理与优化" class="headerlink" title="1. Unity 渲染管线的原理与优化"></a><strong>1. Unity 渲染管线的原理与优化</strong></h3><p>Unity 渲染管线是渲染图像的流程，涉及从场景数据到最终显示在屏幕上的图像的各个阶段。根据渲染方式的不同，Unity 提供了两种主要的渲染管线：<strong>Forward 渲染</strong> 和 <strong>Deferred 渲染</strong>。</p><h4 id="1-1-Forward-渲染"><a href="#1-1-Forward-渲染" class="headerlink" title="1.1 Forward 渲染"></a>1.1 <strong>Forward 渲染</strong></h4><p>Forward 渲染是传统的渲染管线，它会一次性渲染所有物体的所有材质和光照。每个物体的材质都会和场景中的所有光源进行计算，然后根据计算结果生成最终的像素颜色。Forward 渲染适用于光源较少、要求较高的渲染质量的场景。</p><p><strong>Forward 渲染的特点</strong>：</p><ul><li><strong>光照计算简单</strong>：每个物体的光照计算只会考虑与该物体相关的光源。</li><li><strong>支持透明物体</strong>：因为每个物体都单独渲染，所以可以有效处理透明物体的渲染。</li><li><strong>性能消耗较低</strong>：对于光源数量较少的场景，Forward 渲染的性能较好。</li></ul><h4 id="1-2-Deferred-渲染"><a href="#1-2-Deferred-渲染" class="headerlink" title="1.2 Deferred 渲染"></a>1.2 <strong>Deferred 渲染</strong></h4><p>Deferred 渲染与 Forward 渲染不同，它将渲染流程拆解为多个阶段，首先计算出场景中的所有几何数据（如位置、法线、颜色等），然后在后续的渲染阶段进行光照计算。Deferred 渲染适用于场景中光源较多的情况，因为它能够处理大量光源的计算，而不需要对每个物体逐个计算光照。</p><p><strong>Deferred 渲染的特点</strong>：</p><ul><li><strong>适合光源较多的场景</strong>：通过延迟光照计算，可以有效处理多个光源而不会影响性能。</li><li><strong>不适合透明物体</strong>：由于在计算光照时没有直接的物体信息，透明物体无法很好地处理。</li><li><strong>资源占用较高</strong>：Deferred 渲染需要更多的内存和显存来存储中间数据。</li></ul><h4 id="1-3-渲染管线的优化方法"><a href="#1-3-渲染管线的优化方法" class="headerlink" title="1.3 渲染管线的优化方法"></a>1.3 <strong>渲染管线的优化方法</strong></h4><p>优化渲染管线是提升游戏性能的关键。以下是一些优化渲染管线性能的方法：</p><ul><li><strong>减少绘制调用（Draw Calls）</strong>：绘制调用会增加 CPU 的负担，因此尽量合并材质，减少不必要的物体绘制调用。</li><li><strong>使用合批（Batching）</strong>：通过合批将多个相同材质的物体合并成一次渲染调用，减少渲染次数。</li><li><strong>合理使用光源</strong>：减少场景中的实时光源数量，尽量使用烘焙光照（Lightmap）来替代实时光源。</li><li><strong>简化场景中的物体</strong>：对于远距离的物体，可以使用低多边形模型或简化的 LOD（Level of Detail）模型来降低计算负担。</li></ul><hr><h3 id="2-渲染队列、材质与-Shader"><a href="#2-渲染队列、材质与-Shader" class="headerlink" title="2. 渲染队列、材质与 Shader"></a><strong>2. 渲染队列、材质与 Shader</strong></h3><p>在 Unity 中，渲染队列、材质与 Shader 是渲染系统的重要组成部分，它们共同决定了物体在屏幕上显示的效果和顺序。</p><h4 id="2-1-渲染队列（Render-Queue）"><a href="#2-1-渲染队列（Render-Queue）" class="headerlink" title="2.1 渲染队列（Render Queue）"></a>2.1 <strong>渲染队列（Render Queue）</strong></h4><p>渲染队列决定了物体在渲染时的顺序。Unity 使用一个 <strong>渲染队列</strong> 来控制物体从远到近的渲染顺序。例如，远离摄像机的物体先渲染，近处的物体后渲染。通过正确设置渲染队列，可以优化物体的渲染顺序，避免透明物体的渲染顺序问题。</p><p><strong>渲染队列的设置</strong>：</p><ul><li>Unity 默认分配的渲染队列值范围从 <code>1000</code> 到 <code>5000</code>，并按材质的类型进行划分：<ul><li><code>Background</code>: 1000</li><li><code>Geometry</code>: 2000</li><li><code>AlphaTest</code>: 2450</li><li><code>Transparent</code>: 3000</li><li><code>Overlay</code>: 4000</li></ul></li></ul><p>你可以在 Shader 中设置渲染队列，确保透明物体正确渲染。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">SubShader &#123;<br>    Tags &#123; <span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Overlay&quot;</span> &#125;<br>    Pass &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-材质（Material）"><a href="#2-2-材质（Material）" class="headerlink" title="2.2 材质（Material）"></a>2.2 <strong>材质（Material）</strong></h4><p>材质是物体渲染的基础，它通过 Shader 控制物体表面的视觉效果。每个材质有多个属性，如颜色、纹理、光泽度等，Shader 会利用这些属性计算最终的视觉效果。你可以通过修改材质的属性来实现不同的渲染效果。</p><p><strong>创建与使用材质</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Material material = <span class="hljs-keyword">new</span> Material(Shader.Find(<span class="hljs-string">&quot;Standard&quot;</span>));<br>material.color = Color.red;<br>renderer.material = material;<br></code></pre></td></tr></table></figure><h4 id="2-3-Shader-的基本概念"><a href="#2-3-Shader-的基本概念" class="headerlink" title="2.3 Shader 的基本概念"></a>2.3 <strong>Shader 的基本概念</strong></h4><p>Shader 是一种程序，负责计算如何渲染物体的表面。Unity 中的 Shader 分为顶点着色器和像素着色器：</p><ul><li><strong>顶点着色器</strong>：负责对物体的每个顶点进行处理，计算物体的位置、法线、颜色等数据。</li><li><strong>像素着色器</strong>：负责对物体的每个像素进行处理，计算最终颜色和光照效果。</li></ul><h4 id="2-4-自定义-Shader-实现自定义效果"><a href="#2-4-自定义-Shader-实现自定义效果" class="headerlink" title="2.4 自定义 Shader 实现自定义效果"></a>2.4 <strong>自定义 Shader 实现自定义效果</strong></h4><p>Shader 可以通过编程实现各种视觉效果，从基础的材质效果到复杂的光照计算，下面是一个简单的自定义 Shader 示例，模拟水面反射效果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#">Shader <span class="hljs-string">&quot;Custom/WaterReflection&quot;</span> &#123;<br>    Properties &#123;<br>        _Color (<span class="hljs-string">&quot;Base Color&quot;</span>, Color) = (<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>,<span class="hljs-number">1</span>)<br>        _MainTex (<span class="hljs-string">&quot;Base (RGB)&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123; &#125;<br>    &#125;<br>    SubShader &#123;<br>        Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>        Pass &#123;<br>            CGPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>            <span class="hljs-keyword">struct</span> appdata &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            <span class="hljs-keyword">struct</span> v2f &#123;<br>                float4 pos : POSITION;<br>            &#125;;<br><br>            <span class="hljs-function">v2f <span class="hljs-title">vert</span>(<span class="hljs-params">appdata v</span>)</span> &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            <span class="hljs-function">half4 <span class="hljs-title">frag</span>(<span class="hljs-params">v2f i</span>) : SV_Target</span> &#123;<br>                <span class="hljs-keyword">return</span> half4(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Blue water color</span><br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 Shader 会为物体提供一个简单的蓝色水面效果，可以通过修改 <code>frag</code> 函数来实现更复杂的反射和折射效果。</p><hr><h3 id="3-使用-Shader-实现自定义效果"><a href="#3-使用-Shader-实现自定义效果" class="headerlink" title="3. 使用 Shader 实现自定义效果"></a><strong>3. 使用 Shader 实现自定义效果</strong></h3><p>Shader 是图形编程的核心，通过编写自定义的 Shader，你可以创造各种各样的特殊效果，包括光照、反射、折射、法线贴图等。</p><h4 id="3-1-光照与阴影"><a href="#3-1-光照与阴影" class="headerlink" title="3.1 光照与阴影"></a>3.1 <strong>光照与阴影</strong></h4><p>光照和阴影是游戏中的基础渲染效果。Unity 支持多种光照模式，如漫反射光照、镜面反射光照等。在自定义 Shader 中，你可以通过计算光源与物体表面之间的角度来实现光照效果。</p><p>例如，以下 Shader 计算了基本的漫反射光照：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">Shader <span class="hljs-string">&quot;Custom/SimpleDiffuse&quot;</span> &#123;<br>    SubShader &#123;<br>        Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>        Pass &#123;<br>            CGPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>            <span class="hljs-keyword">struct</span> appdata &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            <span class="hljs-keyword">struct</span> v2f &#123;<br>                float4 pos : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            float4 _LightPosition;<br><br>            <span class="hljs-function">v2f <span class="hljs-title">vert</span>(<span class="hljs-params">appdata v</span>)</span> &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.normal = v.normal;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            <span class="hljs-function">half4 <span class="hljs-title">frag</span>(<span class="hljs-params">v2f i</span>) : SV_Target</span> &#123;<br>                half3 lightDir = normalize(_LightPosition.xyz - i.pos.xyz);<br>                <span class="hljs-built_in">float</span> diff = max(<span class="hljs-number">0</span>, dot(i.normal, lightDir));<br>                <span class="hljs-keyword">return</span> half4(diff, diff, diff, <span class="hljs-number">1</span>); <span class="hljs-comment">// Simple diffuse lighting</span><br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-实现反射与折射效果"><a href="#3-2-实现反射与折射效果" class="headerlink" title="3.2 实现反射与折射效果"></a>3.2 <strong>实现反射与折射效果</strong></h4><p>反射和折射效果常常用于水面、玻璃等透明物体。在 Shader 中，你可以通过反射和折射公式来模拟这些效果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#">Shader <span class="hljs-string">&quot;Custom/ReflectiveSurface&quot;</span> &#123;<br>    SubShader &#123;<br>        Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>        Pass &#123;<br>            CGPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>            <span class="hljs-keyword">struct</span> appdata &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            <span class="hljs-keyword">struct</span> v2f &#123;<br>                float4 pos : POSITION;<br>                float3 reflectDir : TEXCOORD0;<br>            &#125;;<br><br>            <span class="hljs-function">v2f <span class="hljs-title">vert</span>(<span class="hljs-params">appdata v</span>)</span> &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.reflectDir = reflect(-normalize(v.vertex.xyz), v.normal);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            <span class="hljs-function">half4 <span class="hljs-title">frag</span>(<span class="hljs-params">v2f i</span>) : SV_Target</span> &#123;<br>                half4 reflectedColor = texCUBE(_CubeMap, i.reflectDir); <span class="hljs-comment">// Use cubemap for reflection</span><br>                <span class="hljs-keyword">return</span> reflectedColor;<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 Shader 使用反射公式来计算每个像素的反射方向，并从环境的立方体贴图中获取反射颜色。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过理解 Unity 的渲染管线，合理优化渲染流程，以及通过 Shader 编写自定义效果，你可以大大提升游戏的图形表现和性能。优化渲染管线时，务必根据场景的需求选择合适的渲染方式（如 Forward 渲染或 Deferred 渲染）。同时，深入理解材质、渲染队列和 Shader 的工作原理，将帮助你在实际开发中应对复杂的图形渲染需求。</p><p>希望本篇博客能够帮助你深入了解 Unity 渲染与图形的基础，并为你的项目开发提供有价值的参考。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02、Unity 脚本与编程：高效的设计与优化实践</title>
    <link href="/posts/62789/"/>
    <url>/posts/62789/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本与编程：高效的设计与优化实践"><a href="#Unity-脚本与编程：高效的设计与优化实践" class="headerlink" title="Unity 脚本与编程：高效的设计与优化实践"></a>Unity 脚本与编程：高效的设计与优化实践</h1><p>在 Unity 游戏开发中，脚本编程是构建游戏逻辑、实现交互和优化性能的核心。无论是设计复用性强的脚本组件，还是优化脚本性能，掌握如何高效地组织和调试代码，都是每个 Unity 开发者必备的技能。本篇博客将深入探讨 Unity 中的脚本生命周期、事件系统、协程与异步操作、脚本组件化设计与组织、以及性能优化与内存管理等关键主题，帮助你更好地设计高效、可维护的游戏脚本。</p><hr><h3 id="1-Unity-脚本的生命周期与组件化设计"><a href="#1-Unity-脚本的生命周期与组件化设计" class="headerlink" title="1. Unity 脚本的生命周期与组件化设计"></a><strong>1. Unity 脚本的生命周期与组件化设计</strong></h3><p>在 Unity 中，脚本通常是通过 <strong>组件化</strong> 的方式附加到游戏对象（GameObject）上的，每个脚本都充当一个 <strong>组件</strong>，负责实现特定的游戏逻辑。Unity 的脚本生命周期是通过一系列生命周期函数（如 <code>Awake</code>、<code>Start</code>、<code>Update</code>、<code>OnDestroy</code>）来管理的。理解这些函数的作用和调用时机，是设计高效游戏脚本的基础。</p><h4 id="1-1-Unity-脚本的生命周期"><a href="#1-1-Unity-脚本的生命周期" class="headerlink" title="1.1 Unity 脚本的生命周期"></a>1.1 <strong>Unity 脚本的生命周期</strong></h4><p>Unity 脚本的生命周期与游戏对象的生命周期密切相关，以下是几个常见的生命周期函数：</p><ul><li><p><strong>Awake</strong>：当脚本实例化时调用，通常用于初始化变量或设置初始状态。<code>Awake</code> 在脚本启用之前调用，仅执行一次。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Awake 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Start</strong>：在游戏对象被启用时调用，执行初始化操作。通常可以依赖其他对象的初始化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Update</strong>：每一帧调用，用于执行每帧需要的操作，例如玩家输入、动画更新等。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Update 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnDestroy</strong>：当游戏对象销毁时调用，适用于清理资源、注销事件监听器等操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;OnDestroy 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-脚本的组件化设计"><a href="#1-2-脚本的组件化设计" class="headerlink" title="1.2 脚本的组件化设计"></a>1.2 <strong>脚本的组件化设计</strong></h4><p>Unity 强调 <strong>组件化设计</strong>，每个脚本组件应该只关注自己职责范围内的逻辑。例如，玩家控制脚本只负责控制玩家的输入与移动，敌人 AI 脚本只负责敌人的行为逻辑。通过这种设计，可以实现脚本的 <strong>高内聚</strong> 和 <strong>低耦合</strong>，使得代码易于复用、维护和扩展。</p><h4 id="1-3-脚本的调试与管理"><a href="#1-3-脚本的调试与管理" class="headerlink" title="1.3 脚本的调试与管理"></a>1.3 <strong>脚本的调试与管理</strong></h4><p>调试 Unity 脚本时，Unity 提供了调试功能，如在 Visual Studio 中设置断点，查看调试信息。合理地使用 <strong>日志</strong> 和 <strong>调试工具</strong>（例如 <code>Debug.Log</code>）可以帮助你快速定位问题。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>Debug.Log(<span class="hljs-string">&quot;Debug Message: Value of variable x: &quot;</span> + x);<br></code></pre></td></tr></table></figure><hr><h3 id="2-Unity-中的事件系统与消息传递"><a href="#2-Unity-中的事件系统与消息传递" class="headerlink" title="2. Unity 中的事件系统与消息传递"></a><strong>2. Unity 中的事件系统与消息传递</strong></h3><p>Unity 提供了强大的 <strong>事件系统</strong>，用于实现不同游戏对象间的通信。事件系统可以帮助不同组件解耦，减少直接的依赖关系，提高代码的可维护性。</p><h4 id="2-1-Unity-的消息传递机制"><a href="#2-1-Unity-的消息传递机制" class="headerlink" title="2.1 Unity 的消息传递机制"></a>2.1 <strong>Unity 的消息传递机制</strong></h4><p>Unity 中的消息传递机制包括以下几种方式：</p><ul><li><p><strong>SendMessage</strong>：发送消息到当前对象或其他对象，调用目标对象中的指定方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>gameObject.SendMessage(<span class="hljs-string">&quot;OnPlayerCollide&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>BroadcastMessage</strong>：广播消息，发送给所有组件，触发相同的函数调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>gameObject.BroadcastMessage(<span class="hljs-string">&quot;OnHit&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Event</strong>：通过事件委托的方式传递消息，适用于复杂的事件订阅机制。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayerHitEvent</span>()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> PlayerHitEvent OnPlayerHit;<br><br><span class="hljs-comment">// 触发事件</span><br>OnPlayerHit?.Invoke();<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-消息传递的最佳实践"><a href="#2-2-消息传递的最佳实践" class="headerlink" title="2.2 消息传递的最佳实践"></a>2.2 <strong>消息传递的最佳实践</strong></h4><ul><li><strong>减少依赖</strong>：尽量避免通过直接引用其他对象来实现通信，利用事件系统可以降低耦合度。</li><li><strong>解耦合</strong>：通过事件或消息传递，通知多个对象做出反应，而不需要彼此之间有直接依赖关系。</li></ul><hr><h3 id="3-协程与异步操作的使用"><a href="#3-协程与异步操作的使用" class="headerlink" title="3. 协程与异步操作的使用"></a><strong>3. 协程与异步操作的使用</strong></h3><p>协程（<strong>Coroutine</strong>）是 Unity 提供的一种简便方式，用于执行需要延时或异步操作的任务。协程的优势在于，它们允许你在执行过程中暂停并稍后恢复，不会阻塞主线程。</p><h4 id="3-1-协程的工作原理"><a href="#3-1-协程的工作原理" class="headerlink" title="3.1 协程的工作原理"></a>3.1 <strong>协程的工作原理</strong></h4><p>协程的核心是 <code>IEnumerator</code> 类型，它允许你在函数中执行某些延时操作或异步任务。你可以通过 <code>yield</code> 语句来控制协程的暂停和恢复。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">WaitAndPrint</span>()</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;2秒后打印&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>要启动协程，可以通过 <code>StartCoroutine</code> 来调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>StartCoroutine(WaitAndPrint());<br></code></pre></td></tr></table></figure><h4 id="3-2-协程的应用场景"><a href="#3-2-协程的应用场景" class="headerlink" title="3.2 协程的应用场景"></a>3.2 <strong>协程的应用场景</strong></h4><ul><li><strong>延迟操作</strong>：如延迟加载资源、延迟动画效果等。</li><li><strong>异步加载</strong>：例如在加载大型场景或资源时，使用协程来避免主线程阻塞。</li><li><strong>定时任务</strong>：定期执行某些操作，如敌人AI的巡逻行为。</li></ul><h4 id="3-3-协程的注意事项"><a href="#3-3-协程的注意事项" class="headerlink" title="3.3 协程的注意事项"></a>3.3 <strong>协程的注意事项</strong></h4><ul><li>协程会在每一帧检查 <code>yield</code> 条件，注意避免不必要的性能开销。</li><li>使用 <code>StopCoroutine</code> 可以中断协程，确保资源释放。</li></ul><hr><h3 id="4-Unity-中的脚本组件化设计与组织"><a href="#4-Unity-中的脚本组件化设计与组织" class="headerlink" title="4. Unity 中的脚本组件化设计与组织"></a><strong>4. Unity 中的脚本组件化设计与组织</strong></h3><p>在一个复杂的游戏项目中，脚本的组织结构非常重要。合理的组织结构不仅可以提高代码的复用性，还能使项目更容易维护和扩展。</p><h4 id="4-1-单例模式"><a href="#4-1-单例模式" class="headerlink" title="4.1 单例模式"></a>4.1 <strong>单例模式</strong></h4><p>单例模式是一种设计模式，确保一个类只有一个实例，并提供全局访问点。它通常用于管理游戏的全局状态或控制类（如游戏管理器、音效管理器）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameManager Instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Instance == <span class="hljs-literal">null</span>) &#123;<br>            Instance = <span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Destroy(gameObject);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-组件化设计与依赖注入"><a href="#4-2-组件化设计与依赖注入" class="headerlink" title="4.2 组件化设计与依赖注入"></a>4.2 <strong>组件化设计与依赖注入</strong></h4><p>依赖注入（<strong>Dependency Injection</strong>）是一种设计模式，通过它，组件不直接创建依赖项，而是将依赖项通过构造函数或属性注入到组件中。这种设计有助于解耦合和提高代码的可测试性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">private</span> IWeapon weapon;<br><br>    <span class="hljs-comment">// 通过构造函数注入依赖</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlayerController</span>(<span class="hljs-params">IWeapon weapon</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-脚本组织与模块划分"><a href="#4-3-脚本组织与模块划分" class="headerlink" title="4.3 脚本组织与模块划分"></a>4.3 <strong>脚本组织与模块划分</strong></h4><ul><li><strong>控制器</strong>（Controllers）：用于处理游戏对象的行为，如玩家控制器、敌人控制器等。</li><li><strong>模型</strong>（Models）：管理游戏数据和状态。</li><li><strong>视图</strong>（Views）：负责展示游戏数据，如 UI 控件、图形渲染等。</li></ul><hr><h3 id="5-脚本性能优化与内存管理"><a href="#5-脚本性能优化与内存管理" class="headerlink" title="5. 脚本性能优化与内存管理"></a><strong>5. 脚本性能优化与内存管理</strong></h3><p>游戏开发中，脚本的性能优化和内存管理至关重要。以下是一些常见的优化技巧：</p><h4 id="5-1-减少-GC（垃圾回收）压力"><a href="#5-1-减少-GC（垃圾回收）压力" class="headerlink" title="5.1 减少 GC（垃圾回收）压力"></a>5.1 <strong>减少 GC（垃圾回收）压力</strong></h4><ul><li><p><strong>对象池</strong>：使用对象池复用对象，避免频繁的内存分配和销毁操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br>ObjectPool&lt;Enemy&gt; enemyPool = <span class="hljs-keyword">new</span> ObjectPool&lt;Enemy&gt;();<br></code></pre></td></tr></table></figure></li><li><p><strong>减少不必要的内存分配</strong>：避免在 <code>Update</code> 或 <code>FixedUpdate</code> 中频繁创建新对象，减少 GC 触发。</p></li></ul><h4 id="5-2-优化循环与内存使用"><a href="#5-2-优化循环与内存使用" class="headerlink" title="5.2 优化循环与内存使用"></a>5.2 <strong>优化循环与内存使用</strong></h4><ul><li><strong>避免重复计算</strong>：在 <code>Update</code> 或其他循环中，避免重复计算相同的结果，可以缓存结果或优化算法。</li><li><strong>使用结构体而非类</strong>：结构体在栈上分配内存，避免了类的堆内存分配和垃圾回收。</li></ul><h4 id="5-3-序列化优化"><a href="#5-3-序列化优化" class="headerlink" title="5.3 序列化优化"></a>5.3 <strong>序列化优化</strong></h4><p>Unity 提供了多种序列化方式，合理使用可以有效减少内存占用：</p><ul><li>**合理使用 <code>SerializeField</code>**：避免在脚本中暴露不必要的公共变量，只序列化真正需要的数据。</li><li><strong>优化 <code>Awake</code> 和 <code>Start</code> 中的数据初始化</strong>：确保资源加载与初始化逻辑简洁高效，减少内存消耗。</li></ul><hr><h3 id="6-C-编程知识点补充"><a href="#6-C-编程知识点补充" class="headerlink" title="6. C# 编程知识点补充"></a><strong>6. C# 编程知识点补充</strong></h3><p>在 Unity 中使用 C# 编写脚本时，掌握一些常用的 C# 编程知识将大大提升开发效率。以下是一些常见的 C# 知识点：</p><h4 id="6-1-委托与事件"><a href="#6-1-委托与事件" class="headerlink" title="6.1 委托与事件"></a>6.1 <strong>委托与事件</strong></h4><p>委托（Delegate）和事件（Event）是 C# 提供的一种类型安全的回调机制。它们允许一个方法作为参数传递，并在特定事件发生时被调用。</p><ul><li><p><strong>委托</strong>：定义一个委托类型，然后创建一个委托实例，并指向某个方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><span class="hljs-keyword">public</span> MyDelegate myDelegate;<br><br>myDelegate = <span class="hljs-keyword">new</span> MyDelegate(PrintMessage);<br>myDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span> &#123;<br>    Debug.Log(message);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>事件</strong>：事件是一种基于委托的特殊用法，用于实现发布&#x2F;订阅模式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Notify OnNotify;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>()</span> &#123;<br>        OnNotify?.Invoke();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RespondToEvent</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Event triggered&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-2-LINQ-查询"><a href="#6-2-LINQ-查询" class="headerlink" title="6.2 LINQ 查询"></a>6.2 <strong>LINQ 查询</strong></h4><p>LINQ（语言集成查询）是 C# 中的一项强大功能，可以帮助开发者通过简洁的语法对集合进行查询、排序和过滤。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br></code></pre></td></tr></table></figure><hr><h3 id="7-总结与实践"><a href="#7-总结与实践" class="headerlink" title="7. 总结与实践"></a><strong>7. 总结与实践</strong></h3><p>在 Unity 开发中，掌握脚本生命周期、事件系统、协程与异步操作的使用、以及脚本的性能优化，是构建高效游戏脚本的关键。通过合理的设计与优化，可以提升游戏的运行效率，并减少不必要的资源消耗。希望通过这篇博客，您能对 Unity 脚本编程有更深入的理解，并在实际项目中应用这些知识。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01、Unity架构与生命周期解析</title>
    <link href="/posts/39444/"/>
    <url>/posts/39444/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-架构与生命周期解析"><a href="#Unity-架构与生命周期解析" class="headerlink" title="Unity 架构与生命周期解析"></a>Unity 架构与生命周期解析</h1><p>Unity 是一个功能强大且广泛使用的跨平台游戏开发引擎，它允许开发者创建 2D 和 3D 游戏、互动体验以及模拟环境。Unity 提供了一个完整的开发工具链，从编辑器到运行时引擎，再到跨平台部署，涵盖了游戏开发的各个方面。在本篇博客中，我们将深入探讨 Unity 引擎的架构和工作原理，并详细讲解其生命周期函数，帮助大家更好地理解 Unity 的内部机制。</p><hr><h3 id="1-Unity-引擎的架构与工作原理"><a href="#1-Unity-引擎的架构与工作原理" class="headerlink" title="1. Unity 引擎的架构与工作原理"></a><strong>1. Unity 引擎的架构与工作原理</strong></h3><p>Unity 引擎的核心架构可以分为几个主要部分：<strong>编辑器、脚本系统、物理引擎和渲染管线</strong>。每个部分都承担着不同的职责，协同工作以实现游戏开发的各个环节。</p><h4 id="1-1-Unity-编辑器"><a href="#1-1-Unity-编辑器" class="headerlink" title="1.1 Unity 编辑器"></a>1.1 <strong>Unity 编辑器</strong></h4><p>Unity 编辑器是开发者与引擎互动的主要界面。它提供了可视化的工具和面板，允许开发者设计游戏场景、管理资源、调试游戏等。</p><ul><li><strong>场景视图 (Scene View)</strong>: 用于查看和编辑游戏中的各个对象。开发者可以通过拖放组件和资源来构建游戏世界。</li><li><strong>游戏视图 (Game View)</strong>: 用于查看游戏的运行效果，类似于最终玩家所看到的画面。</li><li><strong>资产管理器 (Asset Browser)</strong>: 管理游戏中的各种资源，包括纹理、模型、音效、脚本等。</li><li><strong>Inspector 面板</strong>: 用于查看和编辑选中对象的属性。每个 GameObject（游戏对象）和 Component（组件）都可以在此面板中进行配置。</li></ul><h4 id="1-2-脚本与组件"><a href="#1-2-脚本与组件" class="headerlink" title="1.2 脚本与组件"></a>1.2 <strong>脚本与组件</strong></h4><p>Unity 的核心是其 <strong>组件化</strong> 的设计理念。在 Unity 中，游戏对象（<strong>GameObject</strong>）是场景中的所有实体，而它们的行为则通过 <strong>Component</strong>（组件）来实现。</p><ul><li><strong>GameObject（游戏对象）</strong>: 游戏中的每个实体，如角色、敌人、道具等，都是 GameObject。GameObject 本身不包含任何行为，行为是通过组件附加到 GameObject 上的。</li><li><strong>Component（组件）</strong>: 组件是附加到 GameObject 上的模块，它们定义了 GameObject 的行为和属性。例如，Transform 组件定义了 GameObject 的位置、旋转和缩放，而 Rigidbody 组件则赋予物理行为。</li></ul><p>Unity 提供了许多内置组件，如渲染组件、物理组件、音频组件等，开发者也可以编写自定义脚本并将其作为组件附加到 GameObject 上，从而实现游戏的特定行为。</p><h4 id="1-3-物理引擎"><a href="#1-3-物理引擎" class="headerlink" title="1.3 物理引擎"></a>1.3 <strong>物理引擎</strong></h4><p>Unity 内置了强大的物理引擎，主要包括 <strong>刚体（Rigidbody）</strong> 和 <strong>碰撞体（Collider）</strong>。Rigidbody 允许游戏对象受到物理力的影响，Collider 则用于检测碰撞事件。</p><ul><li><strong>Rigidbody</strong>: 让物体具有物理属性，如重力、摩擦力和弹性等。</li><li><strong>Collider</strong>: 用于检测物体之间的碰撞。常见的 Collider 类型有盒型碰撞体（Box Collider）、球形碰撞体（Sphere Collider）等。</li></ul><h4 id="1-4-渲染管线"><a href="#1-4-渲染管线" class="headerlink" title="1.4 渲染管线"></a>1.4 <strong>渲染管线</strong></h4><p>渲染管线负责将游戏中的 3D 对象渲染为最终的图像。Unity 提供了不同的渲染管线以适应不同的需求：</p><ul><li><strong>内置渲染管线</strong>: 默认渲染管线，适用于大多数游戏项目。</li><li><strong>高定义渲染管线（HDRP）</strong>: 为高端图形效果提供优化，适合需要高度逼真图像的游戏。</li><li><strong>轻量级渲染管线（LWRP）</strong>: 专为移动平台和低性能设备设计，注重性能优化。</li></ul><p>渲染管线的工作流程包括多个阶段，如顶点处理、光照计算、阴影绘制、后期处理等。开发者可以在这些阶段自定义渲染行为，以满足游戏的视觉需求。</p><hr><h3 id="2-Unity-的生命周期：从初始化到销毁"><a href="#2-Unity-的生命周期：从初始化到销毁" class="headerlink" title="2. Unity 的生命周期：从初始化到销毁"></a><strong>2. Unity 的生命周期：从初始化到销毁</strong></h3><p>Unity 中的生命周期函数控制了游戏对象的创建、更新、渲染等过程。理解这些生命周期函数的执行顺序，对于有效管理游戏的运行状态至关重要。</p><h4 id="2-1-Awake-和-Start"><a href="#2-1-Awake-和-Start" class="headerlink" title="2.1 Awake 和 Start"></a>2.1 <strong>Awake 和 Start</strong></h4><p>这两个函数用于游戏对象的初始化，分别在不同的时机被调用。</p><ul><li><p><strong>Awake</strong>: 在脚本实例化时被调用，只会调用一次，通常用于初始化变量或设置初始状态。它在所有的 <code>Start</code> 函数之前被调用，确保脚本的初始化优先完成。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Awake 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Start</strong>: 在 <code>Awake</code> 被调用后，脚本第一次启用时调用。它在所有的 <code>Awake</code> 函数调用后执行。适用于需要依赖其他对象或组件初始化的操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-Update-和-LateUpdate"><a href="#2-2-Update-和-LateUpdate" class="headerlink" title="2.2 Update 和 LateUpdate"></a>2.2 <strong>Update 和 LateUpdate</strong></h4><p>这两个函数是游戏的主循环函数，负责每一帧的更新逻辑。</p><ul><li><p><strong>Update</strong>: 每一帧都会调用一次，适用于处理与游戏进度相关的逻辑，如玩家输入、动画控制等。需要注意的是，<code>Update</code> 是按帧频率调用的，如果帧率较低，更新的速度也会减慢。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;Update 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>LateUpdate</strong>: 在所有的 <code>Update</code> 函数执行完之后调用，适用于依赖于其他对象更新的逻辑，如摄像机跟随玩家。<code>LateUpdate</code> 可以确保先更新其他对象，然后再更新与之相关的对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;LateUpdate 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-FixedUpdate"><a href="#2-3-FixedUpdate" class="headerlink" title="2.3 FixedUpdate"></a>2.3 <strong>FixedUpdate</strong></h4><p><code>FixedUpdate</code> 用于处理物理相关的更新，比如刚体的移动和力的应用。它的调用频率固定，独立于 <code>Update</code> 的帧率，因此非常适合物理计算。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;FixedUpdate 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-OnDestroy"><a href="#2-4-OnDestroy" class="headerlink" title="2.4 OnDestroy"></a>2.4 <strong>OnDestroy</strong></h4><p><code>OnDestroy</code> 是当游戏对象被销毁时调用的函数，通常用于清理资源，如移除事件监听器或停止协程等。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span> &#123;<br>    Debug.Log(<span class="hljs-string">&quot;OnDestroy 被调用&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-生命周期总结"><a href="#2-5-生命周期总结" class="headerlink" title="2.5 生命周期总结"></a>2.5 <strong>生命周期总结</strong></h4><ul><li><strong>Awake</strong>：初始化时调用，仅调用一次。</li><li><strong>Start</strong>：对象启用时调用，在 <code>Awake</code> 之后。</li><li><strong>Update</strong>：每帧调用，适用于常规更新逻辑。</li><li><strong>LateUpdate</strong>：在所有 <code>Update</code> 调用后执行，适用于依赖其他对象更新的逻辑。</li><li><strong>FixedUpdate</strong>：固定频率调用，适用于物理计算。</li><li><strong>OnDestroy</strong>：销毁时调用，用于清理资源。</li></ul><hr><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h3><p>Unity 的架构是一个高度模块化的系统，通过编辑器、脚本系统、物理引擎、渲染管线等多个模块协同工作，提供了丰富的功能支持。理解 Unity 的架构和生命周期是每个 Unity 开发者的基础，可以帮助你更高效地开发游戏，管理对象生命周期，并优化性能。</p><p>在实际开发中，理解每个生命周期函数的调用顺序和用途，能帮助你更好地控制游戏的运行状态，确保游戏逻辑的正确性和高效性。如果你还没有完全掌握 Unity 的生命周期，建议你通过实践和调试加深理解，并不断优化代码和资源管理，提升游戏的性能和玩家体验。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JavaScript原型链-类-函数与对象的关系</title>
    <link href="/posts/10749/"/>
    <url>/posts/10749/</url>
    
    <content type="html"><![CDATA[<h1 id="深入解析：JavaScript-原型链、类、对象与继承"><a href="#深入解析：JavaScript-原型链、类、对象与继承" class="headerlink" title="深入解析：JavaScript 原型链、类、对象与继承"></a>深入解析：JavaScript 原型链、类、对象与继承</h1><p>JavaScript 中的原型链、类、对象与继承是理解语言核心机制的关键，它们构成了 JS 面向对象编程（OOP）的基础。本文将全面解析这些概念，包括 <strong>函数、对象、构造函数、原型链、<code>__proto__</code>、<code>prototype</code>、继承</strong> 等，并通过代码实例详细讲解其机制。</p><hr><h2 id="1-函数的本质"><a href="#1-函数的本质" class="headerlink" title="1. 函数的本质"></a>1. 函数的本质</h2><p>在 JavaScript 中，<strong>函数既是可执行的代码块，也是对象</strong>。每个函数都有一个独特的 <code>prototype</code> 属性，这是面向对象的关键点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> greet); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greet.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// &#123; constructor: f &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>greet</code> 是一个函数，同时也是一个对象。</strong></li><li><code>greet.prototype</code> 是一个对象，用于定义共享给所有实例的方法和属性。</li><li>每当函数被用作构造函数（通过 <code>new</code> 操作符），新实例的原型链将连接到这个 <code>prototype</code> 对象。</li></ul><hr><h2 id="2-对象的创建方式"><a href="#2-对象的创建方式" class="headerlink" title="2. 对象的创建方式"></a>2. 对象的创建方式</h2><p>JavaScript 提供多种方式创建对象：</p><h3 id="2-1-字面量创建"><a href="#2-1-字面量创建" class="headerlink" title="2.1 字面量创建"></a>2.1 字面量创建</h3><p>最常用且直接的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-构造函数创建"><a href="#2-2-构造函数创建" class="headerlink" title="2.2 构造函数创建"></a>2.2 构造函数创建</h3><p>构造函数是一个普通函数，与 <code>new</code> 关键字配合，可以生成实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性</span><br>&#125;<br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;John&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>机制：</strong></p><ul><li><code>new</code> 操作符创建一个空对象，将其 <code>__proto__</code> 指向构造函数的 <code>prototype</code>。</li><li>构造函数内部的 <code>this</code> 绑定到新对象，执行构造函数代码后返回该对象。</li></ul><hr><h2 id="3-类：构造函数的语法糖"><a href="#3-类：构造函数的语法糖" class="headerlink" title="3. 类：构造函数的语法糖"></a>3. 类：构造函数的语法糖</h2><p>ES6 引入了 <code>class</code> 关键字，它更接近其他语言中的类定义形式。实际上，类是构造函数的语法糖，底层仍然基于原型机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性</span><br>    &#125;<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>john.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Hello, I&#x27;m John</span><br></code></pre></td></tr></table></figure><p>等效于以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="4-proto-与-prototype-的关系"><a href="#4-proto-与-prototype-的关系" class="headerlink" title="4. __proto__ 与 prototype 的关系"></a>4. <code>__proto__</code> 与 <code>prototype</code> 的关系</h2><h3 id="4-1-概念区别"><a href="#4-1-概念区别" class="headerlink" title="4.1 概念区别"></a>4.1 概念区别</h3><ul><li><p>**<code>__proto__</code>**：每个通过 <code>new</code> 操作符创建的对象都拥有一个隐藏属性 <code>__proto__</code>，它指向创建该对象的构造函数的 <code>prototype</code> 属性。</p></li><li><p>**<code>prototype</code>**：</p><p><code>prototype</code> 是每个函数对象（包括类）自动拥有的一个属性（仅函数和类持有），它指向一个对象，这个对象用于存储可以由该函数实例共享的属性和方法。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ul><li><strong>定义共享方法或属性：</strong> 所有由该函数（作为构造函数）创建的实例都可以通过原型链访问 <code>prototype</code> 对象上的属性和方法。</li><li><strong>建立原型链：</strong> 实例通过其内部的 <code>[[Prototype]]</code>（即 <code>__proto__</code>）属性链接到其构造函数的 <code>prototype</code>。</li></ul></li></ul><h3 id="4-2-验证关系"><a href="#4-2-验证关系" class="headerlink" title="4.2 验证关系"></a>4.2 验证关系</h3><p><strong>类的 <code>prototype</code> 的 <code>constructor</code> 属性默认指向类本身</strong>。这是 JavaScript 的一个设计特点，用于确保类和它的原型之间的逻辑关系一致。</p><p><code>constructor</code> 是 <code>prototype</code> 对象上的一个属性，用于指向创建该 <code>prototype</code> 对象的构造函数。</p><p>对于类或函数来说，它的 <code>prototype.constructor</code> 默认指向自身，这确保了我们可以通过实例的原型链找到对应的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="4-3-原型链"><a href="#4-3-原型链" class="headerlink" title="4.3 原型链"></a>4.3 原型链</h3><p>通过 <code>__proto__</code>，对象可以沿着原型链查找属性和方法.</p><p>实例对象的<code>__proto__</code>指向的是类或函数的prototype,然后<code>子类的prototype.__proto__</code>指向父类的prototype,最后指向<code>Object.prototype</code>,然后<code>Object.prototype</code>取<code>Object.prototype.__proto__</code>结束。因为<code>Object.prototype.__proto__</code>为null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null (原型链的终点)</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-4-prototype-和-constructor-的关系"><a href="#4-4-prototype-和-constructor-的关系" class="headerlink" title="4.4 prototype 和 constructor 的关系"></a>4.4 <code>prototype</code> 和 <code>constructor</code> 的关系</h3><p><strong>constructor是类prototype上的属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br>abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 获取当前实例的原型，即子类的 prototype</span><br>        <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-variable language_">this</span>);<br><br>        <span class="hljs-comment">// 检测子类是否定义了某些方法</span><br>        <span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>;<br>        <span class="hljs-keyword">const</span> hasCustomMethod = hasOwnProperty.<span class="hljs-title function_">call</span>(prototype, <span class="hljs-string">&#x27;customMethod&#x27;</span>);<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Is customMethod defined directly on the subclass prototype?&#x27;</span>, hasCustomMethod);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ParentClass</span> &#123;<br>    <span class="hljs-comment">// 子类定义了一个方法</span><br>    <span class="hljs-title function_">customMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is a custom method in the subclass&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化子类，触发父类逻辑</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br><br><span class="hljs-comment">// 验证原型关系</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Prototype of instance === SubClass.prototype:&#x27;</span>, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance) === <span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SubClass.prototype.constructor === SubClass:&#x27;</span>, <span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">SubClass</span>); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p><strong>解读</strong></p><h4 id="1-Object-getPrototypeOf-this-的作用"><a href="#1-Object-getPrototypeOf-this-的作用" class="headerlink" title="1. Object.getPrototypeOf(this) 的作用"></a><strong>1. <code>Object.getPrototypeOf(this)</code> 的作用</strong></h4><p>this指向的是当前实例，与在哪无关！这里的this是子类的实例，所以this的<code>__proto__</code>就是子类的prototype。</p><ul><li><p>返回值</p><ul><li><code>Object.getPrototypeOf(this)</code> 返回的是当前实例的原型。</li><li>在构造函数中调用时，<code>this</code> 是子类的实例，因此返回的是 <strong>子类的 <code>prototype</code> 对象</strong>。</li></ul></li><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance) === <span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="2-prototype-和-constructor-的关系"><a href="#2-prototype-和-constructor-的关系" class="headerlink" title="2. prototype 和 constructor 的关系"></a><strong>2. <code>prototype</code> 和 <code>constructor</code> 的关系</strong></h4><ul><li><p><strong><code>prototype</code></strong></p><ul><li>每个类都有一个 <code>prototype</code> 对象，用于定义该类实例共享的方法和属性。</li><li><strong><code>SubClass.prototype</code> 是 <code>instance</code> 的原型</strong>。</li></ul></li><li><p><strong><code>constructor</code></strong></p><ul><li>constructor是prototype上的属性， <code>prototype</code> 对象的 <code>constructor</code> 属性指向类本身。</li></ul></li><li><p><strong>验证关系</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">SubClass</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="3-hasOwnProperty-的使用"><a href="#3-hasOwnProperty-的使用" class="headerlink" title="3. hasOwnProperty 的使用"></a><strong>3. <code>hasOwnProperty</code> 的使用</strong></h4><ul><li><p><strong>功能</strong></p><ul><li><code>hasOwnProperty.call(prototype, &#39;methodName&#39;)</code> 检查方法是否直接定义在 <code>prototype</code> 上。</li><li><strong>不会检查继承的方法</strong>，只检查直接定义的内容。</li></ul></li><li><p><strong>原因</strong></p><ul><li>如果直接用 <code>prototype.methodName</code> 判断方法是否存在，会误包含继承自父类的方法。</li></ul></li><li><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hasCustomMethod = <span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;customMethod&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasCustomMethod); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="4-为什么不用-this-而用-Object-getPrototypeOf-this"><a href="#4-为什么不用-this-而用-Object-getPrototypeOf-this" class="headerlink" title="4. 为什么不用 this 而用 Object.getPrototypeOf(this)"></a><strong>4. 为什么不用 <code>this</code> 而用 <code>Object.getPrototypeOf(this)</code></strong></h4><p><code>Object.getPrototypeOf</code> 返回的是对象的 <strong><code>__proto__</code></strong> 属性的值，而不是构造函数的 **<code>prototype</code>**。</p><p><code>Object.getPrototypeOf(obj)</code> 返回的值等于 <code>obj.__proto__</code>，指向对象的原型。</p><ul><li><strong><code>this</code> 是实例</strong>：<ul><li>方法通常定义在 <code>prototype</code> 上，而不是实例本身。</li><li>如果直接用 <code>this.hasOwnProperty(&#39;methodName&#39;)</code> 检测，会始终返回 <code>false</code>。</li></ul></li><li><strong>正确方式</strong><ul><li>使用 <code>Object.getPrototypeOf(this)</code> 获取原型，检查方法是否存在于原型上。</li></ul></li></ul><hr><h4 id="5-原型链中的关系"><a href="#5-原型链中的关系" class="headerlink" title="5. 原型链中的关系"></a><strong>5. 原型链中的关系</strong></h4><ul><li><p><strong>子类的 <code>prototype</code> 是实例的原型</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance) === <span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>**子类的 <code>prototype</code> 继承自父类的 <code>prototype</code>**：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">ParentClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="总结：-proto-、prototype-和-this-的区别"><a href="#总结：-proto-、prototype-和-this-的区别" class="headerlink" title="总结：__proto__、prototype 和 this 的区别"></a><strong>总结：<code>__proto__</code>、<code>prototype</code> 和 <code>this</code> 的区别</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong><code>__proto__</code></strong></th><th><strong><code>prototype</code></strong></th><th><strong><code>this</code></strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>指向实例对象的原型（即构造函数的 <code>prototype</code> 属性）。</td><td>函数（或类）独有的属性，指向一个原型对象。</td><td>代表当前函数或方法执行时的调用上下文对象。</td></tr><tr><td><strong>存在于</strong></td><td>实例对象上，所有通过 <code>new</code> 创建的对象都自动拥有。</td><td>函数（包括类）上。</td><td>在函数或类方法中动态确定，取决于调用时的上下文。</td></tr><tr><td><strong>作用</strong></td><td>用于实现对象的原型链，可以访问构造函数原型上的属性和方法。</td><td>定义实例共享的属性和方法，作为实例的原型。</td><td>用于绑定当前对象的私有属性和方法。</td></tr><tr><td><strong>可被修改</strong></td><td>是可以读写的，直接修改会影响原型链。</td><td>可以被修改或覆盖，但通常应保留其默认行为。</td><td>是动态绑定的，无法直接修改。</td></tr><tr><td><strong>常见用途</strong></td><td>用于获取实例的原型，查找原型链上的属性和方法。</td><td>用于定义可供实例共享的属性和方法。</td><td>用于存储和操作当前对象的特定数据或行为。</td></tr><tr><td><strong>是否私有</strong></td><td>是实例对象的内部链接（非标准，但可访问）。</td><td>是函数（或类）的公共属性。</td><td>是函数或方法中动态绑定的局部变量。</td></tr></tbody></table><ol><li><strong><code>Object.getPrototypeOf(this)</code></strong><ul><li>用于获取当前实例的原型，在子类中返回子类的 <code>prototype</code> 对象。</li></ul></li><li><strong><code>prototype</code></strong><ul><li>是定义共享方法的对象，实例通过原型链访问这些方法。</li></ul></li><li><strong><code>hasOwnProperty</code></strong><ul><li>用于判断方法是否直接定义在 <code>prototype</code> 上，而非继承自父类。</li></ul></li><li><strong>原型链</strong><ul><li><code>instance.__proto__ === SubClass.prototype</code>。</li><li><code>SubClass.prototype.__proto__ === ParentClass.prototype</code>。</li><li><code>ParentClass.prototype.__proto__ === Object.prototype</code>。</li><li><code>Object.prototype.__proto__ === null</code>。结束原型链查找</li></ul></li></ol><p>这种设计通过动态检查子类是否实现某些方法，实现了行为的灵活扩展。</p><h2 id="5-继承的实现"><a href="#5-继承的实现" class="headerlink" title="5. 继承的实现"></a>5. 继承的实现</h2><h3 id="5-1-ES6-class-的继承"><a href="#5-1-ES6-class-的继承" class="headerlink" title="5.1 ES6 class 的继承"></a>5.1 ES6 <code>class</code> 的继承</h3><p>通过 <code>extends</code> 实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Rex barks</span><br></code></pre></td></tr></table></figure><p><strong>本质：</strong></p><ul><li>子类的 <code>prototype.__proto__</code> 指向父类的 <code>prototype</code>。</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(Dog.prototype.__proto__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Animal.prototype)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure><h3 id="5-2-使用-prototype-实现继承"><a href="#5-2-使用-prototype-实现继承" class="headerlink" title="5.2 使用 prototype 实现继承"></a>5.2 使用 <code>prototype</code> 实现继承</h3><p>在 ES6 之前，使用 <code>prototype</code> 手动实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用父类构造函数</span><br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 创建一个基于父类原型的对象</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 修正 `constructor`</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Rex barks</span><br></code></pre></td></tr></table></figure><p><code>Dog.prototype = Object.create(Animal.prototype);</code> 和 <code>Dog.prototype.__proto__ = Animal.prototype;</code> 的效果在设置原型链时是类似的，但它们的实现机制和使用场景有所不同。下面详细对比和解释：</p><hr><h4 id="1-Dog-prototype-Object-create-Animal-prototype"><a href="#1-Dog-prototype-Object-create-Animal-prototype" class="headerlink" title="1. Dog.prototype = Object.create(Animal.prototype);"></a><strong>1. <code>Dog.prototype = Object.create(Animal.prototype);</code></strong></h4><p><strong>行为</strong></p><ul><li><code>Object.create(Animal.prototype)</code> 创建了一个新的对象，这个对象的原型（即 <code>__proto__</code>）是 <code>Animal.prototype</code>。</li><li>然后，将这个新对象赋值给 <code>Dog.prototype</code>。</li></ul><p><strong>结果</strong></p><ul><li><code>Dog.prototype</code> 成为一个独立的对象，它的原型是 <code>Animal.prototype</code>。</li><li>改动 <code>Dog.prototype</code> 不会影响 <code>Animal.prototype</code>，因为它们是两个不同的对象。</li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> !== <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><hr><h4 id="2-Dog-prototype-proto-Animal-prototype"><a href="#2-Dog-prototype-proto-Animal-prototype" class="headerlink" title="2. Dog.prototype.__proto__ = Animal.prototype;"></a><strong>2. <code>Dog.prototype.__proto__ = Animal.prototype;</code></strong></h4><p><strong>行为</strong></p><ul><li>直接设置 <code>Dog.prototype</code> 的 <code>__proto__</code> 指向 <code>Animal.prototype</code>。</li><li>改动的是已有的 <code>Dog.prototype</code> 对象的内部原型链，而不是创建一个新对象。</li></ul><p><strong>结果</strong></p><ul><li><code>Dog.prototype</code> 本身没有被替换，而是修改了它的内部链接（<code>__proto__</code>）。</li><li>如果之前对 <code>Dog.prototype</code> 做过自定义操作，这些修改会保留。</li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> !== <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><hr><p><strong>差异与推荐使用</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong><code>Object.create</code></strong></th><th><strong><code>__proto__</code></strong></th></tr></thead><tbody><tr><td><strong>是否创建新对象</strong></td><td>是（<code>Object.create</code> 会创建一个新对象）</td><td>否，修改的是现有对象的 <code>__proto__</code></td></tr><tr><td><strong>安全性</strong></td><td>更安全，符合面向对象的编程原则</td><td>修改 <code>__proto__</code> 不建议直接用于生产环境</td></tr><tr><td><strong>可控性</strong></td><td>可以确保 <code>Dog.prototype</code> 独立于 <code>Animal.prototype</code></td><td>仅修改原型链，但不创建新对象</td></tr><tr><td><strong>推荐使用场景</strong></td><td>创建独立的原型链</td><td>快速原型修改，通常用于调试或临时操作</td></tr></tbody></table><hr><p><strong>为什么常用 <code>Object.create</code>？</strong></p><ul><li><strong>清晰</strong>：<code>Object.create(Animal.prototype)</code> 明确表示你希望创建一个基于 <code>Animal.prototype</code> 的新对象。</li><li><strong>符合规范</strong>：避免直接操作 <code>__proto__</code>，因为 <code>__proto__</code> 是非标准的历史遗留属性，ES6 引入了更优雅的方式（如 <code>Object.create</code> 和 <code>Object.setPrototypeOf</code>）。</li><li><strong>安全性</strong>：确保 <code>Dog.prototype</code> 独立于 <code>Animal.prototype</code>，减少意外副作用。</li></ul><h3 id="5-3-Object-create-的意义"><a href="#5-3-Object-create-的意义" class="headerlink" title="5.3 Object.create 的意义"></a>5.3 <code>Object.create</code> 的意义</h3><p><code>Object.create(proto)</code> 可以直接创建一个以 <code>proto</code> 为原型的对象，用于实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> animal = &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Animal speaks&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Animal speaks</span><br></code></pre></td></tr></table></figure><hr><h3 id="5-4-Object-setPrototypeOf-的意义"><a href="#5-4-Object-setPrototypeOf-的意义" class="headerlink" title="5.4 Object.setPrototypeOf 的意义"></a>5.4 <code>Object.setPrototypeOf</code> 的意义</h3><p><code>Object.setPrototypeOf</code> 是 JavaScript 提供的一种方法，用于<strong>动态设置一个对象的原型（<code>[[Prototype]]</code>）</strong>。它改变目标对象的内部原型指向，从而影响该对象的继承关系。</p><hr><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, prototype);<br></code></pre></td></tr></table></figure><ul><li>**<code>obj</code>**：要修改其原型的目标对象。</li><li>**<code>prototype</code>**：目标对象的新原型，可以是对象或 <code>null</code>（如果为 <code>null</code>，表示该对象不继承任何对象）。</li></ul><p>返回值：返回修改后的目标对象。</p><hr><p><strong>作用</strong></p><ol><li><strong>动态改变对象的原型链</strong>：<ul><li>改变一个对象的继承关系，让它从另一个对象继承属性和方法。</li></ul></li><li><strong>修复或调整继承链</strong>：<ul><li>在运行时更改对象的原型，比如修正错误的原型设置。</li></ul></li></ol><hr><p><strong>示例</strong></p><h5 id="1-改变原型链"><a href="#1-改变原型链" class="headerlink" title="1. 改变原型链"></a><strong>1. 改变原型链</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> animal = &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Animal speaks&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = &#123;<br>    <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 默认情况下，`dog` 的原型是 `Object.prototype`</span><br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// TypeError: dog.speak is not a function</span><br><br><span class="hljs-comment">// 改变原型链，让 `dog` 继承自 `animal`</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(dog, animal);<br><br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Animal speaks</span><br>dog.<span class="hljs-title function_">bark</span>();  <span class="hljs-comment">// Dog barks</span><br></code></pre></td></tr></table></figure><h5 id="2-修复原型"><a href="#2-修复原型" class="headerlink" title="2. 修复原型"></a><strong>2. 修复原型</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>);<br><br><span class="hljs-comment">// 修复 Dog 的原型链，让它正确继承 Animal.prototype</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>dog.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks`</span>);<br>&#125;;<br><br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Rex barks</span><br></code></pre></td></tr></table></figure><hr><ul><li><strong>优点</strong></li></ul><ol><li><strong>动态灵活</strong>：<ul><li>可以在运行时修改对象的继承关系，而不需要在声明时确定。</li></ul></li><li><strong>兼容性较好</strong>：<ul><li>ES6 正式标准化了 <code>Object.setPrototypeOf</code>，是推荐的方法之一（相较于直接操作 <code>__proto__</code>）。</li></ul></li></ol><hr><ul><li><strong>缺点</strong></li></ul><ol><li><strong>性能问题</strong>：<ul><li>改变原型链可能导致性能下降，因为 JavaScript 引擎需要重新计算和优化对象的属性查找路径。</li><li>如果频繁使用，可能会显著降低代码性能。</li></ul></li><li><strong>潜在风险</strong>：<ul><li>动态修改原型链可能引入难以调试的错误，破坏了代码的可预测性和稳定性。</li></ul></li></ol><hr><p><strong>推荐使用场景</strong></p><ol><li><strong>修复继承关系</strong>：<ul><li>在继承关系设置错误时（如 <code>prototype</code> 错误覆盖），用来修复或重设原型链。</li></ul></li><li><strong>动态调整继承</strong>：<ul><li>在某些场景需要动态扩展或切换继承关系时。</li></ul></li></ol><hr><p><strong>避免使用的场景</strong></p><ol><li><strong>频繁调用</strong>：<ul><li>不要在性能敏感的代码中频繁调用 <code>Object.setPrototypeOf</code>，因为它会显著降低 JavaScript 引擎的优化效果。</li></ul></li><li><strong>可以通过构造函数或 <code>Object.create</code> 实现的场景</strong>：<ul><li>如果可以通过声明时确定继承关系，优先使用 <code>Object.create</code> 或直接设置 <code>prototype</code>。</li></ul></li></ol><p><code>Object.setPrototypeOf</code> 是一种功能强大的工具，用于动态设置或修复对象的原型链。它比直接操作 <code>__proto__</code> 更符合规范，也更安全。但由于性能和可维护性问题，应尽量在明确的需求场景下使用，而不是滥用。</p><h2 id="6-私有属性与方法"><a href="#6-私有属性与方法" class="headerlink" title="6. 私有属性与方法"></a>6. 私有属性与方法</h2><p>ES2022 引入 <code>#</code> 符号定义私有字段，仅类内部可访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    #privateName; <span class="hljs-comment">// 私有字段</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.#privateName = name;<br>    &#125;<br>    <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#privateName;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.#privateName); <span class="hljs-comment">// 报错：私有字段无法访问</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-Object-create-的意义与-new-的区别"><a href="#7-Object-create-的意义与-new-的区别" class="headerlink" title="7. Object.create() 的意义与 new 的区别"></a><strong>7. <code>Object.create()</code> 的意义与 <code>new</code> 的区别</strong></h2><p>在 JavaScript 中，<code>Object.create()</code> 和 <code>new</code> 是两种创建对象的方式，但它们的用途和适用场景截然不同。理解它们的本质有助于更灵活地应用面向对象编程。</p><h3 id="7-1-Object-create-proto-的作用"><a href="#7-1-Object-create-proto-的作用" class="headerlink" title="7.1. Object.create(proto) 的作用"></a><strong>7.1. <code>Object.create(proto)</code> 的作用</strong></h3><p><code>Object.create(proto)</code> 是一种轻量级的对象创建方式，它通过指定的 <code>proto</code> 对象作为原型创建一个新对象。它不会执行构造函数，仅仅设置对象的原型。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><code>Object.create()</code> 不需要构造函数。</li><li>返回的对象直接继承了传入的原型对象。</li></ul><hr><h3 id="7-2-new-的作用"><a href="#7-2-new-的作用" class="headerlink" title="7.2. new 的作用"></a><strong>7.2. <code>new</code> 的作用</strong></h3><p><code>new</code> 操作符用于调用构造函数创建对象，同时会执行构造函数的初始化逻辑。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Dog&quot;</span>);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// 输出：Dog makes a sound</span><br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><code>new</code> 必须结合构造函数使用。</li><li>会执行构造函数逻辑，为新对象初始化属性。</li></ul><hr><h3 id="7-3-Object-create-proto-和-new-的对比"><a href="#7-3-Object-create-proto-和-new-的对比" class="headerlink" title="7.3. Object.create(proto) 和 new 的对比"></a><strong>7.3. <code>Object.create(proto)</code> 和 <code>new</code> 的对比</strong></h3><table><thead><tr><th>功能</th><th><code>Object.create(proto)</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>是否依赖构造函数</td><td>不需要</td><td>必须有构造函数</td></tr><tr><td>是否执行构造函数逻辑</td><td>不执行</td><td>执行</td></tr><tr><td>是否设置原型关系</td><td>是，手动设置为 <code>proto</code></td><td>是，由构造函数的 <code>prototype</code> 决定</td></tr><tr><td>灵活性</td><td>更灵活，适合手动控制原型关系</td><td>更强大，结合初始化功能</td></tr></tbody></table><hr><h3 id="7-4-Object-create-的用法场景"><a href="#7-4-Object-create-的用法场景" class="headerlink" title="7.4 Object.create() 的用法场景"></a><strong>7.4 <code>Object.create()</code> 的用法场景</strong></h3><p><strong>继承父类原型方法</strong></p><p>在不需要执行父类构造函数的场景下，<code>Object.create()</code> 非常适合用于继承原型方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Animal speaks&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 创建一个继承自 Animal.prototype 的对象</span><br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// 输出：Animal speaks</span><br></code></pre></td></tr></table></figure><hr><h3 id="7-5-使用-Object-create-和-new-模拟继承"><a href="#7-5-使用-Object-create-和-new-模拟继承" class="headerlink" title="7.5  使用 Object.create() 和 new 模拟继承"></a><strong>7.5  使用 <code>Object.create()</code> 和 <code>new</code> 模拟继承</strong></h3><p><code>Object.create()</code> 常用于实现继承，它可以将子类的原型指向父类的原型，而无需执行父类构造函数。</p><p><strong>通过 <code>Object.create()</code> 实现继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 调用父类构造函数继承属性</span><br>&#125;<br><br><span class="hljs-comment">// 设置原型链</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 继承父类原型方法</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 修复 constructor 指向</span><br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks`</span>);<br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// 输出：Rex barks</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>通过 <code>new</code> 实现继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound`</span>);<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 调用父类构造函数继承属性</span><br>&#125;<br><br><span class="hljs-comment">// 设置原型链</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// 使用 new 创建父类的一个实例作为子类的原型</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 修复 constructor 指向</span><br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks`</span>);<br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>);<br>dog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// 输出：Rex barks</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>对比：</strong></p><ul><li><strong>使用 <code>Object.create()</code> 的优点：</strong><ul><li>不会执行父类的构造函数，避免不必要的初始化操作。</li><li>更加灵活，可以精确控制原型链。</li></ul></li><li><strong>使用 <code>new</code> 的优点：</strong><ul><li>更易于理解，简化了手动设置原型链的操作。</li></ul></li></ul><hr><h3 id="7-6-new-Animal-prototype-的问题"><a href="#7-6-new-Animal-prototype-的问题" class="headerlink" title="7.6 new Animal.prototype() 的问题"></a><strong>7.6 <code>new Animal.prototype()</code> 的问题</strong></h3><p><code>new</code> 操作符要求目标必须是一个<strong>可调用的函数</strong>，但 <code>Animal.prototype</code> 是一个普通对象，它没有构造函数的属性，因此 <code>new Animal.prototype()</code> 会报错。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// &quot;object&quot;</span><br><br><span class="hljs-comment">// 以下代码会报错：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">prototype</span>(); <span class="hljs-comment">// TypeError: Animal.prototype is not a constructor</span><br></code></pre></td></tr></table></figure><p><strong>为什么 <code>Object.create()</code> 不会报错？</strong></p><p><code>Object.create()</code> 不依赖构造函数，它只需要一个对象作为原型。<code>Animal.prototype</code> 是一个普通对象，可以作为 <code>Object.create()</code> 的参数。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 正常运行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><ol><li><strong><code>Object.create()</code> 的意义：</strong><ul><li>创建一个继承自指定原型的对象。</li><li>不会执行构造函数，是轻量级的继承方法。</li></ul></li><li><strong><code>new</code> 的意义：</strong><ul><li>调用构造函数创建对象。</li><li>同时执行构造函数初始化逻辑。</li></ul></li><li><strong><code>Object.create()</code> 和 <code>new</code> 的区别：</strong><ul><li><code>Object.create()</code> 适合需要手动设置原型链、不需要初始化的场景。</li><li><code>new</code> 适合结合初始化和原型链继承的场景。</li></ul></li><li><strong>避免错误：</strong><ul><li><code>Animal.prototype</code> 通常是普通对象，不能用 <code>new</code> 调用。</li><li>使用 <code>Object.create()</code> 可以更灵活地设置原型关系，而无需调用构造函数。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中的类详细解析</title>
    <link href="/posts/7201/"/>
    <url>/posts/7201/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-中的类、约束、继承、抽象类和接口：详细解析"><a href="#TypeScript-中的类、约束、继承、抽象类和接口：详细解析" class="headerlink" title="TypeScript 中的类、约束、继承、抽象类和接口：详细解析"></a>TypeScript 中的类、约束、继承、抽象类和接口：详细解析</h1><p>在 TypeScript 中，<strong>类</strong>、<strong>继承</strong>、<strong>约束</strong>、<strong>抽象类</strong> 和 <strong>接口</strong> 是构建面向对象程序的重要概念。这些概念提供了更强的类型安全性、更灵活的结构，并能够帮助开发者在编写代码时避免很多常见的错误。本篇博客将详细介绍这些概念，并解答一些常见的疑问，帮助你理解它们如何共同工作。</p><hr><h2 id="1-类（Class）"><a href="#1-类（Class）" class="headerlink" title="1. 类（Class）"></a>1. <strong>类（Class）</strong></h2><p><strong>类</strong>是面向对象编程的核心，它定义了对象的结构和行为。TypeScript 中的类在 ES6 类的基础上进行了增强，支持静态成员、访问修饰符（如 <code>public</code>, <code>private</code> 和 <code>protected</code>）以及构造函数等。</p><h3 id="类的基本语法"><a href="#类的基本语法" class="headerlink" title="类的基本语法"></a>类的基本语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// 成员变量</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-comment">// 构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, and I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);<br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: Hello, my name is Alice, and I am 30 years old.</span><br></code></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：用于初始化对象实例。</li><li><strong>成员变量</strong>：类中定义的属性。</li><li><strong>方法</strong>：定义类的行为。</li></ul><hr><h2 id="2-继承（Inheritance）"><a href="#2-继承（Inheritance）" class="headerlink" title="2. 继承（Inheritance）"></a>2. <strong>继承（Inheritance）</strong></h2><p>继承是面向对象编程的核心特性之一，它允许我们从一个已有的类创建一个新类，并继承父类的属性和方法。通过继承，可以重用代码并且增强其功能。</p><p><strong>继承的基本语法</strong></p><ul><li>**super()**：子类必须调用 <code>super()</code> 来调用父类的构造函数。</li><li><strong>方法重写</strong>：子类可以重写父类的方法。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-comment">// 父类成员对象</span><br>  <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;constructor-Parent&quot;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 父类方法，修改 obj 对象</span><br>  <span class="hljs-title function_">updateObj</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span> = newName;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-comment">// 子类覆盖父类 obj 成员对象</span><br>  <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Child&#x27;</span> &#125;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;constructor-Child&quot;</span>)<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br> <br>&#125;<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: &quot;Child&quot;</span><br><br><span class="hljs-comment">// 通过子类实例调用父类方法</span><br>childInstance.<span class="hljs-title function_">updateObj</span>(<span class="hljs-string">&quot;Updated by Parent&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: &quot;Updated by Parent&quot;</span><br><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-variable constant_">LOG</span>]: <span class="hljs-string">&quot;constructor-Child&quot;</span> <br>[<span class="hljs-variable constant_">LOG</span>]: <span class="hljs-string">&quot;constructor-Parent&quot;</span> <br>[<span class="hljs-variable constant_">LOG</span>]: <span class="hljs-string">&quot;Child&quot;</span> <br>[<span class="hljs-variable constant_">LOG</span>]: <span class="hljs-string">&quot;Updated by Parent&quot;</span> <br></code></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name;<br>    <span class="hljs-built_in">Parent</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;constructor-Parent&quot;</span> &lt;&lt; std::endl;<br>        name = <span class="hljs-string">&quot;Parent&quot;</span>;  <span class="hljs-comment">// 修改成员变量 name</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newName)</span> </span>&#123;<br>        name = newName;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name = <span class="hljs-string">&quot;child&quot;</span>;  <span class="hljs-comment">// 子类覆盖父类的成员变量</span><br><br>    <span class="hljs-built_in">Child</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;constructor-Child&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 父类构造函数会先执行，这时候父类的 name 会被修改</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Child childInstance;<br>    std::cout &lt;&lt; childInstance.name &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: &quot;Parent1&quot;</span><br>    childInstance.<span class="hljs-built_in">updateName</span>(<span class="hljs-string">&quot;Updated by Parent&quot;</span>);<br><span class="hljs-comment">//Parent parentInstance = childInstance;</span><br><span class="hljs-comment">//std::cout &lt;&lt; &amp;childInstance &lt;&lt; std::endl;</span><br><span class="hljs-comment">//std::cout &lt;&lt; &amp;parentInstance &lt;&lt; std::endl;</span><br>std::cout &lt;&lt; childInstance.name &lt;&lt; std::endl;<br>    <span class="hljs-comment">//std::cout &lt;&lt; parentInstance.name &lt;&lt; std::endl;  // 输出: &quot;Updated by Parent&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">constructor-<span class="hljs-title class_">Parent</span><br>constructor-<span class="hljs-title class_">Child</span><br>child<br>child<br></code></pre></td></tr></table></figure><p><strong>思考</strong><br>    为什么c++继承的实现，当子类调用父类的成员函数时，对成员变量进行修改，但是子类的实例化对象获取的成员变量却没有改变，<br>但是在javascript中却恰恰相反，输出的是修改之后的值，为什么类似的代码，得到的结果却不一样！</p><p><strong>分析</strong></p><h4 id="1-C-中的行为分析"><a href="#1-C-中的行为分析" class="headerlink" title="1.C++ 中的行为分析"></a>1.<strong>C++ 中的行为分析</strong></h4><p><strong>C++ 的继承机制和成员变量覆盖</strong></p><p>在 C++ 中，继承关系是静态的。子类会覆盖父类的成员变量，如果子类定义了一个与父类同名的成员变量，那么子类的成员变量会遮蔽（隐藏）父类的成员变量。换句话说，父类和子类各自有独立的成员变量，即使它们同名。</p><p><strong>C++ 中的成员函数调用与对象绑定</strong></p><p>在 C++ 中，当你调用一个父类的成员函数时，实际的行为依赖于 <strong>静态绑定</strong> 和 <strong>动态绑定</strong> 的机制。</p><ol><li><strong>静态绑定</strong>：如果你调用的是父类的成员函数，而该函数没有使用 <code>virtual</code> 关键字（非虚函数），那么函数调用就是静态绑定。函数调用是在编译时就确定下来的，不能通过子类覆盖。</li><li><strong>动态绑定</strong>：如果父类的成员函数是 <code>virtual</code>（虚函数），那么调用的成员函数是动态绑定的，具体调用哪个版本的函数是通过 <strong>虚函数表（VTable）</strong> 实现的，在运行时通过对象的实际类型来确定。</li></ol><ul><li><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h4><ol><li><strong>父类构造函数</strong>：在 C++ 中，子类的构造函数调用之前，<strong>父类的构造函数会先被调用</strong>。在 <code>Parent</code> 类的构造函数中，<code>name</code> 被设置为 <code>&quot;Parent&quot;</code>，但此时 <code>Child</code> 类中的 <code>name</code> 成员已经被初始化为 <code>&quot;child&quot;</code>，因此父类构造函数修改的是父类的 <code>name</code>，而不是子类的 <code>name</code>。</li><li><strong>成员覆盖</strong>：在 C++ 中，父类和子类都有一个名为 <code>name</code> 的成员变量。由于子类的 <code>name</code> 会覆盖父类的 <code>name</code>（即 <strong>隐藏</strong> 父类的成员变量），在访问 <code>childInstance.name</code> 时，访问的是子类的 <code>name</code>，即 <code>&quot;child&quot;</code>。</li><li>**调用 <code>updateName</code>**：当你调用 <code>childInstance.updateName(&quot;Updated by Parent&quot;)</code> 时，实际上调用的是父类的 <code>updateName</code> 方法，因为该方法在 <code>Parent</code> 类中定义，而子类没有重写它。由于该方法修改的是父类的 <code>name</code>，它会更新父类的 <code>name</code> 为 <code>&quot;Updated by Parent&quot;</code>，但是此时 <strong>修改的是父类的 <code>name</code> 成员</strong>，而非子类的 <code>name</code>。因此，输出的是 <code>&quot;child&quot;</code>。</li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h4><p>在 C++ 中，即使子类覆盖了父类的成员变量，父类方法调用时修改的也是父类的 <code>name</code>，而非子类的 <code>name</code>。这是因为成员变量的覆盖并不影响父类的成员。除非调用的是虚函数，他才会根据虚函数表去修改对应实例对象的值。</p></li></ul><h4 id="2-JavaScript-中的继承与方法调用"><a href="#2-JavaScript-中的继承与方法调用" class="headerlink" title="2.JavaScript 中的继承与方法调用"></a>2.<strong>JavaScript 中的继承与方法调用</strong></h4><p>JavaScript 的继承机制和 C++ 有显著不同。在 JavaScript 中，所有对象的属性和方法都是通过原型链来查找的，而且 JavaScript 的类并不像 C++ 那样直接将成员变量分配到类的实例中。成员变量实际上是类实例的属性，并且原型链的行为使得调用父类的方法时，子类可以覆盖和修改父类的属性。</p><p>在 JavaScript 中，当子类实例化时，父类的构造函数会在子类的构造函数中调用（如果子类没有显式调用 <code>super()</code>，会自动调用）。不过，<strong>父类构造函数的调用时机</strong>是：<strong>在子类构造函数的成员变量初始化之前</strong>，但通常会在子类的 <code>this</code> 上下文可用之前调用。</p><p><strong>更详细的解释：</strong></p><ol><li><p><strong>如果子类没有定义构造函数：</strong> 当子类没有定义构造函数时，JavaScript 会自动调用父类的构造函数。并且，父类的构造函数会在子类的成员变量初始化之前被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Parent constructor&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Parent&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-comment">// 没有构造函数，默认调用父类构造函数</span><br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();  <span class="hljs-comment">// 输出: &quot;Parent constructor&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: &quot;Parent&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>如果子类显式定义了构造函数：</strong> 当子类显式定义了构造函数时，必须在子类构造函数内调用 <code>super()</code> 来调用父类的构造函数。<code>super()</code> 必须在子类构造函数中调用，在子类访问 <code>this</code> 之前。否则，JavaScript 会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Parent constructor&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Parent&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();  <span class="hljs-comment">// 调用父类构造函数，必须在访问 `this` 之前</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();  <br><span class="hljs-comment">// 输出: </span><br><span class="hljs-comment">// &quot;Parent constructor&quot; </span><br><span class="hljs-comment">// &quot;Child constructor&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: &quot;Parent&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">age</span>);   <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure></li></ol><p>在上面的例子中，你可以看到：</p><ul><li><p><code>super()</code> 调用是在 <code>Child</code> 类的构造函数中，且它发生在对 <code>this</code> 的访问之前。这样，父类的构造函数会首先被调用，子类再对自己的成员变量进行初始化。</p></li><li><p>如果子类没有显式定义构造函数，会自动调用父类的构造函数，且父类的构造函数会在子类的成员变量初始化之前调用。</p></li><li><p>如果子类显式定义了构造函数，必须显式调用 <code>super()</code>，并且 <code>super()</code> 必须在访问 <code>this</code> 之前调用。</p></li></ul><h4 id="总结：C-和-JavaScript-的差异"><a href="#总结：C-和-JavaScript-的差异" class="headerlink" title="总结：C++ 和 JavaScript 的差异"></a><strong>总结：C++ 和 JavaScript 的差异</strong></h4><ol><li>**C++**：<ul><li><strong>在 C++ 中，父类和子类的成员变量是完全独立的，子类可以覆盖父类的成员，但方法操作的是父类的成员变量（即使是通过子类实例调用父类方法）。</strong></li><li><strong>C++ 中的继承机制更多依赖于成员的直接访问和静态绑定。</strong></li></ul></li><li><strong>JavaScript</strong>：<ul><li><strong>在 JavaScript 中，父类和子类的成员变量（或者对象属性）是共享的，子类的成员变量可以覆盖父类的成员变量。</strong></li><li><strong>方法的调用基于原型链，动态绑定使得子类可以覆盖父类的方法，且修改的成员变量是子类实例的属性。</strong></li><li><strong>需要注意的是，无论父类在构造函数中如何修改成员变量，都会被子类重新定义的成员变量给覆盖，无论子类是否有显性的调用构造函数。</strong></li><li><strong>子类重写成员变量时，不能只声明不定义，要声明和定义一起实现。</strong></li></ul></li></ol><p>因此，C++ 和 JavaScript 在继承和成员变量的覆盖上有显著差异，导致它们在行为上的不同。</p><h2 id="3-抽象类（Abstract-Class）"><a href="#3-抽象类（Abstract-Class）" class="headerlink" title="3. 抽象类（Abstract Class）"></a>3. <strong>抽象类（Abstract Class）</strong></h2><p>抽象类是无法直接实例化的类，它只能作为其他类的基类。抽象类通常包含 <strong>抽象方法</strong>（没有实现的方法），这些方法必须在继承该抽象类的子类中实现。抽象类提供了一种通用的方式来定义一组类的基本结构。</p><h3 id="抽象类的基本语法"><a href="#抽象类的基本语法" class="headerlink" title="抽象类的基本语法"></a>抽象类的基本语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;  <span class="hljs-comment">// 抽象方法，没有实现</span><br><br>  <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Moving...&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Bark!&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.<span class="hljs-title function_">makeSound</span>(); <span class="hljs-comment">// Output: Bark!</span><br>dog.<span class="hljs-title function_">move</span>();      <span class="hljs-comment">// Output: Moving...</span><br></code></pre></td></tr></table></figure><ul><li><strong>抽象方法</strong>：在抽象类中定义，但没有提供实现。子类必须提供实现。</li><li><strong>普通方法</strong>：可以在抽象类中定义，并提供实现。子类可以继承或重写。</li></ul><h3 id="abstract-关键字"><a href="#abstract-关键字" class="headerlink" title="abstract 关键字"></a><strong><code>abstract</code> 关键字</strong></h3><p><code>abstract</code> 关键字用于标记类或方法为抽象的。抽象类不能直接实例化，必须通过继承来创建实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">area</span>(): <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> radius: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">area</span>(): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(circle.<span class="hljs-title function_">area</span>()); <span class="hljs-comment">// Output: 78.53981633974483</span><br></code></pre></td></tr></table></figure><h2 id="4-接口（Interface）"><a href="#4-接口（Interface）" class="headerlink" title="4. 接口（Interface）"></a>4. <strong>接口（Interface）</strong></h2><p>接口是 TypeScript 的一种用于定义对象结构的方式，它定义了对象的 <strong>类型</strong>，但并不提供实现。接口可以包含方法签名、属性声明和索引签名。接口与抽象类的一个主要区别是，接口只定义结构，不允许有实现。</p><h3 id="接口的基本语法"><a href="#接口的基本语法" class="headerlink" title="接口的基本语法"></a>接口的基本语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is moving`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br>dog.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// Output: Buddy is moving</span><br></code></pre></td></tr></table></figure><ul><li><strong>实现接口</strong>：通过 <code>implements</code> 关键字，类可以实现一个或多个接口。</li><li><strong>接口的可选属性</strong>：接口中的属性可以是可选的，通过 <code>?</code> 标记。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">// 可选属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><ul><li><strong>接口</strong>：接口只能定义方法签名和属性，没有方法实现。接口不关心类的继承结构。</li><li><strong>抽象类</strong>：抽象类可以包含实现的方法，也可以定义抽象方法。抽象类是具有部分实现的类。</li></ul><h3 id="示例：接口-vs-抽象类"><a href="#示例：接口-vs-抽象类" class="headerlink" title="示例：接口 vs 抽象类"></a>示例：接口 vs 抽象类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Bark!&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Bark!&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-类型约束（Constraints）和-as-关键字"><a href="#5-类型约束（Constraints）和-as-关键字" class="headerlink" title="5. 类型约束（Constraints）和 as 关键字"></a>5. <strong>类型约束（Constraints）和 <code>as</code> 关键字</strong></h2><p><strong>类型约束</strong>是 TypeScript 中用于指定泛型的类型的机制，它通过 <code>extends</code> 关键字来约束泛型。<code>as</code> 关键字用于强制类型转换。</p><h3 id="约束的基本语法"><a href="#约束的基本语法" class="headerlink" title="约束的基本语法"></a>约束的基本语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> getLength&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> &#125;&gt;(<span class="hljs-attr">value</span>: T): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>));  <span class="hljs-comment">// Output: 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// Output: 3</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>T extends &#123; length: number &#125;</code> 表示泛型 <code>T</code> 必须具有 <code>length</code> 属性。</p><h3 id="as-关键字的使用"><a href="#as-关键字的使用" class="headerlink" title="as 关键字的使用"></a><code>as</code> 关键字的使用</h3><p><code>as</code> 关键字用于将值强制转换为特定类型。它告诉 TypeScript 编译器，开发者有信心该值符合某种类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;  <span class="hljs-comment">// 使用 as 转换类型</span><br></code></pre></td></tr></table></figure><p><code>as</code> 在类型推导中非常有用，尤其是在从外部 API 获取数据时，我们知道返回值的类型但 TypeScript 无法自动推断。</p><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul><li><strong>类（Class）</strong> 是面向对象编程的基本单位，用于定义对象的属性和行为。</li><li><strong>继承（Inheritance）</strong> 允许一个类继承另一个类的属性和方法，并可进行方法重写。</li><li><strong>抽象类（Abstract Class）</strong> 是不能直接实例化的类，主要用于定义其他类的基础结构。</li><li><strong>接口（Interface）</strong> 主要用于定义对象的结构，类可以实现接口并提供方法实现。</li><li><strong>类型约束（Constraints）</strong> 用于限制泛型类型，确保其具有特定的属性或方法。</li><li><strong><code>as</code> 关键字</strong> 用于进行类型断言，将值强制转换为指定的类型。</li></ul><p>理解这些概念及其用法，对于写出清晰、类型安全的 TypeScript 代码至关重要。希望这篇博客能帮助你更好地理解 TypeScript 中的面向对象编程和类型系统！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript联合类型详解</title>
    <link href="/posts/57764/"/>
    <url>/posts/57764/</url>
    
    <content type="html"><![CDATA[<h1 id="联合类型（Union-Types）详解"><a href="#联合类型（Union-Types）详解" class="headerlink" title="联合类型（Union Types）详解"></a>联合类型（Union Types）详解</h1><p>在 TypeScript 中，<strong>联合类型</strong>（Union Types）允许你将多种类型组合在一起，表示一个值可以是多种类型之一。这种灵活的类型定义可以帮助你在开发过程中处理更多元的数据结构，同时保证类型安全。</p><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><p>联合类型的语法是通过 <code>|</code>（竖线）符号将多个类型连接起来。你可以定义一个变量、参数或者返回值，它可以是多个类型中的任何一种。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br>value = <span class="hljs-string">&quot;Hello&quot;</span>;  <span class="hljs-comment">// 合法</span><br>value = <span class="hljs-number">42</span>;       <span class="hljs-comment">// 合法</span><br>value = <span class="hljs-literal">true</span>;     <span class="hljs-comment">// 错误，布尔类型不在联合类型范围内</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>value</code> 可以是 <code>string</code> 或 <code>number</code> 类型。当你使用联合类型时，TypeScript 会根据上下文来推断当前值的类型，但你必须小心处理不同类型的值之间的差异。</p><h2 id="2-联合类型的使用场景"><a href="#2-联合类型的使用场景" class="headerlink" title="2. 联合类型的使用场景"></a>2. 联合类型的使用场景</h2><ul><li><strong>多个可能的类型</strong>：当你不确定一个值的具体类型，或者这个值可能是多种类型中的任何一种时，联合类型非常有用。</li><li><strong>函数参数或返回值</strong>：如果函数参数或者返回值可能是不同的类型，使用联合类型可以确保类型安全。</li></ul><p><strong>例子：联合类型应用于函数参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printId</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ID is:&quot;</span>, id);<br>&#125;<br><br><span class="hljs-title function_">printId</span>(<span class="hljs-number">101</span>);       <span class="hljs-comment">// 合法，传入一个数字</span><br><span class="hljs-title function_">printId</span>(<span class="hljs-string">&quot;ABC123&quot;</span>);  <span class="hljs-comment">// 合法，传入一个字符串</span><br><span class="hljs-title function_">printId</span>(<span class="hljs-literal">true</span>);      <span class="hljs-comment">// 错误，布尔类型不符合联合类型</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>id</code> 可以是 <code>string</code> 或 <code>number</code> 类型，函数会根据传入的参数类型进行处理。</p><h2 id="3-联合类型的细节"><a href="#3-联合类型的细节" class="headerlink" title="3. 联合类型的细节"></a>3. 联合类型的细节</h2><h3 id="3-1-使用联合类型时的类型保护"><a href="#3-1-使用联合类型时的类型保护" class="headerlink" title="3.1. 使用联合类型时的类型保护"></a>3.1. 使用联合类型时的类型保护</h3><p>当你使用联合类型时，TypeScript 会将你处理的值看作是<strong>多个类型的交集</strong>。为了能够安全地对值进行操作，你通常需要在处理该值之前进行 <strong>类型保护</strong>。</p><p>一种常见的类型保护方式是使用 <code>typeof</code> 来检查类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLength</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 只有字符串才有 .length 属性</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 只有数字才有 .toFixed() 方法</span><br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">printLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 输出: 5</span><br><span class="hljs-title function_">printLength</span>(<span class="hljs-number">123.456</span>);   <span class="hljs-comment">// 输出: 123.46</span><br></code></pre></td></tr></table></figure><p>通过使用 <code>typeof</code> 操作符，TypeScript 可以知道在不同的分支中，<code>value</code> 的确切类型是什么，从而允许你安全地调用相应的方法或属性。</p><h3 id="3-2-使用-in-进行类型保护"><a href="#3-2-使用-in-进行类型保护" class="headerlink" title="3.2. 使用 in 进行类型保护"></a>3.2. 使用 <code>in</code> 进行类型保护</h3><p>你还可以通过 <code>in</code> 操作符来检查对象中是否存在某个属性，从而推断类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cat</span> &#123;<br>  <span class="hljs-title function_">meow</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeSound</span>(<span class="hljs-params">animal: Dog | Cat</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bark&quot;</span> <span class="hljs-keyword">in</span> animal) &#123;<br>    animal.<span class="hljs-title function_">bark</span>();  <span class="hljs-comment">// animal 被推断为 Dog 类型</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    animal.<span class="hljs-title function_">meow</span>();  <span class="hljs-comment">// animal 被推断为 Cat 类型</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>in</code> 操作符帮助我们根据 <code>animal</code> 对象的不同属性，来判断它是 <code>Dog</code> 类型还是 <code>Cat</code> 类型。</p><h2 id="4-联合类型与数组"><a href="#4-联合类型与数组" class="headerlink" title="4. 联合类型与数组"></a>4. 联合类型与数组</h2><p>联合类型也可以用于数组元素的类型，意味着数组中的元素可以是不同类型的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">mixedArray</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">100</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mixedArray);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>mixedArray</code> 是一个可以包含 <code>string</code> 或 <code>number</code> 类型的数组。你可以访问数组中的任何元素，但在操作时要小心类型的不一致性。</p><h2 id="5-联合类型与对象"><a href="#5-联合类型与对象" class="headerlink" title="5. 联合类型与对象"></a>5. 联合类型与对象</h2><p>你可以将联合类型应用于对象的属性，表示该属性可以有多种类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// age 可以是数字或字符串</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">person1</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person2</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;unknown&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>age</code> 可以是数字类型或字符串类型。</p><h2 id="6-结合字面量类型和联合类型"><a href="#6-结合字面量类型和联合类型" class="headerlink" title="6. 结合字面量类型和联合类型"></a>6. 结合字面量类型和联合类型</h2><p>你还可以将字面量类型与联合类型结合起来，进一步细化变量或函数的可能值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Direction</span> = <span class="hljs-string">&quot;left&quot;</span> | <span class="hljs-string">&quot;right&quot;</span> | <span class="hljs-string">&quot;up&quot;</span> | <span class="hljs-string">&quot;down&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">direction: Direction</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Moving&quot;</span>, direction);<br>&#125;<br><br><span class="hljs-title function_">move</span>(<span class="hljs-string">&quot;left&quot;</span>);  <span class="hljs-comment">// 合法</span><br><span class="hljs-title function_">move</span>(<span class="hljs-string">&quot;right&quot;</span>); <span class="hljs-comment">// 合法</span><br><span class="hljs-title function_">move</span>(<span class="hljs-string">&quot;forward&quot;</span>); <span class="hljs-comment">// 错误，&quot;forward&quot; 不在字面量联合类型中</span><br></code></pre></td></tr></table></figure><p>通过将字面量类型与联合类型结合，你可以强制变量只能是有限的特定值。</p><h2 id="7-联合类型的局限性"><a href="#7-联合类型的局限性" class="headerlink" title="7. 联合类型的局限性"></a>7. 联合类型的局限性</h2><p>虽然联合类型提供了极大的灵活性，但它也有一些局限性。由于联合类型是多个类型的集合，因此当你访问该值时，TypeScript 无法知道你究竟想对该值进行何种操作。这是因为不同的类型有不同的属性和方法，因此你必须进行类型检查，以避免在不合适的类型上调用不支持的方法。</p><p>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;  <span class="hljs-comment">// 错误，number 类型没有 .length 属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>number</code> 类型没有 <code>.length</code> 属性，所以直接访问会导致错误。</p><h2 id="8-联合类型与类型推导"><a href="#8-联合类型与类型推导" class="headerlink" title="8. 联合类型与类型推导"></a>8. 联合类型与类型推导</h2><p>TypeScript 的类型推导机制可以在大多数情况下推导出联合类型。在定义变量时，如果没有明确指定类型，TypeScript 会根据赋给变量的值来推导其类型。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 推导为 string 类型</span><br>value = <span class="hljs-number">42</span>;           <span class="hljs-comment">// 合法，value 推导为 string | number 类型</span><br></code></pre></td></tr></table></figure><p>如果你将一个变量初始化为某个值，TypeScript 会自动推导出该变量的联合类型，而不需要显式地指定。</p><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><ul><li><strong>定义和使用联合类型</strong>：使用 <code>|</code> 来组合多个类型，表示一个值可以是多种类型中的任何一种。</li><li><strong>类型保护</strong>：为了安全地操作联合类型的值，常用的类型保护方法包括 <code>typeof</code>、<code>instanceof</code> 和 <code>in</code> 操作符。</li><li><strong>联合类型与数组、对象</strong>：联合类型可以应用于数组元素和对象属性，使其可以接受不同类型的值。</li><li><strong>字面量类型和联合类型结合</strong>：字面量类型和联合类型结合，可以进一步限定值的范围。</li><li><strong>类型推导</strong>：TypeScript 会根据赋给变量的值推导出联合类型。</li></ul><p>通过这些特点，联合类型在 TypeScript 中提供了强大的灵活性，使得你可以处理更加复杂和多样化的类型，同时保持类型安全。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript接口详解</title>
    <link href="/posts/47720/"/>
    <url>/posts/47720/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-中的-接口-Interface-详解"><a href="#TypeScript-中的-接口-Interface-详解" class="headerlink" title="TypeScript 中的 接口 (Interface) 详解"></a>TypeScript 中的 <strong>接口 (Interface)</strong> 详解</h1><p><strong>接口 (Interface)</strong> 是 TypeScript 中用于定义对象形状的一种方式。它能够定义对象的结构、类的行为以及函数的签名等，是 TypeScript 类型系统的一个重要组成部分。接口提供了一种契约或规范，来描述对象和类必须遵守的结构或行为。</p><p>在 TypeScript 中，接口的主要作用是声明对象和类的结构，使得代码更具可读性和可维护性。</p><h2 id="1-基本的接口定义"><a href="#1-基本的接口定义" class="headerlink" title="1. 基本的接口定义"></a>1. <strong>基本的接口定义</strong></h2><p>接口的最基本的形式就是通过 <code>interface</code> 关键字定义一个对象的类型。你可以指定对象的属性和它们的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>Person</code> 接口定义了一个对象必须有 <code>name</code> 和 <code>age</code> 两个属性，并且分别是 <code>string</code> 和 <code>number</code> 类型。通过 <code>const person: Person</code>，我们强制要求 <code>person</code> 必须符合 <code>Person</code> 接口的结构。</p><h2 id="2-可选属性"><a href="#2-可选属性" class="headerlink" title="2. 可选属性"></a>2. <strong>可选属性</strong></h2><p>在接口中，我们可以使用 <code>?</code> 来标记某个属性为可选的。这意味着这个属性可以在对象中不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  address?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选属性</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">person1</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person2</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">40</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;123 Street&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>address</code> 是一个可选属性，所以可以选择提供，也可以不提供。</p><h2 id="3-只读属性"><a href="#3-只读属性" class="headerlink" title="3. 只读属性"></a>3. <strong>只读属性</strong></h2><p>可以使用 <code>readonly</code> 修饰符来指定对象的属性是只读的，即初始化后不能被修改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;<br>point.<span class="hljs-property">x</span> = <span class="hljs-number">30</span>;  <span class="hljs-comment">// 错误：不能修改只读属性 &#x27;x&#x27;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 和 <code>y</code> 是只读属性，不能再修改它们的值。</p><h2 id="4-函数类型"><a href="#4-函数类型" class="headerlink" title="4. 函数类型"></a>4. <strong>函数类型</strong></h2><p>接口不仅可以描述对象的结构，也可以用于定义函数的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddFunction</span> &#123;<br>  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: <span class="hljs-title class_">AddFunction</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>AddFunction</code> 接口规定了一个函数类型，该函数接收两个 <code>number</code> 类型的参数并返回一个 <code>number</code> 类型的值。</p><h2 id="5-索引签名"><a href="#5-索引签名" class="headerlink" title="5. 索引签名"></a>5. <strong>索引签名</strong></h2><p>当你不知道对象的确切属性名时，可以使用索引签名来描述对象的结构。索引签名允许你指定对象的属性类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dictionary</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">dict</span>: <span class="hljs-title class_">Dictionary</span> = &#123;<br>  <span class="hljs-string">&quot;apple&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;banana&quot;</span>: <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>Dictionary</code> 接口定义了一个具有字符串键（<code>key: string</code>）和数字值（<code>number</code>）的对象。</p><h2 id="6-类实现接口"><a href="#6-类实现接口" class="headerlink" title="6. 类实现接口"></a>6. <strong>类实现接口</strong></h2><p>接口不仅可以描述对象的结构，还可以作为类的类型约束。在 TypeScript 中，类可以通过 <code>implements</code> 关键字来实现接口，从而强制类符合接口的结构。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">sound</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sound</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Buddy&quot;</span>);<br>dog.<span class="hljs-title function_">sound</span>();  <span class="hljs-comment">// 输出 &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 类实现了 <code>Animal</code> 接口，确保类中有 <code>name</code> 属性和 <code>sound</code> 方法。使用 <code>implements</code> 关键字，我们强制类遵循接口的约定。</p><h2 id="7-继承接口"><a href="#7-继承接口" class="headerlink" title="7. 继承接口"></a>7. <strong>继承接口</strong></h2><p>接口可以继承其他接口。这是通过 <code>extends</code> 关键字来实现的，允许一个接口继承多个其他接口的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">job</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">worker</span>: <span class="hljs-title class_">Worker</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Engineer&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Worker</code> 接口继承了 <code>Person</code> 接口，因此它包含了 <code>name</code> 和 <code>age</code> 属性，并且增加了 <code>job</code> 属性。</p><h2 id="8-接口与联合类型"><a href="#8-接口与联合类型" class="headerlink" title="8. 接口与联合类型"></a>8. <strong>接口与联合类型</strong></h2><p>接口还可以与联合类型结合使用，以便定义多种不同类型的组合。你可以使用接口来描述联合类型中的某个部分。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cat</span> &#123;<br>  <span class="hljs-title function_">meow</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pet</span> = <span class="hljs-title class_">Dog</span> | <span class="hljs-title class_">Cat</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeSound</span>(<span class="hljs-params">pet: Pet</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bark&quot;</span> <span class="hljs-keyword">in</span> pet) &#123;<br>    pet.<span class="hljs-title function_">bark</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    pet.<span class="hljs-title function_">meow</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = &#123; <span class="hljs-attr">bark</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>) &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">cat</span>: <span class="hljs-title class_">Cat</span> = &#123; <span class="hljs-attr">meow</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Meow!&quot;</span>) &#125;;<br><br><span class="hljs-title function_">makeSound</span>(dog); <span class="hljs-comment">// 输出 &quot;Woof!&quot;</span><br><span class="hljs-title function_">makeSound</span>(cat); <span class="hljs-comment">// 输出 &quot;Meow!&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Pet</code> 是一个联合类型，它可以是 <code>Dog</code> 或 <code>Cat</code>。通过检查 <code>pet</code> 是否有 <code>bark</code> 方法来区分不同的类型。</p><h2 id="9-接口的扩展与多重继承"><a href="#9-接口的扩展与多重继承" class="headerlink" title="9. 接口的扩展与多重继承"></a>9. <strong>接口的扩展与多重继承</strong></h2><p>接口不仅可以继承一个接口，也可以继承多个接口，支持多重继承，允许你将多个接口的功能组合到一个接口中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> B &#123;<br>  <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> C <span class="hljs-keyword">extends</span> A, B &#123;<br>  <span class="hljs-attr">c</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: C = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>C</code> 接口继承了 <code>A</code> 和 <code>B</code>，因此它需要包含 <code>a</code>、<code>b</code> 和 <code>c</code> 这三个属性。</p><h2 id="10-接口与类型别名的区别"><a href="#10-接口与类型别名的区别" class="headerlink" title="10. 接口与类型别名的区别"></a>10. <strong>接口与类型别名的区别</strong></h2><p>接口与类型别名在 TypeScript 中有许多相似之处，但它们也有一些区别：</p><ul><li><strong>扩展性</strong>：接口是可以被继承的，并且可以通过声明合并扩展接口。类型别名则不能被直接继承。</li><li><strong>功能限制</strong>：类型别名不仅可以定义对象的结构，也可以定义其他类型（如联合类型、交叉类型、元组等），而接口主要用于描述对象和类的形状。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ShapeType</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这两者看起来相似，但接口通常用于类和对象的定义，而类型别名则更灵活，能支持更复杂的类型结构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>接口 (Interface)</strong> 是 TypeScript 中的强大功能，用于定义对象、类、函数等的结构。</li><li>接口可以包含<strong>属性</strong>、<strong>方法</strong>、<strong>可选属性</strong>、<strong>只读属性</strong>等。</li><li><strong>类实现接口</strong>，可以确保类的结构符合接口的要求。</li><li><strong>接口继承</strong>可以将多个接口的功能合并。</li><li>TypeScript 中还有 **类型别名 (type alias)**，它与接口有许多相似之处，但类型别名可以定义更多复杂的类型结构。</li></ol><p>通过合理使用接口，可以增强 TypeScript 代码的可读性、可维护性和类型安全性，从而提升开发效率和代码质量。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript模块化详解</title>
    <link href="/posts/11376/"/>
    <url>/posts/11376/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-模块化详解：export、import-和-require-的深入解析"><a href="#JavaScript-模块化详解：export、import-和-require-的深入解析" class="headerlink" title="JavaScript 模块化详解：export、import 和 require 的深入解析"></a>JavaScript 模块化详解：<code>export</code>、<code>import</code> 和 <code>require</code> 的深入解析</h3><p>随着现代 JavaScript 应用的不断发展，模块化编程已经成为了标准的开发实践。模块化能够帮助我们将代码组织成更小、更易于管理和维护的块，同时提高代码的重用性和可读性。JavaScript 提供了多种模块化机制，其中最常用的是 <strong>ES6 模块</strong>（<code>import</code>&#x2F;<code>export</code>）和 <strong>CommonJS 模块</strong>（<code>require</code>&#x2F;<code>module.exports</code>）。在 TypeScript 中，推荐使用 ES6 模块化。</p><p>本文将详细探讨这两种模块化方案的使用和机制，并解答一些常见的疑问，帮助你深入理解 <code>export</code>、<code>import</code>、<code>require</code> 和 <code>module.exports</code> 的工作原理和实际应用。</p><hr><h3 id="1-ES6-模块化：export-和-import"><a href="#1-ES6-模块化：export-和-import" class="headerlink" title="1. ES6 模块化：export 和 import"></a>1. ES6 模块化：<code>export</code> 和 <code>import</code></h3><h4 id="1-1-export-导出模块"><a href="#1-1-export-导出模块" class="headerlink" title="1.1 export 导出模块"></a>1.1 <code>export</code> 导出模块</h4><p>在 ES6 模块化中，<code>export</code> 允许我们暴露模块中的功能（如变量、函数、类等），以便其他模块能够引用。</p><h5 id="1-1-1-命名导出"><a href="#1-1-1-命名导出" class="headerlink" title="1.1.1 命名导出"></a>1.1.1 命名导出</h5><p>命名导出让你可以选择性地导出模块中的多个元素，每个导出的成员都可以有一个独立的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">a, b</span>) =&gt; a - b;<br></code></pre></td></tr></table></figure><h5 id="1-1-2-默认导出"><a href="#1-1-2-默认导出" class="headerlink" title="1.1.2 默认导出"></a>1.1.2 默认导出</h5><p>默认导出用于导出一个模块的“主要”部分。每个模块只能有一个默认导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// calculator.js</span><br><span class="hljs-keyword">const</span> calculator = &#123;<br>  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b,<br>  <span class="hljs-attr">subtract</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> calculator;<br></code></pre></td></tr></table></figure><h4 id="1-2-import-导入模块"><a href="#1-2-import-导入模块" class="headerlink" title="1.2 import 导入模块"></a>1.2 <code>import</code> 导入模块</h4><p><code>import</code> 用来导入其他模块的导出。ES6 的 <code>import</code> 语法要求它必须位于代码的顶部，不能在其他代码（如函数、变量定义等）之后出现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; add, subtract &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">subtract</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><h5 id="1-2-1-导入默认导出"><a href="#1-2-1-导入默认导出" class="headerlink" title="1.2.1 导入默认导出"></a>1.2.1 导入默认导出</h5><p>对于默认导出，我们可以不使用花括号，直接指定一个变量名来接收默认导出的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> calculator <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./calculator.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><h5 id="1-2-2-导入命名导出"><a href="#1-2-2-导入命名导出" class="headerlink" title="1.2.2 导入命名导出"></a>1.2.2 导入命名导出</h5><p>你可以使用解构的方式来导入模块中的具体内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><h4 id="1-3-导入的缓存机制"><a href="#1-3-导入的缓存机制" class="headerlink" title="1.3 导入的缓存机制"></a>1.3 导入的缓存机制</h4><p>ES6 模块化遵循 <strong>静态导入机制</strong>，并且支持 <strong>缓存机制</strong>。这意味着模块会被加载一次，并且所有对同一模块的导入都会引用缓存的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// math.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;math.js executed&#x27;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br>javascript复制代码<span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;  <span class="hljs-comment">// 输出: &quot;math.js executed&quot;</span><br><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> add2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;  <span class="hljs-comment">// 不会再次输出</span><br></code></pre></td></tr></table></figure><h4 id="1-4-import-的位置"><a href="#1-4-import-的位置" class="headerlink" title="1.4 import 的位置"></a>1.4 <code>import</code> 的位置</h4><p>在 ES6 模块中，<code>import</code> 语句必须位于代码的最上方，即在其他变量声明或函数定义之前。如果尝试在 <code>import</code> 语句上方写其他代码（如函数、变量等），会导致语法错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 错误示例：`import` 必须在最上方</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;  <span class="hljs-comment">// 错误，`import` 必须在最上方</span><br></code></pre></td></tr></table></figure><p>这是由于 ES6 模块的 <strong>静态结构</strong>，编译器需要在运行前解析所有的模块依赖关系，因此无法动态地调整 <code>import</code> 语句的位置。</p><hr><h3 id="2-CommonJS-模块：module-exports-和-require"><a href="#2-CommonJS-模块：module-exports-和-require" class="headerlink" title="2. CommonJS 模块：module.exports 和 require"></a>2. CommonJS 模块：<code>module.exports</code> 和 <code>require</code></h3><h4 id="2-1-module-exports-导出"><a href="#2-1-module-exports-导出" class="headerlink" title="2.1 module.exports 导出"></a>2.1 <code>module.exports</code> 导出</h4><p>CommonJS 模块化使用 <code>module.exports</code> 来暴露模块内容。你可以将任何对象、函数、类等赋值给 <code>module.exports</code>，以便其他文件能够通过 <code>require</code> 导入这些内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// math.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b,<br>  <span class="hljs-attr">subtract</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-require-导入"><a href="#2-2-require-导入" class="headerlink" title="2.2 require 导入"></a>2.2 <code>require</code> 导入</h4><p><code>require</code> 是 CommonJS 模块化的导入方式，它会导入指定路径的模块并返回 <code>module.exports</code> 的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><h4 id="2-3-require-的灵活性"><a href="#2-3-require-的灵活性" class="headerlink" title="2.3 require 的灵活性"></a>2.3 <code>require</code> 的灵活性</h4><p>与 ES6 模块的静态导入不同，CommonJS 模块的 <code>require</code> 是动态的，意味着你可以在代码的任何位置调用 <code>require</code> 来导入模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">if</span> (someCondition) &#123;<br>  <span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-模块导入的缓存机制"><a href="#3-模块导入的缓存机制" class="headerlink" title="3. 模块导入的缓存机制"></a>3. 模块导入的缓存机制</h3><p>无论是 ES6 模块还是 CommonJS 模块，都存在 <strong>缓存机制</strong>。模块第一次被导入时，代码会执行一次，并且所有后续的导入都会直接返回缓存的内容，而不会再次执行模块的代码。</p><h4 id="3-1-缓存的作用"><a href="#3-1-缓存的作用" class="headerlink" title="3.1 缓存的作用"></a>3.1 缓存的作用</h4><p>这种缓存机制避免了同一模块被多次执行，提高了性能，并确保了模块的状态在不同地方的一致性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;math.js executed&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> count++,<br>  <span class="hljs-attr">getCount</span>: <span class="hljs-function">() =&gt;</span> count<br>&#125;;<br>javascript复制代码<span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> math1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);<br><span class="hljs-keyword">const</span> math2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math1.<span class="hljs-title function_">increment</span>());  <span class="hljs-comment">// 输出: 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math2.<span class="hljs-title function_">getCount</span>());   <span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h4 id="3-2-缓存与模块重载"><a href="#3-2-缓存与模块重载" class="headerlink" title="3.2 缓存与模块重载"></a>3.2 缓存与模块重载</h4><p>由于模块会被缓存，重新调用 <code>require</code> 并不会重新加载模块。要想重新加载模块，必须使用一些特殊的方法（如删除 <code>require.cache</code> 中的缓存，或者使用 <code>require()</code> 时提供新的路径）。</p><hr><h3 id="4-ES6-和-CommonJS-模块化的差异"><a href="#4-ES6-和-CommonJS-模块化的差异" class="headerlink" title="4. ES6 和 CommonJS 模块化的差异"></a>4. ES6 和 CommonJS 模块化的差异</h3><table><thead><tr><th>特性</th><th>ES6 模块</th><th>CommonJS 模块</th></tr></thead><tbody><tr><td>导入方式</td><td><code>import</code></td><td><code>require</code></td></tr><tr><td>导出方式</td><td><code>export</code>&#x2F;<code>export default</code></td><td><code>module.exports</code></td></tr><tr><td>执行时机</td><td>静态加载，编译时解析</td><td>动态加载，代码执行时解析</td></tr><tr><td>缓存机制</td><td>模块导入后缓存，避免重复执行</td><td>同样有缓存机制，避免重复执行</td></tr><tr><td>适用环境</td><td>主要用于浏览器和现代 JavaScript 引擎</td><td>主要用于 Node.js 环境</td></tr></tbody></table><hr><h3 id="5-TypeScript-的模块化"><a href="#5-TypeScript-的模块化" class="headerlink" title="5. TypeScript 的模块化"></a>5. TypeScript 的模块化</h3><p>在 TypeScript 中，模块化的使用和 ES6 模块类似。TypeScript 编译器会将模块转换为 ES6 模块（或者 CommonJS 模块），取决于你在 <code>tsconfig.json</code> 中的 <code>module</code> 配置。</p><ul><li>默认情况下，TypeScript 会使用 <strong>ES6 模块</strong>（即 <code>import</code>&#x2F;<code>export</code>）进行编译。</li><li>你也可以将 TypeScript 编译为 CommonJS 模块，在 Node.js 中使用。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tsconfig.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES6&quot;</span>  <span class="hljs-comment">// 或 &quot;CommonJS&quot; 可选</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>在现代 JavaScript 开发中，模块化是不可或缺的编程范式。我们通过 <code>export</code> 和 <code>import</code>（ES6 模块）以及 <code>module.exports</code> 和 <code>require</code>（CommonJS 模块）实现了代码的组织和模块之间的交互。</p><h4 id="主要要点："><a href="#主要要点：" class="headerlink" title="主要要点："></a>主要要点：</h4><ul><li><strong>ES6 模块</strong>：采用静态导入机制，模块只会加载一次，支持命名导出和默认导出，且 <code>import</code> 必须放在文件顶部。</li><li><strong>CommonJS 模块</strong>：采用动态导入机制，适用于 Node.js，<code>require</code> 可以在任何地方使用。</li><li><strong>缓存机制</strong>：无论是 ES6 还是 CommonJS，模块导入都遵循缓存机制，避免重复加载。</li><li><strong>TypeScript 支持</strong>：TypeScript 默认使用 ES6 模块，能够根据配置输出 CommonJS 模块。</li></ul><p>理解这些细节将帮助你在项目中更高效地使用模块化，使得代码更加清晰、可维护，避免不必要的错误和性能问题。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript泛型详解</title>
    <link href="/posts/56997/"/>
    <url>/posts/56997/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript泛型详解"><a href="#TypeScript泛型详解" class="headerlink" title="TypeScript泛型详解"></a>TypeScript泛型详解</h1><p>TypeScript 的泛型功能是其最强大的特性之一，能够让你编写既灵活又安全的代码。泛型允许你在定义函数、类、接口等时使用占位符来表示类型，从而在实际使用时指定具体类型，使得类型检查更为严格，同时避免了重复代码的编写。</p><p>本文将结合 TypeScript 官方文档，详细解析泛型的概念、用法以及常见应用场景，并举例说明如何正确书写和调用泛型。</p><hr><h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h2><p>泛型可以理解为一个占位符，它允许你在定义函数或类时<strong>不指定类型</strong>，而在使用时指定类型，达到类型复用的目的。这样，我们可以为同一函数或类提供多种不同类型，而不需要为每种类型分别编写不同的实现。</p><h2 id="2-泛型的基本语法"><a href="#2-泛型的基本语法" class="headerlink" title="2. 泛型的基本语法"></a>2. 泛型的基本语法</h2><p>泛型的语法很简单，通常使用尖括号（<code>&lt; &gt;</code>）来表示类型参数。类型参数一般使用大写字母来表示，如 <code>T</code>、<code>K</code>、<code>V</code> 等。你可以将类型参数放在函数、类或接口的名称后面。</p><h3 id="2-1-泛型函数"><a href="#2-1-泛型函数" class="headerlink" title="2.1 泛型函数"></a>2.1 泛型函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code> 是泛型类型参数，可以代表任何类型。</li><li><code>arg: T</code> 表示函数参数 <code>arg</code> 的类型是 <code>T</code>。</li><li><code>: T</code> 表示函数的返回值类型也是 <code>T</code>，这使得输入与输出类型一致。</li></ul><p><strong>调用泛型函数</strong></p><p>调用时，你可以通过显式指定类型来替代泛型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> result1 = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello, TypeScript&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);  <span class="hljs-comment">// 输出: Hello, TypeScript</span><br><br><span class="hljs-keyword">let</span> result2 = identity&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);  <span class="hljs-comment">// 输出: 100</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>identity&lt;string&gt;(&quot;Hello, TypeScript&quot;)</code> 表示将泛型 <code>T</code> 替换为 <code>string</code>，而 <code>identity&lt;number&gt;(100)</code> 则将 <code>T</code> 替换为 <code>number</code>。</p><h3 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h3><p>你也可以为接口定义泛型，泛型接口常用于处理集合、容器等类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">value</span>: T;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">box1</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; = &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">box2</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; = &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> &#125;;<br></code></pre></td></tr></table></figure><p>在这里，<code>Box&lt;T&gt;</code> 接口定义了一个泛型接口，<code>value</code> 的类型是 <code>T</code>，你可以在实例化接口时指定 <code>T</code> 为具体类型。</p><h3 id="2-3-泛型类"><a href="#2-3-泛型类" class="headerlink" title="2.3 泛型类"></a>2.3 泛型类</h3><p>泛型类类似于泛型接口，允许类在实例化时使用不同的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">value</span>: T;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: T</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br><br>  <span class="hljs-title function_">getValue</span>(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> stringContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringContainer.<span class="hljs-title function_">getValue</span>());  <span class="hljs-comment">// 输出: Hello</span><br><br><span class="hljs-keyword">let</span> numberContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberContainer.<span class="hljs-title function_">getValue</span>());  <span class="hljs-comment">// 输出: 123</span><br></code></pre></td></tr></table></figure><p>在此例中，<code>Container&lt;T&gt;</code> 是一个泛型类，它的构造函数和方法都依赖于类型参数 <code>T</code>。</p><hr><h2 id="3-泛型的优势"><a href="#3-泛型的优势" class="headerlink" title="3. 泛型的优势"></a>3. 泛型的优势</h2><ol><li><strong>类型安全：</strong> 泛型提供了更精确的类型检查，使得在编译阶段就能发现潜在的类型错误。</li><li><strong>代码复用：</strong> 泛型使得相同的代码能够处理多种不同类型，而不需要重复编写不同的函数或类。</li><li><strong>灵活性：</strong> 泛型类型可以在函数或类使用时动态指定，灵活应对不同的业务需求。</li></ol><hr><h2 id="4-约束泛型类型"><a href="#4-约束泛型类型" class="headerlink" title="4. 约束泛型类型"></a>4. 约束泛型类型</h2><p>泛型的类型参数是可以约束的，即你可以要求泛型类型满足某些条件或具有某些特性。为此，TypeScript 提供了 <code>extends</code> 关键字来约束泛型类型。</p><h3 id="4-1-约束泛型类型的语法"><a href="#4-1-约束泛型类型的语法" class="headerlink" title="4.1 约束泛型类型的语法"></a>4.1 约束泛型类型的语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> logLength&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> &#125;&gt;(<span class="hljs-attr">arg</span>: T): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>T extends &#123; length: number &#125;</code> 表示泛型 <code>T</code> 必须具有 <code>length</code> 属性（即，<code>T</code> 必须是一个具有 <code>length</code> 属性的类型）。这样可以确保 <code>logLength</code> 函数只接受有 <code>length</code> 属性的类型。</p><h5 id="调用时"><a href="#调用时" class="headerlink" title="调用时"></a><strong>调用时</strong></h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">logLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>));  <span class="hljs-comment">// 输出: 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">logLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure><p>这个函数可以接受任何具有 <code>length</code> 属性的类型，例如字符串和数组。</p><hr><h2 id="5-泛型的默认类型"><a href="#5-泛型的默认类型" class="headerlink" title="5. 泛型的默认类型"></a>5. 泛型的默认类型</h2><p>在 TypeScript 中，泛型类型参数可以有默认类型。如果没有传入具体类型，则使用默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> createPair&lt;T = <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">value</span>: T): [T, T] &#123;<br>  <span class="hljs-keyword">return</span> [value, value];<br>&#125;<br><br><span class="hljs-keyword">let</span> pair1 = <span class="hljs-title function_">createPair</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair1);  <span class="hljs-comment">// 输出: [&quot;Hello&quot;, &quot;Hello&quot;]</span><br><br><span class="hljs-keyword">let</span> pair2 = <span class="hljs-title function_">createPair</span>(<span class="hljs-number">42</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair2);  <span class="hljs-comment">// 输出: [42, 42]</span><br></code></pre></td></tr></table></figure><p>在此例中，<code>T = string</code> 表示如果调用时没有指定类型，<code>T</code> 默认为 <code>string</code>。因此，<code>createPair</code> 函数可以接受任何类型，但默认使用 <code>string</code> 类型。</p><hr><h2 id="6-泛型与联合类型"><a href="#6-泛型与联合类型" class="headerlink" title="6. 泛型与联合类型"></a>6. 泛型与联合类型</h2><p>泛型和联合类型可以结合使用，这样可以让一个函数同时支持多种类型的参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> wrap&lt;T&gt;(<span class="hljs-attr">value</span>: T | <span class="hljs-built_in">string</span>): T &#123;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">let</span> wrappedString = <span class="hljs-title function_">wrap</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> wrappedNumber = <span class="hljs-title function_">wrap</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>在这里，<code>value</code> 参数可以是 <code>T</code> 类型或者 <code>string</code> 类型。调用时传入的参数可以是 <code>string</code> 或者任何类型。</p><hr><h2 id="7-泛型与类型推断"><a href="#7-泛型与类型推断" class="headerlink" title="7. 泛型与类型推断"></a>7. 泛型与类型推断</h2><p>TypeScript 会根据传入的参数类型来自动推断泛型类型。在很多情况下，我们不需要显式指定泛型类型，TypeScript 会根据传入的值自动推断出类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 自动推断 T 为 string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: Hello</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们没有显式指定 <code>T</code> 类型，TypeScript 自动推断 <code>T</code> 为 <code>string</code>，并保证类型安全。</p><hr><h2 id="8-高级泛型应用"><a href="#8-高级泛型应用" class="headerlink" title="8. 高级泛型应用"></a>8. 高级泛型应用</h2><h3 id="8-1-泛型与条件类型"><a href="#8-1-泛型与条件类型" class="headerlink" title="8.1 泛型与条件类型"></a>8.1 泛型与条件类型</h3><p>TypeScript 也支持泛型与条件类型结合使用，从而在类型层面做出更复杂的判断和转换。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">MyType</span>&lt;<span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// a 的类型是 number</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">MyType</span>&lt;<span class="hljs-built_in">number</span>&gt;;  <span class="hljs-comment">// b 的类型是 boolean</span><br></code></pre></td></tr></table></figure><h3 id="8-2-泛型与映射类型"><a href="#8-2-泛型与映射类型" class="headerlink" title="8.2 泛型与映射类型"></a>8.2 泛型与映射类型</h3><p>映射类型允许你基于现有类型构造新的类型。与泛型结合使用，可以帮助你更灵活地定义对象的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionsFlags</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;<br>  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]: <span class="hljs-built_in">boolean</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FeatureFlags</span> = &#123;<br>  <span class="hljs-attr">darkMode</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">newUserProfile</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FeatureOptions</span> = <span class="hljs-title class_">OptionsFlags</span>&lt;<span class="hljs-title class_">FeatureFlags</span>&gt;;<br><span class="hljs-comment">// 结果：&#123; darkMode: boolean; newUserProfile: boolean; &#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>泛型使得 TypeScript 在保持类型安全的同时，增强了代码的灵活性和可复用性。它通过占位符 <code>T</code> 等形式，允许你在函数、类或接口的定义中不指定具体类型，最终在使用时动态地指定类型。</p><p>本文详细介绍了泛型的基本语法、常见应用场景、约束和高级用法。理解泛型的工作原理，并熟练掌握它的使用，将使你能编写出更加健壮和可维护的代码。</p><p>如果你还没有深入理解泛型，请尝试在你的项目中使用它们，逐步积累经验，你将发现泛型能够显著提高你的代码质量和开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探秘JavaScript内部机制:从this到事件循环</title>
    <link href="/posts/56251/"/>
    <url>/posts/56251/</url>
    
    <content type="html"><![CDATA[<h1 id="探秘JavaScript内部机制-从this到事件循环"><a href="#探秘JavaScript内部机制-从this到事件循环" class="headerlink" title="探秘JavaScript内部机制:从this到事件循环"></a>探秘JavaScript内部机制:从this到事件循环</h1><p>JavaScript 是一种高级编程语言，拥有灵活的语法和丰富的特性。虽然我们在日常开发中大多集中在语言的高级语法和 API 上，但要深入理解 JavaScript 的行为，必须掌握它的底层机制。本文将详细介绍 JavaScript 中的一些关键底层机制，包括 <code>this</code>、<code>arguments</code>、<code>prototype</code>、<code>new</code>、闭包、事件循环等，并且探讨更多的内部实现细节。</p><h2 id="1-this：函数上下文中的指针"><a href="#1-this：函数上下文中的指针" class="headerlink" title="1. this：函数上下文中的指针"></a>1. <strong><code>this</code>：函数上下文中的指针</strong></h2><p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，用于指向当前执行上下文中的对象。它的值在函数调用时是动态确定的，取决于函数的调用方式。</p><h3 id="1-1-this-的基本规则"><a href="#1-1-this-的基本规则" class="headerlink" title="1.1 this 的基本规则"></a>1.1 <code>this</code> 的基本规则</h3><ul><li><p><strong>普通函数调用</strong>：<code>this</code> 指向全局对象，在浏览器中是 <code>window</code>，在 Node.js 中是 <code>global</code>。严格模式下 <code>this</code> 为 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 在浏览器中是 window 或 undefined（严格模式）</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>方法调用</strong>：当函数作为对象的方法被调用时，<code>this</code> 指向该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 &quot;Alice&quot;</span><br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// this 指向 obj</span><br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数调用</strong>：当函数作为构造函数被调用时，<code>this</code> 指向新创建的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 &quot;Bob&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>**箭头函数中的 <code>this</code>**：箭头函数不会有自己的 <code>this</code>，它会从外部函数的上下文中继承 <code>this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出 undefined，因为箭头函数继承了外部 `this`</span><br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出 undefined</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-this-的动态绑定"><a href="#1-2-this-的动态绑定" class="headerlink" title="1.2 this 的动态绑定"></a>1.2 <code>this</code> 的动态绑定</h3><p><code>this</code> 是动态绑定的，可以通过 <code>call</code>、<code>apply</code> 和 <code>bind</code> 改变它的指向。</p><p>在 JavaScript 中，<code>call</code>、<code>apply</code> 和 <code>bind</code> 是三个常用于控制函数上下文（即改变 <code>this</code> 的指向）的方法。这三个方法都与函数的调用方式和上下文绑定密切相关。掌握这三个方法对于处理 <code>this</code> 的指向问题至关重要。</p><h4 id="1-2-1-call-方法"><a href="#1-2-1-call-方法" class="headerlink" title="1.2.1. call 方法"></a>1.2.1. <strong><code>call</code> 方法</strong></h4><p><code>call</code> 方法可以显式地改变函数中 <code>this</code> 的指向。它接受一个参数，作为函数执行时的 <code>this</code> 指向。除此之外，<code>call</code> 方法还可以传入一系列参数，这些参数会作为普通参数传递给目标函数。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：在函数执行时，<code>this</code> 指向的对象。可以是任何类型的值，包括 <code>null</code> 和 <code>undefined</code>。</li><li><code>arg1, arg2, ...</code>：要传递给函数的参数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);  <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 30 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>greet.call(person, &#39;Alice&#39;, 30)</code> 显式地将 <code>this</code> 绑定到了 <code>person</code> 对象上。</p><p><strong>特点：</strong></p><ul><li><code>call</code> 立即调用函数，并且可以显式传入参数。</li><li>在调用时，<code>this</code> 会绑定到第一个参数上。</li></ul><hr><h4 id="1-2-2-apply-方法"><a href="#1-2-2-apply-方法" class="headerlink" title="1.2.2. apply 方法"></a>1.2.2. <strong><code>apply</code> 方法</strong></h4><p><code>apply</code> 方法的作用与 <code>call</code> 方法类似，也是用于显式绑定 <code>this</code>。不同之处在于，<code>apply</code> 方法接受的是一个数组或类数组对象作为第二个参数，而不是一系列的独立参数。这意味着 <code>apply</code> 适用于动态传递参数列表的场景。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">apply</span>(thisArg, [argsArray])<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：在函数执行时，<code>this</code> 指向的对象。</li><li><code>argsArray</code>：一个数组或类数组对象，包含传递给函数的参数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>]);  <span class="hljs-comment">// 输出：Hello, my name is Bob and I am 25 years old.</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>greet.apply(person, [&#39;Bob&#39;, 25])</code> 的调用方式与 <code>call</code> 类似，不同的是我们使用了数组来传递参数。</p><p><strong>特点：</strong></p><ul><li><code>apply</code> 方法也立即调用函数，<code>this</code> 会绑定到第一个参数。</li><li>参数以数组的形式传递，因此适用于参数数量不固定或参数动态生成的场景。</li></ul><hr><h4 id="1-2-3-bind-方法"><a href="#1-2-3-bind-方法" class="headerlink" title="1.2.3. bind 方法"></a>1.2.3. <strong><code>bind</code> 方法</strong></h4><p>与 <code>call</code> 和 <code>apply</code> 方法不同，<code>bind</code> 方法不会立即执行函数，而是返回一个新的函数。在返回的新函数中，<code>this</code> 会被永久性地绑定到指定的对象，而这个函数可以在之后的任何时刻调用。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newFunc = <span class="hljs-keyword">function</span>.<span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li><code>thisArg</code>：要绑定到函数上的 <code>this</code> 值。</li><li><code>arg1, arg2, ...</code>：可选的参数，这些参数会在调用 <code>newFunc</code> 时被传递给原函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Charlie&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> boundGreet = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><span class="hljs-title function_">boundGreet</span>(<span class="hljs-number">35</span>);  <span class="hljs-comment">// 输出：Hello, my name is Charlie and I am 35 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>greet.bind(person, &#39;Charlie&#39;)</code> 创建了一个新的函数 <code>boundGreet</code>，这个函数会始终将 <code>this</code> 绑定到 <code>person</code> 对象，并且固定传递 <code>&#39;Charlie&#39;</code> 作为第一个参数。之后，调用 <code>boundGreet(35)</code> 时，<code>this</code> 已经是 <code>person</code>，并且 <code>35</code> 被作为 <code>age</code> 参数传入。</p><p><strong>特点：</strong></p><ul><li><code>bind</code> 返回一个新函数，<strong>不会立即执行</strong>。</li><li>返回的函数在调用时，<code>this</code> 会永久绑定到指定对象。</li><li>可以部分应用（预设部分参数），这使得 <code>bind</code> 在某些情况下非常有用，尤其是在事件处理和回调函数中。</li></ul><hr><h4 id="1-2-4-call、apply-和-bind-的区别"><a href="#1-2-4-call、apply-和-bind-的区别" class="headerlink" title="1.2.4. call、apply 和 bind 的区别"></a>1.2.4. <strong><code>call</code>、<code>apply</code> 和 <code>bind</code> 的区别</strong></h4><table><thead><tr><th>特性</th><th><code>call</code></th><th><code>apply</code></th><th><code>bind</code></th></tr></thead><tbody><tr><td><strong>调用方式</strong></td><td>立即调用</td><td>立即调用</td><td>返回一个新函数</td></tr><tr><td><strong>参数传递方式</strong></td><td>依次传递参数</td><td>传递一个数组</td><td>预设参数并返回一个新函数</td></tr><tr><td><strong>返回值</strong></td><td>没有返回值</td><td>没有返回值</td><td>返回一个新函数</td></tr><tr><td><strong>使用场景</strong></td><td>需要立即调用函数并传递参数</td><td>参数以数组的形式传递时</td><td>需要绑定 <code>this</code> 并在未来某个时刻调用</td></tr></tbody></table><hr><h4 id="1-2-5-实际应用示例"><a href="#1-2-5-实际应用示例" class="headerlink" title="1.2.5. 实际应用示例"></a>1.2.5. <strong>实际应用示例</strong></h4><h5 id="1-call-和-apply-适用于函数重用"><a href="#1-call-和-apply-适用于函数重用" class="headerlink" title="1. call 和 apply 适用于函数重用"></a>1. <code>call</code> 和 <code>apply</code> 适用于函数重用</h5><p><code>call</code> 和 <code>apply</code> 允许你将一个函数的上下文从一个对象转换到另一个对象。例如，可以使用它们来扩展已有函数的功能，或者为某个特定的对象调用其他对象的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br>greet.<span class="hljs-title function_">call</span>(person1);  <span class="hljs-comment">// 输出 &quot;Hello, my name is John&quot;</span><br>greet.<span class="hljs-title function_">call</span>(person2);  <span class="hljs-comment">// 输出 &quot;Hello, my name is Jane&quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-bind-适用于事件处理和回调函数"><a href="#2-bind-适用于事件处理和回调函数" class="headerlink" title="2. bind 适用于事件处理和回调函数"></a>2. <code>bind</code> 适用于事件处理和回调函数</h5><p><code>bind</code> 在事件处理和回调函数中非常有用，因为它可以确保 <code>this</code> 在异步执行时仍然指向正确的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ClickMe&#x27;</span>,<br>  <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用bind确保`this`指向obj</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, obj.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(obj));<br></code></pre></td></tr></table></figure><h5 id="3-bind-和部分应用"><a href="#3-bind-和部分应用" class="headerlink" title="3. bind 和部分应用"></a>3. <strong><code>bind</code> 和部分应用</strong></h5><p><code>bind</code> 还可以用于部分应用（即提前指定部分参数），这使得它在构建一些通用函数时非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">const</span> addFive = add.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 预设第一个参数为5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addFive</span>(<span class="hljs-number">10</span>));  <span class="hljs-comment">// 输出 15</span><br></code></pre></td></tr></table></figure><hr><h4 id="1-2-6-总结"><a href="#1-2-6-总结" class="headerlink" title="1.2.6. 总结"></a>1.2.6. <strong>总结</strong></h4><ul><li><strong><code>call</code></strong> 和 <strong><code>apply</code></strong> 都是用于临时改变函数执行时的上下文 (<code>this</code>)，但是它们在传参方式上有所不同：<code>call</code> 接受单独的参数，而 <code>apply</code> 接受一个数组作为参数。</li><li><strong><code>bind</code></strong> 通过返回一个新函数，允许你永久地绑定 <code>this</code>，并在未来某个时刻调用该函数。它也可以用于预设部分参数。</li></ul><p>理解这三个方法的使用场景和区别，能够帮助你在 JavaScript 编程中更好地控制函数的上下文绑定，避免由于 <code>this</code> 指向错误而导致的 bug。</p><h2 id="2-arguments：动态参数对象"><a href="#2-arguments：动态参数对象" class="headerlink" title="2. arguments：动态参数对象"></a>2. <strong><code>arguments</code>：动态参数对象</strong></h2><p><code>arguments</code> 是一个类似数组的对象，它包含了传递给函数的所有参数。在 JavaScript 的函数中，<code>arguments</code> 会自动创建，它的 <code>length</code> 属性可以获取传递的参数个数。需要注意的是，<code>arguments</code> 不是一个真正的数组，它不拥有数组方法，如 <code>map</code>、<code>forEach</code> 等。</p><h3 id="2-1-使用-arguments"><a href="#2-1-使用-arguments" class="headerlink" title="2.1 使用 arguments"></a>2.1 使用 <code>arguments</code></h3><p><code>arguments</code> 对象非常适合用来处理不确定数量的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    total += <span class="hljs-variable language_">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h3 id="2-2-箭头函数和-arguments"><a href="#2-2-箭头函数和-arguments" class="headerlink" title="2.2 箭头函数和 arguments"></a>2.2 箭头函数和 <code>arguments</code></h3><p>箭头函数没有自己的 <code>arguments</code> 对象，而是从外部的上下文中继承 <code>arguments</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>  <span class="hljs-title function_">arrowFunc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 继承外部函数 arguments</span><br>&#125;<br><br><span class="hljs-title function_">outer</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 输出: [3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-使用-ES6-的扩展运算符"><a href="#2-3-使用-ES6-的扩展运算符" class="headerlink" title="2.3 使用 ES6 的扩展运算符"></a>2.3 使用 ES6 的扩展运算符</h3><p>ES6 引入了扩展运算符（<code>...</code>），我们可以用它代替 <code>arguments</code>，并且可以在函数内部像数组一样处理参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h2 id="3-prototype：原型和继承机制"><a href="#3-prototype：原型和继承机制" class="headerlink" title="3. prototype：原型和继承机制"></a>3. <strong><code>prototype</code>：原型和继承机制</strong></h2><p>JavaScript 是基于原型的编程语言。每个对象都通过 <code>prototype</code> 属性与其他对象建立联系，形成原型链。这种原型链决定了对象属性和方法的继承方式。</p><h3 id="3-1-原型链"><a href="#3-1-原型链" class="headerlink" title="3.1 原型链"></a>3.1 原型链</h3><p>每个函数都有一个 <code>prototype</code> 属性，指向一个对象，该对象就是该函数的原型。对象的原型也是对象，并且它也有原型，这样就形成了一条“原型链”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>alice.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure><h3 id="3-2-原型链的查找机制"><a href="#3-2-原型链的查找机制" class="headerlink" title="3.2 原型链的查找机制"></a>3.2 原型链的查找机制</h3><p>当访问一个对象的属性时，如果该对象本身没有该属性，JavaScript 会通过原型链查找该属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">toString</span>());  <span class="hljs-comment">// 输出: [object Object]</span><br></code></pre></td></tr></table></figure><p>这里，<code>obj</code> 没有 <code>toString</code> 方法，但由于 <code>Object.prototype</code> 中有这个方法，所以 <code>obj</code> 继承了它。</p><h3 id="3-3-prototype-与-proto-的区别"><a href="#3-3-prototype-与-proto-的区别" class="headerlink" title="3.3 prototype 与 __proto__ 的区别"></a>3.3 <code>prototype</code> 与 <code>__proto__</code> 的区别</h3><ul><li><code>prototype</code> 是函数对象的属性，指向该函数的原型对象。</li><li><code>__proto__</code> 是每个实例对象的属性，指向该实例的构造函数的原型对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><h2 id="4-闭包：访问外部函数变量"><a href="#4-闭包：访问外部函数变量" class="headerlink" title="4. 闭包：访问外部函数变量"></a>4. <strong>闭包：访问外部函数变量</strong></h2><p>闭包是 JavaScript 的一项重要特性，它允许函数记住并访问其外部函数的作用域。即使外部函数已经执行结束，闭包依然能访问外部函数的变量。</p><h3 id="4-1-闭包的工作原理"><a href="#4-1-闭包的工作原理" class="headerlink" title="4.1 闭包的工作原理"></a>4.1 闭包的工作原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">counter</span>();  <span class="hljs-comment">// 输出 1</span><br><span class="hljs-title function_">counter</span>();  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>inner</code> 函数是一个闭包，它访问并修改 <code>outer</code> 函数的局部变量 <code>count</code>。</p><h3 id="4-2-闭包的用途"><a href="#4-2-闭包的用途" class="headerlink" title="4.2 闭包的用途"></a>4.2 闭包的用途</h3><ul><li><strong>数据封装</strong>：闭包可以用来封装私有数据，不让外部直接访问。</li><li><strong>回调函数和事件处理器</strong>：闭包常用于处理异步操作、回调函数等。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>      count--;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br>counter.<span class="hljs-title function_">increment</span>();  <span class="hljs-comment">// 输出 1</span><br>counter.<span class="hljs-title function_">increment</span>();  <span class="hljs-comment">// 输出 2</span><br>counter.<span class="hljs-title function_">decrement</span>();  <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h2 id="5-new-操作符：实例化对象"><a href="#5-new-操作符：实例化对象" class="headerlink" title="5. new 操作符：实例化对象"></a>5. <strong><code>new</code> 操作符：实例化对象</strong></h2><p><code>new</code> 是 JavaScript 中用于创建实例的关键字，它不仅可以创建一个新的对象，还会自动执行构造函数中的操作。</p><h3 id="5-1-new-操作符的工作流程"><a href="#5-1-new-操作符的工作流程" class="headerlink" title="5.1 new 操作符的工作流程"></a>5.1 <code>new</code> 操作符的工作流程</h3><ul><li>创建一个新对象。</li><li>将新对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code> 属性。</li><li>执行构造函数，并将 <code>this</code> 绑定到新对象。</li><li>返回新对象（如果构造函数没有显式返回对象，则返回新创建的对象）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bob <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><h2 id="6-事件循环：JavaScript-的异步执行"><a href="#6-事件循环：JavaScript-的异步执行" class="headerlink" title="6. 事件循环：JavaScript 的异步执行"></a>6. <strong>事件循环：JavaScript 的异步执行</strong></h2><p>JavaScript 是单线程的，但它有一个强大的机制来处理异步操作，称为事件循环（Event Loop）。事件循环允许 JavaScript 执行非阻塞操作，例如 I&#x2F;O 操作、定时器、事件监听等。</p><h3 id="6-1-事件循环的流程"><a href="#6-1-事件循环的流程" class="headerlink" title="6.1 事件循环的流程"></a>6.1 事件循环的流程</h3><ol><li>执行栈（Call Stack）：当前正在执行的代码。</li><li>消息队列（Message Queue）：存储待执行的异步任务（如回调函数、事件等）。</li><li>事件循环：不断查看执行栈是否为空，如果为空，则将消息队列中的任务移入执行栈。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middle&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Start</span><br><span class="hljs-comment">// End</span><br><span class="hljs-comment">// Middle</span><br></code></pre></td></tr></table></figure><p>这里，尽管 <code>setTimeout</code> 的延迟时间是 <code>0</code>，但是它依然被放入消息队列，等待主线程执行完当前代码后再执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 的底层机制提供了许多强大的功能，帮助我们高效地管理函数、对象、继承、异步操作等方面的复杂性。理解这些底层机制，能够让我们更好地掌握语言，写出高效、可维护的代码。</p><ul><li>**<code>this</code>**：动态上下文指向，取决于函数的调用方式。</li><li>**<code>arguments</code>**：函数内部的参数对象，提供不定数量参数的访问。</li><li>**<code>prototype</code>**：原型链实现继承机制。</li><li><strong>闭包</strong>：函数可以“记住”外部函数的变量，常用于数据封装和回调。</li><li>**<code>new</code>**：实例化对象，自动设置原型并执行构造函数。</li><li><strong>事件循环</strong>：JavaScript 的异步执行机制，确保代码的非阻塞性执行。</li></ul><p>在实际开发中，掌握这些底层机制将帮助你编写更加高效、灵活、可维护的代码，同时避免一些常见的陷阱。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-fluid免费部署评论功能</title>
    <link href="/posts/6873/"/>
    <url>/posts/6873/</url>
    
    <content type="html"><![CDATA[<h1 id="giscus"><a href="#giscus" class="headerlink" title="giscus"></a>giscus</h1><p>giscus是一个由 GitHub Discussions 驱动的评论系统，部署方便，无跟踪，无广告，永久免费。<br>无需数据库。全部数据均储存在 GitHub Discussions 中。</p><h2 id="1-安装giscus-app"><a href="#1-安装giscus-app" class="headerlink" title="1.安装giscus app"></a>1.安装<a href="https://github.com/apps/giscus">giscus app</a></h2><p>首先，要在你的github中安装<a href="https://github.com/apps/giscus">giscus app</a><br>点击”install”即可<br><img src="/posts/6873/202301120806.webp"><br><img src="/posts/6873/202301120806.webp"></p><p>然后如图依次点击”Only select repositories”和”Select repositories”,并选择你存储评论的仓库(<strong>即部署hexo的仓库，如本仓库yonghengshikong&#x2F;yonghengshikong.github.io</strong>)。<br>点击”install”安装<br><img src="/posts/6873/202301120808.webp"><br><img src="/posts/6873/202301120808.webp"></p><h2 id="2-配置仓库允许评论"><a href="#2-配置仓库允许评论" class="headerlink" title="2.配置仓库允许评论"></a>2.配置仓库允许评论</h2><p>打开hexo仓库的设置页面，选择常规设置，勾选允许评论</p><p><img src="/posts/6873/5.png"></p><p><img src="/posts/6873/6.png"></p><h2 id="3-进入giscus关联仓库"><a href="#3-进入giscus关联仓库" class="headerlink" title="3.进入giscus关联仓库"></a>3.进入giscus关联仓库</h2><p><strong>打开<a href="https://giscus.app/">giscus官网</a>，进一步配置</strong></p><p><img src="/posts/6873/2.png"></p><p><img src="/posts/6873/3.png"></p><p><img src="/posts/6873/4.png" alt="giscus配置数据"></p><h2 id="4-在config-yml中配置"><a href="#4-在config-yml中配置" class="headerlink" title="4.在config.yml中配置"></a>4.在config.yml中配置</h2><p><strong>启动评论，类型设置为giscus</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>  <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">giscus</span><br></code></pre></td></tr></table></figure><p>根据前面的giscus配置数据来填写以下信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Giscus</span><br><span class="hljs-comment"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class="hljs-comment"># Based on GitHub Discussions, similar to Utterances</span><br><span class="hljs-comment"># See: https://giscus.app/</span><br><span class="hljs-attr">giscus:</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">yonghengshikong/yonghengshikong.github.io</span><br>  <span class="hljs-attr">repo-id:</span> <span class="hljs-string">***********</span><br>  <span class="hljs-attr">category:</span> <span class="hljs-string">General</span><br>  <span class="hljs-attr">category-id:</span> <span class="hljs-string">***************</span><br>  <span class="hljs-attr">theme-light:</span> <span class="hljs-string">light</span><br>  <span class="hljs-attr">theme-dark:</span> <span class="hljs-string">dark</span><br>  <span class="hljs-attr">mapping:</span> <span class="hljs-string">title</span><br>  <span class="hljs-attr">reactions-enabled:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">emit-metadata:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">input-position:</span> <span class="hljs-string">bottom</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h2 id="5-最终效果如下"><a href="#5-最终效果如下" class="headerlink" title="5.最终效果如下"></a>5.最终效果如下</h2><p><img src="/posts/6873/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析TypeScript装饰器</title>
    <link href="/posts/52923/"/>
    <url>/posts/52923/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-TypeScript-装饰器"><a href="#深入理解-TypeScript-装饰器" class="headerlink" title="深入理解 TypeScript 装饰器"></a>深入理解 TypeScript 装饰器</h1><p>TypeScript 中的装饰器是一个非常强大且灵活的特性，它允许开发者通过注解和修改类、方法、属性、参数的行为，使得代码更加优雅、模块化和可扩展。本文将从装饰器的类型、参数、返回值、实现机制、用法和应用场景等方面进行详细解析，并通过丰富的示例代码帮助开发者更好地理解和掌握装饰器的使用。</p><h2 id="1-开启装饰器支持"><a href="#1-开启装饰器支持" class="headerlink" title="1. 开启装饰器支持"></a>1. 开启装饰器支持</h2><p>在 TypeScript 中，装饰器是一个实验性特性。为了使用装饰器，需要在 <code>tsconfig.json</code> 配置文件中启用 <code>experimentalDecorators</code> 选项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-装饰器类型概览"><a href="#2-装饰器类型概览" class="headerlink" title="2. 装饰器类型概览"></a>2. 装饰器类型概览</h2><p>TypeScript 支持以下四种主要的装饰器类型：</p><ol><li><strong>类装饰器（Class Decorator）</strong></li><li><strong>方法装饰器（Method Decorator）</strong></li><li><strong>属性装饰器（Property Decorator）</strong></li><li><strong>参数装饰器（Parameter Decorator）</strong></li></ol><p>每种装饰器的参数不同，具体参数说明和使用场景在下面的章节中将详细介绍。</p><h2 id="3-装饰器的基本语法与使用"><a href="#3-装饰器的基本语法与使用" class="headerlink" title="3. 装饰器的基本语法与使用"></a>3. 装饰器的基本语法与使用</h2><h3 id="3-1-类装饰器"><a href="#3-1-类装饰器" class="headerlink" title="3.1 类装饰器"></a>3.1 类装饰器</h3><h4 id="3-1-1-基础实现"><a href="#3-1-1-基础实现" class="headerlink" title="3.1.1 基础实现"></a>3.1.1 基础实现</h4><p>类装饰器是最基本的装饰器，通常用于修改类的行为或替换构造函数。它接受一个参数——构造函数，并且返回一个新的构造函数或修改过的构造函数。</p><p><strong>参数：</strong></p><ul><li><strong>target</strong>：类的构造函数。该构造函数是类的实例化方法，可以在装饰器中被替换或修改。</li></ul><p><strong>返回值：</strong></p><ul><li>可以返回一个新的类构造函数，用来替换原始类的构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-meta">@logClass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MyClass instance created.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Class MyClass has been decorated.</span><br><span class="hljs-comment">// MyClass instance created.</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-装饰器传参的基本实现-装饰器工厂"><a href="#3-1-2-装饰器传参的基本实现-装饰器工厂" class="headerlink" title="3.1.2  装饰器传参的基本实现(装饰器工厂)"></a>3.1.2  装饰器传参的基本实现(装饰器工厂)</h4><p>通过这种方式，你可以在装饰器中使用传入的参数来执行特定的逻辑。我们通过一个简单的示例来演示这个过程：</p><p><strong>示例：为类装饰器传递参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 返回的实际装饰器函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;message&#125;</span>: Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@logClass</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyClass instance created.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>logClass</code> 是一个工厂函数，接收一个 <code>message</code> 参数。</li><li>在 <code>logClass</code> 内部，我们返回一个实际的装饰器函数（<code>target =&gt; &#123; ... &#125;</code>）。</li><li>返回的装饰器函数会接收到类的构造函数作为 <code>target</code> 参数，这样你就可以在装饰器中使用这个类的构造函数，或者执行其他操作。</li><li>这个装饰器在 <code>@logClass(&quot;Hello&quot;)</code> 中使用时，传入了 <code>&quot;Hello&quot;</code> 这个参数，最终输出的内容会包括这个参数。</li></ol><p><strong>输出结果：</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Hello: Class MyClass has been decorated.<br>MyClass<span class="hljs-built_in"> instance </span>created.<br></code></pre></td></tr></table></figure><h4 id="3-2-3-进一步的装饰器参数应用"><a href="#3-2-3-进一步的装饰器参数应用" class="headerlink" title="3.2.3  进一步的装饰器参数应用"></a>3.2.3  进一步的装饰器参数应用</h4><p>你还可以传递更多参数，并在装饰器中执行更复杂的逻辑。以下是一个扩展的示例，演示如何为类装饰器传递多个参数，并执行类属性和方法的修改。</p><p><strong>示例：带多个参数的类装饰器</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span>, level: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;message&#125;</span> [Level: <span class="hljs-subst">$&#123;level&#125;</span>]: Class <span class="hljs-subst">$&#123;target.name&#125;</span> has been decorated.`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@logClass</span>(<span class="hljs-string">&quot;Logging&quot;</span>, <span class="hljs-string">&quot;INFO&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyClass instance created.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Logging [Level: INFO]: Class MyClass has been decorated.<br>MyClass<span class="hljs-built_in"> instance </span>created.<br></code></pre></td></tr></table></figure><h4 id="3-2-4-装饰器组合"><a href="#3-2-4-装饰器组合" class="headerlink" title="3.2.4 装饰器组合"></a>3.2.4 装饰器组合</h4><p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p><ul><li>书写在同一行上：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@f</span> <span class="hljs-meta">@g</span> x<br></code></pre></td></tr></table></figure><ul><li>书写在多行上：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@f</span><br><span class="hljs-meta">@g</span><br>x<br></code></pre></td></tr></table></figure><p>当多个装饰器应用于一个声明上，它们求值方式与<a href="http://en.wikipedia.org/wiki/Function_composition">复合函数</a>相似。在这个模型下，当复合<em>f</em>和<em>g</em>时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于<em>f</em>(<em>g</em>(<em>x</em>))。</p><p>同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ol><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用。</li></ol><p>如果我们使用<strong>装饰器工厂</strong>的话，可以通过下面的例子来观察它们求值的顺序：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;f(): evaluated&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;f(): called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;g(): evaluated&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;g(): called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-meta">@f</span>()<br>    <span class="hljs-meta">@g</span>()<br>    <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在控制台里会打印出如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">f(): evaluated<br>g(): evaluated<br>g(): called<br>f(): called<br></code></pre></td></tr></table></figure><h3 id="3-2-方法装饰器"><a href="#3-2-方法装饰器" class="headerlink" title="3.2 方法装饰器"></a>3.2 方法装饰器</h3><p>方法装饰器用于类的方法，它接受三个参数：</p><ol><li><strong>target</strong>：方法所在类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：方法的名称（<code>string</code> 类型）。</li><li><strong>descriptor</strong>：方法的属性描述符（<code>PropertyDescriptor</code> 类型）。</li></ol><p><strong>参数：</strong></p><ul><li><strong>target</strong>：类的原型（即类的实例对象），如果是静态方法，则为构造函数。</li><li><strong>propertyKey</strong>：方法名称，<code>string</code> 类型。</li><li><strong>descriptor</strong>：该方法的属性描述符（<code>PropertyDescriptor</code>），包含了 <code>value</code>、<code>writable</code>、<code>enumerable</code> 和 <code>configurable</code> 等字段。</li></ul><p><strong>PropertyDescriptor 字段：</strong></p><ul><li><strong>value</strong>：方法本身的实现（即函数）。</li><li><strong>writable</strong>：布尔值，指示方法是否可以被修改。</li><li><strong>enumerable</strong>：布尔值，指示方法是否可枚举。</li><li><strong>configurable</strong>：布尔值，指示方法是否可配置。</li></ul><p>可以通过 <code>descriptor</code> 修改方法的执行行为，如修改其值或禁用它。</p><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;<br>  <br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> was called with arguments:`</span>, args);<br>    <span class="hljs-keyword">return</span> originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Method greet was called with arguments: [ &#x27;Alice&#x27; ]</span><br><span class="hljs-comment">// Hello, Alice</span><br></code></pre></td></tr></table></figure><h3 id="3-3-属性装饰器"><a href="#3-3-属性装饰器" class="headerlink" title="3.3 属性装饰器"></a>3.3 属性装饰器</h3><p>属性装饰器用于类的属性，它只能接收两个参数：</p><ol><li><strong>target</strong>：类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：属性名（<code>string</code> 类型）。</li></ol><p>属性装饰器通常用于为属性添加元数据或进行相关处理，但不能直接修改属性值。如果需要修改属性值，应使用 getter 或 setter。</p><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Property <span class="hljs-subst">$&#123;propertyKey&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logProperty</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-参数装饰器"><a href="#3-4-参数装饰器" class="headerlink" title="3.4 参数装饰器"></a>3.4 参数装饰器</h3><p>参数装饰器用于方法参数，它接受三个参数：</p><ol><li><strong>target</strong>：方法所在类的原型（<code>prototype</code>）。</li><li><strong>propertyKey</strong>：方法名称（<code>string</code> 类型）。</li><li><strong>parameterIndex</strong>：参数在方法中的索引（<code>number</code> 类型）。</li></ol><p><strong>示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logParameter</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, parameterIndex: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Parameter at index <span class="hljs-subst">$&#123;parameterIndex&#125;</span> in method <span class="hljs-subst">$&#123;propertyKey&#125;</span> has been decorated.`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-meta">@logParameter</span> name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Parameter at index 0 in method greet has been decorated.</span><br><span class="hljs-comment">// Hello, Alice</span><br></code></pre></td></tr></table></figure><h2 id="4-装饰器的参数解析"><a href="#4-装饰器的参数解析" class="headerlink" title="4. 装饰器的参数解析"></a>4. 装饰器的参数解析</h2><h3 id="4-1-PropertyDescriptor-详解"><a href="#4-1-PropertyDescriptor-详解" class="headerlink" title="4.1 PropertyDescriptor 详解"></a>4.1 <code>PropertyDescriptor</code> 详解</h3><p><code>PropertyDescriptor</code> 是一个描述对象属性的元数据对象。在 JavaScript 中，<code>PropertyDescriptor</code> 被用于定义对象的属性行为，包括属性是否可写、是否可枚举、是否可配置等。</p><p>在 TypeScript 的装饰器中，<code>PropertyDescriptor</code> 被广泛用于描述方法和属性的行为。通过修改 <code>PropertyDescriptor</code>，我们可以对方法或属性的访问行为进行定制，从而增强类的功能。</p><p><code>**PropertyDescriptor**</code> 主要有以下几个字段：</p><ol><li>value<ul><li><strong>类型</strong>：<code>any</code></li><li><strong>说明</strong>：该字段保存了属性或方法的实际值。对于属性，它是该属性的值；对于方法，它是方法本身（即函数）。我们可以通过修改 <code>value</code> 字段来改变方法或属性的行为。</li></ul></li><li>writable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示属性是否是可写的。如果为 <code>false</code>，则该属性不可修改。对于方法装饰器，这个字段表示方法是否可以被替换。</li></ul></li><li>enumerable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示属性或方法是否可枚举。如果为 <code>false</code>，则该属性不会在 <code>for...in</code> 循环中被列举出来。</li></ul></li><li>configurable<ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>说明</strong>：该字段表示是否可以删除该属性或修改该属性的描述符。如果为 <code>false</code>，则无法删除或修改该属性的描述符。</li></ul></li><li>get<ul><li><strong>类型</strong>：<code>Function | undefined</code></li><li><strong>说明</strong>：该字段仅在属性是访问器属性（getter）时存在。它保存一个函数，用于获取该属性的值。可以通过修改 <code>get</code> 来修改属性的读取行为。</li></ul></li><li>set<ul><li><strong>类型</strong>：<code>Function | undefined</code></li><li><strong>说明</strong>：该字段仅在属性是访问器属性（setter）时存在。它保存一个函数，用于设置该属性的值。可以通过修改 <code>set</code> 来修改属性的写入行为。</li></ul></li></ol><h4 id="4-1-1-修改属性的可写性和可枚举性"><a href="#4-1-1-修改属性的可写性和可枚举性" class="headerlink" title="4.1.1 修改属性的可写性和可枚举性"></a>4.1.1 修改属性的可写性和可枚举性</h4><p>属性装饰器是通过 <code>PropertyDescriptor</code> 来修改属性的行为。例如，假设我们想让某个属性成为只读属性，并且不希望它在 <code>for...in</code> 循环中出现，可以通过 <code>PropertyDescriptor</code> 来实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 使属性只读</span><br>  descriptor.<span class="hljs-property">enumerable</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 使属性不可枚举</span><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@readonly</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jane&#x27;</span>;  <span class="hljs-comment">// 错误：name 属性是只读的</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj));  <span class="hljs-comment">// 输出：[]</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>readonly</code> 装饰器修改了 <code>name</code> 属性，使它变为只读属性且不可枚举。通过设置 <code>descriptor.writable</code> 和 <code>descriptor.enumerable</code>，我们可以控制属性的行为。</p><h4 id="4-1-2-修改方法的实现"><a href="#4-1-2-修改方法的实现" class="headerlink" title="4.1.2 修改方法的实现"></a>4.1.2 修改方法的实现</h4><p>方法装饰器也可以通过 <code>PropertyDescriptor</code> 来修改方法的实现。例如，我们可以在方法执行前后增加日志记录：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;  <span class="hljs-comment">// 保存原始方法</span><br><br>  <span class="hljs-comment">// 修改方法实现，增加日志功能</span><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;key&#125;</span> called with arguments: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(args)&#125;</span>`</span>);<br>    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);  <span class="hljs-comment">// 调用原始方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;key&#125;</span> returned: <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-meta">@logMethod</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 输出：Method add called with arguments: [1,2] 和 Method add returned: 3</span><br>obj.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// 输出：Method greet called with arguments: [&quot;Alice&quot;] 和 Method greet returned: Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>logMethod</code> 装饰器通过修改 <code>descriptor.value</code>，将原始的方法实现替换为带有日志记录功能的新方法。每次调用方法时，都会打印出调用参数和返回值。</p><h4 id="4-1-3-控制属性的访问器行为"><a href="#4-1-3-控制属性的访问器行为" class="headerlink" title="4.1.3 控制属性的访问器行为"></a>4.1.3 控制属性的访问器行为</h4><p>当属性是访问器属性（getter 或 setter）时，<code>PropertyDescriptor</code> 中的 <code>get</code> 和 <code>set</code> 字段将包含访问器的实现。通过修改这些字段，可以定制属性的读取和写入逻辑。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalGetter = descriptor.<span class="hljs-property">get</span>;  <span class="hljs-comment">// 保存原始 getter</span><br><br>  descriptor.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Accessing <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> originalGetter?.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = age;<br>  &#125;<br><br>  <span class="hljs-meta">@validate</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">age</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Age cannot be negative&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">25</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 输出：Accessing age 和 25</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>validate</code> 装饰器在 <code>getter</code> 被调用时添加了日志功能。通过修改 <code>descriptor.get</code>，我们可以在读取属性时执行额外的逻辑。</p><p><code>PropertyDescriptor</code> 是 TypeScript 装饰器中非常重要的一个参数，它允许开发者对属性和方法的行为进行细粒度的控制。通过 <code>PropertyDescriptor</code>，我们可以：</p><ul><li>控制属性的可写性（<code>writable</code>）</li><li>控制属性是否可枚举（<code>enumerable</code>）</li><li>控制属性是否可配置（<code>configurable</code>）</li><li>修改方法的实现（<code>value</code>）</li><li>修改属性的访问器（<code>get</code> 和 <code>set</code>）</li></ul><p>通过灵活地使用 <code>PropertyDescriptor</code>，我们可以增强类和对象的功能，实现日志记录、缓存、权限控制等功能。掌握 <code>PropertyDescriptor</code> 的使用，可以让我们更好地在 TypeScript 中实现装饰器模式，提升代码的灵活性和可维护性。</p><h3 id="4-2-装饰器的用处"><a href="#4-2-装饰器的用处" class="headerlink" title="4.2 装饰器的用处"></a>4.2 装饰器的用处</h3><p>装饰器提供了一种灵活的方式来修改类、方法、属性或参数的行为。它在以下场景中非常有用：</p><ol><li><strong>依赖注入</strong>：使用装饰器动态地为类或方法注入依赖对象。</li><li><strong>权限控制</strong>：控制方法的访问权限，比如基于用户角色或权限进行限制。</li><li><strong>日志记录</strong>：自动记录方法的调用，参数和返回值，帮助调试和性能监控。</li><li><strong>性能优化</strong>：通过缓存、延迟加载等技术优化方法的执行效率。</li><li><strong>事件监听</strong>：自动为类或方法注册事件监听器。</li></ol><h3 id="4-3-使用装饰器的场景示例"><a href="#4-3-使用装饰器的场景示例" class="headerlink" title="4.3 使用装饰器的场景示例"></a>4.3 使用装饰器的场景示例</h3><p><strong>示例 1：依赖注入</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">service: <span class="hljs-built_in">any</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>    target[propertyKey] = service;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerService</span> &#123;<br>  <span class="hljs-title function_">log</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@inject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerService</span>())<br>  <span class="hljs-attr">logger</span>: <span class="hljs-title class_">LoggerService</span>;<br><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出：Hello, world!</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：性能监控</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">monitorPerformance</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;<br><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> took <span class="hljs-subst">$&#123;end - start&#125;</span>ms to execute`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-meta">@monitorPerformance</span><br>  <span class="hljs-title function_">longRunningTask</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 模拟长时间的任务</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e8</span>; i++) &#123;&#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">longRunningTask</span>();  <span class="hljs-comment">// 输出：Method longRunningTask took XXXms to execute</span><br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>装饰器是 TypeScript 提供的一个强大特性，通过注解类、方法、属性或参数来改变它们的行为。在这篇文章中，我们详细探讨了装饰器的语法、参数、用途以及一些常见的应用场景。掌握装饰器的使用方法，能够让你在项目中写出更加优雅、简洁和可扩展的代码。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript14新特性详解</title>
    <link href="/posts/37339/"/>
    <url>/posts/37339/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2023（ES14）新特性详解"><a href="#ECMAScript-2023（ES14）新特性详解" class="headerlink" title="ECMAScript 2023（ES14）新特性详解"></a>ECMAScript 2023（ES14）新特性详解</h1><p>ECMAScript 2023（也称为 ES14）引入了一些重要的新特性，旨在提高 JavaScript 的功能和开发者的体验。以下是 ES14 的主要新特性：</p><h2 id="1-Array-prototype-toSorted"><a href="#1-Array-prototype-toSorted" class="headerlink" title="1. Array.prototype.toSorted()"></a>1. <code>Array.prototype.toSorted()</code></h2><p><code>Array.prototype.toSorted()</code> 方法返回一个新的数组，包含原数组的所有元素，但以指定的排序顺序排列。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toSorted</span>(compareFunction);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>compareFunction</code>（可选）：用于排序的函数，定义了排序顺序。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含按指定顺序排序的元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sortedNumbers = numbers.<span class="hljs-title function_">toSorted</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedNumbers); <span class="hljs-comment">// 输出: [1, 1, 3, 4, 5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 原数组仍为: [3, 1, 4, 1, 5]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Array-prototype-toReversed"><a href="#2-Array-prototype-toReversed" class="headerlink" title="2. Array.prototype.toReversed()"></a>2. <code>Array.prototype.toReversed()</code></h2><p><code>Array.prototype.toReversed()</code> 方法返回一个新的数组，包含原数组的所有元素，但顺序是反向的。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toReversed</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含原数组的元素按反向顺序排列。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> reversedArray = array.<span class="hljs-title function_">toReversed</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedArray); <span class="hljs-comment">// 输出: [3, 2, 1]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// 原数组仍为: [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Array-prototype-toSpliced"><a href="#3-Array-prototype-toSpliced" class="headerlink" title="3. Array.prototype.toSpliced()"></a>3. <code>Array.prototype.toSpliced()</code></h2><p><code>Array.prototype.toSpliced()</code> 方法返回一个新的数组，包含原数组的元素，但在指定位置删除了指定数量的元素。此方法不会修改原数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = array.<span class="hljs-title function_">toSpliced</span>(start, deleteCount, ...items);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>start</code>: 开始删除的索引。</li><li><code>deleteCount</code>: 要删除的元素数量。</li><li><code>...items</code>（可选）：要添加的新元素。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的数组，包含删除了指定元素的原数组元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>const splicedArray = <span class="hljs-built_in">array</span>.toSpliced(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(splicedArray); <span class="hljs-comment">// 输出: [1, &#x27;a&#x27;, &#x27;b&#x27;, 4]</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">array</span>); <span class="hljs-comment">// 原数组仍为: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Symbol-symbols"><a href="#4-Symbol-symbols" class="headerlink" title="4. Symbol.symbols"></a>4. <code>Symbol.symbols</code></h2><p><code>Symbol.symbols</code> 是一种新的内置 <code>Symbol</code>，它允许开发者标记不可修改的字段。这个新特性可以帮助实现更严格的类型和字段管理。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> immutableField = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;immutable&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>    [immutableField]: <span class="hljs-string">&#x27;This field cannot be changed&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[immutableField]); <span class="hljs-comment">// 输出: This field cannot be changed</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-WeakRefs-和-FinalizationRegistry"><a href="#5-WeakRefs-和-FinalizationRegistry" class="headerlink" title="5. WeakRefs 和 FinalizationRegistry"></a>5. <code>WeakRefs</code> 和 <code>FinalizationRegistry</code></h2><p>在 ES14 中，<code>WeakRef</code> 和 <code>FinalizationRegistry</code> 的支持得到了增强，使得开发者可以更好地管理内存和对象的生命周期。这对于实现内存敏感的功能非常有用。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> registry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function">(<span class="hljs-params">heldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Resource <span class="hljs-subst">$&#123;heldValue&#125;</span> is garbage collected`</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> resource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&#x27;Resource 1&#x27;</span>);<br><span class="hljs-keyword">const</span> weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(resource);<br><br>registry.<span class="hljs-title function_">register</span>(resource, resource.<span class="hljs-property">name</span>);<br><br>resource = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 解除对资源的引用，触发垃圾回收</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2023（ES14）引入了多项新特性，使得 JavaScript 更加灵活和高效。新方法如 <code>toSorted</code>、<code>toReversed</code> 和 <code>toSpliced</code> 提供了不修改原数组的情况下进行操作的能力，而 <code>Symbol.symbols</code> 和对 <code>WeakRefs</code> 的改进则增强了对内存管理的控制。这些改进不仅提升了开发者的体验，也为 JavaScript 的未来发展提供了更多可能性。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript13新特性详解</title>
    <link href="/posts/41881/"/>
    <url>/posts/41881/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2022（ES13）新特性详解"><a href="#ECMAScript-2022（ES13）新特性详解" class="headerlink" title="ECMAScript 2022（ES13）新特性详解"></a>ECMAScript 2022（ES13）新特性详解</h1><p>ECMAScript 2022（也称为 ES13）是 ECMAScript 的又一个小版本更新，主要引入了一些新特性来增强语言的表达力和性能。以下是 ES13 的主要新特性，包括详细的 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-at"><a href="#1-Array-prototype-at" class="headerlink" title="1. Array.prototype.at()"></a>1. <code>Array.prototype.at()</code></h2><p><code>Array.prototype.at()</code> 方法允许通过给定的索引获取数组中元素的值，可以接受负数索引，从而方便地访问数组末尾的元素。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">at</span>(index)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>index</code>: 要获取的元素的索引。可以是正数（从开头开始）或负数（从结尾开始）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回数组中指定索引的元素；如果索引超出范围，则返回 <code>undefined</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// 50</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">2</span>)); <span class="hljs-comment">// 40</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Object-hasOwn"><a href="#2-Object-hasOwn" class="headerlink" title="2. Object.hasOwn()"></a>2. <code>Object.hasOwn()</code></h2><p><code>Object.hasOwn()</code> 方法提供了一种简洁的方式来判断对象是否具有某个自身属性，类似于 <code>Object.prototype.hasOwnProperty()</code>，但语法更简洁。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, prop)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要检查的对象。</li><li><code>prop</code>: 要检查的属性名（字符串）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>如果对象具有该自身属性，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;gender&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-类字段和私有字段"><a href="#3-类字段和私有字段" class="headerlink" title="3. 类字段和私有字段"></a>3. 类字段和私有字段</h2><p>在 ES13 中，类支持声明公共字段和私有字段。这使得定义类属性更加简洁和清晰。</p><h3 id="3-1-公共字段"><a href="#3-1-公共字段" class="headerlink" title="3.1 公共字段"></a>3.1 公共字段</h3><p>可以在类中直接声明公共字段。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    myField = value;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br>    age = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-私有字段"><a href="#3-2-私有字段" class="headerlink" title="3.2 私有字段"></a>3.2 私有字段</h3><p>私有字段以 <code>#</code> 开头，仅能在类的内部访问。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    #myPrivateField;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    #ssn = <span class="hljs-string">&#x27;123-45-6789&#x27;</span>; <span class="hljs-comment">// 私有字段</span><br>    <br>    <span class="hljs-title function_">getSSN</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#ssn; <span class="hljs-comment">// 可以访问私有字段</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getSSN</span>()); <span class="hljs-comment">// 123-45-6789</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.#ssn); <span class="hljs-comment">// SyntaxError: Private field &#x27;#ssn&#x27; must be declared in an enclosing class</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2022（ES13）引入的新特性如 <code>Array.prototype.at()</code>、<code>Object.hasOwn()</code>、类字段和私有字段等，极大地增强了 JavaScript 的语法和可用性，使得编写和维护代码变得更加简洁。了解这些新特性可以帮助开发者更有效地利用 JavaScript，提升开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript12新特性详解</title>
    <link href="/posts/13144/"/>
    <url>/posts/13144/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2021（ES12）新特性详解"><a href="#ECMAScript-2021（ES12）新特性详解" class="headerlink" title="ECMAScript 2021（ES12）新特性详解"></a>ECMAScript 2021（ES12）新特性详解</h1><p>ECMAScript 2021（也称为 ES12）引入了一系列新特性，进一步增强了 JavaScript 的功能和灵活性。主要的新特性包括 <strong>String.prototype.replaceAll</strong>、<strong>Promise.any</strong>、<strong>WeakRefs</strong>、<strong>逻辑赋值运算符</strong>、<strong>数字分隔符</strong>、<strong>Promise.allSettled()</strong> 以及 <strong>Array.prototype.at</strong>。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-String-prototype-replaceAll"><a href="#1-String-prototype-replaceAll" class="headerlink" title="1. String.prototype.replaceAll"></a>1. String.prototype.replaceAll</h2><p><code>String.prototype.replaceAll()</code> 方法用于返回一个新字符串，其中所有匹配的子字符串都被替换为指定的替换字符串。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">replaceAll</span>(search, replacement)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>search</code>：要替换的子字符串，可以是一个字符串或正则表达式（不使用全局标志）。</li><li><code>replacement</code>：替换成的字符串。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新字符串，其中所有匹配的子字符串都被替换。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;I like cats. Cats are great!&#x27;</span>;<br><span class="hljs-keyword">const</span> newStr = str.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;cats&#x27;</span>, <span class="hljs-string">&#x27;dogs&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr); <span class="hljs-comment">// &#x27;I like dogs. Dogs are great!&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a>2. Promise.any</h2><p><code>Promise.any()</code> 方法接受一个可迭代的 Promise 对象，并返回一个 Promise，该 Promise 在其中一个输入 Promise 成功时解析，或在所有输入 Promise 都失败时被拒绝。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(promises)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>promises</code>：一个可迭代的 Promise 对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 Promise，当其中一个 Promise 成功时解析为该 Promise 的值；如果所有 Promise 都失败，则返回一个 AggregateError。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error 1&#x27;</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error 2&#x27;</span>);<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Success&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &#x27;Success&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Logical-Assignment-Operators"><a href="#3-Logical-Assignment-Operators" class="headerlink" title="3. Logical Assignment Operators"></a>3. Logical Assignment Operators</h2><p>逻辑赋值运算符结合了逻辑运算和赋值操作，简化了常见的逻辑赋值模式。</p><ul><li><p><strong>语法</strong>:</p><ul><li><code>x ||= y</code> （逻辑或赋值）</li><li><code>x &amp;&amp;= y</code> （逻辑与赋值）</li><li><code>x ??= y</code> （空值合并赋值）</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br><br>a ||= b; <span class="hljs-comment">// 如果 a 为 falsy，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span>;<br>c &amp;&amp;= b; <span class="hljs-comment">// 如果 c 为 truthy，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">let</span> d = <span class="hljs-literal">undefined</span>;<br>d ??= b; <span class="hljs-comment">// 如果 d 为 null 或 undefined，则赋值为 b</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Numeric-Separators"><a href="#4-Numeric-Separators" class="headerlink" title="4. Numeric Separators"></a>4. Numeric Separators</h2><p>数字分隔符（<code>_</code>）允许在数字中使用下划线作为分隔符，以提高数字的可读性。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> billion = <span class="hljs-number">1_000_000_000</span>;<br><span class="hljs-keyword">const</span> hex = <span class="hljs-number">0xFF_FF_FF</span>;<br><span class="hljs-keyword">const</span> binary = <span class="hljs-number">0b1010_1011_1100_1100</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(billion); <span class="hljs-comment">// 1000000000</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hex); <span class="hljs-comment">// 16777215</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binary); <span class="hljs-comment">// 43980</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-WeakRefs"><a href="#5-WeakRefs" class="headerlink" title="5. WeakRefs"></a>5. WeakRefs</h2><p><code>WeakRef</code> 允许你持有对对象的弱引用，这样可以防止引用的对象被垃圾回收。这对实现缓存或其他内存管理方案非常有用。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Weak Reference&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakRef.<span class="hljs-title function_">deref</span>()); <span class="hljs-comment">// &#123; name: &#x27;Weak Reference&#x27; &#125;</span><br><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 允许 obj 被垃圾回收</span><br><br><span class="hljs-comment">// 由于是弱引用，obj 可能会被回收</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakRef.<span class="hljs-title function_">deref</span>()); <span class="hljs-comment">// 可能输出 undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2021（ES12）引入的新特性，如 <code>String.prototype.replaceAll</code>、<code>Promise.any</code>、逻辑赋值运算符、数字分隔符、<code>WeakRefs</code> ，为 JavaScript 的开发提供了更高的灵活性和便利性。这些新特性使得开发者在处理字符串、异步操作、数字表示和数组访问方面变得更加高效。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript11新特性详解</title>
    <link href="/posts/49688/"/>
    <url>/posts/49688/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2020（ES11）新特性详解"><a href="#ECMAScript-2020（ES11）新特性详解" class="headerlink" title="ECMAScript 2020（ES11）新特性详解"></a>ECMAScript 2020（ES11）新特性详解</h1><p>ECMAScript 2020（也称为 ES11）引入了一系列新特性，进一步增强了 JavaScript 的功能和灵活性。主要的新特性包括 <strong>Optional Chaining</strong>、<strong>Nullish Coalescing Operator</strong>、<strong>BigInt</strong>、<strong>Promise.allSettled()<strong>、</strong>globalThis</strong>、<strong>module <code>import.meta</code><strong>、</strong>String.prototype.matchAll</strong> 和 <strong>WeakRefs</strong>。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-Optional-Chaining"><a href="#1-Optional-Chaining" class="headerlink" title="1. Optional Chaining"></a>1. Optional Chaining</h2><p>可选链（Optional Chaining）运算符（<code>?.</code>）使得访问深层嵌套对象的属性变得更安全，避免了因为访问 <code>undefined</code> 或 <code>null</code> 属性而抛出错误。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj?.<span class="hljs-property">prop</span><br>obj?.[expr]<br>obj?.<span class="hljs-title function_">method</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>如果所访问的值存在，则返回该值；如果不存在（为 <code>null</code> 或 <code>undefined</code>），则返回 <code>undefined</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Wonderland&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">address</span>?.<span class="hljs-property">city</span>); <span class="hljs-comment">// &#x27;Wonderland&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">address</span>?.<span class="hljs-property">zip</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">getName</span>?.()); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Nullish-Coalescing-Operator"><a href="#2-Nullish-Coalescing-Operator" class="headerlink" title="2. Nullish Coalescing Operator"></a>2. Nullish Coalescing Operator</h2><p>空值合并运算符（Nullish Coalescing Operator，<code>??</code>）用于返回其右侧操作数的值，当且仅当其左侧操作数为 <code>null</code> 或 <code>undefined</code> 时。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">value1 ?? value2<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回 <code>value1</code>，如果 <code>value1</code> 不是 <code>null</code> 或 <code>undefined</code>；否则返回 <code>value2</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;default string&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// &#x27;default string&#x27;</span><br><br><span class="hljs-keyword">const</span> bar = <span class="hljs-number">0</span> ?? <span class="hljs-number">42</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// 0</span><br><br><span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;&#x27;</span> ?? <span class="hljs-string">&#x27;default string&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-BigInt"><a href="#3-BigInt" class="headerlink" title="3. BigInt"></a>3. BigInt</h2><p>BigInt 提供了一种表示大于 <code>Number.MAX_SAFE_INTEGER</code> 的整数的新数据类型，适用于需要高精度整数计算的场景。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigIntValue = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789012345678901234567890</span>);<br><span class="hljs-keyword">const</span> bigIntValue2 = <span class="hljs-number">123456789012345678901234567890n</span>; <span class="hljs-comment">// 使用 n 后缀</span><br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 BigInt 类型的整数。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigInt1 = <span class="hljs-number">123456789012345678901234567890n</span>;<br><span class="hljs-keyword">const</span> bigInt2 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">12345678901234567890</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigInt1 + bigInt2); <span class="hljs-comment">// 12345678901234567891234567890n</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigInt1 &gt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Promise-allSettled"><a href="#4-Promise-allSettled" class="headerlink" title="4. Promise.allSettled()"></a>4. Promise.allSettled()</h2><p><code>Promise.allSettled()</code> 方法返回一个 Promise，解析为一个对象数组，表示所有给定 Promise 的最终结果（每个 Promise 的状态要么是 fulfilled 要么是 rejected）。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>promises</code>：一个可迭代的 Promise 对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个 Promise，当所有给定的 Promise 处理结束后，解析为一个对象数组，每个对象的形状为 <code>&#123; status, value, reason &#125;</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> &#123;<br>    results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">status</span>);<br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Result:&#x27;</span>, result.<span class="hljs-property">value</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, result.<span class="hljs-property">reason</span>);<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-globalThis"><a href="#5-globalThis" class="headerlink" title="5. globalThis"></a>5. globalThis</h2><p><code>globalThis</code> 提供了一个统一的方式来访问全局对象，无论是在浏览器环境还是 Node.js 环境中。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis); <span class="hljs-comment">// 在浏览器中输出 window 对象，在 Node.js 中输出 global 对象</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6-module-import-meta"><a href="#6-module-import-meta" class="headerlink" title="6. module import.meta"></a>6. module <code>import.meta</code></h2><p><code>import.meta</code> 是一个包含模块元数据的对象，主要用于模块内部的信息。</p><ul><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>); <span class="hljs-comment">// 输出当前模块的 URL</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7. String.prototype.matchAll"></a>7. String.prototype.matchAll</h2><p><code>String.prototype.matchAll()</code> 方法返回一个可迭代的匹配对象，包含所有与正则表达式匹配的结果。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">matchAll</span>(regexp)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>regexp</code>：一个正则表达式对象（必须是带有 <code>g</code> 标志的）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个可迭代的对象，每个元素是一个包含匹配结果的数组。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;test1test2test3&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/test(\d)/g</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> str.<span class="hljs-title function_">matchAll</span>(regex)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Matched: <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span>, Group: <span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>]&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Matched: test1, Group: 1</span><br><span class="hljs-comment">// Matched: test2, Group: 2</span><br><span class="hljs-comment">// Matched: test3, Group: 3</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2020（ES11）引入的新特性，如 Optional Chaining、Nullish Coalescing Operator、BigInt、Promise.allSettled()、globalThis、module <code>import.meta</code>、String.prototype.matchAll，为 JavaScript 的开发提供了更高的灵活性和便利性。这些新特性使得开发者在处理数据、管理异步操作和优化内存方面变得更加高效。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript10新特性详解</title>
    <link href="/posts/21209/"/>
    <url>/posts/21209/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2019（ES10）新特性详解"><a href="#ECMAScript-2019（ES10）新特性详解" class="headerlink" title="ECMAScript 2019（ES10）新特性详解"></a>ECMAScript 2019（ES10）新特性详解</h1><p>ECMAScript 2019（也称为 ES10）引入了一些实用的新特性，增强了 JavaScript 的功能和可用性。主要的新特性包括 <strong>Array.prototype.flat()<strong>、</strong>Array.prototype.flatMap()<strong>、</strong>Object.fromEntries()<strong>、</strong>String.prototype.trimStart()</strong> 和 **String.prototype.trimEnd()**。下面将详细介绍这些新特性，包括 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-flat"><a href="#1-Array-prototype-flat" class="headerlink" title="1. Array.prototype.flat()"></a>1. Array.prototype.flat()</h2><p><code>Array.prototype.flat()</code> 方法用于将嵌套的数组“拉平”，将多维数组转换为一维数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">flat</span>([depth])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>depth</code>（可选）：一个整数，表示要拉平的嵌套数组的深度。默认值为 <code>1</code>。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新数组，包含拉平后的元素。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>()); <span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Array-prototype-flatMap"><a href="#2-Array-prototype-flatMap" class="headerlink" title="2. Array.prototype.flatMap()"></a>2. Array.prototype.flatMap()</h2><p><code>Array.prototype.flatMap()</code> 方法首先映射每个元素，然后将结果扁平化为一个新数组。它是 <code>map()</code> 和 <code>flat()</code> 的组合。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">flatMap</span>(<span class="hljs-title function_">callback</span>(currentValue[, index[, array]])[, thisArg])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="hljs">callback<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>    ：用于生成数组的函数，接受以下参数：<br><br>    - `currentValue`：当前处理的元素。<br>    - `index`（可选）：当前处理元素的索引。<br>    - `array`（可选）：调用 `flatMap` 的数组。<br><br>  - `thisArg`（可选）：执行 `callback` 函数时，用作 `this` 的值。<br><br><span class="hljs-title">- **返回值**:</span><br><br>  - 返回一个新数组，包含通过 `callback` 处理的每个元素，并拉平一层。<br><br><span class="hljs-title">- **用法示例**:</span><br><br>  ```javascript<br>  const array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-comment">;</span><br>  <br>  const result = array.flatMap(x =&gt; [x, x * <span class="hljs-number">2</span>])<span class="hljs-comment">;</span><br>  console.log(result)<span class="hljs-comment">; // [1, 2, 2, 4, 3, 6, 4, 8]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="3-Object-fromEntries"><a href="#3-Object-fromEntries" class="headerlink" title="3. Object.fromEntries()"></a>3. Object.fromEntries()</h2><p><code>Object.fromEntries()</code> 方法将一个键值对的列表转换为一个对象。这可以用于将 Map 或其他包含键值对的数据结构转换为对象。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(iterable)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>iterable</code>：一个可迭代对象，其中每个元素都是一个长度为 2 的数组，表示键值对。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新对象，包含转换后的键值对。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>],<br>    [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>]<br>]);<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(entries);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; name: &#x27;John&#x27;, age: 30 &#125;</span><br><br><span class="hljs-keyword">const</span> array = [[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>], [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>]];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(array)); <span class="hljs-comment">// &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-String-prototype-trimStart"><a href="#4-String-prototype-trimStart" class="headerlink" title="4. String.prototype.trimStart()"></a>4. String.prototype.trimStart()</h2><p><code>String.prototype.trimStart()</code> 方法用于删除字符串开头的空白字符（空格、制表符等）。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">trimStart</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的字符串，去除了开头的空白字符。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;   Hello, World!   &#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimStart</span>()); <span class="hljs-comment">// &#x27;Hello, World!   &#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-String-prototype-trimEnd"><a href="#5-String-prototype-trimEnd" class="headerlink" title="5. String.prototype.trimEnd()"></a>5. String.prototype.trimEnd()</h2><p><code>String.prototype.trimEnd()</code> 方法用于删除字符串结尾的空白字符。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">trimEnd</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的字符串，去除了结尾的空白字符。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;   Hello, World!   &#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimEnd</span>()); <span class="hljs-comment">// &#x27;   Hello, World!&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2019（ES10）引入的这些新特性，如 <code>Array.prototype.flat()</code>、<code>Array.prototype.flatMap()</code>、<code>Object.fromEntries()</code>、<code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code>，显著提高了 JavaScript 的功能和可读性。它们使得处理数组、对象和字符串变得更加方便和直观，帮助开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript9新特性详解</title>
    <link href="/posts/29004/"/>
    <url>/posts/29004/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2018（ES9）新特性详解"><a href="#ECMAScript-2018（ES9）新特性详解" class="headerlink" title="ECMAScript 2018（ES9）新特性详解"></a>ECMAScript 2018（ES9）新特性详解</h1><p>ECMAScript 2018（也称为 ES9）引入了一些新的特性和改进，使得 JavaScript 更加强大和灵活。下面将详细介绍 ES9 的主要新特性，包括：<strong>异步迭代器（Async Iterators）</strong>、<strong>Promise.prototype.finally()<strong>、</strong>扩展对象（Spread Properties）</strong> 和 <strong>正则表达式的改进</strong>。每个特性都会包含 API 说明、参数、返回值及用法示例。</p><h1 id="1-异步迭代器（Async-Iterators）"><a href="#1-异步迭代器（Async-Iterators）" class="headerlink" title="1. 异步迭代器（Async Iterators）"></a>1. 异步迭代器（Async Iterators）</h1><p>异步迭代器允许你在处理异步数据时使用 <code>for await...of</code> 循环。这样可以方便地处理异步操作，尤其是在处理网络请求、文件读取等场景中。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> asyncIterable) &#123;<br>    <span class="hljs-comment">// 处理每个 item</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>没有返回值。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 模拟异步操作</span><br>        <span class="hljs-keyword">yield</span> item;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processAsyncData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-title function_">asyncGenerator</span>()) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出 &#x27;a&#x27;，&#x27;b&#x27;，&#x27;c&#x27; 每隔 1 秒</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processAsyncData</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-1-示例剖析"><a href="#1-1-示例剖析" class="headerlink" title="1.1 示例剖析"></a>1.1 <strong>示例剖析</strong></h2><h3 id="1-异步生成器函数"><a href="#1-异步生成器函数" class="headerlink" title="1. 异步生成器函数"></a>1. 异步生成器函数</h3><p>首先，异步生成器是一个函数，可以使用 <code>async function*</code> 声明。异步生成器的特点是可以使用 <code>await</code> 关键字，并且使用 <code>yield</code> 返回多个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 模拟异步操作</span><br>        <span class="hljs-keyword">yield</span> item; <span class="hljs-comment">// 暂停执行并返回当前 item</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong><code>async function\*</code></strong>: 声明一个异步生成器函数。</li><li><strong><code>yield</code></strong>: 用于暂停函数的执行，并返回一个值给调用者。</li><li><strong><code>await</code></strong>: 可以在异步生成器中使用，以等待异步操作完成。</li></ul><h3 id="2-异步迭代器"><a href="#2-异步迭代器" class="headerlink" title="2. 异步迭代器"></a>2. 异步迭代器</h3><p>当你调用异步生成器函数（如 <code>asyncGenerator()</code>）时，它返回一个异步迭代器。这个迭代器可以通过 <code>next()</code> 方法逐步获取值。</p><ul><li><strong><code>next()</code> 方法</strong>: 返回一个 Promise，该 Promise 的 <code>value</code> 属性是生成器 <code>yield</code> 返回的值，<code>done</code> 属性指示生成器是否已完成。</li></ul><h3 id="3-for-await-of-语句"><a href="#3-for-await-of-语句" class="headerlink" title="3. for await...of 语句"></a>3. <code>for await...of</code> 语句</h3><p><code>for await...of</code> 是一个用于遍历异步迭代器的语句。它可以处理异步操作，使得代码更易于阅读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processAsyncData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-title function_">asyncGenerator</span>()) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 每隔 1 秒输出 &#x27;a&#x27;，&#x27;b&#x27;，&#x27;c&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong>自动调用 <code>next()</code></strong>: 在循环中，<code>for await...of</code> 会自动调用异步生成器的 <code>next()</code> 方法，获取生成器的下一个值。</li><li><strong>异步等待</strong>: 在调用 <code>next()</code> 时，如果生成器还未到达下一个 <code>yield</code>，则会等待直到异步操作完成，获取到值后继续执行循环。</li><li><strong>停止条件</strong>: 当生成器完成（即没有更多的值可以 <code>yield</code>），<code>done</code> 会变为 <code>true</code>，循环会自动停止。</li></ul><h3 id="4-详细流程"><a href="#4-详细流程" class="headerlink" title="4. 详细流程"></a>4. 详细流程</h3><p>让我们详细分析执行 <code>processAsyncData</code> 的流程：</p><ol><li><strong>调用 <code>asyncGenerator()</code></strong>: 这会创建一个异步生成器对象，准备生成值。</li><li><strong>进入 <code>for await...of</code> 循环</strong>: 这时，循环开始，准备处理从异步生成器获取的值。</li><li><strong>第一次迭代</strong>:<ul><li><code>next()</code> 被自动调用。</li><li>在 <code>asyncGenerator</code> 中，执行到第一个 <code>await</code>，即 <code>await new Promise(...)</code>，此时会暂停执行。</li><li>等待 1 秒后，Promise 被解决，执行到 <code>yield item</code>，返回 <code>&#39;a&#39;</code>。</li><li><code>for await...of</code> 接收到这个值，赋值给 <code>value</code>，并执行 <code>console.log(value)</code>，输出 <code>&#39;a&#39;</code>。</li></ul></li><li><strong>第二次迭代</strong>:<ul><li>再次自动调用 <code>next()</code>。</li><li>同样地，执行到 <code>await</code>，暂停 1 秒后返回 <code>&#39;b&#39;</code>，并输出。</li></ul></li><li><strong>第三次迭代</strong>:<ul><li>继续执行，返回 <code>&#39;c&#39;</code>。</li></ul></li><li><strong>结束</strong>:<ul><li>当没有更多的值可 <code>yield</code> 时，异步生成器完成，<code>next()</code> 返回一个 <code>done</code> 为 <code>true</code> 的对象，循环结束。</li></ul></li></ol><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><code>async function*</code> 创建异步生成器，可以在其中使用 <code>await</code> 和 <code>yield</code>。</li><li><code>for await...of</code> 语句用于遍历异步生成器，自动处理 <code>next()</code> 调用和异步等待。</li><li>这使得异步操作的控制流更为简单和清晰，避免了手动处理 Promise 的复杂性。</li></ul><h1 id="2-Promise-prototype-finally"><a href="#2-Promise-prototype-finally" class="headerlink" title="2. Promise.prototype.finally()"></a>2. Promise.prototype.finally()</h1><p><code>Promise.prototype.finally()</code> 方法为 Promise 提供了一个清理功能，允许你在 Promise 解决或拒绝后执行一段代码。这对于进行一些清理操作（例如关闭加载指示器）非常有用。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise.<span class="hljs-title function_">finally</span>(onFinally);<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>onFinally</code>: 一个可选的回调函数，在 Promise 解决或拒绝后执行。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新的 Promise，其结果与原 Promise 相同。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据获取成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 输出: 数据获取成功</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;发生错误:&#x27;</span>, error);<br>    &#125;)<br>    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;清理操作&#x27;</span>); <span class="hljs-comment">// 不论成功或失败都会执行</span><br>    &#125;);<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-扩展对象（Spread-Properties）"><a href="#3-扩展对象（Spread-Properties）" class="headerlink" title="3. 扩展对象（Spread Properties）"></a>3. 扩展对象（Spread Properties）</h1><p>扩展对象语法允许我们使用扩展运算符（<code>...</code>）在对象字面量中复制属性。这使得对象的合并和克隆更加简洁。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newObject = &#123; ...obj1, ...obj2 &#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj1</code>, <code>obj2</code>: 要合并的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个新对象，包含所有合并后的属性。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">4</span> &#125;;<br><span class="hljs-keyword">const</span> merged = &#123; ...obj1, ...obj2 &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(merged); <span class="hljs-comment">// 输出: &#123; a: 1, b: 3, c: 4 &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="4-正则表达式的改进"><a href="#4-正则表达式的改进" class="headerlink" title="4. 正则表达式的改进"></a>4. 正则表达式的改进</h1><p>ES9 对正则表达式进行了增强，新增了两个主要功能：<strong>命名捕获组</strong>和<strong>s（dotAll）标志</strong>。</p><h2 id="4-1-命名捕获组"><a href="#4-1-命名捕获组" class="headerlink" title="4.1 命名捕获组"></a>4.1 命名捕获组</h2><p>使用命名捕获组可以更容易地从正则表达式中提取信息。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?&lt;name&gt;pattern)/</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>:</p><ul><li>捕获组的命名可以通过 <code>groups</code> 属性访问。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?&lt;firstName&gt;\w+) (?&lt;lastName&gt;\w+)/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;John Doe&#x27;</span>;<br><span class="hljs-keyword">const</span> result = regex.<span class="hljs-title function_">exec</span>(str);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">groups</span>.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// 输出: John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">groups</span>.<span class="hljs-property">lastName</span>); <span class="hljs-comment">// 输出: Doe</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-2-s（dotAll）标志"><a href="#4-2-s（dotAll）标志" class="headerlink" title="4.2 s（dotAll）标志"></a>4.2 s（dotAll）标志</h2><p><code>s</code> 标志使得点号 <code>.</code> 可以匹配换行符，这对于多行字符串的匹配非常有用。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/.*?/</span>s; <span class="hljs-comment">// 点号可以匹配换行符</span><br></code></pre></td></tr></table></figure></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> text = <span class="hljs-string">`Hello\nWorld`</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/Hello.*World/</span>s;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(text)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ECMAScript 2018（ES9）引入的这些新特性，极大地增强了 JavaScript 处理异步操作、对象合并、正则表达式等方面的能力。它们使得代码更加简洁和易于维护，帮助开发者更高效地完成任务。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript8新特性详解</title>
    <link href="/posts/57741/"/>
    <url>/posts/57741/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2017（ES8）新特性详解"><a href="#ECMAScript-2017（ES8）新特性详解" class="headerlink" title="ECMAScript 2017（ES8）新特性详解"></a>ECMAScript 2017（ES8）新特性详解</h1><p>ECMAScript 2017（也称为 ES8）引入了多个新的特性，其中最主要的有：**<code>async/await</code>** 语法、**<code>Object.entries()</code>** 和 <strong><code>Object.values()</code></strong> 方法、以及 <strong><code>String.prototype.padStart()</code></strong> 和 <strong><code>String.prototype.padEnd()</code></strong> 方法。下面将详细介绍这些新特性。</p><h1 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async&#x2F;await"></a>1. async&#x2F;await</h1><p><code>async/await</code> 语法用于简化基于 Promise 的异步编程，使异步代码的写法更接近同步代码的风格。</p><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p><code>async/await</code> 是 ECMAScript 2017（ES8）引入的一种语法，用于简化基于 Promise 的异步编程。它使得异步代码的书写方式更接近于同步代码，从而提高了代码的可读性和可维护性。</p><h2 id="1-2-async-函数"><a href="#1-2-async-函数" class="headerlink" title="1.2 async 函数"></a>1.2 async 函数</h2><ul><li><strong>定义</strong>: 使用 <code>async</code> 关键字定义的函数被称为异步函数，返回一个 Promise 对象。</li><li><strong>返回值</strong>: 如果异步函数内部有 <code>return</code> 语句，则该值会被包装成一个 resolved 的 Promise。如果没有 <code>return</code> 语句，则默认返回一个 resolved 状态的 Promise，值为 <code>undefined</code>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 实际上返回的是 Promise.resolve(42)</span><br>&#125;<br><br><span class="hljs-title function_">example</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h2 id="1-3-await-表达式"><a href="#1-3-await-表达式" class="headerlink" title="1.3 await 表达式"></a>1.3 await 表达式</h2><ul><li><strong>定义</strong>: <code>await</code> 关键字用于等待一个 Promise 的结果，它只能在 <code>async</code> 函数内部使用。</li><li><strong>功能</strong>: <code>await</code> 会暂停 <code>async</code> 函数的执行，直到 Promise 被解决（resolved）或拒绝（rejected）。当 Promise 被解决时，<code>await</code> 表达式返回该 Promise 的结果；当 Promise 被拒绝时，<code>await</code> 表达式会抛出错误。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)); <span class="hljs-comment">// 打印获取到的数据</span><br></code></pre></td></tr></table></figure><h2 id="1-4-错误处理"><a href="#1-4-错误处理" class="headerlink" title="1.4 错误处理"></a>1.4 错误处理</h2><p>在使用 <code>async/await</code> 时，可以使用 <code>try/catch</code> 语句块来处理错误。<code>await</code> 抛出的任何错误都可以在 <code>catch</code> 中捕获。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchDataWithErrorHandling</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>);<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取数据时出错:&#x27;</span>, error);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchDataWithErrorHandling</span>();<br></code></pre></td></tr></table></figure><h2 id="1-5-串行与并行处理"><a href="#1-5-串行与并行处理" class="headerlink" title="1.5 串行与并行处理"></a>1.5 串行与并行处理</h2><ul><li><p><strong>串行处理</strong>: 如果多个异步操作之间存在依赖关系，可以逐个使用 <code>await</code> 进行串行处理。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">serialExecution</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataFromAPI1</span>();<br>    <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataFromAPI2</span>(result1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>并行处理</strong>: 对于没有依赖关系的多个异步操作，可以使用 <code>Promise.all()</code> 来实现并行处理。这样可以提高性能。</p><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parallelExecution</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">fetchDataFromAPI1</span>();<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">fetchDataFromAPI2</span>();<br>    <span class="hljs-keyword">const</span> [result1, result2] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1, result2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h2><ul><li><code>async/await</code> 是一种简化异步编程的语法，使得异步代码看起来像同步代码。</li><li><code>async</code> 关键字用于定义异步函数，返回一个 Promise。</li><li><code>await</code> 关键字用于等待 Promise 的结果，暂停函数的执行。</li><li>错误可以通过 <code>try/catch</code> 进行处理。</li><li>支持串行和并行处理，可以提高代码的性能和可读性。</li></ul><h1 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2. Object.entries()"></a>2. Object.entries()</h1><p><code>Object.entries()</code> 方法返回一个给定对象自身可枚举属性的键值对数组。该数组中的每个元素都是一个数组，其中包含两个元素：属性名和属性值。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要查询的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个数组，数组的每个元素是一个包含对象自身可枚举属性的键值对数组。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">const</span> entries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries); <br><span class="hljs-comment">// [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="3-Object-values"><a href="#3-Object-values" class="headerlink" title="3. Object.values()"></a>3. Object.values()</h1><p><code>Object.values()</code> 方法返回一个给定对象自身可枚举属性值的数组。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj)<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>obj</code>: 要查询的对象。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回一个数组，数组中的元素是对象自身可枚举属性的值。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">const</span> values = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="4-String-prototype-padStart"><a href="#4-String-prototype-padStart" class="headerlink" title="4. String.prototype.padStart()"></a>4. String.prototype.padStart()</h1><p><code>String.prototype.padStart()</code> 方法用于在当前字符串的开头填充指定的字符，以达到给定的总长度。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">padStart</span>(targetLength [, padString])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>targetLength</code>: 返回的字符串所需的长度。</li><li><code>padString</code>（可选）: 填充字符串，默认为空格。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回填充后的字符串。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;5&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">// &#x27;05&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// &#x27;12312&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-String-prototype-padEnd"><a href="#5-String-prototype-padEnd" class="headerlink" title="5. String.prototype.padEnd()"></a>5. String.prototype.padEnd()</h1><p><code>String.prototype.padEnd()</code> 方法用于在当前字符串的结尾填充指定的字符，以达到给定的总长度。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">padEnd</span>(targetLength [, padString])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li><code>targetLength</code>: 返回的字符串所需的长度。</li><li><code>padString</code>（可选）: 填充字符串，默认为空格。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回填充后的字符串。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;5&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">// &#x27;50&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// &#x27;5abc&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ECMAScript 2017（ES8）引入的新特性如 <code>async/await</code> 语法、<code>Object.entries()</code>、<code>Object.values()</code>、<code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code>，极大地增强了 JavaScript 的可用性和可读性。这些特性使得异步编程、对象操作和字符串处理变得更加简洁高效，有助于开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript7新特性详解</title>
    <link href="/posts/5576/"/>
    <url>/posts/5576/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-2016（ES7）新特性详解"><a href="#ECMAScript-2016（ES7）新特性详解" class="headerlink" title="ECMAScript 2016（ES7）新特性详解"></a>ECMAScript 2016（ES7）新特性详解</h1><p>ECMAScript 2016（也称为 ES7）是 ECMAScript 的一个小版本更新，主要引入了两个新特性：**<code>Array.prototype.includes()</code>** 和 <strong>指数运算符（<code>\**</code>）</strong>。下面将详细介绍这两个新特性，包含 API 说明、参数、返回值及用法示例。</p><h2 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a>1. Array.prototype.includes()</h2><p><code>Array.prototype.includes()</code> 方法用于判断数组是否包含特定的元素，返回一个布尔值。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">includes</span>(valueToFind[, fromIndex])<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li>valueToFind: 要查找的值，可以是任何数据类型。</li><li>fromIndex: （可选）从该索引开始搜索。默认值为 <code>0</code>。如果为负值，则表示从数组末尾开始查找。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>如果数组包含 <code>valueToFind</code>，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-title class_">NaN</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-指数运算符（Exponentiation-Operator）"><a href="#2-指数运算符（Exponentiation-Operator）" class="headerlink" title="2. 指数运算符（Exponentiation Operator）"></a>2. 指数运算符（Exponentiation Operator）</h2><p>指数运算符（<code>**</code>）提供了一种简洁的方式来进行幂运算，相比于 <code>Math.pow()</code>，语法更为直观。</p><ul><li><p><strong>语法</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">base ** exponent<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>:</p><ul><li>base: 基数，可以是任何数字或表达式。</li><li>exponent: 指数，可以是任何数字（包括负数、零或小数）。</li></ul></li><li><p><strong>返回值</strong>:</p><ul><li>返回 <code>base</code> 的 <code>exponent</code> 次幂。</li></ul></li><li><p><strong>用法示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>); <span class="hljs-comment">// 8</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 9</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span> ** <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)); <span class="hljs-comment">// 512</span><br><br><span class="hljs-keyword">let</span> base = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> exponent = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(base ** exponent); <span class="hljs-comment">// 125</span><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((a + b) ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ECMAScript 2016（ES7）引入的两个新特性，<code>Array.prototype.includes()</code> 和 指数运算符（<code>**</code>），提升了 JavaScript 的可用性和可读性。这些新特性使得数组包含检查和数学运算变得更加简洁，帮助开发者编写更清晰的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript从基础到进阶</title>
    <link href="/posts/26356/"/>
    <url>/posts/26356/</url>
    
    <content type="html"><![CDATA[<h1 id="全面掌握-TypeScript：从基础到进阶"><a href="#全面掌握-TypeScript：从基础到进阶" class="headerlink" title="全面掌握 TypeScript：从基础到进阶"></a>全面掌握 TypeScript：从基础到进阶</h1><p>TypeScript 是 JavaScript 的一个超集，它增加了静态类型检查和最新的 ES 功能，帮助我们构建更可维护、更健壮的代码。本文将深入探讨 TypeScript 的所有关键知识点，从基础语法到高级用法。</p><hr><h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><p>TypeScript 是由 Microsoft 开发的编程语言，它增加了静态类型，支持最新的 ECMAScript 标准，拥有更好的代码提示和重构能力，特别适合中大型项目开发。</p><hr><h2 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="2. 安装与配置"></a>2. 安装与配置</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g typescript<br></code></pre></td></tr></table></figure><h3 id="创建-tsconfig-json"><a href="#创建-tsconfig-json" class="headerlink" title="创建 tsconfig.json"></a>创建 <code>tsconfig.json</code></h3><p>可以使用 <code>tsc --init</code> 命令生成项目的配置文件 <code>tsconfig.json</code>，在其中设置编译选项和路径。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-基本类型"><a href="#3-基本类型" class="headerlink" title="3. 基本类型"></a>3. 基本类型</h2><p>TypeScript 提供了多种基本数据类型，与 JavaScript 相似，同时增加了静态类型检查。</p><h3 id="基本类型示例"><a href="#基本类型示例" class="headerlink" title="基本类型示例"></a>基本类型示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;John Doe&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">42</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;  <span class="hljs-comment">// `any` 可以被赋值为任何类型</span><br></code></pre></td></tr></table></figure><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li><code>null</code> 和 <code>undefined</code> 也是 TypeScript 中的基本类型。</li><li><code>void</code> 表示函数没有返回值。</li><li><code>never</code> 表示不可能存在的类型，通常用于抛出错误的函数。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-接口（Interfaces）"><a href="#4-接口（Interfaces）" class="headerlink" title="4. 接口（Interfaces）"></a>4. 接口（Interfaces）</h2><p>接口用于定义对象的结构，确保类或对象符合某些规则。</p><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">john</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="可选属性和只读属性"><a href="#可选属性和只读属性" class="headerlink" title="可选属性和只读属性"></a>可选属性和只读属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可选属性</span><br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 只读属性</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-类（Classes）"><a href="#5-类（Classes）" class="headerlink" title="5. 类（Classes）"></a>5. 类（Classes）</h2><p>TypeScript 的类提供了面向对象的特性，比如继承、访问控制修饰符等。</p><h3 id="基本类的定义"><a href="#基本类的定义" class="headerlink" title="基本类的定义"></a>基本类的定义</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> speaks`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承与访问修饰符"><a href="#继承与访问修饰符" class="headerlink" title="继承与访问修饰符"></a>继承与访问修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-函数（Functions）"><a href="#6-函数（Functions）" class="headerlink" title="6. 函数（Functions）"></a>6. 函数（Functions）</h2><h3 id="函数参数类型与返回类型"><a href="#函数参数类型与返回类型" class="headerlink" title="函数参数类型与返回类型"></a>函数参数类型与返回类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Hello&quot;</span></span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">timestamp: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">year: <span class="hljs-built_in">number</span>, month: <span class="hljs-built_in">number</span>, day: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params">yearOrTimestamp: <span class="hljs-built_in">number</span>, month?: <span class="hljs-built_in">number</span>, day?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span> &#123;<br>  <span class="hljs-keyword">if</span> (month !== <span class="hljs-literal">undefined</span> &amp;&amp; day !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(yearOrTimestamp, month - <span class="hljs-number">1</span>, day);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(yearOrTimestamp);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-泛型（Generics）"><a href="#7-泛型（Generics）" class="headerlink" title="7. 泛型（Generics）"></a>7. 泛型（Generics）</h2><p>泛型用于创建复用性更高的代码，适用于类、接口和函数。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> &#125;&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-类型推断与类型兼容性"><a href="#8-类型推断与类型兼容性" class="headerlink" title="8. 类型推断与类型兼容性"></a>8. 类型推断与类型兼容性</h2><p>TypeScript 可以推断变量类型，也支持类型之间的兼容性检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// TypeScript 会自动推断 `str` 为 `string`</span><br></code></pre></td></tr></table></figure><hr><h2 id="9-高级类型"><a href="#9-高级类型" class="headerlink" title="9. 高级类型"></a>9. 高级类型</h2><h3 id="交叉类型和联合类型"><a href="#交叉类型和联合类型" class="headerlink" title="交叉类型和联合类型"></a>交叉类型和联合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fish</span> = &#123; <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Bird</span> = &#123; <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FishOrBird</span> = <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span>;<br></code></pre></td></tr></table></figure><h3 id="映射类型与条件类型"><a href="#映射类型与条件类型" class="headerlink" title="映射类型与条件类型"></a>映射类型与条件类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="10-模块与命名空间"><a href="#10-模块与命名空间" class="headerlink" title="10. 模块与命名空间"></a>10. 模块与命名空间</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>TypeScript 支持模块化，通过 <code>import</code> 和 <code>export</code> 来导入和导出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// math.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Shapes</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> radius: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shapes</span>.<span class="hljs-title class_">Circle</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="11-装饰器（Decorators）"><a href="#11-装饰器（Decorators）" class="headerlink" title="11. 装饰器（Decorators）"></a>11. 装饰器（Decorators）</h2><p>装饰器用于增强类或类成员的行为，常用于依赖注入和日志记录等功能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Log</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;propertyKey&#125;</span> called`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-meta">@Log</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="12-TypeScript-工具与配置"><a href="#12-TypeScript-工具与配置" class="headerlink" title="12. TypeScript 工具与配置"></a>12. TypeScript 工具与配置</h2><h3 id="使用-tsconfig-json-配置项目"><a href="#使用-tsconfig-json-配置项目" class="headerlink" title="使用 tsconfig.json 配置项目"></a>使用 tsconfig.json 配置项目</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="13-TypeScript-实践：最佳实践与代码规范"><a href="#13-TypeScript-实践：最佳实践与代码规范" class="headerlink" title="13. TypeScript 实践：最佳实践与代码规范"></a>13. TypeScript 实践：最佳实践与代码规范</h2><ul><li><strong>使用严格模式</strong>：启用 <code>strict</code> 以确保代码的类型安全。</li><li><strong>避免使用 <code>any</code> 类型</strong>：<code>any</code> 会削弱类型检查，尽量使用具体类型。</li><li><strong>保持函数纯粹</strong>：在编写函数时，避免不必要的副作用。</li><li><strong>定义清晰的接口</strong>：使用接口来定义数据结构，使代码更具可读性。</li></ul><hr><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>TypeScript 是一门非常强大且实用的语言。通过掌握 TypeScript，您可以编写更加高效、健壮的 JavaScript 代码，并大幅提高团队开发效率。希望本文能为您全面了解 TypeScript 提供帮助！</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocos-Creator中SpriteFrame和Texture的区别</title>
    <link href="/posts/32972/"/>
    <url>/posts/32972/</url>
    
    <content type="html"><![CDATA[<h2 id="Cocos-Creator-中-SpriteFrame-和-Texture-的区别及其在-UI-开发中的重要性"><a href="#Cocos-Creator-中-SpriteFrame-和-Texture-的区别及其在-UI-开发中的重要性" class="headerlink" title="Cocos Creator 中 SpriteFrame 和 Texture 的区别及其在 UI 开发中的重要性"></a>Cocos Creator 中 SpriteFrame 和 Texture 的区别及其在 UI 开发中的重要性</h2><p>在 Cocos Creator 的开发过程中，理解 <code>SpriteFrame</code> 和 <code>Texture</code> 之间的区别是至关重要的，特别是在 UI 开发中。本文将详细讨论这两者的定义、特性及其在实际开发中的应用，尤其是 <code>SpriteFrame</code> 在性能和资源管理方面的优势。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>Texture</strong>：<code>Texture</code> 是 GPU 渲染所使用的基本图像数据，包含了颜色信息和其他绘制相关的数据。开发者通常直接与纹理打交道，并需要手动管理内存，包括加载和卸载纹理。</p><p><strong>SpriteFrame</strong>：<code>SpriteFrame</code> 是 Cocos Creator 中对 <code>Texture</code> 的一种封装，包含了对 <code>Texture</code> 的引用以及一些额外的信息（如锚点、变换等）。<code>SpriteFrame</code> 更加适合用于 <code>Sprite</code> 组件，因为它在使用时提供了更多的灵活性。</p><h3 id="2-渲染流程"><a href="#2-渲染流程" class="headerlink" title="2. 渲染流程"></a>2. 渲染流程</h3><p>理解 Cocos Creator 中的渲染流程有助于更好地使用 <code>SpriteFrame</code> 和 <code>Texture</code>。一般来说，渲染流程如下：</p><ol><li><strong>加载资源</strong>：当加载 <code>SpriteFrame</code> 时，Cocos Creator 会自动处理纹理的加载。如果使用 <code>Texture</code>，开发者需要手动加载和释放纹理。</li><li><strong>渲染准备</strong>：<code>SpriteFrame</code> 包含的纹理会被添加到渲染队列中，Cocos Creator 会根据需要自动调整纹理的状态。</li><li><strong>渲染</strong>：渲染引擎将使用 <code>SpriteFrame</code> 中的纹理进行绘制，绘制时会考虑锚点、缩放等属性。</li><li><strong>资源管理</strong>：当 <code>SpriteFrame</code> 不再使用时，Cocos Creator 会自动卸载不再需要的纹理，避免内存泄漏。而使用 <code>Texture</code> 时，开发者必须手动卸载纹理。</li></ol><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h3><h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><ul><li>使用 <code>Texture</code> 时，开发者需要手动管理纹理的加载和卸载，这可能会导致内存浪费和潜在的内存泄漏。</li><li>使用 <code>SpriteFrame</code> 时，Cocos Creator 会自动处理纹理的生命周期，开发者不需要担心手动释放资源。</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li><strong>合批渲染</strong>：当使用 <code>SpriteFrame</code> 并且多个 <code>Sprite</code> 共享同一张图集时，可以实现合批渲染（Batching）。合批渲染允许 Cocos Creator 在单个绘制调用中渲染多个精灵，显著提高渲染性能。由于减少了 CPU 与 GPU 之间的交互次数，这种方式能够显著提升渲染效率，从而降低绘制调用的开销。</li><li><strong>自动管理</strong>：Cocos Creator 在使用 <code>SpriteFrame</code> 时，会自动处理纹理的加载和卸载，从而优化内存使用和渲染性能。相比之下，直接使用 <code>Texture</code> 可能需要手动管理纹理，这容易导致性能下降。</li></ul><h3 id="4-UI-开发中的应用"><a href="#4-UI-开发中的应用" class="headerlink" title="4. UI 开发中的应用"></a>4. UI 开发中的应用</h3><p>在 UI 开发中，通常使用 <code>SpriteFrame</code>，原因如下：</p><ul><li><strong>便捷性</strong>：<code>SpriteFrame</code> 提供了额外的属性和方法，方便开发者进行 UI 相关的操作，如设置锚点和调整图像的显示。</li><li><strong>性能</strong>：<code>SpriteFrame</code> 在渲染时会更高效，因为 Cocos Creator 能够在后台自动处理纹理的管理，减少了手动操作带来的复杂性和潜在的错误。此外，合批渲染的优势使得多个 UI 元素在同一帧中被渲染时更加高效。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><h4 id="SpriteFrame-的应用场景："><a href="#SpriteFrame-的应用场景：" class="headerlink" title="SpriteFrame 的应用场景："></a>SpriteFrame 的应用场景：</h4><ul><li><strong>UI 元素</strong>：用于按钮、图标、背景等 UI 元素的渲染，因其便捷性和性能优化。</li><li><strong>动画精灵</strong>：在角色动画中，使用 <code>SpriteFrame</code> 可以方便地处理精灵的切换。</li><li><strong>图集使用</strong>：使用 <code>SpriteFrame</code> 时，可以很方便地使用图集，并实现合批渲染，提升渲染效率。</li></ul><h4 id="Texture-的应用场景："><a href="#Texture-的应用场景：" class="headerlink" title="Texture 的应用场景："></a>Texture 的应用场景：</h4><ul><li><strong>特殊效果</strong>：用于一些特殊的渲染效果或 Shader，需要直接对纹理数据进行操作的场景。</li><li><strong>不频繁更新的纹理</strong>：如果纹理较为静态，不需要频繁更新，也可以考虑直接使用 <code>Texture</code>，以避免额外的封装开销。</li><li><strong>大纹理或视频</strong>：某些大纹理或视频流可能直接需要使用 <code>Texture</code> 来满足性能需求。</li></ul><h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><h4 id="使用-SpriteFrame"><a href="#使用-SpriteFrame" class="headerlink" title="使用 SpriteFrame"></a>使用 SpriteFrame</h4><p>以下是一个使用 <code>SpriteFrame</code> 加载和设置的代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cc.<span class="hljs-title class_">Class</span>(&#123;<br>    <span class="hljs-attr">extends</span>: cc.<span class="hljs-property">Component</span>,<br><br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">spriteFrame</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">SpriteFrame</span>,<br>        &#125;,<br>        <span class="hljs-attr">sprite</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Sprite</span>,<br>        &#125;,<br>    &#125;,<br><br>    <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 加载 SpriteFrame</span><br>        cc.<span class="hljs-property">loader</span>.<span class="hljs-title function_">loadRes</span>(<span class="hljs-string">&quot;path/to/your/image&quot;</span>, cc.<span class="hljs-property">SpriteFrame</span>, <span class="hljs-function">(<span class="hljs-params">err, spriteFrame</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (err) &#123;<br>                cc.<span class="hljs-title function_">error</span>(err);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteFrame</span> = spriteFrame; <span class="hljs-comment">// 保存 SpriteFrame</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sprite</span>.<span class="hljs-property">spriteFrame</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteFrame</span>; <span class="hljs-comment">// 设置为 Sprite 的 SpriteFrame</span><br>        &#125;);<br>    &#125;,<br><br>    <span class="hljs-comment">// onDestroy 方法不再需要手动释放资源</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="使用-Texture"><a href="#使用-Texture" class="headerlink" title="使用 Texture"></a>使用 Texture</h4><p>如果直接使用 <code>Texture</code>，手动管理的示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cc.<span class="hljs-title class_">Class</span>(&#123;<br>    <span class="hljs-attr">extends</span>: cc.<span class="hljs-property">Component</span>,<br><br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">texture</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Texture2D</span>,<br>        &#125;,<br>        <span class="hljs-attr">sprite</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">type</span>: cc.<span class="hljs-property">Sprite</span>,<br>        &#125;,<br>    &#125;,<br><br>    <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 加载 Texture</span><br>        cc.<span class="hljs-property">loader</span>.<span class="hljs-title function_">loadRes</span>(<span class="hljs-string">&quot;path/to/your/image&quot;</span>, cc.<span class="hljs-property">Texture2D</span>, <span class="hljs-function">(<span class="hljs-params">err, texture</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (err) &#123;<br>                cc.<span class="hljs-title function_">error</span>(err);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span> = texture; <span class="hljs-comment">// 保存 Texture</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sprite</span>.<span class="hljs-property">spriteFrame</span> = <span class="hljs-keyword">new</span> cc.<span class="hljs-title class_">SpriteFrame</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>); <span class="hljs-comment">// 将 Texture 转换为 SpriteFrame</span><br>        &#125;);<br>    &#125;,<br><br>    <span class="hljs-title function_">onDestroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 手动卸载纹理</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span>.<span class="hljs-title function_">destroy</span>();<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">texture</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 防止悬空引用</span><br>        &#125;<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h3><p>综上所述，<code>SpriteFrame</code> 和 <code>Texture</code> 是 Cocos Creator 中非常重要的概念。对于 UI 开发来说，优先选择使用 <code>SpriteFrame</code>，可以更好地管理资源，提高开发效率，并优化性能。理解这两者的区别将有助于开发者在实际项目中作出更明智的选择。在实际开发中，考虑合批渲染和资源管理的便利性，可以使项目更加高效和稳定。通过合批渲染，多个 UI 元素能够在同一绘制调用中被渲染，极大提高了渲染性能。</p><p>希望这次的修改能满足您的需求！如果还有其他问题或需要进一步的调整，请随时告诉我。</p>]]></content>
    
    
    <categories>
      
      <category>Cocos Creator</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos Creator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十、NodeJs mongoDB详解</title>
    <link href="/posts/59814/"/>
    <url>/posts/59814/</url>
    
    <content type="html"><![CDATA[<h1 id="十、NodeJs-mongoDB®详解"><a href="#十、NodeJs-mongoDB®详解" class="headerlink" title="十、NodeJs mongoDB®详解"></a>十、NodeJs mongoDB®详解</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>MongoDB 是一个面向文档的 NoSQL 数据库，以高性能、高可用性和自动扩展著称。它使用 BSON（一种类似 JSON 的二进制格式）存储数据，使得数据结构更加灵活。MongoDB 不使用关系型数据库的表结构，而是使用集合（Collection）和文档（Document），通过键值对存储数据，适用于大数据和实时数据处理等需求。</p><p>官方地址 <a href="https://www.mongodb.com/">https://www.mongodb.com/</a></p><p>MongoDB 设计的特点：</p><ul><li><strong>文档存储</strong>：数据以文档（Document）形式存储，灵活且易于扩展。</li><li><strong>Schema-less</strong>：允许文档结构随需求调整，方便处理非结构化和半结构化数据。</li><li><strong>分布式架构</strong>：支持自动分片（Sharding）和高可用性，适合扩展到大量节点。</li><li><strong>强大查询语言</strong>：支持聚合、筛选、排序、投影等多样查询方式。</li></ul><h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><ul><li><p><strong>数据库 (Database)</strong><br>MongoDB 的数据库相当于关系型数据库中的数据库，里面包含多个集合（表）。每个 MongoDB 实例可以创建多个数据库，每个数据库有独立的权限控制。</p></li><li><p><strong>集合 (Collection)</strong><br>集合类似于关系数据库中的表，但不强制要求文档的 Schema 相同，因此可以在同一集合中存储不同结构的文档。集合在数据库中，使用时需指定数据库。</p></li><li><p><strong>文档 (Document)</strong><br>文档是 MongoDB 中的基本数据单元，相当于关系数据库中的一行记录。每个文档是一个 BSON 格式的对象，结构类似于 JSON。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;001&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skills&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Python&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;JavaScript&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>_id</code> 字段是每个文档的唯一标识，如果不指定，MongoDB 会自动生成。</p></li><li><p><strong>字段 (Field)</strong><br>字段是文档中的键值对，类似于关系数据库中的列。一个文档可以包含多个字段，并且字段类型可以不同，例如字符串、数值、数组、嵌套文档等。</p></li><li><p><strong>索引 (Index)</strong><br>MongoDB 支持为集合创建索引，常见的是单字段索引、复合索引和文本索引等。索引提高查询速度，但会占用额外空间。</p></li><li><p><strong>副本集 (Replica Set)</strong><br>MongoDB 中的一组节点，负责数据的冗余备份。副本集中包含一个主节点和多个从节点，主节点负责写操作，从节点同步数据，确保高可用性。</p></li><li><p><strong>分片 (Sharding)</strong><br>MongoDB 的水平分片策略，将数据分散到不同的分片中，使系统具备良好的扩展性。</p></li></ul><p><img src="/posts/59814/915718a948758c68.png"></p><h1 id="三、下载安装与启动"><a href="#三、下载安装与启动" class="headerlink" title="三、下载安装与启动"></a>三、下载安装与启动</h1><h2 id="1-Windows-系统"><a href="#1-Windows-系统" class="headerlink" title="1. Windows 系统"></a>1. Windows 系统</h2><h3 id="1-1-下载-MongoDB"><a href="#1-1-下载-MongoDB" class="headerlink" title="1.1 下载 MongoDB"></a>1.1 下载 MongoDB</h3><ol><li>前往 <a href="https://www.mongodb.com/try/download/community">MongoDB 官方下载页面</a>。</li><li>选择 <strong>Windows</strong> 操作系统和 <strong>版本</strong>（一般选择最新稳定版）。</li><li>下载 <code>.msi</code> 安装包。</li></ol><h3 id="1-2-安装-MongoDB"><a href="#1-2-安装-MongoDB" class="headerlink" title="1.2 安装 MongoDB"></a>1.2 安装 MongoDB</h3><ol><li>双击下载的 <code>.msi</code> 文件启动安装。</li><li>选择 <strong>Complete（完全安装）</strong>。</li><li>勾选 <strong>Install MongoDB as a Service</strong>，以便 MongoDB 随系统启动。</li><li>继续安装，完成后 MongoDB 将安装在 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;</code>。</li></ol><h3 id="1-3-配置-MongoDB"><a href="#1-3-配置-MongoDB" class="headerlink" title="1.3 配置 MongoDB"></a>1.3 配置 MongoDB</h3><ol><li><p>打开 <strong>命令提示符</strong>，输入以下命令来创建 MongoDB 数据目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">md C:\data\db<br></code></pre></td></tr></table></figure><p>如果需要更改路径，可以在配置文件中设置。</p></li><li><p>将 MongoDB 可执行文件添加到系统路径，进入系统环境变量配置并添加 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;\bin</code> 到 <code>PATH</code>。</p></li><li><p>在命令提示符中输入以下命令启动 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongod<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="2-macOS-系统"><a href="#2-macOS-系统" class="headerlink" title="2. macOS 系统"></a>2. macOS 系统</h2><h3 id="2-1-使用-Homebrew-安装-MongoDB"><a href="#2-1-使用-Homebrew-安装-MongoDB" class="headerlink" title="2.1 使用 Homebrew 安装 MongoDB"></a>2.1 使用 Homebrew 安装 MongoDB</h3><ol><li><p>打开 <strong>终端</strong>，更新 Homebrew：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew update<br></code></pre></td></tr></table></figure></li><li><p>安装 MongoDB 社区版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew tap mongodb/brew<br>brew install mongodb-community@6.0<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-启动-MongoDB"><a href="#2-2-启动-MongoDB" class="headerlink" title="2.2 启动 MongoDB"></a>2.2 启动 MongoDB</h3><ol><li><p>使用以下命令启动 MongoDB 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew services start mongodb/brew/mongodb-community<br></code></pre></td></tr></table></figure></li><li><p>要停止服务，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew services stop mongodb/brew/mongodb-community<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="3-Linux-系统（以-Ubuntu-为例）"><a href="#3-Linux-系统（以-Ubuntu-为例）" class="headerlink" title="3. Linux 系统（以 Ubuntu 为例）"></a>3. Linux 系统（以 Ubuntu 为例）</h3><h4 id="3-1-添加-MongoDB-源"><a href="#3-1-添加-MongoDB-源" class="headerlink" title="3.1 添加 MongoDB 源"></a>3.1 添加 MongoDB 源</h4><ol><li><p>导入 MongoDB 公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -<br></code></pre></td></tr></table></figure></li><li><p>添加 MongoDB 源到系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/6.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list<br></code></pre></td></tr></table></figure></li><li><p>更新系统包索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-2-安装-MongoDB"><a href="#3-2-安装-MongoDB" class="headerlink" title="3.2 安装 MongoDB"></a>3.2 安装 MongoDB</h4><p>安装 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install -y mongodb-org<br></code></pre></td></tr></table></figure><h4 id="3-3-启动-MongoDB-服务"><a href="#3-3-启动-MongoDB-服务" class="headerlink" title="3.3 启动 MongoDB 服务"></a>3.3 启动 MongoDB 服务</h4><ol><li><p>启动 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start mongod<br></code></pre></td></tr></table></figure></li><li><p>设置 MongoDB 开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable mongod<br></code></pre></td></tr></table></figure></li><li><p>检查 MongoDB 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status mongod<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-验证-MongoDB-安装"><a href="#4-验证-MongoDB-安装" class="headerlink" title="4. 验证 MongoDB 安装"></a>4. 验证 MongoDB 安装</h3><p>无论在哪个系统上安装 MongoDB，可以通过以下命令来连接 MongoDB 服务器，验证安装是否成功：</p><ol><li><p>启动 <strong>MongoDB Shell</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongo<br></code></pre></td></tr></table></figure></li><li><p>连接成功后，MongoDB Shell 会显示一个提示符，输入以下命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">show dbs<br></code></pre></td></tr></table></figure><p>如果列出可用数据库，则说明 MongoDB 已正确安装。</p></li></ol><hr><h3 id="5-基本配置文件"><a href="#5-基本配置文件" class="headerlink" title="5. 基本配置文件"></a>5. 基本配置文件</h3><p>可以在 <code>/etc/mongod.conf</code>（Linux）或 <code>C:\Program Files\MongoDB\Server\&lt;version&gt;\bin\mongod.cfg</code>（Windows）中修改 MongoDB 的配置文件。以下是一个简单配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># mongod.conf</span><br><br><span class="hljs-comment"># 数据存储位置</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">dbPath:</span> <span class="hljs-string">/var/lib/mongodb</span><br><br><span class="hljs-comment"># 日志文件</span><br><span class="hljs-attr">systemLog:</span><br>  <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/mongodb/mongod.log</span><br>  <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 绑定地址</span><br><span class="hljs-attr">net:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br>  <span class="hljs-attr">bindIp:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>配置完成后，可以重启 MongoDB 以应用新配置。</p><h1 id="四、基本操作命令"><a href="#四、基本操作命令" class="headerlink" title="四、基本操作命令"></a>四、基本操作命令</h1><h2 id="1-数据库操作命令"><a href="#1-数据库操作命令" class="headerlink" title="1.数据库操作命令"></a>1.数据库操作命令</h2><h3 id="1-1-显示所有数据库"><a href="#1-1-显示所有数据库" class="headerlink" title="1.1 显示所有数据库"></a>1.1 显示所有数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show dbs<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：列出当前 MongoDB 实例中的所有数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show dbs<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-切换-创建数据库"><a href="#1-2-切换-创建数据库" class="headerlink" title="1.2 切换&#x2F;创建数据库"></a>1.2 切换&#x2F;创建数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use &lt;database_name&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：切换到指定数据库，如果该数据库不存在则创建一个新数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use myDatabase<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-删除数据库"><a href="#1-3-删除数据库" class="headerlink" title="1.3 删除数据库"></a>1.3 删除数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropDatabase</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：删除当前使用的数据库。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">use myDatabase<br>db.<span class="hljs-title function_">dropDatabase</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="2-集合操作命令"><a href="#2-集合操作命令" class="headerlink" title="2.集合操作命令"></a>2.集合操作命令</h2><h3 id="2-1-显示集合"><a href="#2-1-显示集合" class="headerlink" title="2.1 显示集合"></a>2.1 显示集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show collections<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：列出当前数据库中的所有集合。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show collections<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-创建集合"><a href="#2-2-创建集合" class="headerlink" title="2.2 创建集合"></a>2.2 创建集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createCollection</span>(name, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>name</code>：集合名称。</li><li><code>options</code>：可选参数，如 <code>capped</code>（是否固定大小）、<code>size</code>（指定集合大小）等。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createCollection</span>(<span class="hljs-string">&quot;logs&quot;</span>, &#123; <span class="hljs-attr">capped</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">5242880</span> &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-删除集合"><a href="#2-3-删除集合" class="headerlink" title="2.3 删除集合"></a>2.3 删除集合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">drop</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：删除指定集合。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">logs</span>.<span class="hljs-title function_">drop</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-文档操作命令"><a href="#3-文档操作命令" class="headerlink" title="3.文档操作命令"></a>3.文档操作命令</h2><h3 id="3-1-插入文档"><a href="#3-1-插入文档" class="headerlink" title="3.1 插入文档"></a>3.1 插入文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">insertOne</span>(<span class="hljs-variable language_">document</span>)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">insertMany</span>(documents)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>document</code>：插入的单个文档。</li><li><code>documents</code>：插入的多个文档组成的数组。</li></ul></li><li><p>示例</p><p>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertMany</span>([&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> &#125;])<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-查找文档"><a href="#3-2-查找文档" class="headerlink" title="3.2 查找文档"></a>3.2 查找文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">find</span>(query, projection)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>query</code>：可选参数，筛选条件。</li><li><code>projection</code>：可选参数，指定返回的字段（1 表示返回，0 表示不返回）。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gte</span>: <span class="hljs-number">25</span> &#125; &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">0</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><p>查询所有信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">pretty</span>()<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-更新文档"><a href="#3-3-更新文档" class="headerlink" title="3.3 更新文档"></a>3.3 更新文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateOne</span>(filter, update, options)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateMany</span>(filter, update, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>filter</code>：指定更新的文档筛选条件。</li><li><code>update</code>：更新操作。</li><li><code>options</code>：可选参数，<code>upsert</code> 表示是否在不存在时插入新文档。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125; &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">updateMany</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">30</span> &#125; &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-删除文档"><a href="#3-4-删除文档" class="headerlink" title="3.4 删除文档"></a>3.4 删除文档</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">deleteOne</span>(filter)<br>db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">deleteMany</span>(filter)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>filter</code>：指定删除的文档条件。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;)<br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">deleteMany</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">30</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-查询操作符"><a href="#4-查询操作符" class="headerlink" title="4.查询操作符"></a>4.查询操作符</h2><h3 id="4-1-比较操作符"><a href="#4-1-比较操作符" class="headerlink" title="4.1 比较操作符"></a>4.1 比较操作符</h3><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>$eq</code></td><td>等于</td></tr><tr><td><code>$ne</code></td><td>不等于</td></tr><tr><td><code>$gt</code></td><td>大于</td></tr><tr><td><code>$gte</code></td><td>大于等于</td></tr><tr><td><code>$lt</code></td><td>小于</td></tr><tr><td><code>$lte</code></td><td>小于等于</td></tr></tbody></table><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gte</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">$lte</span>: <span class="hljs-number">35</span> &#125; &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-逻辑操作符"><a href="#4-2-逻辑操作符" class="headerlink" title="4.2 逻辑操作符"></a>4.2 逻辑操作符</h3><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>$and</code></td><td>逻辑与</td></tr><tr><td><code>$or</code></td><td>逻辑或</td></tr><tr><td><code>$not</code></td><td>逻辑非</td></tr></tbody></table><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">$or</span>: [&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$lt</span>: <span class="hljs-number">20</span> &#125; &#125;, &#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">30</span> &#125; &#125;] &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="索引操作命令"><a href="#索引操作命令" class="headerlink" title="索引操作命令"></a>索引操作命令</h2><h3 id="5-1-创建索引"><a href="#5-1-创建索引" class="headerlink" title="5.1 创建索引"></a>5.1 创建索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">createIndex</span>(&#123; <span class="hljs-attr">field</span>: <span class="hljs-number">1</span> &#125;, options)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>field</code>：要索引的字段和排序（1 为升序，-1 为降序）。</li><li><code>options</code>：可选参数，如 <code>unique</code> 是否唯一索引。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">createIndex</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-查看索引"><a href="#5-2-查看索引" class="headerlink" title="5.2 查看索引"></a>5.2 查看索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">getIndexes</span>()<br></code></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：查看当前集合中的所有索引。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">getIndexes</span>()<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="6-聚合操作命令"><a href="#6-聚合操作命令" class="headerlink" title="6.聚合操作命令"></a>6.聚合操作命令</h2><h3 id="6-1-聚合查询"><a href="#6-1-聚合查询" class="headerlink" title="6.1 聚合查询"></a>6.1 聚合查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">aggregate</span>(pipeline)<br></code></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><code>pipeline</code>：包含多个聚合阶段的数组。</li></ul></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">orders</span>.<span class="hljs-title function_">aggregate</span>([<br>    &#123; <span class="hljs-attr">$match</span>: &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;shipped&quot;</span> &#125; &#125;,<br>    &#123; <span class="hljs-attr">$group</span>: &#123; <span class="hljs-attr">_id</span>: <span class="hljs-string">&quot;$customer&quot;</span>, <span class="hljs-attr">total</span>: &#123; <span class="hljs-attr">$sum</span>: <span class="hljs-string">&quot;$amount&quot;</span> &#125; &#125; &#125;,<br>    &#123; <span class="hljs-attr">$sort</span>: &#123; <span class="hljs-attr">total</span>: -<span class="hljs-number">1</span> &#125; &#125;<br>])<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-用户和权限管理命令"><a href="#7-用户和权限管理命令" class="headerlink" title="7.用户和权限管理命令"></a>7.用户和权限管理命令</h2><h3 id="7-1-创建用户"><a href="#7-1-创建用户" class="headerlink" title="7.1 创建用户"></a>7.1 创建用户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createUser</span>(&#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>    <span class="hljs-attr">pwd</span>: <span class="hljs-string">&quot;password&quot;</span>,<br>    <span class="hljs-attr">roles</span>: [&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;role_name&quot;</span>, <span class="hljs-attr">db</span>: <span class="hljs-string">&quot;database_name&quot;</span> &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">createUser</span>(&#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-attr">pwd</span>: <span class="hljs-string">&quot;password123&quot;</span>,<br>    <span class="hljs-attr">roles</span>: [&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;readWrite&quot;</span>, <span class="hljs-attr">db</span>: <span class="hljs-string">&quot;myDatabase&quot;</span> &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-2-删除用户"><a href="#7-2-删除用户" class="headerlink" title="7.2 删除用户"></a>7.2 删除用户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropUser</span>(<span class="hljs-string">&quot;username&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-title function_">dropUser</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="8-备份和恢复命令"><a href="#8-备份和恢复命令" class="headerlink" title="8.备份和恢复命令"></a>8.备份和恢复命令</h2><h3 id="8-1-备份数据库"><a href="#8-1-备份数据库" class="headerlink" title="8.1 备份数据库"></a>8.1 备份数据库</h3><p>在命令行使用 <code>mongodump</code> 命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mongodump --db myDatabase --out /backup/path<br></code></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将 <code>myDatabase</code> 数据库导出到指定路径。</li></ul><h3 id="8-2-恢复数据库"><a href="#8-2-恢复数据库" class="headerlink" title="8.2 恢复数据库"></a>8.2 恢复数据库</h3><p>在命令行使用 <code>mongorestore</code> 命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mongorestore --db myDatabase /backup/path/myDatabase<br></code></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将备份的数据库文件恢复到 MongoDB。</li></ul><h2 id="9-总结所有的操作符"><a href="#9-总结所有的操作符" class="headerlink" title="9.总结所有的操作符"></a>9.总结所有的操作符</h2><table><thead><tr><th>操作符</th><th>分类</th><th>说明</th></tr></thead><tbody><tr><td><strong>$set</strong></td><td>更新操作</td><td>将字段设置为指定的值。如果字段不存在，则创建该字段。</td></tr><tr><td><strong>$unset</strong></td><td>更新操作</td><td>删除指定的字段。</td></tr><tr><td><strong>$inc</strong></td><td>更新操作</td><td>将字段的值增加指定的数值（支持正数或负数）。</td></tr><tr><td><strong>$mul</strong></td><td>更新操作</td><td>将字段的值乘以指定的数值。</td></tr><tr><td><strong>$rename</strong></td><td>更新操作</td><td>重命名字段。</td></tr><tr><td><strong>$min</strong></td><td>更新操作</td><td>如果指定的值小于当前字段值，则将字段更新为指定的值。</td></tr><tr><td><strong>$max</strong></td><td>更新操作</td><td>如果指定的值大于当前字段值，则将字段更新为指定的值。</td></tr><tr><td><strong>$currentDate</strong></td><td>更新操作</td><td>将字段更新为当前日期。支持 Date 或 Timestamp 类型。</td></tr><tr><td><strong>$addToSet</strong></td><td>数组操作</td><td>如果值不在数组中，则添加到数组中（类似于去重的功能）。</td></tr><tr><td><strong>$pop</strong></td><td>数组操作</td><td>从数组中移除第一个或最后一个元素。</td></tr><tr><td><strong>$pull</strong></td><td>数组操作</td><td>从数组中删除所有匹配的元素。</td></tr><tr><td><strong>$push</strong></td><td>数组操作</td><td>将一个或多个值添加到数组的末尾。</td></tr><tr><td><strong>$each</strong></td><td>数组操作</td><td>与 <code>$push</code> 结合使用，用于一次插入多个值。</td></tr><tr><td><strong>$slice</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，限制数组的最大长度。</td></tr><tr><td><strong>$sort</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，对数组中的元素进行排序。</td></tr><tr><td><strong>$position</strong></td><td>数组操作</td><td>与 <code>$push</code> 和 <code>$each</code> 结合使用，指定元素插入数组的位置。</td></tr><tr><td><strong>$pullAll</strong></td><td>数组操作</td><td>从数组中删除与指定值完全匹配的所有元素。</td></tr><tr><td><strong>$elemMatch</strong></td><td>查询操作</td><td>用于查询数组中符合指定条件的元素。</td></tr><tr><td><strong>$in</strong></td><td>查询操作</td><td>匹配字段的值在给定数组中的文档。</td></tr><tr><td><strong>$nin</strong></td><td>查询操作</td><td>匹配字段的值不在给定数组中的文档。</td></tr><tr><td><strong>$and</strong></td><td>逻辑操作</td><td>满足所有条件的文档。</td></tr><tr><td><strong>$or</strong></td><td>逻辑操作</td><td>满足至少一个条件的文档。</td></tr><tr><td><strong>$not</strong></td><td>逻辑操作</td><td>否定表达式，用于匹配与指定条件不符的文档。</td></tr><tr><td><strong>$nor</strong></td><td>逻辑操作</td><td>不满足任意一个条件的文档。</td></tr><tr><td><strong>$gt</strong></td><td>比较操作</td><td>匹配字段的值大于指定值的文档。</td></tr><tr><td><strong>$gte</strong></td><td>比较操作</td><td>匹配字段的值大于或等于指定值的文档。</td></tr><tr><td><strong>$lt</strong></td><td>比较操作</td><td>匹配字段的值小于指定值的文档。</td></tr><tr><td><strong>$lte</strong></td><td>比较操作</td><td>匹配字段的值小于或等于指定值的文档。</td></tr><tr><td><strong>$eq</strong></td><td>比较操作</td><td>匹配字段的值等于指定值的文档。</td></tr><tr><td><strong>$ne</strong></td><td>比较操作</td><td>匹配字段的值不等于指定值的文档。</td></tr><tr><td><strong>$exists</strong></td><td>查询操作</td><td>匹配包含或不包含指定字段的文档。</td></tr><tr><td><strong>$type</strong></td><td>查询操作</td><td>匹配指定字段类型的文档。</td></tr><tr><td><strong>$size</strong></td><td>查询操作</td><td>匹配数组长度等于指定值的文档。</td></tr><tr><td><strong>$regex</strong></td><td>查询操作</td><td>使用正则表达式匹配字段值。</td></tr><tr><td><strong>$text</strong></td><td>查询操作</td><td>进行全文索引查询。</td></tr><tr><td><strong>$where</strong></td><td>查询操作</td><td>使用 JavaScript 表达式匹配文档。</td></tr><tr><td><strong>$geoWithin</strong></td><td>地理位置查询</td><td>匹配位于指定地理形状内的点。</td></tr><tr><td><strong>$geoIntersects</strong></td><td>地理位置查询</td><td>匹配与指定的地理形状相交的点。</td></tr><tr><td><strong>$near</strong></td><td>地理位置查询</td><td>查找距离某点附近的点。</td></tr><tr><td><strong>$nearSphere</strong></td><td>地理位置查询</td><td>查找球体距离某点附近的点。</td></tr><tr><td><strong>$mod</strong></td><td>查询操作</td><td>匹配字段的值是指定除数的余数的文档。</td></tr></tbody></table><p>这些操作符在 MongoDB 中具有不同的用途，可以组合使用来实现复杂的查询和更新操作。例如，通过结合 <code>$set</code>、<code>$push</code> 和 <code>$pull</code> 可以在一个操作中更新多个字段并同时操作数组内容。这种灵活性使得 MongoDB 非常适用于文档更新和复杂查询的场景。</p><h1 id="五、-MongoDB-的锁机制"><a href="#五、-MongoDB-的锁机制" class="headerlink" title="五、 MongoDB 的锁机制"></a>五、 MongoDB 的锁机制</h1><h2 id="1-MongoDB-的锁机制"><a href="#1-MongoDB-的锁机制" class="headerlink" title="1.MongoDB 的锁机制"></a>1.MongoDB 的锁机制</h2><p>在分布式数据库中，数据一致性与并发控制是两个重要的问题。MongoDB 作为一个广泛使用的 NoSQL 数据库，提供了一些机制来确保数据的原子性和一致性。</p><h3 id="1-1-文档级锁"><a href="#1-1-文档级锁" class="headerlink" title="1.1 文档级锁"></a>1.1 文档级锁</h3><p>MongoDB 使用文档级锁（Document-Level Locking）来管理对数据的并发访问。这意味着在对单个文档进行操作时，MongoDB 会为该文档加锁，而允许其他文档同时被访问。这种机制显著提高了并发性能，特别是在高并发场景下。</p><ul><li><strong>原子性</strong>：MongoDB 中对单个文档的操作是原子性的。也就是说，对于同一文档的更新操作，要么完全成功，要么完全失败，不会出现部分更新的情况。</li></ul><h3 id="1-2-多文档操作的非原子性"><a href="#1-2-多文档操作的非原子性" class="headerlink" title="1.2 多文档操作的非原子性"></a>1.2 多文档操作的非原子性</h3><p>尽管单文档操作是原子性的，但当执行多文档操作（例如 <code>updateMany</code>）时，整体操作并不是原子性的。每个文档的修改是原子性的，但多个文档的操作整体上可能会由于某些文档更新失败而导致状态不一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">collection</span>.<span class="hljs-title function_">updateMany</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;pending&#x27;</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;complete&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，如果有一个文档在更新时因其他进程修改而失败，那么剩余的文档仍然会被更新，导致状态不一致。</p><h2 id="2-事务支持"><a href="#2-事务支持" class="headerlink" title="2. 事务支持"></a>2. 事务支持</h2><p>MongoDB 4.0 及以上版本支持多文档事务，这样可以确保多个操作作为一个整体要么完全成功，要么完全失败。事务的使用可以避免因部分操作成功而导致的数据不一致问题。</p><h3 id="2-1-事务的原理"><a href="#2-1-事务的原理" class="headerlink" title="2.1 事务的原理"></a>2.1 事务的原理</h3><p>在使用事务时，MongoDB 会在开始事务时锁定相应的文档，确保在事务未提交前，其他操作不能对这些文档进行修改。只有在成功提交事务后，修改才会生效。</p><h3 id="2-2-使用示例"><a href="#2-2-使用示例" class="headerlink" title="2.2 使用示例"></a>2.2 使用示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> session = client.<span class="hljs-title function_">startSession</span>();<br><br>session.<span class="hljs-title function_">startTransaction</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> collection1.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125; &#125;, &#123; session &#125;);<br>    <span class="hljs-keyword">await</span> collection2.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">_id</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125; &#125;, &#123; session &#125;);<br>    <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">commitTransaction</span>();<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">abortTransaction</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Transaction aborted due to error:&#x27;</span>, error);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    session.<span class="hljs-title function_">endSession</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果 <code>collection1</code> 或 <code>collection2</code> 的更新失败，事务将被中止，并且任何已经进行的更改都会被撤销。</p><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h2><p>在某些情况下，使用乐观锁可以有效解决并发修改的问题。乐观锁的思路是在更新时验证文档的版本号或修改时间戳，确保在更新时文档没有被其他进程修改。</p><h3 id="3-1-实现乐观锁的示例"><a href="#3-1-实现乐观锁的示例" class="headerlink" title="3.1 实现乐观锁的示例"></a>3.1 实现乐观锁的示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> collection.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">_id</span>: documentId &#125;);<br><span class="hljs-keyword">if</span> (result.<span class="hljs-property">version</span> === currentVersion) &#123;<br>    <span class="hljs-keyword">await</span> collection.<span class="hljs-title function_">updateOne</span>(<br>        &#123; <span class="hljs-attr">_id</span>: documentId &#125;,<br>        &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">field</span>: newValue, <span class="hljs-attr">version</span>: currentVersion + <span class="hljs-number">1</span> &#125; &#125;<br>    );<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Document was modified by another process&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，只有在文档的版本号与当前版本一致时才进行更新，这样可以避免数据覆盖的问题。</p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>MongoDB 的锁机制和事务支持为开发者提供了强大的工具来处理并发数据操作的问题。了解这些机制不仅有助于提高应用程序的性能，还能确保数据的一致性。在高并发环境下，合理使用事务和乐观锁可以有效避免数据冲突和不一致问题。</p><p>对于开发者而言，掌握这些知识是构建健壮且可靠的 MongoDB 应用程序的重要基础。</p><h1 id="六、Mongoose"><a href="#六、Mongoose" class="headerlink" title="六、Mongoose"></a>六、Mongoose</h1><h2 id="1-Mongoose-简介"><a href="#1-Mongoose-简介" class="headerlink" title="1. Mongoose 简介"></a>1. Mongoose 简介</h2><p>Mongoose 是 MongoDB 官方推荐的 Node.js ODM 库，它允许我们通过 JavaScript 定义 MongoDB 数据的 Schema，提供了数据验证、模型管理和数据操作功能。</p><hr><h2 id="2-安装-Mongoose"><a href="#2-安装-Mongoose" class="headerlink" title="2. 安装 Mongoose"></a>2. 安装 Mongoose</h2><p>在 Node.js 项目中，可以使用 npm 或 yarn 安装 Mongoose：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install mongoose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br>yarn add mongoose<br></code></pre></td></tr></table></figure><hr><h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3. 连接数据库"></a>3. 连接数据库</h2><p>使用 <code>mongoose.connect</code> 方法连接 MongoDB 数据库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/mydatabase&#x27;</span>, &#123;<br>  <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span>,<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接成功&#x27;</span>))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;连接失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>uri</code></td><td>String</td><td>数据库 URI，例如 <code>mongodb://localhost:27017/dbname</code></td></tr><tr><td><code>options</code></td><td>Object</td><td>连接配置项，<code>useNewUrlParser</code> 和 <code>useUnifiedTopology</code> 为常见项</td></tr><tr><td><code>useNewUrlParser</code></td><td>Boolean</td><td>使用新的 URL 解析器，避免警告</td></tr><tr><td><code>useUnifiedTopology</code></td><td>Boolean</td><td>启用新的 MongoDB 驱动引擎</td></tr></tbody></table><hr><h2 id="4-定义-Schema-和-Model"><a href="#4-定义-Schema-和-Model" class="headerlink" title="4. 定义 Schema 和 Model"></a>4. 定义 Schema 和 Model</h2><p><strong>Schema 常用类型</strong></p><p><strong>Mongoose 支持多种数据类型。常见类型如下</strong>：</p><table><thead><tr><th>类型</th><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>required</code></td><td>是否必填</td><td><code>required: true</code></td></tr><tr><td></td><td><code>minlength</code></td><td>最小长度</td><td><code>minlength: 2</code></td></tr><tr><td></td><td><code>maxlength</code></td><td>最大长度</td><td><code>maxlength: 100</code></td></tr><tr><td></td><td><code>trim</code></td><td>去掉两侧空格</td><td><code>trim: true</code></td></tr><tr><td></td><td><code>uppercase</code></td><td>转换为大写</td><td><code>uppercase: true</code></td></tr><tr><td></td><td><code>lowercase</code></td><td>转换为小写</td><td><code>lowercase: true</code></td></tr><tr><td></td><td><code>enum</code></td><td>允许的枚举值</td><td><code>enum: [&#39;ADMIN&#39;, &#39;USER&#39;, &#39;GUEST&#39;]</code></td></tr><tr><td><code>Number</code></td><td><code>min</code></td><td>最小值</td><td><code>min: 0</code></td></tr><tr><td></td><td><code>max</code></td><td>最大值</td><td><code>max: 120</code></td></tr><tr><td></td><td><code>default</code></td><td>默认值</td><td><code>default: 18</code></td></tr><tr><td><code>Date</code></td><td><code>default</code></td><td>默认日期（可用 <code>Date.now</code>）</td><td><code>default: Date.now</code></td></tr><tr><td><code>Boolean</code></td><td><code>default</code></td><td>布尔型默认值</td><td><code>default: true</code></td></tr><tr><td><code>Buffer</code></td><td></td><td>用于存储二进制数据</td><td></td></tr><tr><td><code>Mixed</code></td><td><code>default</code></td><td>可以存储任意数据</td><td><code>default: &#123; role: &#39;user&#39; &#125;</code></td></tr><tr><td><code>ObjectId</code></td><td><code>ref</code></td><td>关联到另一集合</td><td><code>ref: &#39;User&#39;</code></td></tr><tr><td><code>Array</code></td><td><code>default</code></td><td>数组的默认值</td><td><code>default: []</code></td></tr><tr><td><code>Map</code></td><td><code>of</code></td><td>指定 Map 值的类型</td><td><code>of: String</code></td></tr><tr><td>嵌套对象</td><td></td><td>定义嵌套对象结构</td><td><code>&#123; street: String, city: String &#125;</code></td></tr></tbody></table><p><strong>定义 Schema 示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-comment">// 字符串类型示例</span><br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minlength</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">maxlength</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">trim</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 移除字符串两侧空格</span><br>    <span class="hljs-attr">uppercase</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 将字符串转换为大写</span><br>    <span class="hljs-attr">lowercase</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 保持小写</span><br>    <span class="hljs-attr">enum</span>: [<span class="hljs-string">&#x27;ADMIN&#x27;</span>, <span class="hljs-string">&#x27;USER&#x27;</span>, <span class="hljs-string">&#x27;GUEST&#x27;</span>],  <span class="hljs-comment">// 枚举限定值</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 数值类型示例</span><br>  <span class="hljs-attr">age</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>: <span class="hljs-number">120</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">18</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 日期类型示例</span><br>  <span class="hljs-attr">birthdate</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>,  <span class="hljs-comment">// 默认当前时间</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 布尔类型示例</span><br>  <span class="hljs-attr">isActive</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 二进制数据类型示例</span><br>  <span class="hljs-attr">profilePicture</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Buffer</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 混合类型示例，允许任意类型数据</span><br>  <span class="hljs-attr">metadata</span>: &#123;<br>    <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">Mixed</span>,<br>    <span class="hljs-attr">default</span>: &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span> &#125;,<br>  &#125;,<br><br>  <span class="hljs-comment">// ObjectId 类型示例</span><br>  <span class="hljs-attr">parentUser</span>: &#123;<br>    <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,<br>    <span class="hljs-attr">ref</span>: <span class="hljs-string">&#x27;User&#x27;</span>,  <span class="hljs-comment">// 关联另一个集合</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 数组类型示例</span><br>  <span class="hljs-attr">hobbies</span>: &#123;<br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>],  <span class="hljs-comment">// 字符串数组</span><br>    <span class="hljs-attr">default</span>: [],<br>  &#125;,<br><br>  <span class="hljs-comment">// Map 类型示例</span><br>  <span class="hljs-attr">socialLinks</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Map</span>,<br>    <span class="hljs-attr">of</span>: <span class="hljs-title class_">String</span>,  <span class="hljs-comment">// 每个键的值为字符串类型</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 嵌套对象示例</span><br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">street</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    <span class="hljs-attr">city</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span> &#125;,<br>    <span class="hljs-attr">zip</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">match</span>: <span class="hljs-regexp">/^[0-9]&#123;5&#125;$/</span> &#125;,  <span class="hljs-comment">// 正则匹配5位数字</span><br>  &#125;,<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>Model 定义与使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><hr><h2 id="5-CRUD-操作"><a href="#5-CRUD-操作" class="headerlink" title="5. CRUD 操作"></a>5. CRUD 操作</h2><p>Mongoose 提供了一系列方法用于增删改查。以下是常用 CRUD 方法的参数说明和示例：</p><h3 id="1-创建文档-create"><a href="#1-创建文档-create" class="headerlink" title="1.创建文档 - create()"></a>1.创建文档 - <code>create()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建成功:&#x27;</span>, doc))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;创建失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>doc</code></td><td>Object</td><td>要插入的文档</td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><h3 id="2-查询文档-find"><a href="#2-查询文档-find" class="headerlink" title="2.查询文档 - find()"></a>2.查询文档 - <code>find()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">18</span> &#125; &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询结果:&#x27;</span>, users))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;查询失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查询条件，例如 <code>&#123; age: 25 &#125;</code></td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><h3 id="3-更新文档-updateOne"><a href="#3-更新文档-updateOne" class="headerlink" title="3.更新文档 - updateOne()"></a>3.更新文档 - <code>updateOne()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">updateOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;, &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新成功:&#x27;</span>, result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;更新失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查找条件，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code></td></tr><tr><td><code>update</code></td><td>Object</td><td>更新内容，例如 <code>&#123; age: 26 &#125;</code></td></tr><tr><td><code>options</code></td><td>Object</td><td>可选，配置项，<code>upsert</code> 等</td></tr></tbody></table><h3 id="4-删除文档-deleteOne"><a href="#4-删除文档-deleteOne" class="headerlink" title="4.删除文档 - deleteOne()"></a>4.删除文档 - <code>deleteOne()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功:&#x27;</span>, result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;删除失败:&#x27;</span>, err));<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>filter</code></td><td>Object</td><td>查找条件，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code></td></tr><tr><td><code>callback</code></td><td>Function</td><td>可选，回调函数</td></tr></tbody></table><hr><h2 id="6-条件运算符"><a href="#6-条件运算符" class="headerlink" title="6. 条件运算符"></a>6. 条件运算符</h2><p>Mongoose 支持丰富的查询条件运算符，用于复杂的数据查询。常见的条件运算符如下：</p><table><thead><tr><th>条件运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>$eq</code></td><td>等于某个值</td><td><code>&#123; age: &#123; $eq: 18 &#125; &#125;</code></td></tr><tr><td><code>$ne</code></td><td>不等于某个值</td><td><code>&#123; age: &#123; $ne: 18 &#125; &#125;</code></td></tr><tr><td><code>$gt</code></td><td>大于某个值</td><td><code>&#123; age: &#123; $gt: 18 &#125; &#125;</code></td></tr><tr><td><code>$gte</code></td><td>大于等于某个值</td><td><code>&#123; age: &#123; $gte: 18 &#125; &#125;</code></td></tr><tr><td><code>$lt</code></td><td>小于某个值</td><td><code>&#123; age: &#123; $lt: 18 &#125; &#125;</code></td></tr><tr><td><code>$lte</code></td><td>小于等于某个值</td><td><code>&#123; age: &#123; $lte: 18 &#125; &#125;</code></td></tr><tr><td><code>$in</code></td><td>在某个集合中</td><td><code>&#123; age: &#123; $in: [18, 20, 25] &#125; &#125;</code></td></tr><tr><td><code>$nin</code></td><td>不在某个集合中</td><td><code>&#123; age: &#123; $nin: [18, 20, 25] &#125; &#125;</code></td></tr><tr><td><code>$or</code></td><td>满足任一条件</td><td><code>&#123; $or: [&#123; age: 18 &#125;, &#123; name: &#39;John&#39; &#125;] &#125;</code></td></tr><tr><td><code>$and</code></td><td>满足所有条件</td><td><code>&#123; $and: [&#123; age: &#123; $gte: 18 &#125; &#125;, &#123; age: &#123; $lt: 25 &#125; &#125;] &#125;</code></td></tr><tr><td><code>$exists</code></td><td>字段是否存在</td><td><code>&#123; email: &#123; $exists: true &#125; &#125;</code></td></tr><tr><td><code>$regex</code></td><td>匹配正则表达式</td><td><code>&#123; name: &#123; $regex: /^J/i &#125; &#125;</code></td></tr></tbody></table><p><strong>示例：查找年龄大于 18 且爱好包含 “reading” 的用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123;<br>  <span class="hljs-attr">age</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">18</span> &#125;,<br>  <span class="hljs-attr">hobbies</span>: &#123; <span class="hljs-attr">$in</span>: [<span class="hljs-string">&#x27;reading&#x27;</span>] &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(users));<br></code></pre></td></tr></table></figure><hr><h2 id="7-索引和聚合"><a href="#7-索引和聚合" class="headerlink" title="7. 索引和聚合"></a>7. 索引和聚合</h2><h3 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h3><p> Mongoose 支持为字段创建索引以加速查询。常见索引类型有唯一索引、复合索引和文本索引。</p><p><strong>优点</strong>：</p><p><strong>查询性能</strong>：在复杂的查询中使用其他字段（例如用户名、电子邮件等）作为筛选条件，MongoDB 如果没有针对这些字段建立索引，就必须扫描整个集合，导致性能下降。为频繁查询的字段创建索引可以显著提升效率。</p><p><strong>复合查询</strong>：例如，在查询中需要组合多个字段，如按 <code>name</code> 和 <code>age</code> 共同筛选用户，这种情况下可以创建复合索引 <code>&#123; name: 1, age: 1 &#125;</code> 来加速联合查询。</p><p><strong>唯一约束</strong>：业务需求可能要求某些字段具有唯一性（如电子邮件或用户名），可通过 <code>unique</code> 索引来确保。</p><p><strong>排序需求</strong>：如果某字段常用于排序，创建索引能优化排序操作。默认 <code>_id</code> 索引只能对 <code>_id</code> 字段排序，如果我们想按 <code>createdAt</code> 排序，就需要为 <code>createdAt</code> 字段创建索引。</p><p><strong>全文搜索</strong>：MongoDB 提供了文本索引来支持复杂的全文检索，适用于字段内容较长或频繁进行模糊查询的情况。</p><table><thead><tr><th>索引类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>单字段索引</td><td>为单个字段创建索引</td><td><code>&#123; name: 1 &#125;</code></td></tr><tr><td>复合索引</td><td>为多个字段组合创建索引</td><td><code>&#123; name: 1, age: -1 &#125;</code></td></tr><tr><td>唯一索引</td><td>保证字段值的唯一性</td><td><code>&#123; email: &#123; unique: true &#125; &#125;</code></td></tr><tr><td>文本索引</td><td>支持全文搜索</td><td><code>&#123; description: &#39;text&#39; &#125;</code></td></tr><tr><td>稀疏索引</td><td>忽略 <code>null</code> 和缺失的字段</td><td><code>&#123; phone: &#123; sparse: true &#125; &#125;</code></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">email</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;,  <span class="hljs-comment">// 唯一索引</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-title class_">Number</span>,<br>&#125;);<br><br>userSchema.<span class="hljs-title function_">index</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">age</span>: -<span class="hljs-number">1</span> &#125;);  <span class="hljs-comment">// 复合索引</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><h3 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h3><p> Mongoose 提供的聚合框架可以对数据进行复杂的统计分析，常用的聚合管道操作符包括 <code>$match</code>、<code>$group</code>、<code>$sort</code>、<code>$limit</code> 等。</p><table><thead><tr><th>操作符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>$match</code></td><td>筛选符合条件的文档</td><td><code>&#123; age: &#123; $gt: 18 &#125; &#125;</code></td></tr><tr><td><code>$group</code></td><td>分组统计</td><td><code>&#123; _id: &quot;$hobbies&quot;, total: &#123; $sum: 1 &#125; &#125;</code></td></tr><tr><td><code>$sort</code></td><td>排序</td><td><code>&#123; age: -1 &#125;</code></td></tr><tr><td><code>$limit</code></td><td>限制结果数量</td><td><code>5</code></td></tr><tr><td><code>$project</code></td><td>控制输出字段</td><td><code>&#123; name: 1, age: 1 &#125;</code></td></tr></tbody></table><p><strong>示例：按爱好分组并统计每个爱好的人数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">aggregate</span>([<br>  &#123; <span class="hljs-attr">$unwind</span>: <span class="hljs-string">&quot;$hobbies&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">$group</span>: &#123; <span class="hljs-attr">_id</span>: <span class="hljs-string">&quot;$hobbies&quot;</span>, <span class="hljs-attr">count</span>: &#123; <span class="hljs-attr">$sum</span>: <span class="hljs-number">1</span> &#125; &#125; &#125;,<br>  &#123; <span class="hljs-attr">$sort</span>: &#123; <span class="hljs-attr">count</span>: -<span class="hljs-number">1</span> &#125; &#125;,<br>  &#123; <span class="hljs-attr">$limit</span>: <span class="hljs-number">5</span> &#125;<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));<br></code></pre></td></tr></table></figure><hr><h2 id="8-验证和钩子"><a href="#8-验证和钩子" class="headerlink" title="8. 验证和钩子"></a>8. 验证和钩子</h2><h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>Mongoose 提供了内置的字段验证功能，可以通过参数如 <code>required</code>、<code>minlength</code>、<code>maxlength</code>、<code>match</code> 等来实现基础验证，还可以自定义验证。</p><p>以下是一个详细的表格，列出了 Mongoose 中常见的验证类型及其参数说明和示例：</p><table><thead><tr><th>验证类型</th><th>参数</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>必填</strong></td><td><code>required</code></td><td>确保字段必须存在</td><td><code>&#123; required: true &#125;</code></td></tr><tr><td><strong>最小长度</strong></td><td><code>minlength</code></td><td>限制字符串的最小长度</td><td><code>&#123; minlength: 5 &#125;</code></td></tr><tr><td><strong>最大长度</strong></td><td><code>maxlength</code></td><td>限制字符串的最大长度</td><td><code>&#123; maxlength: 100 &#125;</code></td></tr><tr><td><strong>正则匹配</strong></td><td><code>match</code></td><td>字符串必须匹配指定的正则表达式</td><td><code>&#123; match: /^[a-z]+$/ &#125;</code></td></tr><tr><td><strong>数值最小值</strong></td><td><code>min</code></td><td>限制数值的最小值</td><td><code>&#123; min: 18 &#125;</code></td></tr><tr><td><strong>数值最大值</strong></td><td><code>max</code></td><td>限制数值的最大值</td><td><code>&#123; max: 65 &#125;</code></td></tr><tr><td><strong>自定义验证</strong></td><td><code>validate</code></td><td>使用自定义函数验证</td><td><code>&#123; validate: customValidatorFn &#125;</code></td></tr><tr><td><strong>唯一值</strong></td><td><code>unique</code></td><td>确保字段在集合中唯一</td><td><code>&#123; unique: true &#125;</code></td></tr><tr><td><strong>默认值</strong></td><td><code>default</code></td><td>设置字段的默认值</td><td><code>&#123; default: &#39;未设置&#39; &#125;</code></td></tr><tr><td><strong>枚举值</strong></td><td><code>enum</code></td><td>限制字段的值为预定义的一组值</td><td><code>&#123; enum: [&#39;user&#39;, &#39;admin&#39;, &#39;guest&#39;] &#125;</code></td></tr><tr><td><strong>数值类型</strong></td><td><code>type</code></td><td>指定字段的数据类型</td><td><code>&#123; type: Number &#125;</code></td></tr><tr><td><strong>日期类型</strong></td><td><code>type</code></td><td>指定字段为日期类型</td><td><code>&#123; type: Date &#125;</code></td></tr><tr><td><strong>数组类型</strong></td><td><code>type</code></td><td>指定字段为数组类型</td><td><code>&#123; type: [String] &#125;</code></td></tr><tr><td><strong>对象类型</strong></td><td><code>type</code></td><td>指定字段为对象类型</td><td><code>&#123; type: Object &#125;</code></td></tr></tbody></table><p><strong>示例：完整的 Mongoose 模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">username</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">minlength</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">maxlength</span>: <span class="hljs-number">15</span>,<br>    <span class="hljs-attr">validate</span>: &#123;<br>      <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9]&#123;2,14&#125;$/</span>.<span class="hljs-title function_">test</span>(v);<br>      &#125;,<br>      <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;props.value&#125;</span> 不是一个有效的用户名！`</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">email</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">match</span>: <span class="hljs-regexp">/.+\@.+\..+/</span> <br>  &#125;,<br>  <span class="hljs-attr">age</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <br>    <span class="hljs-attr">max</span>: <span class="hljs-number">120</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">18</span> <br>  &#125;,<br>  <span class="hljs-attr">role</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <br>    <span class="hljs-attr">enum</span>: [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;moderator&#x27;</span>], <br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> <br>  &#125;,<br>  <span class="hljs-attr">hobbies</span>: &#123; <br>    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>], <span class="hljs-comment">// 数组类型</span><br>    <span class="hljs-attr">default</span>: [] <br>  &#125;,<br>  <span class="hljs-attr">createdAt</span>: &#123; <br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>, <br>    <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> <br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;testuser&#x27;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>  <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&#x27;reading&#x27;</span>, <span class="hljs-string">&#x27;gaming&#x27;</span>]<br>&#125;);<br><br>user.<span class="hljs-title function_">save</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户保存成功！&#x27;</span>))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;保存用户时出错：&#x27;</span>, err.<span class="hljs-property">errors</span>));<br></code></pre></td></tr></table></figure><p>这个模式使用了各种验证类型来确保用户数据的有效性，展示了如何在 Mongoose 中使用这些验证规则。</p><p><strong>validate参数说明</strong></p><ol><li><strong>validator</strong>:<ul><li><strong>类型</strong>: <code>Function</code></li><li><strong>描述</strong>: 自定义验证函数，接受一个参数 <code>v</code>（要验证的值）。返回 <code>true</code> 表示验证通过，返回 <code>false</code> 表示验证失败。</li></ul></li><li><strong>message</strong>:<ul><li><strong>类型</strong>: <code>String | Function</code></li><li><strong>描述</strong>: 当验证失败时，返回的错误信息。可以使用字符串，也可以使用一个函数，函数接受一个参数 <code>props</code>，其中包含被验证的值（<code>props.value</code>）、字段路径（<code>props.path</code>）、模型实例等信息。</li></ul></li></ol><p><strong>自定义验证的注意事项</strong></p><ul><li>如果在模式中为字段设置了 <code>required: true</code>，则该字段的值必须存在，验证会在保存文档之前进行。</li><li>自定义验证在保存时会触发，如果自定义验证失败，Mongoose 将抛出一个错误，包含所有验证失败的字段信息。</li><li>使用自定义验证时，确保验证逻辑高效，以免在大量数据操作时影响性能。</li></ul><h3 id="2-钩子"><a href="#2-钩子" class="headerlink" title="2.钩子"></a>2.钩子</h3><p>Mongoose 钩子（中间件）支持在文档保存、更新、删除等操作前后执行自定义逻辑。钩子分为两类：<strong>文档中间件</strong> 和 <strong>查询中间件</strong>。</p><p><strong>文档中间件</strong></p><table><thead><tr><th>钩子</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>save</code></td><td>在文档保存之前或之后触发</td><td><code>schema.pre(&#39;save&#39;, fn)</code></td></tr><tr><td><code>remove</code></td><td>在文档删除之前或之后触发</td><td><code>schema.pre(&#39;remove&#39;, fn)</code></td></tr></tbody></table><p><strong>查询中间件</strong></p><table><thead><tr><th>钩子</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>find</code></td><td>在 <code>find</code> 查询前或后触发</td><td><code>schema.pre(&#39;find&#39;, fn)</code></td></tr><tr><td><code>findOne</code></td><td>在 <code>findOne</code> 查询前或后触发</td><td><code>schema.pre(&#39;findOne&#39;, fn)</code></td></tr><tr><td><code>updateOne</code></td><td>在 <code>updateOne</code> 查询前或后触发</td><td><code>schema.pre(&#39;updateOne&#39;, fn)</code></td></tr></tbody></table><p><strong>示例：<code>pre-save</code> 钩子自动记录文档的创建时间</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">userSchema.<span class="hljs-title function_">pre</span>(<span class="hljs-string">&#x27;save&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isNew</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  &#125;<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="9-正则匹配"><a href="#9-正则匹配" class="headerlink" title="9. 正则匹配"></a>9. 正则匹配</h2><p>下面是几种等效的不同写法：</p><h3 id="1-使用-RegExp-构造函数"><a href="#1-使用-RegExp-构造函数" class="headerlink" title="1.使用 RegExp 构造函数"></a>1.使用 <code>RegExp</code> 构造函数</h3><p>使用 JavaScript 的 <code>RegExp</code> 构造函数可以更加动态地传递正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;imissyou&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure><p>如果你需要忽略大小写，可以在正则表达式中添加修饰符，例如 <code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure><h3 id="2-使用-regex-运算符"><a href="#2-使用-regex-运算符" class="headerlink" title="2. 使用 $regex 运算符"></a>2. 使用 <code>$regex</code> 运算符</h3><p>MongoDB 提供了 <code>$regex</code> 运算符用于匹配正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>同样，你可以使用 <code>$options</code> 来指定正则表达式选项，例如忽略大小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-attr">$options</span>: <span class="hljs-string">&#x27;i&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><h3 id="3-使用嵌套的-regex-和-options-选项"><a href="#3-使用嵌套的-regex-和-options-选项" class="headerlink" title="3. 使用嵌套的 $regex 和 $options 选项"></a>3. 使用嵌套的 <code>$regex</code> 和 <code>$options</code> 选项</h3><p>如果你需要多个选项，比如忽略大小写或者多行模式，你可以使用 <code>$options</code> 来同时启用多个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">$regex</span>: <span class="hljs-string">&#x27;imissyou&#x27;</span>, <span class="hljs-attr">$options</span>: <span class="hljs-string">&#x27;im&#x27;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-动态生成正则表达式"><a href="#4-动态生成正则表达式" class="headerlink" title="4. 动态生成正则表达式"></a>4. 动态生成正则表达式</h3><p>如果正则表达式是动态生成的，可以结合 JavaScript 变量来创建查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pattern = <span class="hljs-string">&#x27;imissyou&#x27;</span>;<br><span class="hljs-keyword">let</span> caseInsensitive = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果需要忽略大小写</span><br><br><span class="hljs-keyword">let</span> query = &#123; <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(pattern, caseInsensitive ? <span class="hljs-string">&#x27;i&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>) &#125;;<br>db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(query);<br></code></pre></td></tr></table></figure><h3 id="5-查询匹配前缀、后缀或包含"><a href="#5-查询匹配前缀、后缀或包含" class="headerlink" title="5. 查询匹配前缀、后缀或包含"></a>5. 查询匹配前缀、后缀或包含</h3><p>使用正则表达式匹配字符串的开头、结尾或中间部分：</p><ul><li><strong>匹配以 <code>imissyou</code> 开头：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^imissyou/</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>匹配以 <code>imissyou</code> 结尾：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/imissyou$/</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>匹配包含 <code>imissyou</code> 且忽略大小写：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">db.<span class="hljs-property">students</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-regexp">/imissyou/i</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="10-个性化读取"><a href="#10-个性化读取" class="headerlink" title="10. 个性化读取"></a>10. 个性化读取</h2><h3 id="1-字段筛选"><a href="#1-字段筛选" class="headerlink" title="1. 字段筛选"></a>1. 字段筛选</h3><p><strong>只读取部分数据，0:不要的字段，1:要的字段</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//0:不要的字段</span><br><span class="hljs-comment">//1:要的字段</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">select</span>(&#123;<span class="hljs-attr">_id</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">title</span>:<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-数据排序"><a href="#2-数据排序" class="headerlink" title="2. 数据排序"></a>2. 数据排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//sort 排序</span><br><span class="hljs-comment">//1:升序</span><br><span class="hljs-comment">//-1:倒序</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">sort</span>(&#123;<span class="hljs-attr">hot</span>:<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-数据截取"><a href="#3-数据截取" class="headerlink" title="3. 数据截取"></a>3. 数据截取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//skip 跳过 limit 限定</span><br><span class="hljs-title class_">SongModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">skip</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">limit</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="七、图形化管理工具"><a href="#七、图形化管理工具" class="headerlink" title="七、图形化管理工具"></a>七、图形化管理工具</h1><p>我们可以使用图形化的管理工具来对Mongodb进行交互，这里演示两个图形化工具</p><ul><li><strong>Robo 3T 免费 <a href="https://github.com/Studio3T/robomongo/releases">https://github.com/Studio3T/robomongo/releases</a></strong></li><li><strong>Navicat 收费 <a href="https://www.navicat.com.cn/">https://www.navicat.com.cn/</a></strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九、NodeJs express框架</title>
    <link href="/posts/21819/"/>
    <url>/posts/21819/</url>
    
    <content type="html"><![CDATA[<h1 id="九、NodeJs-express框架"><a href="#九、NodeJs-express框架" class="headerlink" title="九、NodeJs express框架"></a>九、NodeJs express框架</h1><h1 id="一、express介绍"><a href="#一、express介绍" class="headerlink" title="一、express介绍"></a>一、express介绍</h1><p><strong>express 是一个基于 Node.js 平台的极简、灵活的WEB应用开发框架，官方网址：<a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></strong></p><p>简单来说，express是一个封装好的工具包，封装了很多功能，便于我们开发WEB应用（HTTP服务）</p><h1 id="二、express使用"><a href="#二、express使用" class="headerlink" title="二、express使用"></a>二、express使用</h1><h2 id="2-1-express-下载"><a href="#2-1-express-下载" class="headerlink" title="2.1 express 下载"></a>2.1 express 下载</h2><p>express 本身是一个npm包，所以可以通过npm安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br>npm i express<br></code></pre></td></tr></table></figure><h2 id="2-2-express-初体验"><a href="#2-2-express-初体验" class="headerlink" title="2.2 express 初体验"></a>2.2 express 初体验</h2><p>大家可以按照这个步骤进行操作：</p><h3 id="1．创建JS文件，键入如下代码"><a href="#1．创建JS文件，键入如下代码" class="headerlink" title="1．创建JS文件，键入如下代码"></a>1．创建JS文件，键入如下代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//2. 创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//3. 创建路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello express server&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//4. 监听端口 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2．命令行下执行该脚本"><a href="#2．命令行下执行该脚本" class="headerlink" title="2．命令行下执行该脚本"></a>2．命令行下执行该脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">node &lt;文件名&gt;<br><span class="hljs-comment"># 或者</span><br>nodemon &lt;文件名&gt;<br></code></pre></td></tr></table></figure><h1 id="三、express-路由"><a href="#三、express-路由" class="headerlink" title="三、express 路由"></a>三、express 路由</h1><h2 id="3-1-什么是路由"><a href="#3-1-什么是路由" class="headerlink" title="3.1 什么是路由"></a>3.1 什么是路由</h2><p>官方定义：<strong>路由确定了应用程序如何响应客户端对特定端点的请求</strong></p><h2 id="3-2-路由的使用"><a href="#3-2-路由的使用" class="headerlink" title="3.2 路由的使用"></a>3.2 路由的使用</h2><p>一个路由的组成有请求方法，路径和 回调函数组成</p><p>express中提供了一系列方法，可以很方便的使用路由，使用格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.&lt;method&gt;(path，callback)<br></code></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//创建 get 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;网站首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//首页路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我才是真正的首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//创建 post 路由</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//匹配所有的请求方法</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;1 秒钟为您找到相关结果约 100,000,000 个&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//自定义 404 路由</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//监听端口 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-3-获取请求参数"><a href="#3-3-获取请求参数" class="headerlink" title="3.3 获取请求参数"></a>3.3 获取请求参数</h2><p>express 框架封装了一些API来方便获取请求报文中的数据，并且兼容原生HTTP模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//获取请求的路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//1. 获取报文的方式与原生 HTTP 获取方式是兼容的</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">method</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">httpVersion</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>);<br>    <span class="hljs-comment">//2. express 独有的获取报文的方式</span><br>    <span class="hljs-comment">//获取查询字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>); <span class="hljs-comment">// 『相对重要』</span><br>    <span class="hljs-comment">// 获取指定的请求头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;host&#x27;</span>));<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求报文的获取&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;启动成功....&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-4-获取路由参数"><a href="#3-4-获取路由参数" class="headerlink" title="3.4 获取路由参数"></a>3.4 获取路由参数</h2><p>路由参数指的是URL 路径中的参数（数据）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品详情, 商品 id 为&#x27;</span> + req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="四、express响应设置"><a href="#四、express响应设置" class="headerlink" title="四、express响应设置"></a>四、express响应设置</h1><p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取请求的路由规则</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/response&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//1. express 中设置响应的方式兼容 HTTP 模块的方式</span><br>    res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>    res.<span class="hljs-property">statusMessage</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>);<br>    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;响应体&#x27;</span>);<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br>    <span class="hljs-comment">//2. express 的响应方法</span><br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>); <span class="hljs-comment">//设置响应状态码</span><br>    res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-string">&#x27;yyy&#x27;</span>);<span class="hljs-comment">//设置响应头</span><br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;中文响应不乱码&#x27;</span>);<span class="hljs-comment">//设置响应体</span><br>    <span class="hljs-comment">//连贯操作</span><br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-string">&#x27;yyy&#x27;</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;你好朋友&#x27;</span>)<br>    <span class="hljs-comment">//3. 其他响应</span><br>    res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;http://atguigu.com&#x27;</span>)<span class="hljs-comment">//重定向</span><br>    res.<span class="hljs-title function_">download</span>(<span class="hljs-string">&#x27;./package.json&#x27;</span>);<span class="hljs-comment">//下载响应</span><br>    res.<span class="hljs-title function_">json</span>();<span class="hljs-comment">//响应 JSON</span><br>    res.<span class="hljs-title function_">sendFile</span>(__dirname + <span class="hljs-string">&#x27;/home.html&#x27;</span>) <span class="hljs-comment">//响应文件内容</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="五、express-中间件"><a href="#五、express-中间件" class="headerlink" title="五、express 中间件"></a>五、express 中间件</h1><h2 id="5-1-什么是中间件"><a href="#5-1-什么是中间件" class="headerlink" title="5.1 什么是中间件"></a>5.1 什么是中间件</h2><p><strong>中间件（Middleware）本质是一个回调函数</strong></p><p><strong>中间件函数 可以像路由回调一样访问 请求对象（request），响应对象（response）</strong></p><h2 id="5-2-中间件的作用"><a href="#5-2-中间件的作用" class="headerlink" title="5.2 中间件的作用"></a>5.2 中间件的作用</h2><p>中间件的作用就是使用函数封装公共操作，简化代码</p><h2 id="5-3-中间件的类型"><a href="#5-3-中间件的类型" class="headerlink" title="5.3 中间件的类型"></a>5.3 中间件的类型</h2><ul><li><p>全局中间件</p></li><li><p>路由中间件</p></li></ul><h3 id="5-3-1-定义全局中间件"><a href="#5-3-1-定义全局中间件" class="headerlink" title="5.3.1 定义全局中间件"></a>5.3.1 定义全局中间件</h3><p>每一个请求到达服务端之后 都会执行全局中间件函数</p><p>声明中间件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> recordMiddleware = <span class="hljs-keyword">function</span>(<span class="hljs-params">request,response,next</span>)&#123;<br>    <span class="hljs-comment">//实现功能代码</span><br>    <span class="hljs-comment">//.....</span><br>    <span class="hljs-comment">//执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next)</span><br>    <span class="hljs-title function_">next</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts/21819/3c76d3f4ddfdb7f6.png"></p><p><strong>应用中间件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(recordMiddleware);<br></code></pre></td></tr></table></figure><p>声明时可以直接将匿名函数传递给 use</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第一个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-3-2-多个全局中间件"><a href="#5-3-2-多个全局中间件" class="headerlink" title="5.3.2 多个全局中间件"></a>5.3.2 多个全局中间件</h3><p>express 允许使用 app.use() 定义多个全局中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第一个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;定义第二个中间件&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="5-3-3-定义路由中间件"><a href="#5-3-3-定义路由中间件" class="headerlink" title="5.3.3 定义路由中间件"></a>5.3.3 定义路由中间件</h3><p>如果只需要对某一些路由进行功能封装，则就需要路由中间件</p><p>调用格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/路径&#x27;</span>,<span class="hljs-string">`中间件函数`</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    <br>&#125;);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/路径&#x27;</span>,<span class="hljs-string">`中间件函数1`</span>,<span class="hljs-string">`中间件函数2`</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    <br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="5-4-静态资源中间件"><a href="#5-4-静态资源中间件" class="headerlink" title="5.4 静态资源中间件"></a>5.4 静态资源中间件</h2><p>express 内置处理静态资源的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入express框架</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public&#x27;</span>)); <span class="hljs-comment">//当然这个目录中都是一些静态资源</span><br><span class="hljs-comment">//如果访问的内容经常变化，还是需要设置路由</span><br><span class="hljs-comment">//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，</span><br><span class="hljs-comment">//则谁书写在前，优先执行谁</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    respsonse.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>index．html文件为默认打开的资源</li><li>如果静态资源与路由规则同时匹配，谁先匹配谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ol><h2 id="5-5-获取请求体数据-body-parser"><a href="#5-5-获取请求体数据-body-parser" class="headerlink" title="5.5 获取请求体数据 body-parser"></a>5.5 获取请求体数据 body-parser</h2><p>express 可以使用 body-parser 包处理请求体</p><p><strong>第一步：安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i body-parser<br></code></pre></td></tr></table></figure><p><strong>第二步：导入body-parser包</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>第三步：获取中间件函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//处理 querystring 格式的请求体</span><br><span class="hljs-keyword">let</span> urlParser = bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123;<span class="hljs-attr">extended</span>:<span class="hljs-literal">false</span>&#125;));<br><span class="hljs-comment">//处理 JSON 格式的请求体</span><br><span class="hljs-keyword">let</span> jsonParser = bodyParser.<span class="hljs-title function_">json</span>();<br></code></pre></td></tr></table></figure><p><strong>第四步：设置路由中间件，然后使用 request.body 来获取请求体数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, urlParser, <span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//获取请求体数据</span><br><span class="hljs-comment">//console.log(request.body);</span><br><span class="hljs-comment">//用户名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">body</span>.<span class="hljs-property">username</span>);<br><span class="hljs-comment">//密码</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">body</span>.<span class="hljs-property">userpass</span>);<br>response.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;获取请求体数据&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>获取到的请求体数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Object: null prototype] &#123; username: <span class="hljs-string">&#x27;admin&#x27;</span>, userpass: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="六、-Router"><a href="#六、-Router" class="headerlink" title="六、 Router"></a>六、 Router</h1><h2 id="6-1-什么是-Router"><a href="#6-1-什么是-Router" class="headerlink" title="6.1 什么是 Router"></a>6.1 什么是 Router</h2><p>express 中的Router是一个完整的中间件和路由系统，可以看做是一个小型的app对象。</p><h2 id="6-2-Router作用"><a href="#6-2-Router作用" class="headerlink" title="6.2 Router作用"></a>6.2 Router作用</h2><p>对路由进行模块化，更好的管理路由</p><h2 id="6-3-Router使用"><a href="#6-3-Router使用" class="headerlink" title="6.3 Router使用"></a>6.3 Router使用</h2><p>创建独立的 JS 文件（homeRouter.js）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//2. 创建路由器对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-comment">//3. 在 router 对象身上添加路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;)<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/cart&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;购物车&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//4. 暴露</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>主文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//5.引入子路由文件</span><br><span class="hljs-keyword">const</span> homeRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/homeRouter&#x27;</span>);<br><span class="hljs-comment">//6.设置和使用中间件</span><br>app.<span class="hljs-title function_">use</span>(homeRouter);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><h1 id="七、EJS模板引擎"><a href="#七、EJS模板引擎" class="headerlink" title="七、EJS模板引擎"></a>七、EJS模板引擎</h1><p>EJS（Embedded JavaScript）是一个轻量级的模板引擎，它允许我们在 HTML 中嵌入 JavaScript 代码。通过 EJS，我们可以在服务器端渲染动态内容，生成 HTML 文件。EJS 的语法非常简单直观，适合用于 Express.js 等基于 Node.js 的 Web 框架。</p><h2 id="7-1-EJS-的安装与使用"><a href="#7-1-EJS-的安装与使用" class="headerlink" title="7.1 EJS 的安装与使用"></a>7.1 EJS 的安装与使用</h2><h3 id="7-1-1-安装-EJS"><a href="#7-1-1-安装-EJS" class="headerlink" title="7.1.1 安装 EJS"></a>7.1.1 安装 EJS</h3><p>EJS 是一个 npm 包，可以通过 npm 进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install ejs<br></code></pre></td></tr></table></figure><h3 id="7-1-2-在-Express-中使用-EJS"><a href="#7-1-2-在-Express-中使用-EJS" class="headerlink" title="7.1.2 在 Express 中使用 EJS"></a>7.1.2 在 Express 中使用 EJS</h3><p>我们可以通过如下步骤将 EJS 集成到 Express 项目中：</p><ol><li><strong>引入 EJS</strong>：在项目中设置视图引擎为 EJS。</li><li><strong>创建视图文件</strong>：编写 <code>.ejs</code> 模板文件。</li><li><strong>渲染视图</strong>：通过路由函数返回渲染后的 HTML。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 设置视图引擎为 EJS</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br><span class="hljs-comment">// 路由渲染视图</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hello EJS&#x27;</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码中，<code>res.render</code> 方法会去 <code>views</code> 文件夹中寻找 <code>index.ejs</code> 文件，并将 <code>title</code> 和 <code>user</code> 变量传递给模板进行渲染。</p><h2 id="7-2-EJS-基本语法"><a href="#7-2-EJS-基本语法" class="headerlink" title="7.2 EJS 基本语法"></a>7.2 EJS 基本语法</h2><h3 id="7-2-1-输出变量"><a href="#7-2-1-输出变量" class="headerlink" title="7.2.1 输出变量"></a>7.2.1 输出变量</h3><p>EJS 中最常用的功能就是在 HTML 文件中输出变量。通过 <code>&lt;%= %&gt;</code> 来输出变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;<br>&lt;p&gt;Welcome, &lt;%= user %&gt;!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>假设传递的数据为 <code>&#123; title: &#39;Hello EJS&#39;, user: &#39;John Doe&#39; &#125;</code>，那么渲染后的 HTML 结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello EJS<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome, John Doe!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-执行-JavaScript-代码"><a href="#7-2-2-执行-JavaScript-代码" class="headerlink" title="7.2.2 执行 JavaScript 代码"></a>7.2.2 执行 JavaScript 代码</h3><p>在 EJS 模板中，可以通过 <code>&lt;% %&gt;</code> 语法执行 JavaScript 代码，但不会输出结果。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;ul&gt;<br>    &lt;% for(let i = 0; i &lt; 3; i++) &#123; %&gt;<br>        &lt;li&gt;Item &lt;%= i + 1 %&gt;&lt;/li&gt;<br>    &lt;% &#125; %&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>渲染后的结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-3-条件语句"><a href="#7-2-3-条件语句" class="headerlink" title="7.2.3 条件语句"></a>7.2.3 条件语句</h3><p>可以在 EJS 中编写 if、else 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;% if (user === &#x27;John Doe&#x27;) &#123; %&gt;<br>    &lt;p&gt;Hello, John Doe!&lt;/p&gt;<br>&lt;% &#125; else &#123; %&gt;<br>    &lt;p&gt;Hello, guest!&lt;/p&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><h3 id="7-2-4-转义-HTML"><a href="#7-2-4-转义-HTML" class="headerlink" title="7.2.4 转义 HTML"></a>7.2.4 转义 HTML</h3><p>在输出变量时，如果使用 <code>&lt;%- %&gt;</code>，EJS 会对内容进行 HTML 转义。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- &quot;&lt;div&gt;Hello World&lt;/div&gt;&quot; %&gt;<br></code></pre></td></tr></table></figure><p>渲染后直接显示 <code>&lt;div&gt;Hello World&lt;/div&gt;</code> 作为 HTML 标签，而不是输出标签字符串。</p><h3 id="7-2-5-注释"><a href="#7-2-5-注释" class="headerlink" title="7.2.5 注释"></a>7.2.5 注释</h3><p>EJS 支持在模板中添加注释，使用 <code>&lt;%# %&gt;</code> 进行注释，注释不会显示在渲染后的 HTML 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%# This is a comment %&gt;<br></code></pre></td></tr></table></figure><h2 id="7-3-EJS-高级用法"><a href="#7-3-EJS-高级用法" class="headerlink" title="7.3 EJS 高级用法"></a>7.3 EJS 高级用法</h2><h3 id="7-3-1-模板继承"><a href="#7-3-1-模板继承" class="headerlink" title="7.3.1 模板继承"></a>7.3.1 模板继承</h3><p>EJS 支持通过 <code>include</code> 来引入其他模板文件。通过这种方式，我们可以复用公共部分的模板，如头部和尾部：</p><p><strong>头部模板 (header.ejs)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header Section<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>尾部模板 (footer.ejs)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Footer Section<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>主模板 (index.ejs)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- include(&#x27;header&#x27;) %&gt;<br><br>&lt;p&gt;Content of the page goes here.&lt;/p&gt;<br><br>&lt;%- include(&#x27;footer&#x27;) %&gt;<br></code></pre></td></tr></table></figure><p>EJS 会把 <code>header.ejs</code> 和 <code>footer.ejs</code> 中的内容包含进主模板中，最终渲染的页面结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header Section<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content of the page goes here.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Footer Section<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-2-传递参数给-include"><a href="#7-3-2-传递参数给-include" class="headerlink" title="7.3.2 传递参数给 include"></a>7.3.2 传递参数给 include</h3><p>我们可以给 <code>include</code> 的模板传递参数，例如传递不同的数据给包含的模板：</p><p><strong>navbar.ejs</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;nav&gt;<br>    &lt;ul&gt;<br>        &lt;% for(let link of links) &#123; %&gt;<br>            &lt;li&gt;&lt;a href=&quot;&lt;%= link.href %&gt;&quot;&gt;&lt;%= link.text %&gt;&lt;/a&gt;&lt;/li&gt;<br>        &lt;% &#125; %&gt;<br>    &lt;/ul&gt;<br>&lt;/nav&gt;<br></code></pre></td></tr></table></figure><p><strong>主模板</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- include(&#x27;navbar&#x27;, &#123; links: [&#123;href: &#x27;/home&#x27;, text: &#x27;Home&#x27;&#125;, &#123;href: &#x27;/about&#x27;, text: &#x27;About&#x27;&#125;] &#125;) %&gt;<br><br>&lt;p&gt;Main content goes here&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Main content goes here<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-3-循环输出动态内容"><a href="#7-3-3-循环输出动态内容" class="headerlink" title="7.3.3 循环输出动态内容"></a>7.3.3 循环输出动态内容</h3><p>EJS 支持在模板中循环输出动态内容，这在处理列表数据时非常有用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;ul&gt;<br>    &lt;% items.forEach(function(item) &#123; %&gt;<br>        &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;<br>    &lt;% &#125;); %&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>假设传递的 <code>items</code> 为 <code>[&#39;Apple&#39;, &#39;Banana&#39;, &#39;Orange&#39;]</code>，最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Apple<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Banana<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Orange<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-3-4-表单处理"><a href="#7-3-4-表单处理" class="headerlink" title="7.3.4 表单处理"></a>7.3.4 表单处理</h3><p>EJS 中可以嵌入表单，并且处理表单提交的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/submit&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>Username:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在服务器端处理表单提交：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/submit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; username, password &#125; = req.<span class="hljs-property">body</span>;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`Username: <span class="hljs-subst">$&#123;username&#125;</span>, Password: <span class="hljs-subst">$&#123;password&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-4-EJS-与其他模板引擎对比"><a href="#7-4-EJS-与其他模板引擎对比" class="headerlink" title="7.4 EJS 与其他模板引擎对比"></a>7.4 EJS 与其他模板引擎对比</h2><h3 id="7-4-1-与-Pug-的对比"><a href="#7-4-1-与-Pug-的对比" class="headerlink" title="7.4.1 与 Pug 的对比"></a>7.4.1 与 Pug 的对比</h3><p>Pug 是另一个流行的模板引擎，它通过缩进来组织 HTML 结构，代码简洁，但语法相对复杂，而 EJS 更贴近 HTML 的写法，容易上手。</p><h3 id="7-4-2-与-Handlebars-的对比"><a href="#7-4-2-与-Handlebars-的对比" class="headerlink" title="7.4.2 与 Handlebars 的对比"></a>7.4.2 与 Handlebars 的对比</h3><p>Handlebars 使用双花括号 <code>&#123;&#123;&#125;&#125;</code> 来嵌入数据，支持逻辑较少，主打简单与纯粹，EJS 则支持更多的 JavaScript 逻辑，功能更强大。</p><h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><p>EJS 是一个简洁、强大且易于使用的模板引擎，适用于 Node.js 中的服务器端渲染。通过灵活使用 EJS 的语法和功能，可以快速开发出高效的 Web 应用。</p><p><strong>常见优点：</strong></p><ul><li>语法简单易懂，接近原生 HTML。</li><li>支持嵌入任意 JavaScript 代码。</li><li>可以与 Express 等框架无缝结合。</li></ul><p><strong>使用场景：</strong></p><ul><li>动态网页生成。</li><li>服务器端渲染。</li><li>基于模板的前后端交互。</li></ul><p>通过对 EJS 的理解和灵活使用，我们可以更加高效地构建 Web 应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八、NodeJs 模块系统</title>
    <link href="/posts/56695/"/>
    <url>/posts/56695/</url>
    
    <content type="html"><![CDATA[<h1 id="八、NodeJs-模块系统"><a href="#八、NodeJs-模块系统" class="headerlink" title="八、NodeJs 模块系统"></a>八、NodeJs 模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展。</p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>在 Node.js 中，引入一个模块非常简单，如下我们创建一个 <strong>main.js</strong> 文件并引入 hello 模块，代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>);<br>hello.<span class="hljs-title function_">world</span>();<br></code></pre></td></tr></table></figure><p>以上实例中，代码 require(‘.&#x2F;hello’) 引入了当前目录下的 hello.js 文件（.&#x2F; 为当前目录，node.js 默认后缀为 js）。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p><p>接下来我们就来创建 hello.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">world</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘.&#x2F;hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p><p>有时候我们只是想把一个对象封装到模块中，格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//hello.js </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">var</span> name; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thyName</span>) &#123; <br>        name = thyName; <br>    &#125;; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name); <br>    &#125;; <br>&#125;; <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Hello</span>;<br></code></pre></td></tr></table></figure><p>这样就可以直接获得这个对象了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>); <br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>(); <br>hello.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;BYVoid&#x27;</span>); <br>hello.<span class="hljs-title function_">sayHello</span>(); <br></code></pre></td></tr></table></figure><p>模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.world &#x3D; function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p><hr><h2 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><br>...<br><br>http.<span class="hljs-title function_">createServer</span>(...);<br></code></pre></td></tr></table></figure><p>Node.js 中自带了一个叫做 <strong>http</strong> 的模块，在我们的代码中请求它并把返回值赋给一个本地变量。</p><p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p><p>Node.js 的 require 方法中的文件查找策略如下：</p><p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p><p><img src="/posts/56695/nodejs-require.jpg"></p><h3 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h3><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p><h3 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载"></a>从原生模块加载</h3><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http&#x2F;http.js&#x2F;http.node&#x2F;http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p><p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p><h3 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h3><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p><p>require方法接受以下几种参数的传递：</p><ul><li>http、fs、path等，原生模块。</li><li>.&#x2F;mod或..&#x2F;mod，相对路径的文件模块。</li><li>&#x2F;pathtomodule&#x2F;mod，绝对路径的文件模块。</li><li>mod，非原生模块的文件模块。</li></ul><p>在路径 Y 下执行 require(X) 语句执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果 X 是内置模块<br>   a. 返回内置模块<br>   b. 停止执行<br>2. 如果 X 以 <span class="hljs-string">&#x27;/&#x27;</span> 开头<br>   a. 设置 Y 为文件根路径<br>3. 如果 X 以 <span class="hljs-string">&#x27;./&#x27;</span> 或 <span class="hljs-string">&#x27;/&#x27;</span> or <span class="hljs-string">&#x27;../&#x27;</span> 开头<br>   a. LOAD_AS_FILE(Y + X)<br>   b. LOAD_AS_DIRECTORY(Y + X)<br>4. LOAD_NODE_MODULES(X, <span class="hljs-built_in">dirname</span>(Y))<br>5. 抛出异常 <span class="hljs-string">&quot;not found&quot;</span><br><br>LOAD_AS_FILE(X)<br>1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。<br>3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。<br>4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。<br><br>LOAD_INDEX(X)<br>1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。<br>2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。<br>3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。<br><br>LOAD_AS_DIRECTORY(X)<br>1. 如果 X/package.json 是一个文件,<br>   a. 解析 X/package.json, 并查找 <span class="hljs-string">&quot;main&quot;</span> 字段。<br>   b. <span class="hljs-built_in">let</span> M = X + (json main 字段)<br>   c. LOAD_AS_FILE(M)<br>   d. LOAD_INDEX(M)<br>2. LOAD_INDEX(X)<br><br>LOAD_NODE_MODULES(X, START)<br>1. <span class="hljs-built_in">let</span> DIRS=NODE_MODULES_PATHS(START)<br>2. <span class="hljs-keyword">for</span> each DIR <span class="hljs-keyword">in</span> DIRS:<br>   a. LOAD_AS_FILE(DIR/X)<br>   b. LOAD_AS_DIRECTORY(DIR/X)<br><br>NODE_MODULES_PATHS(START)<br>1. <span class="hljs-built_in">let</span> PARTS = path <span class="hljs-built_in">split</span>(START)<br>2. <span class="hljs-built_in">let</span> I = count of PARTS - 1<br>3. <span class="hljs-built_in">let</span> DIRS = []<br>4. <span class="hljs-keyword">while</span> I &gt;= 0,<br>   a. <span class="hljs-keyword">if</span> PARTS[I] = <span class="hljs-string">&quot;node_modules&quot;</span> CONTINUE<br>   b. DIR = path <span class="hljs-built_in">join</span>(PARTS[0 .. I] + <span class="hljs-string">&quot;node_modules&quot;</span>)<br>   c. DIRS = DIRS + DIR<br>   d. <span class="hljs-built_in">let</span> I = I - 1<br>5. <span class="hljs-built_in">return</span> DIRS<br></code></pre></td></tr></table></figure><blockquote><p><strong>exports 和 module.exports 的使用</strong></p><p>如果要对外暴露属性或方法，就用 <strong>exports</strong> 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 <strong>module.exports</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七、NodeJs HTTP协议</title>
    <link href="/posts/5656/"/>
    <url>/posts/5656/</url>
    
    <content type="html"><![CDATA[<h1 id="七、NodeJs-HTTP协议"><a href="#七、NodeJs-HTTP协议" class="headerlink" title="七、NodeJs HTTP协议"></a>七、NodeJs HTTP协议</h1><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>HTTP（hypertext transport protocol）协议；中文叫超文本传输协议</p><p>是一种基于TCP&#x2F;IP的应用层通信协议</p><p>这个协议详细规定了 浏览器 和万维网 服务器 之间互相通信的规则。</p><p>协议中主要规定了两个方面的内容</p><ul><li><p>客户端:用来向服务器发送数据，可以被称之为请求报文</p></li><li><p>服务端:向客户端返回数据，可以被称之为响应报文</p></li></ul><p>报文:可以简单理解为就是一堆字符串</p><h1 id="二、请求报文的组成"><a href="#二、请求报文的组成" class="headerlink" title="二、请求报文的组成"></a>二、请求报文的组成</h1><ul><li><p>请求行</p></li><li><p>请求头</p></li><li><p>空行</p></li><li><p>请求体</p></li></ul><h1 id="三、HTTP的请求行"><a href="#三、HTTP的请求行" class="headerlink" title="三、HTTP的请求行"></a>三、HTTP的请求行</h1><ul><li><p>请求方法（get、post、put、delete等）</p></li><li><p>请求URL（统一资源定位器）</p></li></ul><p>例如:<a href="http://www.baidu.com/index.html?a%EF%BC%9D100&b%EF%BC%9D200#logo">http://www.baidu.com:80/index.html?a＝100&amp;b＝200#logo</a></p><ul><li><p>http: 协议（https、ftp、ssh等）</p></li><li><p><a href="http://www.baidu.com/">www.baidu.com</a>         域名</p></li><li><p>80                                端口号</p></li><li><p>&#x2F;index.html                路径</p></li><li><p>a&#x3D;1008.b&#x3D;200           查询字符串</p></li><li><p>#logo                           哈希（锚点链接）</p></li></ul><p>HTTP协议版本号</p><h1 id="四、HTTP请求头"><a href="#四、HTTP请求头" class="headerlink" title="四、HTTP请求头"></a>四、HTTP请求头</h1><p>格式:『头名:头值』</p><p>常见的请求头有:</p><table><thead><tr><th>请求头</th><th>解释</th></tr></thead><tbody><tr><td>Host</td><td>主机名</td></tr><tr><td>Connection</td><td>连接的设置keep-alive（保持连接）；close（关闭连接）</td></tr><tr><td>Cache-Control</td><td>缓存控制 max-age＝0 （没有缓存）</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>将网页中的http请求转化为https请求（很少用）老网站升级</td></tr><tr><td>User-Agent</td><td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自哪个客户端，一般在PC端和手机端的区分</td></tr><tr><td>Accept</td><td>设置浏览器接收的数据类型</td></tr><tr><td>Accept-Encoding</td><td>设置接收的压缩方式</td></tr><tr><td>Accept-Language</td><td>设置接收的语言q＝0.7为喜好系数，满分为1</td></tr><tr><td>Cookie</td><td>后面单独讲</td></tr></tbody></table><h1 id="五、HTTP的请求体"><a href="#五、HTTP的请求体" class="headerlink" title="五、HTTP的请求体"></a>五、HTTP的请求体</h1><p>请求体内容的格式是非常灵活的，</p><p>（可以是空）⇒GET请求，</p><p>（也可以是字符串，还可以是JSON)⇒POST请求</p><p>例如:</p><ul><li><p>字符串:keywords&#x3D;手机8price&#x3D;2000</p></li><li><p>JSON:｛＂keywords＂:＂手机＂，＂price＂:2000｝</p></li></ul><h1 id="六、响应报文的组成"><a href="#六、响应报文的组成" class="headerlink" title="六、响应报文的组成"></a>六、响应报文的组成</h1><ul><li><strong>响应行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure><ul><li><p>HTTP&#x2F;1.1:HTTP协议版本号</p></li><li><p>200:响应状态码 404 Not Found 500 Internal Server Error 还有一些状态码，参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p></li><li><p>OK:响应状态描述</p></li></ul><p><span style="background:#e5eecc">响应状态码和响应字符串关系是–对应的。</span></p><ul><li><strong>响应头</strong></li></ul><table border="1"><tr><td colspan="1" rowspan="1">Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据Connection 链接设置</td></tr><tr><td colspan="1" rowspan="1">Content-Type:text/html;charset=utf-8 设置响应体的数据类型以及字符集，响应体为html，字符集utf-8</td></tr><tr><td colspan="1" rowspan="1">Content-Length:响应体的长度，单位为字节</td></tr></table><ul><li><p><strong>空行</strong></p></li><li><p><strong>响应体</strong></p></li></ul><p><strong>响应体内容的类型是非常灵活的，常见的类型有HTML、CSS、JS、图片、JSON</strong></p><h1 id="七、创建HTTP服务"><a href="#七、创建HTTP服务" class="headerlink" title="七、创建HTTP服务"></a>七、创建HTTP服务</h1><p>使用nodejs 创建 HTTP服务</p><h2 id="7-1-操作步骤"><a href="#7-1-操作步骤" class="headerlink" title="7.1 操作步骤"></a>7.1 操作步骤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//2. 创建服务对象 create 创建 server 服务</span><br><span class="hljs-comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据</span><br><span class="hljs-comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello HTTP server&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//3. 监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口 9000 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>http.createServer 里的回调函数的执行时机: 当接收到 HTTP 请求的时候，就会执行</strong></p><h2 id="7-2-测试"><a href="#7-2-测试" class="headerlink" title="7.2 测试"></a>7.2 测试</h2><p>浏览器请求对应端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://127.0.0.1:9000<br></code></pre></td></tr></table></figure><h2 id="7-3-注意事项"><a href="#7-3-注意事项" class="headerlink" title="7.3 注意事项"></a>7.3 注意事项</h2><h3 id="1-命令行-ctrl＋c停止服务"><a href="#1-命令行-ctrl＋c停止服务" class="headerlink" title="1.命令行 ctrl＋c停止服务"></a>1.命令行 <strong>ctrl＋c</strong>停止服务</h3><h3 id="2-当服务启动后，更新代码-必须重启服务才能生效"><a href="#2-当服务启动后，更新代码-必须重启服务才能生效" class="headerlink" title="2.当服务启动后，更新代码 必须重启服务才能生效"></a>2.当服务启动后，更新代码 必须重启服务才能生效</h3><h3 id="3-响应内容中文乱码的解决办法"><a href="#3-响应内容中文乱码的解决办法" class="headerlink" title="3.响应内容中文乱码的解决办法"></a>3.响应内容中文乱码的解决办法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-端口号被占用"><a href="#4-端口号被占用" class="headerlink" title="4.端口号被占用"></a>4.端口号被占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: listen EADDRINUSE: address already <span class="hljs-keyword">in</span> use :::9000<br></code></pre></td></tr></table></figure><p>1）关闭当前正在运行监听端口的服务（使用较多）</p><p>2）修改其他端口号</p><p>5.HTTP协议默认端口是80。HTTPS协议的默认端口是443，HTTP服务开发常用端口有3000，8080,8090,9000等</p><p><strong>如果端口被其他程序占用，可以使用资源监视器 找到占用端口的程序，然后使用 任务管理器 关闭对应的程序</strong></p><h1 id="八、浏览器查看HTTP报文"><a href="#八、浏览器查看HTTP报文" class="headerlink" title="八、浏览器查看HTTP报文"></a>八、浏览器查看HTTP报文</h1><p><strong>点击步骤</strong></p><p><img src="/posts/5656/image-20241014173924293.png"></p><h2 id="8-1查看请求行与请求头"><a href="#8-1查看请求行与请求头" class="headerlink" title="8.1查看请求行与请求头"></a>8.1查看请求行与请求头</h2><h2 id><a href="#" class="headerlink" title></a><img src="/posts/5656/image-20241014174034947.png"></h2><h2 id="8-2查看请求体"><a href="#8-2查看请求体" class="headerlink" title="8.2查看请求体"></a>8.2查看请求体</h2><p><img src="/posts/5656/image-20241014174143907.png"></p><h2 id="8-3查看URL查询字符串"><a href="#8-3查看URL查询字符串" class="headerlink" title="8.3查看URL查询字符串"></a>8.3查看URL查询字符串</h2><p><img src="/posts/5656/image-20241014174204151.png"></p><h2 id="8-4查看响应行与响应头"><a href="#8-4查看响应行与响应头" class="headerlink" title="8.4查看响应行与响应头"></a>8.4查看响应行与响应头</h2><p><img src="/posts/5656/image-20241014174335095.png"></p><h2 id="8-5查看响应体"><a href="#8-5查看响应体" class="headerlink" title="8.5查看响应体"></a>8.5查看响应体</h2><p><img src="/posts/5656/image-20241014174400437.png"></p><h1 id="九、获取HTTP请求报文"><a href="#九、获取HTTP请求报文" class="headerlink" title="九、获取HTTP请求报文"></a>九、获取HTTP请求报文</h1><p>想要获取请求的数据，需要通过request 对象</p><table><thead><tr><th>含义</th><th>语法</th><th>重点掌握</th></tr></thead><tbody><tr><td>请求方法</td><td>request.method</td><td>*</td></tr><tr><td>请求版本</td><td>request.httpVersion</td><td></td></tr><tr><td>请求路径</td><td>request.url</td><td>*</td></tr><tr><td>URL 路径</td><td>require(‘url’).parse(request.url).pathname</td><td>*</td></tr><tr><td>URL查询字符串</td><td>require(‘url’).parse(request.url, true).query</td><td>*</td></tr><tr><td>请求头</td><td>request.headers</td><td>*</td></tr><tr><td>请求体</td><td>request.on(‘data, function(chunk){}); request.on(‘end’, function(){});</td><td></td></tr></tbody></table><p><strong>注意事项:</strong></p><p>1.request.url只能获取路径以及查询字符串，无法获取URL中的域名以及协议的内容</p><p>2.request.headers将请求信息转化成一个对象，并将属性名都转化成了『小写』</p><p>3.关于路径:如果访问网站的时候，只填写了IP地址或者是域名信息，此时请求的路径为『&#x2F;』</p><p>4.关于favicon.ico:这个请求是属于浏览器自动发送的请求</p><h2 id="9-1-搭建HTTP服务"><a href="#9-1-搭建HTTP服务" class="headerlink" title="9.1 搭建HTTP服务"></a>9.1 搭建HTTP服务</h2><p>按照以下要求搭建HTTP服务</p><table><thead><tr><th>请求类型（方法）</th><th>请求地址</th><th>响应体结果</th></tr></thead><tbody><tr><td>get</td><td>&#x2F;login</td><td>登录页面</td></tr><tr><td>get</td><td>&#x2F;reg</td><td>注册页面</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、引入http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-comment">//2、建立服务</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request; <span class="hljs-comment">//对象的解构赋值</span><br>    <span class="hljs-comment">//设置响应头信息</span><br>    <span class="hljs-comment">//解决中文乱码</span><br>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/register&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;注册页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp; method == <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;登录页面&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//3、监听端口</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="十、设置HTTP响应报文"><a href="#十、设置HTTP响应报文" class="headerlink" title="十、设置HTTP响应报文"></a>十、设置HTTP响应报文</h1><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage（用的非常少）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader（＇头名，＇头值）</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’) response.end(‘xxx’)</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//write 和 end 的两种使用情况:</span><br><span class="hljs-comment">//1. write 和 end 的结合使用 响应体相对分散</span><br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;xx&#x27;</span>);<br>response.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">//每一个请求，在处理的时候必须要执行 end 方法的</span><br><span class="hljs-comment">//2. 单独使用 end 方法 响应体相对集中</span><br>response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="10-1-示例"><a href="#10-1-示例" class="headerlink" title="10.1 示例"></a>10.1 示例</h2><p>搭建HTTP服务，响应一个4行3列的表格，并且要求表格有 隔行换色效果，且点击单元格能 高亮显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="hljs-string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="hljs-string">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="hljs-string">    &lt;style&gt;</span><br><span class="hljs-string">    td&#123;</span><br><span class="hljs-string">    padding: 20px 40px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(odd)&#123;</span><br><span class="hljs-string">    background: #aef;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table tr:nth-child(even)&#123;</span><br><span class="hljs-string">    background: #fcb;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    table, td&#123;</span><br><span class="hljs-string">    border-collapse: collapse;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &lt;/style&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="hljs-string">    &lt;/table&gt;</span><br><span class="hljs-string">    &lt;script&gt;</span><br><span class="hljs-string">    //获取所有的 td</span><br><span class="hljs-string">    let tds = document.querySelectorAll(&#x27;td&#x27;);</span><br><span class="hljs-string">    //遍历</span><br><span class="hljs-string">    tds.forEach(item =&gt; &#123;</span><br><span class="hljs-string">    item.onclick = function()&#123;</span><br><span class="hljs-string">    this.style.background = &#x27;#222&#x27;;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">`</span>); <span class="hljs-comment">//设置响应体</span><br>&#125;);<br><span class="hljs-comment">//监听端口, 启动服务</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动....&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="十一、网页资源的基本加载过程"><a href="#十一、网页资源的基本加载过程" class="headerlink" title="十一、网页资源的基本加载过程"></a>十一、网页资源的基本加载过程</h1><p><img src="/posts/5656/image-20241014175420098.png"></p><p>网页资源的加载都是循序渐进的，首先获取HTML的内容，然后解析HTML在发送其他资源的请求，如CSS， Javascript，图片等。理解了这个内容对于后续的学习与成长有非常大的帮助</p><h1 id="十二、静态资源服务"><a href="#十二、静态资源服务" class="headerlink" title="十二、静态资源服务"></a>十二、静态资源服务</h1><p>静态资源是指内容长时间不发生改变的资源，例如图片，视频，cSS文件，JS文件，HTML文件，字体文件等</p><p>动态资源是指内容经常更新的资源，例如百度首页，网易首页，京东搜索列表页面等</p><h2 id="12-1-网站根目录或静态资源目录"><a href="#12-1-网站根目录或静态资源目录" class="headerlink" title="12.1 网站根目录或静态资源目录"></a>12.1 网站根目录或静态资源目录</h2><p>HTTP服务在哪个文件夹中寻找静态资源，那个文件夹就是静态资源目录，也称之为 网站根目录</p><p>思考:vscode 中使用live-server访问HTML时，它启动的服务中网站根目录是谁？</p><h2 id="12-2-网页中的URL"><a href="#12-2-网页中的URL" class="headerlink" title="12.2 网页中的URL"></a>12.2 网页中的URL</h2><p>网页中的URL主要分为两大类:相对路径与绝对路径</p><h3 id="12-2-1-绝对路径"><a href="#12-2-1-绝对路径" class="headerlink" title="12.2.1 绝对路径"></a>12.2.1 绝对路径</h3><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><table><thead><tr><th>形式</th><th>特点</th></tr></thead><tbody><tr><td><a href="http://atguigu.com/web">http://atguigu.com/web</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td>&#x2F;&#x2F;atguigu.com&#x2F;web</td><td>与页面URL的协议拼接形成完整URL再发送请求。大型网站用的比较多</td></tr><tr><td>&#x2F;web</td><td>与页面URL的协议、主机名、端口拼接形成完整URL再发送请求。中小型网站</td></tr></tbody></table><h3 id="12-2-2-相对路径"><a href="#12-2-2-相对路径" class="headerlink" title="12.2.2 相对路径"></a>12.2.2 相对路径</h3><p>相对路径在发送请求时，需要与当前页面URL路径进行计算，得到完整URL后，再发送请求，学习阶段用的较多</p><p>例如当前网页url为<a href="http://www.atguigu.com/course/h5.html">http://www.atguigu.com/course/h5.html</a></p><table><thead><tr><th>形式</th><th>最终的URL</th></tr></thead><tbody><tr><td>.&#x2F;css&#x2F;app.css</td><td><a href="http://www.atguigu.com/course/css/app.css">http://www.atguigu.com/course/css/app.css</a></td></tr><tr><td>js&#x2F;app.js</td><td><a href="http://www.atguigu.com/course/js/app.js">http://www.atguigu.com/course/js/app.js</a></td></tr><tr><td>..&#x2F;img&#x2F;logo.png</td><td><a href="http://www.atguigu.com/img/logo.png">http://www.atguigu.com/img/logo.png</a></td></tr><tr><td>..&#x2F;..&#x2F;mp4&#x2F;show.mp4</td><td><a href="http://www.atguigu.com/mp4/show.mp4">http://www.atguigu.com/mp4/show.mp4</a></td></tr></tbody></table><h3 id="12-2-3-网页中使用URL的场景小结"><a href="#12-2-3-网页中使用URL的场景小结" class="headerlink" title="12.2.3 网页中使用URL的场景小结"></a>12.2.3 网页中使用URL的场景小结</h3><p>包括但不限于如下场景:</p><ul><li><p>a标签href</p></li><li><p>link标签 href</p></li><li><p>script标签src</p></li><li><p>img标签 src</p></li><li><p>video audio 标签 src</p></li><li><p>form中的action</p></li><li><p>AJAX请求中的URL</p></li></ul><h2 id="12-3-设置资源类型（mime类型）"><a href="#12-3-设置资源类型（mime类型）" class="headerlink" title="12.3 设置资源类型（mime类型）"></a>12.3 设置资源类型（mime类型）</h2><p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。</p><p><code>mime 类型结构:［type］/［subType］</code></p><p><code>例如:text/html text/css image/jpeg image/png application/json</code></p><p>HTTP服务可以设置响应头Content-Type 来表明响应体的MIME类型，浏览器会根据该类型决定如何处理资源</p><p>下面是常见文件对应的mime类型</p><ul><li><p>html:’text&#x2F;html’,</p></li><li><p>css:’text&#x2F;css’,</p></li><li><p>js: ‘text&#x2F;javascript’,</p></li><li><p>png: ‘image&#x2F;png’,</p></li><li><p>jpg: ‘image&#x2F;jpeg’,</p></li><li><p>gif: ‘image&#x2F;gif’,</p></li><li><p>mp4: ‘video&#x2F;mp4’,</p></li><li><p>mp3: ‘audio&#x2F;mpeg’,</p></li><li><p>json: ‘application&#x2F;json’</p></li></ul><p>对于未知的资源类型，可以选择 application&#x2F;octet-stream类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的下载效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//判断请求方式以及请求路径</span><br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/index.html&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/css/app.css&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/css/app.css&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; url == <span class="hljs-string">&quot;/js/app.js&quot;</span>) &#123;<br>        <span class="hljs-comment">//需要响应文件中的内容</span><br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/public/js/app.js&#x27;</span>);<br>        response.<span class="hljs-title function_">end</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//404响应</span><br>        response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>        response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>很明显上面的代码，当只要有一个请求路径就需要进行判断，显然这种方式不够完美，那么我们需要封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//获取请求的方法已经路径</span><br>    <span class="hljs-keyword">let</span> &#123; url, method &#125; = request;<br>    <span class="hljs-comment">//文件夹路径</span><br>    <span class="hljs-keyword">let</span> rootDir = __dirname + <span class="hljs-string">&#x27;/public&#x27;</span>;<br>    <span class="hljs-comment">//拼接文件路径</span><br>    <span class="hljs-keyword">let</span> filePath = rootDir + url;<br>    <span class="hljs-comment">//读取文件内容</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断</span><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-comment">//如果出现错误，响应404状态码</span><br>            response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>            response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//响应文件内容</span><br>            response.<span class="hljs-title function_">end</span>(data);<br>        &#125;<br>    &#125;)<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;80端口正在启动中....&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="12-4-GET和POST请求场景小结"><a href="#12-4-GET和POST请求场景小结" class="headerlink" title="12.4 GET和POST请求场景小结"></a>12.4 GET和POST请求场景小结</h2><h3 id="12-4-1-GET-请求的情况"><a href="#12-4-1-GET-请求的情况" class="headerlink" title="12.4.1 GET 请求的情况:"></a>12.4.1 <strong>GET 请求的情况:</strong></h3><p>在地址栏直接输入url访问</p><ul><li><p>点击a链接</p></li><li><p>link标签引入css</p></li><li><p>script 标签引入js</p></li><li><p>img标签引入图片</p></li><li><p>form标签中的method为get（不区分大小写）</p></li><li><p>ajax中的get请求</p></li></ul><h3 id="12-4-2-POST-请求的情况"><a href="#12-4-2-POST-请求的情况" class="headerlink" title="12.4.2 POST 请求的情况:"></a>12.4.2 <strong>POST 请求的情况:</strong></h3><ul><li><p>form标签中的method为post（不区分大小写）</p></li><li><p>AJAX的post请求</p></li></ul><h2 id="十三、GET和POST请求的区别"><a href="#十三、GET和POST请求的区别" class="headerlink" title="十三、GET和POST请求的区别"></a>十三、GET和POST请求的区别</h2><p>GET和POST是HTTP协议请求的两种方式。</p><ul><li><p>GET主要用来获取数据，POST主要用来提交数据</p></li><li><p>GET带参数请求是将参数缀到URL之后，在地址栏中输入url访问网站就是GET请求，POST带参数请求是将参数放到请求体中</p></li><li><p>POST 请求相对GET安全一些，因为在浏览器中参数会暴露在地址栏</p></li><li><p>GET请求大小有限制，一般为2K，而POST 请求则没有大小限制</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、NodeJs path模块</title>
    <link href="/posts/5760/"/>
    <url>/posts/5760/</url>
    
    <content type="html"><![CDATA[<h1 id="六、NodeJs-path模块"><a href="#六、NodeJs-path模块" class="headerlink" title="六、NodeJs path模块"></a>六、NodeJs path模块</h1><p>path 模块提供了操作路径的功能，我们将介绍如下几个较为常用的几个 API：</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>path.resolve</td><td>拼接规范的绝对路径 常用</td></tr><tr><td>path.sep</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse</td><td>解析路径并返回对象</td></tr><tr><td>path.basename</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname</td><td>获取路径的目录名</td></tr><tr><td>path.extname</td><td>获得路径的扩展名</td></tr></tbody></table><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">//获取路径分隔符</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-property">sep</span>);<br><br><span class="hljs-comment">//拼接绝对路径</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;test&#x27;</span>));<br><br><span class="hljs-comment">//解析路径</span><br><br><span class="hljs-keyword">let</span> pathname = <span class="hljs-string">&#x27;D:/program file/nodejs/node.exe&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">parse</span>(pathname));<br><br><span class="hljs-comment">//获取路径基础名称</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(pathname))<br><br><span class="hljs-comment">//获取路径的目录名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">dirname</span>(pathname));<br><br><span class="hljs-comment">//获取路径的扩展名</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(pathname));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、NodeJs fs模块</title>
    <link href="/posts/3454/"/>
    <url>/posts/3454/</url>
    
    <content type="html"><![CDATA[<h1 id="五、NodeJs-fs模块"><a href="#五、NodeJs-fs模块" class="headerlink" title="五、NodeJs fs模块"></a>五、NodeJs fs模块</h1><p>fs 全称为 file system，称之为文件系统，是 Node.js 中的内置模块，可以对计算机中的磁盘进行操作。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile &#x2F; appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h1 id="一、文件写入"><a href="#一、文件写入" class="headerlink" title="一、文件写入"></a>一、文件写入</h1><p>文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果</p><h2 id="1-1-writeFile-异步写入"><a href="#1-1-writeFile-异步写入" class="headerlink" title="1-1. writeFile 异步写入"></a>1-1. writeFile 异步写入</h2><p>语法： </p><p><strong>fs.writeFile(file, data[, options], callback)</strong></p><p>参数说明：</p><ul><li><p>file 文件名</p></li><li><p>data 待写入的数据</p></li><li><p>options 选项设置（可选）</p></li><li><p>callback 写入回调</p></li></ul><p>返回值： undefined</p><p><strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// require 是 Node.js 环境中的&#x27;全局&#x27;变量，用来导入模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">//将 『三人行，必有我师焉。』 写入到当前文件夹下的『座右铭.txt』文件中</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)；<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-2-writeFileSync-同步写入"><a href="#1-2-writeFileSync-同步写入" class="headerlink" title="1-2. writeFileSync 同步写入"></a>1-2. writeFileSync 同步写入</h2><p> 语法: </p><p><strong>fs.writeFileSync(file, data[, options])</strong></p><p> 参数与 fs.writeFile 大体一致，只是没有 callback 参数</p><p> 返回值：undefined</p><p> <strong>代码示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>    fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;三人行，必有我师焉。&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p> Node.js 中的磁盘操作是由其他线程完成的，结果的处理有两种模式：</p><p> 同步处理 JavaScript 主线程会等待其他线程的执行结果，然后再继续执行主线程的代码，</p><p> 效率较低</p><p> 异步处理 JavaScript 主线程不会等待其他线程的执行结果，直接执行后续的主线程代码，</p><p>效率较好</p><h2 id="1-3-appendFile-appendFileSync-追加写入"><a href="#1-3-appendFile-appendFileSync-追加写入" class="headerlink" title="1-3. appendFile &#x2F; appendFileSync 追加写入"></a>1-3. appendFile &#x2F; appendFileSync 追加写入</h2><p> appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同</p><p> 语法:</p><ul><li><p><strong>fs.appendFile(file, data[, options], callback)</strong></p></li><li><p><strong>fs.appendFileSync(file, data[, options])</strong></p></li></ul><p> 返回值： 二者都为 undefined</p><p> 实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;择其善者而从之，其不善者而改之。&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;追加成功&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">appendFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;\r\n温故而知新, 可以为师矣&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-4-createWriteStream-流式写入"><a href="#1-4-createWriteStream-流式写入" class="headerlink" title="1-4. createWriteStream 流式写入"></a>1-4. createWriteStream 流式写入</h2><p> 语法：</p><p> <strong>fs.createWriteStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>返回值：Object</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ws = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;天光云影共徘徊\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;问渠那得清如许\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;为有源头活水来\r\n&#x27;</span>);<br>ws.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure><p> 程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p> 流式写入方式适用于大文件写入或者频繁写入的场景, writeFile 适合于写入频率较低的场景</p><h2 id="1-5-写入文件的场景"><a href="#1-5-写入文件的场景" class="headerlink" title="1-5 写入文件的场景"></a>1-5 写入文件的场景</h2><p> 文件写入在计算机中是一个非常常见的操作，下面的场景都用到了文件写入</p><ul><li><p>下载文件</p></li><li><p>安装软件</p></li><li><p>保存程序日志，如 Git</p></li><li><p>编辑器保存文件</p></li><li><p>视频录制</p></li></ul><p> 当需要持久化保存数据的时候，应该想到文件写入</p><h1 id="二、文件读取"><a href="#二、文件读取" class="headerlink" title="二、文件读取"></a>二、文件读取</h1><p> 文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h2 id="2-1-readFile-异步读取"><a href="#2-1-readFile-异步读取" class="headerlink" title="2-1 readFile 异步读取"></a>2-1 readFile 异步读取</h2><p> 语法：<strong>fs.readFile(path[, options], callback)</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li><li><p>callback 回调函数</p></li></ul><p> 返回值： undefined</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="2-2-readFileSync-同步读取"><a href="#2-2-readFileSync-同步读取" class="headerlink" title="2-2 readFileSync 同步读取"></a>2-2 readFileSync 同步读取</h2><p> 语法：<strong>fs.readFileSync(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li></ul><p> 返回值： string | Buffer</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>);<br><span class="hljs-keyword">let</span> data2 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="2-3-createReadStream-流式读取"><a href="#2-3-createReadStream-流式读取" class="headerlink" title="2-3 createReadStream 流式读取"></a>2-3 createReadStream 流式读取</h2><p> 语法：<strong>fs.createReadStream(path[, options])</strong></p><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（可选）</p></li></ul><p> 返回值： Object</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建读取流对象</span><br><span class="hljs-keyword">let</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br><span class="hljs-comment">//每次取出 64k 数据后执行一次 data 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;);<br><span class="hljs-comment">//读取完毕后, 执行 end 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-4-读取文件应用场景"><a href="#2-4-读取文件应用场景" class="headerlink" title="2-4 读取文件应用场景"></a>2-4 读取文件应用场景</h2><ul><li><p>电脑开机</p></li><li><p>程序运行</p></li><li><p>编辑器打开文件</p></li><li><p>查看图片</p></li><li><p>播放视频</p></li><li><p>播放音乐</p></li><li><p>Git 查看日志</p></li><li><p>上传文件</p></li><li><p>查看聊天记录</p></li></ul><h1 id="三、文件移动与重命名"><a href="#三、文件移动与重命名" class="headerlink" title="三、文件移动与重命名"></a>三、文件移动与重命名</h1><p> 在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名文件或文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rename(oldPath, newPath, callback)</strong></p></li><li><p><strong>fs.renameSync(oldPath, newPath)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>oldPath 文件当前的路径</p></li><li><p>newPath 文件新的路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><p> &#x2F;&#x2F;创建读取流对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/观书有感.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;移动完成&#x27;</span>)<br>&#125;);<br>fs.<span class="hljs-title function_">renameSync</span>(<span class="hljs-string">&#x27;./座右铭.txt&#x27;</span>, <span class="hljs-string">&#x27;./论语/我的座右铭.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="四、文件删除"><a href="#四、文件删除" class="headerlink" title="四、文件删除"></a>四、文件删除</h1><p> 在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件</p><p> 语法：</p><ul><li><p><strong>fs.unlink(path, callback)</strong></p></li><li><p><strong>fs.unlinkSync(path)</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件路径</p></li><li><p>callback 操作后的回调</p></li></ul><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br>fs.<span class="hljs-title function_">unlinkSync</span>(<span class="hljs-string">&#x27;./test2.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="五、文件夹操作"><a href="#五、文件夹操作" class="headerlink" title="五、文件夹操作"></a>五、文件夹操作</h1><p> 借助 Node.js 的能力，我们可以对文件夹进行创建 、读取、 删除等操作</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir &#x2F; mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir &#x2F; readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir &#x2F; rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h2 id="5-1-mkdir-创建文件夹"><a href="#5-1-mkdir-创建文件夹" class="headerlink" title="5-1 mkdir 创建文件夹"></a>5-1 mkdir 创建文件夹</h2><p> 在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹</p><p> 语法：</p><ul><li><p><strong>fs.mkdir(path[, options], callback)</strong></p></li><li><p><strong>fs.mkdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归异步创建</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./1/2/3&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归创建成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//递归同步创建文件夹</span><br>fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-string">&#x27;./x/y/z&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p> &#x2F;&#x2F;异步创建文件夹</p><h2 id="5-2-readdir-读取文件夹"><a href="#5-2-readdir-读取文件夹" class="headerlink" title="5-2 readdir 读取文件夹"></a>5-2 readdir 读取文件夹</h2><p> 在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹</p><p> 语法：</p><ul><li><p><strong>fs.readdir(path[, options], callback)</strong></p></li><li><p><strong>fs.readdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步读取</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步读取</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-string">&#x27;./论语&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h2 id="5-3-rmdir-删除文件夹"><a href="#5-3-rmdir-删除文件夹" class="headerlink" title="5-3 rmdir 删除文件夹"></a>5-3 rmdir 删除文件夹</h2><p> 在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹</p><p> 语法：</p><ul><li><p><strong>fs.rmdir(path[, options], callback)</strong></p></li><li><p><strong>fs.rmdirSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./page&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//异步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./1&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;递归删除&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//同步递归删除文件夹</span><br>fs.<span class="hljs-title function_">rmdirSync</span>(<span class="hljs-string">&#x27;./x&#x27;</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><h1 id="六、查看资源状态"><a href="#六、查看资源状态" class="headerlink" title="六、查看资源状态"></a>六、查看资源状态</h1><p> 在 Node.js 中，我们可以使用 stat 或 statSync 来查看资源的详细信息</p><p> 语法：</p><ul><li><p><strong>fs.stat(path[, options], callback)</strong></p></li><li><p><strong>fs.statSync(path[, options])</strong></p></li></ul><p> 参数说明：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（可选）</p></li><li><p>callback 操作后的回调</p></li></ul><p> 示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步获取状态</span><br>fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><span class="hljs-comment">//同步获取状态</span><br><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">statSync</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>);<br></code></pre></td></tr></table></figure><p> 结果值对象结构：</p><ul><li><p>size 文件体积</p></li><li><p>birthtime 创建时间</p></li><li><p>mtime 最后修改时间</p></li><li><p>isFile 检测是否为文件</p></li><li><p>isDirectory 检测是否为文件夹</p></li></ul><p> ….</p><h1 id="七、相对路径问题"><a href="#七、相对路径问题" class="headerlink" title="七、相对路径问题"></a>七、相对路径问题</h1><p> fs 模块对资源进行操作时，路径的写法有两种：</p><p> <strong>相对路径</strong></p><ul><li><p>.&#x2F;座右铭.txt 当前目录下的座右铭.txt</p></li><li><p>座右铭.txt 等效于上面的写法</p></li><li><p>..&#x2F;座右铭.txt 当前目录的上一级目录中的座右铭.txt</p></li></ul><p> <strong>绝对路径</strong></p><ul><li><p>D:&#x2F;Program Files windows 系统下的绝对路径</p></li><li><p>&#x2F;usr&#x2F;bin Linux 系统下的绝对路径</p></li></ul><p> 相对路径中所谓的当前目录，指的是命令行的工作目录，而并非是文件的所在目录</p><p> 所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG</p><h1 id="八、-dirname"><a href="#八、-dirname" class="headerlink" title="八、__dirname"></a>八、__dirname</h1><p> __dirname 与 require 类似，都是 Node.js 环境中的’全局’变量</p><p> __dirname 保存着当前文件所在目录的绝对路径，可以使用 __dirname 与文件名拼接成绝对路径</p><p> 代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = fs.<span class="hljs-title function_">readFileSync</span>(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><p> <em>使用 fs 模块的时候，尽量使用 __dirname 将路径转化为绝对路径，这样可以避免相对路径产生的Bug</em></p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、NodeJs Stream(流)</title>
    <link href="/posts/6344/"/>
    <url>/posts/6344/</url>
    
    <content type="html"><![CDATA[<h1 id="四、NodeJs-Stream-流"><a href="#四、NodeJs-Stream-流" class="headerlink" title="四、NodeJs Stream(流)"></a>四、NodeJs Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p><p>Node.js，Stream 有四种流类型：</p><ul><li><strong>Readable</strong> - 可读操作。</li><li><strong>Writable</strong> - 可写操作。</li><li><strong>Duplex</strong> - 可读可写操作.</li><li><strong>Transform</strong> - 操作被写入数据，然后读出结果。</li></ul><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><ul><li><strong>data</strong> - 当有数据可读时触发。</li><li><strong>end</strong> - 没有更多的数据可读时触发。</li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul><p>本教程会为大家介绍常用的流操作。</p><hr><h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-comment">// 创建可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 设置编码为 utf8。</span><br>readerStream.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 处理流事件 --&gt; data, end, and error</span><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) &#123;<br>   data += chunk;<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br>readerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;菜鸟教程官网地址：www.runoob.com&#x27;</span>;<br><br><span class="hljs-comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 使用 utf8 编码写入数据</span><br>writerStream.<span class="hljs-title function_">write</span>(data,<span class="hljs-string">&#x27;UTF8&#x27;</span>);<br><br><span class="hljs-comment">// 标记文件末尾</span><br>writerStream.<span class="hljs-title function_">end</span>();<br><br><span class="hljs-comment">// 处理流事件 --&gt; finish、error</span><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入完成。&quot;</span>);<br>&#125;);<br><br>writerStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br>写入完成。<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p><p><img src="/posts/6344/bVcla61.png"></p><p>如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。</p><p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p><p>设置 input.txt 文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><p>创建 main.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br><span class="hljs-comment">// 创建一个可读流</span><br><span class="hljs-keyword">var</span> readerStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个可写流</span><br><span class="hljs-keyword">var</span> writerStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>);<br><br><span class="hljs-comment">// 管道读写操作</span><br><span class="hljs-comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br>readerStream.<span class="hljs-title function_">pipe</span>(writerStream);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js <br>程序执行完毕<br></code></pre></td></tr></table></figure><p>查看 output.txt 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> output.txt <br>菜鸟教程官网地址：www.runoob.com<br>管道流操作实例<br></code></pre></td></tr></table></figure><hr><h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p><p>接下来我们就是用管道和链式来压缩和解压文件。</p><p>创建 compress.js 文件, 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 压缩 input.txt 文件为 input.txt.gz</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件压缩完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node compress.js <br>文件压缩完成。<br></code></pre></td></tr></table></figure><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p><p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>);<br><br><span class="hljs-comment">// 解压 input.txt.gz 文件为 input.txt</span><br>fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;input.txt.gz&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGunzip</span>())<br>  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>));<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件解压完成。&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node decompress.js <br>文件解压完成。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、NodeJs Buffer(缓冲区)</title>
    <link href="/posts/16461/"/>
    <url>/posts/16461/</url>
    
    <content type="html"><![CDATA[<h1 id="三、NodeJs-Buffer-缓冲区"><a href="#三、NodeJs-Buffer-缓冲区" class="headerlink" title="三、NodeJs Buffer(缓冲区)"></a>三、NodeJs Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p><p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I&#x2F;O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><blockquote><p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 <strong>Buffer.from()</strong> 接口去创建Buffer对象。</p></blockquote><hr><h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br><br><span class="hljs-comment">// 输出 72756e6f6f62</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>));<br><br><span class="hljs-comment">// 输出 cnVub29i</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;base64&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Node.js 目前支持的字符编码包括：</strong></p><ul><li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li><li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li><li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li><li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li><li><strong>base64</strong> - Base64 编码。</li><li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li><li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li><li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li></ul><hr><h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p><ul><li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li><li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li><li><strong>Buffer.allocUnsafeSlow(size)</strong></li><li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li><li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li><li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li><li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="hljs-comment">// 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="hljs-comment">// 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="hljs-comment">// 因此需要使用 fill() 或 write() 重写。</span><br><span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="hljs-keyword">const</span> buf6 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;tést&#x27;</span>, <span class="hljs-string">&#x27;latin1&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>写入 Node 缓冲区的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">write</span>(string[, offset[, length]][, encoding])<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>string</strong> - 写入缓冲区的字符串。</li><li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li><li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li></ul><p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">256</span>);<br>len = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;www.runoob.com&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写入字节数 : &quot;</span>+  len);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span> main.js<br>写入字节数 : 14<br></code></pre></td></tr></table></figure><hr><h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>读取 Node 缓冲区数据的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toString</span>([encoding[, start[, end]]])<br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li><li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li><li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">26</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) &#123;<br>  buf[i] = i + <span class="hljs-number">97</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>));       <span class="hljs-comment">// 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));   <span class="hljs-comment">//使用 &#x27;ascii&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));    <span class="hljs-comment">// 使用 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( buf.<span class="hljs-title function_">toString</span>(<span class="hljs-literal">undefined</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)); <span class="hljs-comment">// 使用默认的 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>abcdefghijklmnopqrstuvwxyz<br>abcde<br>abcde<br>abcde<br></code></pre></td></tr></table></figure><hr><h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toJSON</span>()<br></code></pre></td></tr></table></figure><p>当字符串化一个 Buffer 实例时，<a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a> 会隐式地调用该 **toJSON()**。</p><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回 JSON 对象。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>]);<br><span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(buf);<br><br><span class="hljs-comment">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);<br><br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> value &amp;&amp; value.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;Buffer&#x27;</span> ?<br>    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(value.<span class="hljs-property">data</span>) :<br>    value;<br>&#125;);<br><br><span class="hljs-comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Buffer&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>:[1,2,3,4,5]&#125;<br>&lt;Buffer 01 02 03 04 05&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区合并的语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(list[, totalLength])<br></code></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li><li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>((<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>));<br><span class="hljs-keyword">var</span> buffer3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buffer1,buffer2]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer3 内容: &quot;</span> + buffer3.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer3 内容: 菜鸟教程www.runoob.com<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">compare</span>(otherBuffer);<br></code></pre></td></tr></table></figure><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</li></ul><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个数字，表示 <strong>buf</strong> 在 <strong>otherBuffer</strong> 之前，之后或相同。</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>);<br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>);<br><span class="hljs-keyword">var</span> result = buffer1.<span class="hljs-title function_">compare</span>(buffer2);<br><br><span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之前&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 与 &quot;</span> + buffer2 + <span class="hljs-string">&quot;相同&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1 + <span class="hljs-string">&quot; 在 &quot;</span> + buffer2 + <span class="hljs-string">&quot;之后&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ABC在ABCD之前<br></code></pre></td></tr></table></figure><hr><h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区拷贝语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">copy</span>(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])<br></code></pre></td></tr></table></figure><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</li><li><strong>targetStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceStart</strong> - 数字, 可选, 默认: 0</li><li><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>没有返回值。</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abcdefghijkl&#x27;</span>);<br><span class="hljs-keyword">var</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);<br><br><span class="hljs-comment">//将 buf2 插入到 buf1 指定位置上</span><br>buf2.<span class="hljs-title function_">copy</span>(buf1, <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">abRUNOOBijkl<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">slice</span>([start[, end]])<br></code></pre></td></tr></table></figure><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p><ul><li><strong>start</strong> - 数字, 可选, 默认: 0</li><li><strong>end</strong> - 数字, 可选, 默认: buffer.length</li></ul><h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>);<br><span class="hljs-comment">// 剪切缓冲区</span><br><span class="hljs-keyword">var</span> buffer2 = buffer1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer2 content: &quot;</span> + buffer2.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer2 content: ru<br></code></pre></td></tr></table></figure><hr><h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>Node 缓冲区长度计算语法如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h3><p>返回 Buffer 对象所占据的内存长度。</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>);<br><span class="hljs-comment">//  缓冲区长度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;buffer length: &quot;</span> + buffer.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">buffer length: 14<br></code></pre></td></tr></table></figure><hr><h2 id="方法参考手册"><a href="#方法参考手册" class="headerlink" title="方法参考手册"></a>方法参考手册</h2><p>以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>new Buffer(size)</strong> 分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。废弃的: 使用 Buffer.alloc() 代替（或 Buffer.allocUnsafe()）。</td></tr><tr><td align="left">2</td><td align="left"><strong>new Buffer(buffer)</strong> 拷贝参数 buffer 的数据到 Buffer 实例。废弃的: 使用 Buffer.from(buffer) 代替。</td></tr><tr><td align="left">3</td><td align="left"><strong>new Buffer(str[, encoding])</strong> 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 废弃的: 使用 Buffer.from(string[, encoding]) 代替。</td></tr><tr><td align="left">4</td><td align="left"><strong>buf.length</strong> 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td></tr><tr><td align="left">5</td><td align="left"><strong>buf.write(string[, offset[, length]][, encoding])</strong> 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</td></tr><tr><td align="left">6</td><td align="left"><strong>buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如： <code>const buf = Buffer.allocUnsafe(6); buf.writeUIntLE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer ab 90 78 56 34 12&gt; console.log(buf);</code>noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">7</td><td align="left"><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])</strong> 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。<code>const buf = Buffer.allocUnsafe(6); buf.writeUIntBE(0x1234567890ab, 0, 6); // 输出: &lt;Buffer 12 34 56 78 90 ab&gt; console.log(buf);</code></td></tr><tr><td align="left">8</td><td align="left"><strong>buf.writeIntLE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">9</td><td align="left"><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])</strong> 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td align="left">10</td><td align="left"><strong>buf.readUIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">11</td><td align="left"><strong>buf.readUIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">12</td><td align="left"><strong>buf.readIntLE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">13</td><td align="left"><strong>buf.readIntBE(offset, byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td align="left">14</td><td align="left"><strong>buf.toString([encoding[, start[, end]]])</strong> 根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</td></tr><tr><td align="left">15</td><td align="left"><strong>buf.toJSON()</strong> 将 Buffer 实例转换为 JSON 对象。</td></tr><tr><td align="left">16</td><td align="left"><strong>buf[index]</strong> 获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td></tr><tr><td align="left">17</td><td align="left"><strong>buf.equals(otherBuffer)</strong> 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td></tr><tr><td align="left">18</td><td align="left"><strong>buf.compare(otherBuffer)</strong> 比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td></tr><tr><td align="left">19</td><td align="left"><strong>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</strong> buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td></tr><tr><td align="left">20</td><td align="left"><strong>buf.slice([start[, end]])</strong> 剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td></tr><tr><td align="left">21</td><td align="left"><strong>buf.readUInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">22</td><td align="left"><strong>buf.readUInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">23</td><td align="left"><strong>buf.readUInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">24</td><td align="left"><strong>buf.readUInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">25</td><td align="left"><strong>buf.readUInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">26</td><td align="left"><strong>buf.readInt8(offset[, noAssert])</strong> 根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">27</td><td align="left"><strong>buf.readInt16LE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">28</td><td align="left"><strong>buf.readInt16BE(offset[, noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td align="left">29</td><td align="left"><strong>buf.readInt32LE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">30</td><td align="left"><strong>buf.readInt32BE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">31</td><td align="left"><strong>buf.readFloatLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">32</td><td align="left"><strong>buf.readFloatBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td align="left">33</td><td align="left"><strong>buf.readDoubleLE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">34</td><td align="left"><strong>buf.readDoubleBE(offset[, noAssert])</strong> 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td align="left">35</td><td align="left"><strong>buf.writeUInt8(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td></tr><tr><td align="left">36</td><td align="left"><strong>buf.writeUInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">37</td><td align="left"><strong>buf.writeUInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">38</td><td align="left"><strong>buf.writeUInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">39</td><td align="left"><strong>buf.writeUInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">40</td><td align="left"><strong>buf.writeInt8(value, offset[, noAssert])</strong></td></tr><tr><td align="left">41</td><td align="left"><strong>buf.writeInt16LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">42</td><td align="left"><strong>buf.writeInt16BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr><tr><td align="left">43</td><td align="left"><strong>buf.writeInt32LE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">44</td><td align="left"><strong>buf.writeInt32BE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">45</td><td align="left"><strong>buf.writeFloatLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">46</td><td align="left"><strong>buf.writeFloatBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">47</td><td align="left"><strong>buf.writeDoubleLE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">48</td><td align="left"><strong>buf.writeDoubleBE(value, offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td align="left">49</td><td align="left"><strong>buf.fill(value[, offset][, end])</strong> 使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、NodeJs EventEmitter</title>
    <link href="/posts/42651/"/>
    <url>/posts/42651/</url>
    
    <content type="html"><![CDATA[<h1 id="二、NodeJs-EventEmitter"><a href="#二、NodeJs-EventEmitter" class="headerlink" title="二、NodeJs EventEmitter"></a>二、NodeJs EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node event.js <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>2 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br>1 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">node.js:201 <br>throw e; // process.nextTick error, or <span class="hljs-string">&#x27;error&#x27;</span> event on first tick <br>^ <br>Error: Uncaught, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at EventEmitter.emit (events.js:50:15) <br>at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) <br>at Module._compile (module.js:441:26) <br>at Object..js (module.js:459:10) <br>at Module.load (module.js:348:31) <br>at Function._load (module.js:308:12) <br>at Array.0 (module.js:479:10) <br>at EventEmitter._tickCallback (node.js:192:40) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、NodeJs 事件循环</title>
    <link href="/posts/17687/"/>
    <url>/posts/17687/</url>
    
    <content type="html"><![CDATA[<h1 id="一、NodeJs-事件循环"><a href="#一、NodeJs-事件循环" class="headerlink" title="一、NodeJs 事件循环"></a>一、NodeJs 事件循环</h1><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p><p>Node.js 几乎每一个 API 都是支持回调函数的。</p><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p><hr><h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><p><img src="/posts/17687/event_loop.jpg"></p><p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>以下程序绑定事件处理程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定事件及事件的处理程序</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, eventHandler);<br></code></pre></td></tr></table></figure><p>我们可以通过程序触发事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 触发事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建 main.js 文件，代码如下所示：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>&#x2F;&#x2F; 引入 events 模块 var events &#x3D; require(‘events’); &#x2F;&#x2F; 创建 eventEmitter 对象 var eventEmitter &#x3D; new events.EventEmitter();  &#x2F;&#x2F; 创建事件处理程序 var connectHandler &#x3D; function connected() {   console.log(‘连接成功。’);     &#x2F;&#x2F; 触发 data_received 事件    eventEmitter.emit(‘data_received’); }  &#x2F;&#x2F; 绑定 connection 事件处理程序 eventEmitter.on(‘connection’, connectHandler);  &#x2F;&#x2F; 使用匿名函数绑定 data_received 事件 eventEmitter.on(‘data_received’, function(){   console.log(‘数据接收成功。’); });  &#x2F;&#x2F; 触发 connection 事件  eventEmitter.emit(‘connection’);  console.log(“程序执行完毕。”);</p><p>接下来让我们执行以上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node main.js<br>连接成功。<br>数据接收成功。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p><p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>创建 main.js 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>   <span class="hljs-keyword">if</span> (err)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">stack</span>);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p><p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p><p>执行以上代码，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>菜鸟教程官网地址：www.runoob.com<br></code></pre></td></tr></table></figure><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">程序执行完毕<br>Error: ENOENT, open <span class="hljs-string">&#x27;input.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs基础</title>
    <link href="/posts/31322/"/>
    <url>/posts/31322/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Node-js是什么"><a href="#一、Node-js是什么" class="headerlink" title="一、Node.js是什么"></a>一、Node.js是什么</h1><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p><h3 id="1、特性"><a href="#1、特性" class="headerlink" title="1、特性"></a>1、特性</h3><p>Node.js 可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p><ul><li>文件的读写 (File System)</li><li>进程的管理 (Process)</li><li>网络通信 (HTTP&#x2F;HTTPS)</li><li>……</li></ul><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><h4 id="2-1-浏览器安全级别的限制"><a href="#2-1-浏览器安全级别的限制" class="headerlink" title="2.1 浏览器安全级别的限制"></a>2.1 浏览器安全级别的限制</h4><p><strong>Ajax测试</strong></p><p>浏览器访问存在跨域问题，所以以下的get请求无法成功！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>browser-safe-sandbox<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#x27;</span>, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    xhr.<span class="hljs-title function_">send</span>()</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>浏览器预览</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">browser-sync start --server --files **/* --directory<br></code></pre></td></tr></table></figure><h4 id="2-2-文件的读写-File-System"><a href="#2-2-文件的读写-File-System" class="headerlink" title="2.2 文件的读写 (File System)"></a>2.2 文件的读写 (File System)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./ajax.png&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-3-进程的管理（Process）"><a href="#2-3-进程的管理（Process）" class="headerlink" title="2.3 进程的管理（Process）"></a>2.3 进程的管理（Process）</h4><p><strong>NodeJs可以通过process来获取执行命令中传入的参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(argv)<br>&#125;<br><br><span class="hljs-title function_">main</span>(process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node 2.3-process.js argv1 argv2<br></code></pre></td></tr></table></figure><h4 id="2-4-网络通信（HTTP-HTTPS）"><a href="#2-4-网络通信（HTTP-HTTPS）" class="headerlink" title="2.4 网络通信（HTTP&#x2F;HTTPS）"></a>2.4 网络通信（HTTP&#x2F;HTTPS）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span><br>  &#125;)<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;hello nodejs&quot;</span>)<br>  res.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h1 id="二、Node-相关工具"><a href="#二、Node-相关工具" class="headerlink" title="二、Node 相关工具"></a>二、Node 相关工具</h1><h3 id="1、NVM-Node-Version-Manager"><a href="#1、NVM-Node-Version-Manager" class="headerlink" title="1、NVM: Node Version Manager"></a>1、NVM: Node Version Manager</h3><p><strong>1.1 Mac 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/nvm-sh/nvm/blob/master/README.md<br></code></pre></td></tr></table></figure><p><strong>1.2 Windows 安装 nvm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm-windows<br>nodist<br></code></pre></td></tr></table></figure><h3 id="2、NPM-Node-Package-Manager"><a href="#2、NPM-Node-Package-Manager" class="headerlink" title="2、NPM: Node Package Manager"></a>2、NPM: Node Package Manager</h3><h4 id="2-1-全局安装package"><a href="#2-1-全局安装package" class="headerlink" title="2.1 全局安装package"></a>2.1 全局安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install forever --global (-g)<br>$ forever<br>$ npm uninstall forever --global<br>$ forever<br></code></pre></td></tr></table></figure><p><strong>全局安装包的目录</strong></p><ul><li>Mac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Users/felix/.nvm/versions/node/nvm各个版本/bin/<br></code></pre></td></tr></table></figure></li><li>Windows<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\你的用户名\AppData\Roaming\npm\node_modules<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-本地安装package"><a href="#2-2-本地安装package" class="headerlink" title="2.2 本地安装package"></a>2.2 本地安装package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/desktop<br>$ <span class="hljs-built_in">mkdir</span> gp-project<br>$ <span class="hljs-built_in">cd</span> gp-project<br>$ npm install underscore<br>$ npm list (<span class="hljs-built_in">ls</span>)<br></code></pre></td></tr></table></figure><h4 id="2-3-package-json初始化"><a href="#2-3-package-json初始化" class="headerlink" title="2.3 package.json初始化"></a>2.3 package.json初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm init -y<br>$ <span class="hljs-built_in">ls</span><br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-4-使用package-json"><a href="#2-4-使用package-json" class="headerlink" title="2.4 使用package.json"></a>2.4 使用package.json</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install underscore --save<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ npm install lodash --save-dev<br>$ <span class="hljs-built_in">cat</span> package.json<br>$ <span class="hljs-built_in">rm</span> -rf node_modules<br>$ <span class="hljs-built_in">ls</span><br>$ npm install<br>$ npm uninstall underscore --save<br>$ npm list | grep underscore<br>$ <span class="hljs-built_in">cat</span> package.json<br></code></pre></td></tr></table></figure><h4 id="2-5-安装指定版本的包"><a href="#2-5-安装指定版本的包" class="headerlink" title="2.5 安装指定版本的包"></a>2.5 安装指定版本的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>$ npm list<br>$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.8.0<br>$ npm list<br>$ npm uninstall underscore<br>$ npm list<br></code></pre></td></tr></table></figure><h4 id="2-6-更新本地安装的包"><a href="#2-6-更新本地安装的包" class="headerlink" title="2.6 更新本地安装的包"></a>2.6 更新本地安装的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm info underscore<br>$ npm view underscore versions<br>$ npm install underscore@1.4.4 --save-dev<br>$ npm list | grep gulp<br>$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本<br>$ npm list | grep gulp<br>$ npm update<br></code></pre></td></tr></table></figure><h4 id="2-7-清除缓存"><a href="#2-7-清除缓存" class="headerlink" title="2.7 清除缓存"></a>2.7 清除缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h4 id="2-8-上传自己的包"><a href="#2-8-上传自己的包" class="headerlink" title="2.8 上传自己的包"></a>2.8 上传自己的包</h4><h6 id="2-8-1-编写模块"><a href="#2-8-1-编写模块" class="headerlink" title="2.8.1 编写模块"></a>2.8.1 编写模块</h6><p>保存为index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span>; <br>&#125; <br></code></pre></td></tr></table></figure><h6 id="2-8-2-初始化包描述文件"><a href="#2-8-2-初始化包描述文件" class="headerlink" title="2.8.2 初始化包描述文件"></a>2.8.2 初始化包描述文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init <br></code></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19-npm&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.1&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gp19 self module&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make test&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Git&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git+https://github.com/lurongtao/gp19-npm.git&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>    <span class="hljs-string">&quot;demo&quot;</span> <br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Felixlu&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm/issues&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/lurongtao/gp19-npm#readme&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><h6 id="2-8-3-注册npm仓库账号"><a href="#2-8-3-注册npm仓库账号" class="headerlink" title="2.8.3 注册npm仓库账号"></a>2.8.3 注册npm仓库账号</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://www.npmjs.com 上面的账号<br>felix_lurt/qqmko09ijn<br>$ npm adduser<br></code></pre></td></tr></table></figure><h6 id="2-8-4-上传包"><a href="#2-8-4-上传包" class="headerlink" title="2.8.4 上传包"></a>2.8.4 上传包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm publish<br></code></pre></td></tr></table></figure><p>坑：403 Forbidden</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看npm源：npm config get registry<br>切换npm源方法一：npm config <span class="hljs-built_in">set</span> registry http://registry.npmjs.org<br>切换npm源方法二：nrm use npm<br></code></pre></td></tr></table></figure><h6 id="2-8-5-安装包"><a href="#2-8-5-安装包" class="headerlink" title="2.8.5 安装包"></a>2.8.5 安装包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install gp19-npm<br></code></pre></td></tr></table></figure><h6 id="2-8-6-卸载包"><a href="#2-8-6-卸载包" class="headerlink" title="2.8.6 卸载包"></a>2.8.6 卸载包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看当前项目引用了哪些包 ：<br>npm <span class="hljs-built_in">ls</span><br>卸载包：<br>npm unpublish --force<br></code></pre></td></tr></table></figure><h6 id="2-8-7-使用引入包"><a href="#2-8-7-使用引入包" class="headerlink" title="2.8.7 使用引入包"></a>2.8.7 使用引入包</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gp19-npm&#x27;</span>)<br>hello.<span class="hljs-title function_">sayHello</span>()<br></code></pre></td></tr></table></figure><h4 id="2-9-npm-脚本"><a href="#2-9-npm-脚本" class="headerlink" title="2.9 npm 脚本"></a>2.9 npm 脚本</h4><p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。</p><p><strong>一、什么是 npm 脚本？</strong></p><p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node build.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>二、执行顺序</strong></p><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><p>script1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br></code></pre></td></tr></table></figure><p>script2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y)<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script1.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;script2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node script2.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果是并行执行（即同时的平行执行），可以使用 <code>&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp; npm run script2<br></code></pre></td></tr></table></figure><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用 <code>&amp;&amp;</code> 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm run script1 &amp;&amp; npm run script2<br></code></pre></td></tr></table></figure><p><strong>三、简写形式</strong></p><p>常用的 npm 脚本简写形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm start 是 npm run start<br></code></pre></td></tr></table></figure><p><strong>四、变量</strong></p><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p><p>首先，通过 <code>npm_package_</code> 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。</p><blockquote><p>注意：一定要在 npm 脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到值的</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.2.5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node view.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回 1.2.5。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// view.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>); <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>); <span class="hljs-comment">// 1.2.5</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用$npm_package_name 和 $npm_package_version 取到这两个值。</p><p>npm_package_前缀也支持嵌套的package.json字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>scripts<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_package_repository_type&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。</p><p>下面是另外一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_scripts_install 变量的值等于 foo.js。</p><p>然后，npm 脚本还可以通过 npm_config_ 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;view&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo $npm_config_tag&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>注意，package.json 里面的 config 对象，可以被环境变量覆盖。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;config&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;port&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;start&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node server.js&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，npm_package_config_port 变量返回的是 8080。这个值可以用下面的方法覆盖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> foo:port 80<br></code></pre></td></tr></table></figure><p>最后，env命令可以列出所有环境变量。</p><p>“env”: “env”</p><h4 id="2-10-npm-安装-git-上发布的包"><a href="#2-10-npm-安装-git-上发布的包" class="headerlink" title="2.10 npm 安装 git 上发布的包"></a>2.10 npm 安装 git 上发布的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这样适合安装公司内部的git服务器上的项目</span><br>npm install git+https://git@github.com:lurongtao/gp-project.git<br><br><span class="hljs-comment"># 或者以ssh的方式</span><br>npm install git+ssh://git@github.com:lurongtao/gp-project.git<br></code></pre></td></tr></table></figure><h4 id="2-11-cross-env-使用"><a href="#2-11-cross-env-使用" class="headerlink" title="2.11 cross-env 使用"></a>2.11 cross-env 使用</h4><h5 id="2-11-1-cross-env是什么"><a href="#2-11-1-cross-env是什么" class="headerlink" title="2.11.1 cross-env是什么"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p><h5 id="2-11-2-出现原因"><a href="#2-11-2-出现原因" class="headerlink" title="2.11.2 出现原因"></a>2.11.2 出现原因</h5><p>当您使用 NODE_ENV&#x3D;production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows 不支持 NODE_ENV&#x3D;production 的设置方式。</p><h5 id="2-11-3-解决"><a href="#2-11-3-解决" class="headerlink" title="2.11.3 解决"></a>2.11.3 解决</h5><p>cross-env 使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包(cross-env)能够提供一个设置环境变量的 scripts，让你能够以 Unix 方式设置环境变量，然后在 Windows 上也能兼容运行。</p><h5 id="2-11-4-安装"><a href="#2-11-4-安装" class="headerlink" title="2.11.4 安装"></a>2.11.4 安装</h5><p>npm install –save-dev cross-env</p><h5 id="2-11-5-使用"><a href="#2-11-5-使用" class="headerlink" title="2.11.5 使用"></a>2.11.5 使用</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>NODE_ENV环境变量将由 cross-env 设置<br>打印 process.env.NODE_ENV &#x3D;&#x3D;&#x3D; ‘production’</p><h3 id="3、NRM-npm-registry-manager"><a href="#3、NRM-npm-registry-manager" class="headerlink" title="3、NRM: npm registry manager"></a>3、NRM: npm registry manager</h3><h4 id="3-1-手工切换源"><a href="#3-1-手工切换源" class="headerlink" title="3.1 手工切换源"></a>3.1 手工切换源</h4><h5 id="3-1-1-查看当前源"><a href="#3-1-1-查看当前源" class="headerlink" title="3.1.1 查看当前源"></a>3.1.1 查看当前源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h5 id="3-1-2-切换淘宝源"><a href="#3-1-2-切换淘宝源" class="headerlink" title="3.1.2 切换淘宝源"></a>3.1.2 切换淘宝源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h4 id="3-2-NRM-管理源"><a href="#3-2-NRM-管理源" class="headerlink" title="3.2 NRM 管理源"></a>3.2 NRM 管理源</h4><p>NRM (npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h5 id="3-2-1-安装-nrm"><a href="#3-2-1-安装-nrm" class="headerlink" title="3.2.1 安装 nrm"></a>3.2.1 安装 nrm</h5><p>在命令行执行命令，npm install -g nrm，全局安装nrm。</p><h5 id="3-2-2-使用-nrm"><a href="#3-2-2-使用-nrm" class="headerlink" title="3.2.2 使用 nrm"></a>3.2.2 使用 nrm</h5><p>执行命令 nrm ls 查看可选的源。<br>其中，带*的是当前使用的源，上面的输出表明当前源是官方源。</p><h5 id="3-2-3-切换-nrm"><a href="#3-2-3-切换-nrm" class="headerlink" title="3.2.3 切换 nrm"></a>3.2.3 切换 nrm</h5><p>如果要切换到taobao源，执行命令nrm use taobao。</p><h5 id="3-2-4-测试速度"><a href="#3-2-4-测试速度" class="headerlink" title="3.2.4 测试速度"></a>3.2.4 测试速度</h5><p>你还可以通过 nrm test 测试相应源的响应时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nrm <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="4、NPX-npm-package-extention"><a href="#4、NPX-npm-package-extention" class="headerlink" title="4、NPX: npm package extention"></a>4、NPX: npm package extention</h3><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g npx<br></code></pre></td></tr></table></figure><h4 id="4-1-调用项目安装的模块"><a href="#4-1-调用项目安装的模块" class="headerlink" title="4.1 调用项目安装的模块"></a>4.1 调用项目安装的模块</h4><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -D mocha<br></code></pre></td></tr></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 项目的根目录下执行</span><br>$ <span class="hljs-keyword">node</span><span class="hljs-title">-modules</span>/.bin/mocha --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx mocha <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>npx 的原理很简单，就是运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于 <span class="hljs-built_in">ls</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npx <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。</p><h4 id="4-2-避免全局安装模块"><a href="#4-2-避免全局安装模块" class="headerlink" title="4.2 避免全局安装模块"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app 这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">npx</span> <span class="hljs-built_in">create-react-app</span> <span class="hljs-string">my-react-app</span><br></code></pre></td></tr></table></figure><p>上面代码运行时，npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ npx http-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="4-3-–no-install-参数和-–ignore-existing-参数"><a href="#4-3-–no-install-参数和-–ignore-existing-参数" class="headerlink" title="4.3 –no-install 参数和 –ignore-existing 参数"></a>4.3 –no-install 参数和 –ignore-existing 参数</h4><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> npx --<span class="hljs-keyword">no</span>-install http-server<br></code></pre></td></tr></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npx <span class="hljs-comment">--ignore-existing http-server</span><br></code></pre></td></tr></table></figure><h1 id="三、模块-包-与-CommonJS"><a href="#三、模块-包-与-CommonJS" class="headerlink" title="三、模块&#x2F;包 与 CommonJS"></a>三、模块&#x2F;包 与 CommonJS</h1><h3 id="1、模块-包分类"><a href="#1、模块-包分类" class="headerlink" title="1、模块&#x2F;包分类"></a>1、模块&#x2F;包分类</h3><p>Node.js 有三类模块，即内置的模块、第三方的模块、自定义的模块。</p><h4 id="1-1-内置的模块"><a href="#1-1-内置的模块" class="headerlink" title="1.1 内置的模块"></a>1.1 内置的模块</h4><p>Node.js 内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> extname = path.<span class="hljs-title function_">extname</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(extname)<br></code></pre></td></tr></table></figure><h4 id="1-2-第三方的Node-js模块"><a href="#1-2-第三方的Node-js模块" class="headerlink" title="1.2 第三方的Node.js模块"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> chalk<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chalk&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">blue</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="1-3-自定义的Node-js模块"><a href="#1-3-自定义的Node-js模块" class="headerlink" title="1.3 自定义的Node.js模块"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p><p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p><h5 id="1-3-1-模块定义、接口暴露和引用接口"><a href="#1-3-1-模块定义、接口暴露和引用接口" class="headerlink" title="1.3.1 模块定义、接口暴露和引用接口"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能 抽离成为一个单独的 js  文件 作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。</p><p>m1.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;gp19&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayName</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module 1&#x27;</span>)<br><br><span class="hljs-comment">// 接口暴露方法一：</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br><br><span class="hljs-comment">// 接口暴露方法二：</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">say</span> = sayName<br><br><span class="hljs-comment">// 错误！</span><br><span class="hljs-built_in">exports</span> = &#123;<br>  <span class="hljs-attr">say</span>: sayName<br>&#125;<br></code></pre></td></tr></table></figure><p>main.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./m1&#x27;</span>)<br>m1.<span class="hljs-title function_">say</span>()<br></code></pre></td></tr></table></figure><h5 id="1-3-2-模块的循环引用"><a href="#1-3-2-模块的循环引用" class="headerlink" title="1.3.2 模块的循环引用"></a>1.3.2 模块的循环引用</h5><p>由于 exports 使用方式方式不对，会在两个不同 js 循环引用的情况下，导致其中一个 js 无法获取另外一个 js 的方法，从而导致执行报错。如：</p><ul><li>a.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in a, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>b.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b starting&#x27;</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in b, a.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;main starting&#x27;</span>)<br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in main, a.done = %j, b.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>, b.<span class="hljs-property">done</span>)<br></code></pre></td></tr></table></figure><p>main.js 首先会 load a.js, 此时执行到const b &#x3D; require(‘.&#x2F;b.js’);的时候，程序会转去loadb.js, 在b.js中执行到const a &#x3D; require(‘.&#x2F;a.js’); 为了防止无限循环，将a.jsexports的未完成副本返回到b.js模块。然后b.js完成加载，并将其导出对象提供给a.js模块。</p><p>我们知道nodeJs的对每个js文件进行了一层包装称为module，module中有一个属性exports，当调用require(‘a.js’)的时候其实返回的是module.exports对象，module.exports初始化为一个{}空的object，所以在上面的例子中，执行到b.js中const a &#x3D; require(‘.&#x2F;a.js’);时不会load新的a module, 而是将已经load但是还未完成的a module的exports属性返回给b module，所以b.js拿到的是a module的exports对象，即：{done:false}, 虽然在a.js中exports.done被修改成了true，但是由于此时a.js未load完成，所以在b.js输出的a module的属性done为false，而在main.js中输出的a module的属性done为true. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。 </p><h1 id="四、常用内置模块"><a href="#四、常用内置模块" class="headerlink" title="四、常用内置模块"></a>四、常用内置模块</h1><p>这里介绍几个常用的内置模块：url, querystring, http, events, fs, stream, readline, crypto, zlib</p><h3 id="1、url"><a href="#1、url" class="headerlink" title="1、url"></a>1、url</h3><h4 id="1-1-parse"><a href="#1-1-parse" class="headerlink" title="1.1 parse"></a>1.1 parse</h4><p>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlString = <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br><span class="hljs-keyword">const</span> parsedStr = url.<span class="hljs-title function_">parse</span>(urlString)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedStr)<br></code></pre></td></tr></table></figure><h4 id="1-2-format"><a href="#1-2-format" class="headerlink" title="1.2 format"></a>1.2 format</h4><p>url.format(urlObject)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> urlObject = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">slashes</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">auth</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;www.baidu.com:443&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;443&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;www.baidu.com&#x27;</span>,<br>  <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#tag=110&#x27;</span>,<br>  <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mouse&#x27;</span> &#125;,<br>  <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/ad/index.html&#x27;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/ad/index.html?id=8&amp;name=mouse&#x27;</span>,<br>  <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> parsedObj = url.<span class="hljs-title function_">format</span>(urlObject)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedObj)<br></code></pre></td></tr></table></figure><h4 id="1-3-resolve"><a href="#1-3-resolve" class="headerlink" title="1.3 resolve"></a>1.3 resolve</h4><p>url.resolve(from, to)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">var</span> a = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/one/two/three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>)<br><span class="hljs-keyword">var</span> b = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/&#x27;</span>, <span class="hljs-string">&#x27;/one&#x27;</span>)<br><span class="hljs-keyword">var</span> c = url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;http://example.com/one&#x27;</span>, <span class="hljs-string">&#x27;/two&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-string">&quot;,&quot;</span> + b + <span class="hljs-string">&quot;,&quot;</span> + c)<br></code></pre></td></tr></table></figure><h3 id="2、querystring"><a href="#2、querystring" class="headerlink" title="2、querystring"></a>2、querystring</h3><h4 id="2-1-parse"><a href="#2-1-parse" class="headerlink" title="2.1 parse"></a>2.1 parse</h4><p>querystring.parse(str[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qs = <span class="hljs-string">&#x27;x=3&amp;y=4&#x27;</span><br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">parse</span>(qs)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-2-stringify"><a href="#2-2-stringify" class="headerlink" title="2.2 stringify"></a>2.2 stringify</h4><p>querystring.stringify(obj[, sep[, eq[, options]]])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> qo = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">var</span> parsed = querystring.<span class="hljs-title function_">stringify</span>(qo)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)<br></code></pre></td></tr></table></figure><h4 id="2-3-escape-unescape"><a href="#2-3-escape-unescape" class="headerlink" title="2.3 escape&#x2F;unescape"></a>2.3 escape&#x2F;unescape</h4><p>querystring.escape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id=3&amp;city=北京&amp;url=https://www.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> escaped = querystring.<span class="hljs-built_in">escape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(escaped)<br></code></pre></td></tr></table></figure><p>querystring.unescape(str)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#x27;</span><br><span class="hljs-keyword">var</span> unescaped = querystring.<span class="hljs-built_in">unescape</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unescaped)<br></code></pre></td></tr></table></figure><h3 id="3、http-https"><a href="#3、http-https" class="headerlink" title="3、http&#x2F;https"></a>3、http&#x2F;https</h3><h4 id="3-1-get"><a href="#3-1-get" class="headerlink" title="3.1 get"></a>3.1 get</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><br><span class="hljs-comment">// 1、接口 2、跨域</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">var</span> url = request.<span class="hljs-property">url</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br>  <br>  <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;&#x27;</span><br><br>  response.<span class="hljs-title function_">writeHeader</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  https.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://m.lagou.com/listmore.json<span class="hljs-subst">$&#123;url&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>        <span class="hljs-attr">ret</span>: <span class="hljs-literal">true</span>,<br>        data<br>      &#125;))<br>    &#125;)<br>  &#125;)<br><br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-post：服务器提交（攻击）"><a href="#3-2-post：服务器提交（攻击）" class="headerlink" title="3.2 post：服务器提交（攻击）"></a>3.2 post：服务器提交（攻击）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> postData = querystring.<span class="hljs-title function_">stringify</span>(&#123;<br>  <span class="hljs-attr">province</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;上海&#x27;</span>,<br>  <span class="hljs-attr">district</span>: <span class="hljs-string">&#x27;宝山区&#x27;</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;同济支路199号智慧七立方3号楼2-4层&#x27;</span>,<br>  <span class="hljs-attr">latitude</span>: <span class="hljs-number">43.0</span>,<br>  <span class="hljs-attr">longitude</span>: <span class="hljs-number">160.0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;求购一条小鱼&#x27;</span>,<br>  <span class="hljs-attr">contact</span>: <span class="hljs-string">&#x27;13666666&#x27;</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>  <span class="hljs-attr">time</span>: <span class="hljs-number">1571217561</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;ik9hkddr.qcloud.la&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index.php/trade/add_item&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(postData)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doPost</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> data<br>  <br>  <span class="hljs-keyword">let</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> data += chunk)<br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  req.<span class="hljs-title function_">write</span>(postData)<br>  req.<span class="hljs-title function_">end</span>()<br>&#125;<br><br><span class="hljs-comment">// setInterval(() =&gt; &#123;</span><br><span class="hljs-comment">//   doPost()</span><br><span class="hljs-comment">// &#125;, 1000)</span><br></code></pre></td></tr></table></figure><h4 id="3-3-跨域：jsonp"><a href="#3-3-跨域：jsonp" class="headerlink" title="3.3 跨域：jsonp"></a>3.3 跨域：jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/user&#x27;</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;urlObj.query.cb&#125;</span>(&#123;&quot;name&quot;: &quot;gp145&quot;&#125;)`</span>)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-4-跨域：CORS"><a href="#3-4-跨域：CORS" class="headerlink" title="3.4 跨域：CORS"></a>3.4 跨域：CORS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">let</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    data += chunk<br>  &#125;)<br><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">responseResult</span>(querystring.<span class="hljs-title function_">parse</span>(data))<br>  &#125;)<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">responseResult</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (urlObj.<span class="hljs-property">pathname</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/api/login&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>          <span class="hljs-attr">message</span>: data<br>        &#125;))<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404.&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localhost:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-5-跨域：middleware（http-proxy-middware）"><a href="#3-5-跨域：middleware（http-proxy-middware）" class="headerlink" title="3.5 跨域：middleware（http-proxy-middware）"></a>3.5 跨域：middleware（http-proxy-middware）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> url = req.<span class="hljs-property">url</span><br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\/api/</span>.<span class="hljs-title function_">test</span>(url)) &#123;<br>    <span class="hljs-keyword">let</span> apiProxy = <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123; <br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://m.lagou.com&#x27;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;)<br>  <br>    <span class="hljs-comment">// http-proy-middleware 在Node.js中使用的方法</span><br>    <span class="hljs-title function_">apiProxy</span>(req, res)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">switch</span> (url) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/search.html&#x27;</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;search.html&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;[404]page not found.&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>)<br></code></pre></td></tr></table></figure><h4 id="3-6-爬虫"><a href="#3-6-爬虫" class="headerlink" title="3.6 爬虫"></a>3.6 爬虫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>)<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> options = &#123;<br>    <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https:&#x27;</span>,<br>    <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;maoyan.com&#x27;</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> req = https.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span><br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>      data += chunk<br>    &#125;)<br>  <br>    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">filterData</span>(data)<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterData</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> $ = cheerio.<span class="hljs-title function_">load</span>(data)<br>    <span class="hljs-keyword">let</span> $movieList = $(<span class="hljs-string">&#x27;.movie-item&#x27;</span>)<br>    <span class="hljs-keyword">let</span> movies = []<br>    $movieList.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, value</span>) =&gt;</span> &#123;<br>      movies.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">title</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-title&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;title&#x27;</span>),<br>        <span class="hljs-attr">score</span>: $(value).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.movie-score i&#x27;</span>).<span class="hljs-title function_">text</span>(),<br>      &#125;)<br>    &#125;)<br>    <br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(movies))<br>  &#125;<br>  <br>  req.<span class="hljs-title function_">end</span>()<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9000</span>)<br></code></pre></td></tr></table></figure><h3 id="4、Events"><a href="#4、Events" class="headerlink" title="4、Events"></a>4、Events</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEventEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEventEmitter</span>()<br><br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">movie</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movie)<br>&#125;)<br><br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;我和我的祖国&#x27;</span>)<br>event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;中国机长&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="5、File-System"><a href="#5、File-System" class="headerlink" title="5、File System"></a>5、File System</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> fsP = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-property">promises</span><br><br><span class="hljs-comment">// 创建文件夹</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 文件夹改名</span><br>fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./logs&#x27;</span>, <span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件夹</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./log&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 写内容到文件里</span><br>fs.<span class="hljs-title function_">writeFile</span>(<br>  <span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>,<br>  <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  <span class="hljs-comment">// 错误优先的回调函数</span><br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件创建成功&#x27;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-comment">// 给文件追加内容</span><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;\nworld&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 读取文件内容</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br><br><span class="hljs-comment">// 删除文件</span><br>fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./logs/log1.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 批量写文件</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">`./logs/log-<span class="hljs-subst">$&#123;i&#125;</span>.txt`</span>, <span class="hljs-string">`log-<span class="hljs-subst">$&#123;i&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done.&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 读取文件/目录信息</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;value&#125;</span>`</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// console.log(value + &#x27;:&#x27; + stats.size)</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value + <span class="hljs-string">&#x27; is &#x27;</span> + (stats.<span class="hljs-title function_">isDirectory</span>() ? <span class="hljs-string">&#x27;directory&#x27;</span> : <span class="hljs-string">&#x27;file&#x27;</span>))<br>    &#125;)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 同步读取文件</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">message</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法一</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 异步读取文件：方法二</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-comment">// 异步读取文件：方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>;(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">getFile</span>())<br>&#125;)()<br><br><span class="hljs-comment">// 异步读取文件：方法四</span><br><span class="hljs-keyword">const</span> fsp = fsP.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./logs/log-1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fsP)<br><br><span class="hljs-comment">// watch 监测文件变化</span><br>fs.<span class="hljs-title function_">watch</span>(<span class="hljs-string">&#x27;./logs/log-0.txt&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6、Stream"><a href="#6、Stream" class="headerlink" title="6、Stream"></a>6、Stream</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="7、Zlib"><a href="#7、Zlib" class="headerlink" title="7、Zlib"></a>7、Zlib</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zlib&#x27;</span>)<br><br><span class="hljs-keyword">const</span> gzip = zlib.<span class="hljs-title function_">createGzip</span>()<br><br><span class="hljs-keyword">const</span> readstream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./note.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> writestream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./note2.txt&#x27;</span>)<br><br>readstream<br>  .<span class="hljs-title function_">pipe</span>(gzip)<br>  .<span class="hljs-title function_">pipe</span>(writestream)<br><br>writestream.<span class="hljs-title function_">write</span>(readstream)<br></code></pre></td></tr></table></figure><h3 id="8、ReadLine"><a href="#8、ReadLine" class="headerlink" title="8、ReadLine"></a>8、ReadLine</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;readline&#x27;</span>)<br><br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span><br>&#125;)<br><br>rl.<span class="hljs-title function_">question</span>(<span class="hljs-string">&#x27;What do you think of Node.js? &#x27;</span>, <span class="hljs-function">(<span class="hljs-params">answer</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Log the answer in a database</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Thank you for your valuable feedback: <span class="hljs-subst">$&#123;answer&#125;</span>`</span>)<br><br>  rl.<span class="hljs-title function_">close</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9、Crypto"><a href="#9、Crypto" class="headerlink" title="9、Crypto"></a>9、Crypto</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&#x27;abcdefg&#x27;</span><br><span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, secret)<br>                   .<span class="hljs-title function_">update</span>(<span class="hljs-string">&#x27;I love you&#x27;</span>)<br>                   .<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash)<br></code></pre></td></tr></table></figure><h1 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>http.<span class="hljs-title function_">createServer</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> req, res </span>) &#123;<br><br>  <span class="hljs-keyword">switch</span> ( req.<span class="hljs-property">url</span> ) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/home&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;home&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/mine&#x27;</span>:<br>      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;mine&#x27;</span>)<br>      res.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/login&#x27;</span>: <br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/login.html&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span> ( error ) <span class="hljs-keyword">throw</span> error  <br>        res.<span class="hljs-title function_">write</span>( data )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/fulian.jpg&#x27;</span>:<br>      fs.<span class="hljs-title function_">readFile</span>( <span class="hljs-string">&#x27;./static/fulian.jpg&#x27;</span>, <span class="hljs-string">&#x27;binary&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"> error , data </span>) &#123;<br>        <span class="hljs-keyword">if</span>( error ) <span class="hljs-keyword">throw</span> error <br>        res.<span class="hljs-title function_">write</span>( data, <span class="hljs-string">&#x27;binary&#x27;</span> )<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>: <br>      <span class="hljs-keyword">break</span><br>   &#125;<br><br> &#125;).<span class="hljs-title function_">listen</span>( <span class="hljs-number">8000</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;服务器运行在： http://localhost:8000&#x27;</span> )<br> &#125;)<br></code></pre></td></tr></table></figure><h1 id="五、静态资源服务"><a href="#五、静态资源服务" class="headerlink" title="五、静态资源服务"></a>五、静态资源服务</h1><h3 id="5-1-readStaticFile"><a href="#5-1-readStaticFile" class="headerlink" title="5.1 readStaticFile"></a>5.1 readStaticFile</h3><p>&#x2F;modules&#x2F;readStaticFile.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入依赖的模块</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">var</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mime&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readStaticFile</span>(<span class="hljs-params">res, filePathname</span>) &#123;<br><br>  <span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">parse</span>(filePathname).<span class="hljs-property">ext</span><br>  <span class="hljs-keyword">var</span> mimeType = mime.<span class="hljs-title function_">getType</span>(ext)<br><br>  <span class="hljs-comment">// 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 </span><br>  <span class="hljs-keyword">if</span> (ext) &#123;<br>    <span class="hljs-comment">// 根据传入的目标文件路径来读取对应文件</span><br>    fs.<span class="hljs-title function_">readFile</span>(filePathname, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;)<br>        res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;404 - NOT FOUND&quot;</span>)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: mimeType &#125;)<br>        res.<span class="hljs-title function_">write</span>(data)<br>        res.<span class="hljs-title function_">end</span>()<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 返回 true 表示, 客户端想要的 是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 返回 false 表示, 客户端想要的 不是 静态文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = readStaticFile<br></code></pre></td></tr></table></figure><h3 id="5-2-server"><a href="#5-2-server" class="headerlink" title="5.2 server"></a>5.2 server</h3><p>&#x2F;server.js </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入相关模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">var</span> readStaticFile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/readStaticFile&#x27;</span>);<br><br><span class="hljs-comment">// 搭建 HTTP 服务器</span><br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">var</span> urlObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>);<br>  <span class="hljs-keyword">var</span> urlPathname = urlObj.<span class="hljs-property">pathname</span>;<br>  <span class="hljs-keyword">var</span> filePathname = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/public&quot;</span>, urlPathname);<br><br>  <span class="hljs-comment">// 读取静态文件</span><br>  <span class="hljs-title function_">readStaticFile</span>(res, filePathname);<br>&#125;);<br><br><span class="hljs-comment">// 在 3000 端口监听请求</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器运行中.&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;正在监听 3000 端口:&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NPM详解-从基础到高级的全面教程</title>
    <link href="/posts/46482/"/>
    <url>/posts/46482/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-详解：从基础到高级的全面教程"><a href="#NPM-详解：从基础到高级的全面教程" class="headerlink" title="NPM 详解：从基础到高级的全面教程"></a>NPM 详解：从基础到高级的全面教程</h1><p>NPM (Node Package Manager) 是 Node.js 的默认包管理工具，用于管理项目中的依赖包。作为前端开发和后端开发的重要工具，NPM 的作用不仅仅是安装包，它还包含很多实用的功能，如版本管理、脚本执行和发布包等。在这篇文章中，我们将深入探讨 NPM 的各个方面，帮助你从基础知识开始，到掌握一些高级用法。</p><h1 id="1-NPM-的基础知识"><a href="#1-NPM-的基础知识" class="headerlink" title="1. NPM 的基础知识"></a>1. NPM 的基础知识</h1><h2 id="1-1-什么是-NPM？"><a href="#1-1-什么是-NPM？" class="headerlink" title="1.1 什么是 NPM？"></a>1.1 什么是 NPM？</h2><p>NPM 是 Node.js 的包管理工具，它允许开发者从 NPM 的注册库中下载和分享代码包。NPM 解决了依赖管理问题，使得开发者不必重复造轮子，可以直接安装他人写好的功能模块。</p><ul><li><strong>Registry</strong>: NPM 注册库中存储了海量的开源包。</li><li><strong>Package</strong>: 每个 NPM 包都是一个独立的模块，通常包含一个 <code>package.json</code> 文件，用于描述包的信息和依赖关系。</li></ul><h2 id="1-2-NPM-的安装与配置"><a href="#1-2-NPM-的安装与配置" class="headerlink" title="1.2 NPM 的安装与配置"></a>1.2 NPM 的安装与配置</h2><p>Node.js 安装包中已经包含了 NPM，因此只要安装了 Node.js，就可以使用 NPM。你可以通过以下命令查看 NPM 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm -v<br></code></pre></td></tr></table></figure><p>可以通过 <code>npm config</code> 来查看或设置 NPM 的全局配置。常见的配置有：</p><ul><li><strong>设置 NPM 源</strong>：可以设置使用国内镜像源，如 <code>淘宝镜像</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><ul><li><strong>查看配置</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config list<br></code></pre></td></tr></table></figure><h1 id="2-package-json"><a href="#2-package-json" class="headerlink" title="2.package.json"></a>2.package.json</h1><p><code>package.json</code> 文件是 Node.js 项目的核心配置文件，它记录了项目的元信息和依赖包。我们可以通过 <code>npm init</code> 来创建一个新的 <code>package.json</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br></code></pre></td></tr></table></figure><p>常见字段包括：</p><ul><li><code>name</code>: 项目名称。</li><li><code>version</code>: 项目版本。</li><li><code>scripts</code>: 项目脚本，便于执行一些常见的任务。</li><li><code>dependencies</code>: 项目的运行时依赖包。</li><li><code>devDependencies</code>: 项目的开发时依赖包。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-package-json-的核心字段"><a href="#2-1-package-json-的核心字段" class="headerlink" title="2.1 package.json 的核心字段"></a>2.1 package.json 的核心字段</h2><h3 id="2-1-1-name-包名"><a href="#2-1-1-name-包名" class="headerlink" title="2.1.1 name (包名)"></a>2.1.1 <code>name</code> (包名)</h3><p><code>name</code> 定义了项目的名称。这个名称必须唯一，且在 NPM 注册库中有效。</p><ul><li><p>要求</p><p>：</p><ul><li>必须是小写字母，允许包含连字符（<code>-</code>）或下划线（<code>_</code>）。</li><li>长度应少于 214 个字符。</li><li>不能以 <code>.</code> 或 <code>_</code> 开头。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-version-版本号"><a href="#2-1-2-version-版本号" class="headerlink" title="2.1.2 version (版本号)"></a>2.1.2 <code>version</code> (版本号)</h3><p><code>version</code> 字段遵循 语义化版本规范（SemVer），表示当前包的版本号。常见的版本号格式为 <code>x.y.z</code>：</p><ul><li><code>x</code>: 主版本号，非兼容性 API 变更。</li><li><code>y</code>: 次版本号，向下兼容的新功能。</li><li><code>z</code>: 修订号，向下兼容的错误修复。</li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-3-description-描述"><a href="#2-1-3-description-描述" class="headerlink" title="2.1.3 description (描述)"></a>2.1.3 <code>description</code> (描述)</h3><p><code>description</code> 用于提供包的简短描述，通常会显示在 NPM 页面上，帮助用户快速了解包的功能。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample Node.js project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-4-keywords-关键词"><a href="#2-1-4-keywords-关键词" class="headerlink" title="2.1.4 keywords (关键词)"></a>2.1.4 <code>keywords</code> (关键词)</h3><p><code>keywords</code> 字段是一个字符串数组，帮助开发者通过关键词在 NPM 上搜索到这个包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;API&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-5-homepage-主页"><a href="#2-1-5-homepage-主页" class="headerlink" title="2.1.5 homepage (主页)"></a>2.1.5 <code>homepage</code> (主页)</h3><p>定义项目的主页 URL，通常是项目的官方文档或 GitHub 页面。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-6-license-许可证"><a href="#2-1-6-license-许可证" class="headerlink" title="2.1.6 license (许可证)"></a>2.1.6 <code>license</code> (许可证)</h3><p><code>license</code> 表示项目的许可证类型，用来告知用户如何合法使用代码。常见的值如：<code>MIT</code>、<code>ISC</code>、<code>GPL-3.0</code> 等。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-7-author-作者"><a href="#2-1-7-author-作者" class="headerlink" title="2.1.7 author (作者)"></a>2.1.7 <code>author</code> (作者)</h3><p><code>author</code> 用来描述包的作者信息，可以是一个简单的字符串，也可以包括更多的详细信息。</p><ul><li><strong>简单形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>详细形式</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john@example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://john.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-8-contributors-贡献者"><a href="#2-1-8-contributors-贡献者" class="headerlink" title="2.1.8 contributors (贡献者)"></a>2.1.8 <code>contributors</code> (贡献者)</h3><p>这个字段记录了项目的贡献者，形式与 <code>author</code> 类似，可以包含多个人。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;contributors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane Smith&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jane@example.com&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-依赖管理"><a href="#2-2-依赖管理" class="headerlink" title="2.2 依赖管理"></a>2.2 依赖管理</h2><h3 id="2-2-1-dependencies-运行时依赖"><a href="#2-2-1-dependencies-运行时依赖" class="headerlink" title="2.2.1 dependencies (运行时依赖)"></a>2.2.1 <code>dependencies</code> (运行时依赖)</h3><p><code>dependencies</code> 用于定义项目在运行时所依赖的包。NPM 会根据此字段安装这些依赖。</p><ul><li><strong>格式</strong>：<code>包名: 版本范围</code></li><li><strong>版本范围符号</strong>：<ul><li><code>^1.0.0</code>：允许安装 1.x.x 的任何更新。</li><li><code>~1.0.0</code>：允许安装 1.0.x 的更新。</li><li><code>1.0.0</code>：锁定版本，不允许更新。</li><li><code>*</code>：任何版本。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-2-devDependencies-开发时依赖"><a href="#2-2-2-devDependencies-开发时依赖" class="headerlink" title="2.2.2 devDependencies (开发时依赖)"></a>2.2.2 <code>devDependencies</code> (开发时依赖)</h3><p><code>devDependencies</code> 记录的是仅在开发环境下需要的依赖包，比如测试框架、构建工具等。这些依赖不会在生产环境中安装。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-3-peerDependencies-同伴依赖"><a href="#2-2-3-peerDependencies-同伴依赖" class="headerlink" title="2.2.3 peerDependencies (同伴依赖)"></a>2.2.3 <code>peerDependencies</code> (同伴依赖)</h3><p><code>peerDependencies</code> 用于定义包与项目的兼容性要求，常用于插件开发，要求项目必须安装特定版本的某些包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;peerDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=16.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-4-optionalDependencies-可选依赖"><a href="#2-2-4-optionalDependencies-可选依赖" class="headerlink" title="2.2.4 optionalDependencies (可选依赖)"></a>2.2.4 <code>optionalDependencies</code> (可选依赖)</h3><p><code>optionalDependencies</code> 表示非强制安装的依赖，如果安装失败，项目依然可以继续运行。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;optionalDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fsevents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-bundledDependencies-打包依赖"><a href="#2-2-5-bundledDependencies-打包依赖" class="headerlink" title="2.2.5 bundledDependencies (打包依赖)"></a>2.2.5 <code>bundledDependencies</code> (打包依赖)</h3><p><code>bundledDependencies</code> 表示需要一起打包发布的依赖包。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bundledDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;lodash&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-NPM-脚本-scripts"><a href="#2-3-NPM-脚本-scripts" class="headerlink" title="2.3 NPM 脚本 (scripts)"></a>2.3 NPM 脚本 (<code>scripts</code>)</h2><p><code>scripts</code> 字段可以定义各种自定义命令和自动化任务。每个脚本可以通过 <code>npm run &lt;script&gt;</code> 来运行。</p><h3 id="2-3-1-基本脚本"><a href="#2-3-1-基本脚本" class="headerlink" title="2.3.1 基本脚本"></a>2.3.1 基本脚本</h3><ul><li><strong>start</strong>：默认启动脚本。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test</strong>：通常用于执行测试。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-自定义脚本"><a href="#2-3-2-自定义脚本" class="headerlink" title="2.3.2 自定义脚本"></a>2.3.2 自定义脚本</h3><p>你可以定义任意名称的脚本，并通过 <code>npm run &lt;script-name&gt;</code> 执行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-4-使用变量"><a href="#2-4-使用变量" class="headerlink" title="2.4 使用变量"></a>2.4 使用变量</h2><p>NPM 允许在脚本中使用变量，如环境变量。通常通过 <code>process.env</code> 读取：</p><ul><li><strong>在脚本中使用环境变量</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>跨平台支持</strong>：为了兼容 Windows 系统，使用 <a href="https://www.npmjs.com/package/cross-env">cross-env</a> 包来设置环境变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install cross-env --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production node app.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=development node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>NODE_ENV=production node app.js</code> 这条命令主要用于设置环境变量 <code>NODE_ENV</code> 并运行应用程序。具体拆解如下：</p><ol><li><p>**<code>NODE_ENV=production</code>**：</p><ul><li>这部分用于设置 <code>NODE_ENV</code> 环境变量的值为 <code>production</code>。<code>NODE_ENV</code> 是 Node.js 应用中常见的一个环境变量，表示应用当前的运行环境。</li><li>通常有以下几种值：<ul><li><code>development</code>：开发环境，用于本地调试、测试。</li><li><code>production</code>：生产环境，用于发布和正式运行。</li><li><code>test</code>：测试环境，用于自动化测试。</li></ul></li></ul><p>在不同的 <code>NODE_ENV</code> 下，代码通常会有不同的行为。比如：</p><ul><li>在开发环境中，可能会启用更多的日志输出、调试功能等。</li><li>在生产环境中，可能会禁用调试功能、启用性能优化等。</li></ul></li><li><p>**<code>node app.js</code>**：</p><ul><li>这部分用于启动 Node.js 应用，运行 <code>app.js</code> 文件。<code>node</code> 是运行 Node.js 脚本的命令，后面的 <code>app.js</code> 是需要执行的 JavaScript 文件。</li></ul><p>因此，整条命令的含义是：在生产环境下执行 <code>app.js</code> 文件。</p></li></ol><p><strong>作用</strong></p><p>通过设置 <code>NODE_ENV</code>，你可以控制应用程序的运行模式。例如，在 <code>production</code> 环境中，很多框架和库（如 Express、React 等）会根据 <code>NODE_ENV</code> 来优化性能和行为，以确保更高的运行效率和安全性。</p><p><strong>举例</strong></p><p>在 Express.js 应用中，使用 <code>NODE_ENV</code> 可以区分开发模式和生产模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 生产环境中的逻辑，比如启用压缩、禁用详细日志等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">compression</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 开发环境中的逻辑，比如启用详细日志、错误提示等</span><br>  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">morgan</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置 <code>NODE_ENV=production</code>，代码会执行生产环境的逻辑。</p><h3 id="2-4-1-npm-package-环境变量"><a href="#2-4-1-npm-package-环境变量" class="headerlink" title="2.4.1 npm_package_* 环境变量"></a>2.4.1 <code>npm_package_*</code> 环境变量</h3><p>这些变量基于 <code>package.json</code> 文件中的字段生成，能够直接访问项目的配置信息。</p><p><strong>常用字段：</strong></p><ul><li><code>npm_package_name</code>：项目名称（<code>package.json</code> 中的 <code>name</code> 字段）</li><li><code>npm_package_version</code>：项目版本（<code>package.json</code> 中的 <code>version</code> 字段）</li><li><code>npm_package_description</code>：项目描述（<code>package.json</code> 中的 <code>description</code> 字段）</li><li><code>npm_package_author</code>：项目作者（<code>package.json</code> 中的 <code>author</code> 字段）</li><li><code>npm_package_license</code>：项目的许可证类型（<code>package.json</code> 中的 <code>license</code> 字段）</li><li><code>npm_package_scripts_*</code>：项目中定义的 <code>scripts</code> 脚本。例如 <code>npm_package_scripts_start</code> 对应 <code>package.json</code> 中的 <code>start</code> 脚本。</li><li><code>npm_package_dependencies_*</code>：项目依赖项版本。例如 <code>npm_package_dependencies_express</code> 对应 <code>package.json</code> 中 <code>dependencies</code> 下的 <code>express</code> 包的版本。</li><li><code>npm_package_devDependencies_*</code>：开发依赖项版本。例如 <code>npm_package_devDependencies_mocha</code> 对应 <code>package.json</code> 中 <code>devDependencies</code> 下的 <code>mocha</code> 包的版本。</li><li><code>npm_package_keywords_*</code>：项目关键词列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取项目名称</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_name</span><br><br><span class="hljs-comment"># 获取 express 依赖的版本</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_package_dependencies_express</span><br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><p>当你使用 <code>npm run</code> 命令运行脚本时，<code>npm</code> 会自动将 <code>package.json</code> 中的部分内容导出为环境变量，这些环境变量以 <code>npm_package_</code> 为前缀。</p><p>例如，假设你的 <code>package.json</code> 文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-app&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is a sample application&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在运行 <code>npm run start</code> 时，以下环境变量会自动设置：</p><ul><li><code>npm_package_name=my-app</code></li><li><code>npm_package_version=1.0.0</code></li><li><code>npm_package_description=This is a sample application</code></li><li><code>npm_package_author=John Doe</code></li><li><code>npm_package_dependencies_express=^4.17.1</code></li></ul><h4 id="1-使用-npm-package-环境变量"><a href="#1-使用-npm-package-环境变量" class="headerlink" title="1. 使用 npm_package_* 环境变量"></a>1. 使用 <code>npm_package_*</code> 环境变量</h4><p>在脚本中，你可以通过 <code>process.env</code> 来访问这些环境变量。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 package.json 中的字段值</span><br><span class="hljs-keyword">const</span> appName = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_name</span>;<br><span class="hljs-keyword">const</span> appVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_version</span>;<br><span class="hljs-keyword">const</span> appDescription = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_description</span>;<br><span class="hljs-keyword">const</span> appAuthor = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_author</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Name: <span class="hljs-subst">$&#123;appName&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`App Version: <span class="hljs-subst">$&#123;appVersion&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Description: <span class="hljs-subst">$&#123;appDescription&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Author: <span class="hljs-subst">$&#123;appAuthor&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="2-运行脚本"><a href="#2-运行脚本" class="headerlink" title="2. 运行脚本"></a>2. 运行脚本</h4><p>假设在 <code>package.json</code> 中定义了以下 <code>scripts</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>当你运行 <code>npm run start</code> 时，<code>npm</code> 会将 <code>package.json</code> 中的内容作为环境变量导出，并在脚本中可以通过 <code>process.env</code> 访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run start<br></code></pre></td></tr></table></figure><p>输出将会是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Name:</span> <span class="hljs-string">my-app</span><br><span class="hljs-attr">App Version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">Description:</span> <span class="hljs-string">This</span> <span class="hljs-string">is</span> <span class="hljs-string">a</span> <span class="hljs-string">sample</span> <span class="hljs-string">application</span><br><span class="hljs-attr">Author:</span> <span class="hljs-string">John</span> <span class="hljs-string">Doe</span><br></code></pre></td></tr></table></figure><h4 id="3-环境变量命名规则"><a href="#3-环境变量命名规则" class="headerlink" title="3. 环境变量命名规则"></a>3. 环境变量命名规则</h4><ul><li><strong>基本字段</strong>：<code>npm_package_</code> 后接字段名称。例如，<code>name</code> 字段对应 <code>npm_package_name</code>，<code>version</code> 字段对应 <code>npm_package_version</code>。</li><li><strong>嵌套字段</strong>：如果字段是嵌套的，则会用 <code>_</code> 分隔。例如，<code>dependencies</code> 下的 <code>express</code> 包版本可以通过 <code>npm_package_dependencies_express</code> 访问。</li><li><strong>数组字段</strong>：对于数组类型的字段，如 <code>keywords</code>，会自动生成索引的环境变量。例如，<code>keywords</code> 数组的第一个元素是 <code>npm_package_keywords_0</code>。</li></ul><h4 id="4-自定义字段"><a href="#4-自定义字段" class="headerlink" title="4. 自定义字段"></a>4. 自定义字段</h4><p><code>npm_package_*</code> 变量支持自定义字段。假设你在 <code>package.json</code> 中添加了自定义字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;customField&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;apiEndpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://api.example.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;enableFeatureX&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这些自定义字段可以通过如下环境变量访问：</p><ul><li><code>npm_package_customField_apiEndpoint</code>：自定义字段 <code>apiEndpoint</code> 的值。</li><li><code>npm_package_customField_enableFeatureX</code>：自定义字段 <code>enableFeatureX</code> 的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> apiEndpoint = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_apiEndpoint</span>;<br><span class="hljs-keyword">const</span> enableFeatureX = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_customField_enableFeatureX</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`API Endpoint: <span class="hljs-subst">$&#123;apiEndpoint&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Feature X Enabled: <span class="hljs-subst">$&#123;enableFeatureX&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h4 id="5-访问限制"><a href="#5-访问限制" class="headerlink" title="5. 访问限制"></a>5. 访问限制</h4><p>通过 <code>npm_package_*</code> 变量方式访问 <code>package.json</code> 字段有以下几点需要注意：</p><ul><li>只能通过 <code>npm run</code> 命令访问这些环境变量，直接运行 <code>node app.js</code> 是无法自动注入这些变量的。</li><li>如果 <code>package.json</code> 中的某个字段是对象类型，环境变量会为其每个子字段生成对应的变量，但不能直接获取整个对象。</li></ul><h4 id="6-示例：访问-package-json-的-dependencies"><a href="#6-示例：访问-package-json-的-dependencies" class="headerlink" title="6. 示例：访问 package.json 的 dependencies"></a>6. 示例：访问 <code>package.json</code> 的 <code>dependencies</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 访问 dependencies 中的 express 版本</span><br><span class="hljs-keyword">const</span> expressVersion = process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_package_dependencies_express</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Express Version: <span class="hljs-subst">$&#123;expressVersion&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-2-npm-config-变量"><a href="#2-4-2-npm-config-变量" class="headerlink" title="2.4.2 npm_config_* 变量"></a>2.4.2 <code>npm_config_*</code> 变量</h3><p>这些变量用于访问 <code>npm</code> 配置的参数。可以在命令行通过 <code>npm config set</code> 或 <code>npm run</code> 脚本中传递这些配置参数。</p><p><strong>常用配置变量：</strong></p><ul><li><code>npm_config_registry</code>：使用的 npm 注册表 URL。</li><li><code>npm_config_node_version</code>：当前使用的 Node.js 版本。</li><li><code>npm_config_tag</code>：发布时使用的标签（通过 <code>--tag</code> 设置，例如 <code>beta</code>、<code>latest</code>）。</li><li><code>npm_config_global</code>：如果为 <code>true</code>，则指明操作为全局安装或设置。</li><li><code>npm_config_prefix</code>：全局模块的安装路径。</li><li><code>npm_config_cache</code>：npm 的缓存路径。</li><li><code>npm_config_production</code>：如果为 <code>true</code>，表示当前处于生产环境（通过 <code>--production</code> 设置）。</li><li><code>npm_config_init_author_name</code>：初始化项目时的默认作者名称。</li><li><code>npm_config_init_version</code>：初始化项目时的默认版本。</li><li><code>npm_config_save_dev</code>：是否将依赖项保存到 <code>devDependencies</code> 中。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出使用的 npm registry</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_registry</span><br><br><span class="hljs-comment"># 获取配置的默认作者</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_config_init_author_name</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-npm-lifecycle-变量"><a href="#2-4-3-npm-lifecycle-变量" class="headerlink" title="2.4.3 npm_lifecycle_* 变量"></a>2.4.3 <code>npm_lifecycle_*</code> 变量</h3><p>这些变量在运行 <code>npm run</code> 脚本时自动生成，提供有关当前执行生命周期的信息。</p><p><strong>常用生命周期变量：</strong></p><ul><li><code>npm_lifecycle_event</code>：当前运行的脚本事件名称。例如，<code>npm run build</code> 时，<code>npm_lifecycle_event</code> 为 <code>build</code>。</li><li><code>npm_lifecycle_script</code>：当前正在执行的脚本内容。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前运行的生命周期事件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_lifecycle_event</span><br></code></pre></td></tr></table></figure><h3 id="2-4-4-npm-变量"><a href="#2-4-4-npm-变量" class="headerlink" title="2.4.4 npm_* 变量"></a>2.4.4 <code>npm_*</code> 变量</h3><p>这些变量提供了一些与当前 <code>npm</code> 环境和运行时相关的信息。</p><p><strong>常用变量：</strong></p><ul><li><code>npm_command</code>：当前正在执行的 <code>npm</code> 命令。例如，<code>npm install</code> 时，<code>npm_command</code> 为 <code>install</code>。</li><li><code>npm_execpath</code>：执行 npm 的路径。</li><li><code>npm_node_execpath</code>：Node.js 可执行文件的路径。</li><li><code>npm_config_user_agent</code>：当前 <code>npm</code> 客户端的用户代理字符串。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前的 npm 命令</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_command</span><br><br><span class="hljs-comment"># 输出 npm 可执行文件路径</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$npm_execpath</span><br></code></pre></td></tr></table></figure><h3 id="2-4-5-自定义-npm-config-变量"><a href="#2-4-5-自定义-npm-config-变量" class="headerlink" title="2.4.5 自定义 npm_config_* 变量"></a>2.4.5 自定义 <code>npm_config_*</code> 变量</h3><p>你还可以通过命令行或配置文件自定义 <code>npm_config_*</code> 变量。例如，你可以通过 <code>npm run</code> 命令传递自定义的变量，供脚本使用。</p><p><strong>示例：</strong></p><p>在 <code>package.json</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;view&quot;</span>: <span class="hljs-string">&quot;echo $npm_config_myCustomVar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run view --myCustomVar=HelloWorld<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HelloWorld</span><br></code></pre></td></tr></table></figure><h3 id="2-4-6-总结"><a href="#2-4-6-总结" class="headerlink" title="2.4.6 总结"></a>2.4.6 总结</h3><p>以下是常见 <code>npm</code> 变量的分类总结：</p><table><thead><tr><th>变量类型</th><th>说明</th></tr></thead><tbody><tr><td><code>npm_package_*</code></td><td>访问 <code>package.json</code> 中的字段值</td></tr><tr><td><code>npm_config_*</code></td><td>访问 <code>npm</code> 配置的参数</td></tr><tr><td><code>npm_lifecycle_*</code></td><td>运行时有关生命周期的信息</td></tr><tr><td><code>npm_*</code></td><td>一些与当前 <code>npm</code> 环境相关的信息</td></tr><tr><td>自定义 <code>npm_config_*</code></td><td>通过命令行或配置文件传递的自定义参数</td></tr></tbody></table><p>这些变量在 <code>npm</code> 的脚本管理和环境配置中十分有用，能够帮助你在不同环境下动态获取项目信息、依赖版本或自定义配置等。</p><h2 id="2-5-package-json-其他常见字段"><a href="#2-5-package-json-其他常见字段" class="headerlink" title="2.5 package.json 其他常见字段"></a>2.5 package.json 其他常见字段</h2><h3 id="2-5-1-main-入口文件"><a href="#2-5-1-main-入口文件" class="headerlink" title="2.5.1 main (入口文件)"></a>2.5.1 <code>main</code> (入口文件)</h3><p><code>main</code> 指定了包的入口文件。当用户 <code>require</code> 该包时，首先加载的就是该文件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-2-engines-引擎"><a href="#2-5-2-engines-引擎" class="headerlink" title="2.5.2 engines (引擎)"></a>2.5.2 <code>engines</code> (引擎)</h3><p><code>engines</code> 字段用于指定项目所需的 Node.js 或 NPM 版本。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=12.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;npm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=6.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-repository-仓库"><a href="#2-5-3-repository-仓库" class="headerlink" title="2.5.3 repository (仓库)"></a>2.5.3 <code>repository</code> (仓库)</h3><p><code>repository</code> 字段记录项目的代码仓库地址。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-4-bugs-问题反馈"><a href="#2-5-4-bugs-问题反馈" class="headerlink" title="2.5.4 bugs (问题反馈)"></a>2.5.4 <code>bugs</code> (问题反馈)</h3><p><code>bugs</code> 字段用于提供问题反馈的地址或电子邮件。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/my-project/issues&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support@example.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-5-files-发布文件"><a href="#2-5-5-files-发布文件" class="headerlink" title="2.5.5 files (发布文件)"></a>2.5.5 <code>files</code> (发布文件)</h3><p><code>files</code> 字段指定了在发布到 NPM 时需要包含的文件列表。未包含在此列表中的文件将不会发布。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;dist/&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-6-config-自定义配置"><a href="#2-5-6-config-自定义配置" class="headerlink" title="2.5.6 config (自定义配置)"></a>2.5.6 <code>config</code> (自定义配置)</h3><p><code>config</code> 字段允许自定义配置，用于脚本中引用的变量。</p><h1 id="3-NPM-的常用命令"><a href="#3-NPM-的常用命令" class="headerlink" title="3. NPM 的常用命令"></a>3. NPM 的常用命令</h1><h2 id="3-1-安装包"><a href="#3-1-安装包" class="headerlink" title="3.1 安装包"></a>3.1 安装包</h2><ul><li><strong>安装指定依赖包</strong>：默认会将依赖包安装到 <code>node_modules</code> 文件夹下，并更新 <code>package.json</code> 中的依赖。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>安装开发依赖包</strong>：使用 <code>--save-dev</code> 参数可以将包安装到 <code>devDependencies</code> 中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install &lt;package-name&gt; --save-dev<br></code></pre></td></tr></table></figure><ul><li><strong>全局安装</strong>：某些工具需要全局安装，如 <code>create-react-app</code>、<code>eslint</code> 等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-2-移除包"><a href="#3-2-移除包" class="headerlink" title="3.2 移除包"></a>3.2 移除包</h2><p>可以通过 <code>uninstall</code> 命令移除包，并自动更新 <code>package.json</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-3-更新包"><a href="#3-3-更新包" class="headerlink" title="3.3 更新包"></a>3.3 更新包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-检查过期包"><a href="#3-4-检查过期包" class="headerlink" title="3.4 检查过期包"></a>3.4 检查过期包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm outdated<br></code></pre></td></tr></table></figure><h2 id="3-5-修复漏洞"><a href="#3-5-修复漏洞" class="headerlink" title="3.5 修复漏洞"></a>3.5 修复漏洞</h2><p>NPM 提供了 <code>audit</code> 命令来检查项目中存在的安全漏洞，并通过 <code>audit fix</code> 自动修复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm audit<br>npm audit fix<br></code></pre></td></tr></table></figure><h2 id="3-6-清理缓存"><a href="#3-6-清理缓存" class="headerlink" title="3.6 清理缓存"></a>3.6 清理缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm cache clean --force<br></code></pre></td></tr></table></figure><h1 id="4-NPM-脚本"><a href="#4-NPM-脚本" class="headerlink" title="4. NPM 脚本"></a>4. NPM 脚本</h1><p>NPM 允许在 <code>package.json</code> 文件中的 <code>scripts</code> 部分定义自定义命令。这些命令可以通过 <code>npm run &lt;script-name&gt;</code> 执行，常用于自动化工作流。</p><h2 id="4-1-定义和执行脚本"><a href="#4-1-定义和执行脚本" class="headerlink" title="4.1 定义和执行脚本"></a>4.1 定义和执行脚本</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><ul><li><code>pre</code> 和 <code>post</code> 钩子：NPM 支持在某个脚本执行前后自动执行一些预定义的任务。例如，定义 <code>pretest</code> 或 <code>posttest</code>，它们分别在 <code>test</code> 脚本前后执行。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;pretest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm install&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;posttest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run lint&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-脚本参数"><a href="#4-2-脚本参数" class="headerlink" title="4.2 脚本参数"></a>4.2 脚本参数</h2><p>你可以通过 <code>--</code> 向 NPM 脚本传递参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build -- --mode production<br></code></pre></td></tr></table></figure><h1 id="5-NPM-的版本管理"><a href="#5-NPM-的版本管理" class="headerlink" title="5. NPM 的版本管理"></a>5. NPM 的版本管理</h1><p>NPM 支持多种版本控制策略，便于项目在不同版本的依赖包中自由切换。</p><h2 id="5-1-版本号规则"><a href="#5-1-版本号规则" class="headerlink" title="5.1 版本号规则"></a>5.1 版本号规则</h2><p>NPM 的版本号遵循 语义化版本号 规范：</p><ul><li><strong>主版本号</strong>：非兼容性 API 变更。</li><li><strong>次版本号</strong>：向下兼容的新功能。</li><li><strong>修订号</strong>：向下兼容的问题修复。</li></ul><p>版本号示例：<code>^1.2.3</code>，其中 <code>^</code> 表示允许安装 <code>1.x.x</code> 版本的更新，<code>~1.2.3</code> 表示允许安装 <code>1.2.x</code> 的更新。</p><h2 id="5-2-锁定版本"><a href="#5-2-锁定版本" class="headerlink" title="5.2 锁定版本"></a>5.2 锁定版本</h2><p><code>package-lock.json</code> 是 NPM 自动生成的文件，它锁定了每个依赖包的版本，确保团队中每个人安装的包版本一致，避免版本不兼容问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm ci<br></code></pre></td></tr></table></figure><p><code>npm ci</code> 命令基于 <code>package-lock.json</code> 文件安装所有依赖，适用于 CI&#x2F;CD 环境下的构建流程。</p><h1 id="6-发布自己的-NPM-包"><a href="#6-发布自己的-NPM-包" class="headerlink" title="6. 发布自己的 NPM 包"></a>6. 发布自己的 NPM 包</h1><p>你可以通过 NPM 将自己的包发布到 NPM 注册库供其他开发者使用。</p><h2 id="6-1-创建-NPM-账户"><a href="#6-1-创建-NPM-账户" class="headerlink" title="6.1 创建 NPM 账户"></a>6.1 创建 NPM 账户</h2><p>首先，你需要注册一个 NPM 账户并登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm login<br></code></pre></td></tr></table></figure><h2 id="6-2-准备项目"><a href="#6-2-准备项目" class="headerlink" title="6.2 准备项目"></a>6.2 准备项目</h2><p>确保项目的 <code>package.json</code> 文件正确配置，尤其是以下字段：</p><ul><li><code>name</code>: 包名，需要唯一。</li><li><code>version</code>: 包版本，初始版本可以为 <code>1.0.0</code>。</li><li><code>main</code>: 入口文件。</li></ul><h2 id="6-3-发布包"><a href="#6-3-发布包" class="headerlink" title="6.3 发布包"></a>6.3 发布包</h2><p>执行以下命令将包发布到 NPM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish<br></code></pre></td></tr></table></figure><p>如果是发布新的版本，只需要在 <code>package.json</code> 中修改版本号，再次运行 <code>npm publish</code>。</p><h2 id="6-4-包版本管理"><a href="#6-4-包版本管理" class="headerlink" title="6.4 包版本管理"></a>6.4 包版本管理</h2><p>当你需要发布预览版或测试版时，可以使用 <code>npm publish</code> 的 <code>tag</code> 选项发布特定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish --tag beta<br></code></pre></td></tr></table></figure><h1 id="7-高级使用"><a href="#7-高级使用" class="headerlink" title="7. 高级使用"></a>7. 高级使用</h1><h2 id="7-1-使用-NPM-进行项目初始化"><a href="#7-1-使用-NPM-进行项目初始化" class="headerlink" title="7.1 使用 NPM 进行项目初始化"></a>7.1 使用 NPM 进行项目初始化</h2><p>有时我们需要为某些项目做初始化工作，NPM 的 <code>init</code> 命令可以与预设的模板搭配使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init &lt;模板名&gt;<br></code></pre></td></tr></table></figure><h2 id="7-2-本地开发包"><a href="#7-2-本地开发包" class="headerlink" title="7.2 本地开发包"></a>7.2 本地开发包</h2><p>在开发 NPM 包时，你可以使用 <code>npm link</code> 将本地包链接到全局环境中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><h2 id="7-3-npx-命令"><a href="#7-3-npx-命令" class="headerlink" title="7.3 npx 命令"></a>7.3 npx 命令</h2><p><code>npx</code> 是 NPM 附带的一个命令，它允许直接执行包中的命令，而无需全局安装。例如，运行 <code>create-react-app</code> 时，可以直接使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-react-app my-app<br></code></pre></td></tr></table></figure><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>NPM 是 Node.js 项目的基础工具，它不仅能帮助你高效地管理依赖，还能通过 <code>scripts</code> 和 <code>npx</code> 提升开发效率。通过掌握 NPM 的各种命令和功能，能够更好地维护项目和发布自己的代码包。</p><p>希望通过这篇教程，你对 NPM 有了更全面的理解。</p>]]></content>
    
    
    <categories>
      
      <category>NPM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NPM</tag>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解浏览器原理与DOM</title>
    <link href="/posts/32299/"/>
    <url>/posts/32299/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解浏览器原理与-DOM"><a href="#深入理解浏览器原理与-DOM" class="headerlink" title="深入理解浏览器原理与 DOM"></a>深入理解浏览器原理与 DOM</h1><h1 id="一、什么是浏览器？"><a href="#一、什么是浏览器？" class="headerlink" title="一、什么是浏览器？"></a>一、什么是浏览器？</h1><p>浏览器是用户访问互联网的工具，它负责请求网页内容、解析网页、展示内容并处理用户与网页的互动。现代浏览器如 Chrome、Firefox 和 Safari 不仅支持 HTML、CSS 和 JavaScript，还集成了许多功能来优化用户体验和安全性。</p><h1 id="二、浏览器的工作过程"><a href="#二、浏览器的工作过程" class="headerlink" title="二、浏览器的工作过程"></a>二、浏览器的工作过程</h1><p>浏览器的工作过程可以分为多个步骤，每个步骤都有其重要性。让我们逐步深入了解。</p><h2 id="1-用户输入-URL"><a href="#1-用户输入-URL" class="headerlink" title="1. 用户输入 URL"></a>1. 用户输入 URL</h2><p>用户在浏览器的地址栏中输入一个网址（URL），例如 <code>http://www.example.com</code>。URL 通常包含协议（如 HTTP 或 HTTPS）、域名、路径、查询参数和锚点等信息。</p><h2 id="2-解析-URL"><a href="#2-解析-URL" class="headerlink" title="2. 解析 URL"></a>2. 解析 URL</h2><p>浏览器首先解析输入的 URL，提取出以下组成部分：</p><ul><li><strong>协议</strong>：指示使用的协议（HTTP 或 HTTPS）。</li><li><strong>域名</strong>：指向目标服务器的地址。</li><li><strong>路径</strong>：指向服务器上资源的位置。</li><li><strong>查询参数</strong>：可选，通常用于传递数据给服务器。</li></ul><h2 id="3-DNS-查询"><a href="#3-DNS-查询" class="headerlink" title="3. DNS 查询"></a>3. DNS 查询</h2><p>浏览器需要将域名转换为 IP 地址，才能找到服务器。为此，浏览器会向 DNS（域名系统）发送查询请求。DNS 服务器返回相应的 IP 地址，如果该地址已被缓存，浏览器可以直接使用。</p><h2 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h2><p>一旦获得了服务器的 IP 地址，浏览器会与服务器建立 TCP 连接。这个过程包含以下步骤：</p><ul><li><p>三次握手</p><p>：为了确保连接的可靠性，TCP 协议使用三次握手机制。</p><ol><li>浏览器发送一个 SYN（同步）包给服务器，请求建立连接。</li><li>服务器回复一个 SYN-ACK（同步-确认）包，确认收到请求并准备建立连接。</li><li>浏览器再次发送一个 ACK（确认）包，连接成功建立。</li></ol></li></ul><h2 id="5-发送-HTTP-请求"><a href="#5-发送-HTTP-请求" class="headerlink" title="5. 发送 HTTP 请求"></a>5. 发送 HTTP 请求</h2><p>建立连接后，浏览器会发送一个 HTTP 请求，向服务器请求资源。这个请求包含：</p><ul><li><strong>请求方法</strong>：通常是 GET（获取资源）或 POST（提交数据）。</li><li><strong>请求路径</strong>：服务器上资源的具体路径。</li><li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li><li><strong>请求头</strong>：包含浏览器信息、接受的内容类型等元数据。</li><li><strong>请求体</strong>（可选）：在 POST 请求中，包含发送给服务器的数据。</li></ul><h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>服务器接收到请求后，会处理请求并生成响应。服务器执行的操作可能包括：</p><ul><li>查询数据库。</li><li>处理业务逻辑。</li><li>生成动态网页内容。</li></ul><h2 id="7-服务器发送-HTTP-响应"><a href="#7-服务器发送-HTTP-响应" class="headerlink" title="7. 服务器发送 HTTP 响应"></a>7. 服务器发送 HTTP 响应</h2><p>处理完成后，服务器会发送一个 HTTP 响应回浏览器，响应包括：</p><ul><li><strong>状态码</strong>：指示请求处理的结果，如 200（成功）、404（未找到）或 500（服务器错误）。</li><li><strong>响应头</strong>：包含关于响应的信息，如内容类型、缓存策略、内容长度等。</li><li><strong>响应体</strong>：实际的网页内容，通常是 HTML 文档，也可能包括 CSS、JavaScript、图片等资源。</li></ul><h2 id="8-接收响应"><a href="#8-接收响应" class="headerlink" title="8. 接收响应"></a>8. 接收响应</h2><p>浏览器接收到服务器的响应后，首先检查状态码，确认请求是否成功。如果状态码是 200，浏览器将开始解析响应体。</p><h2 id="9-构建-DOM-树"><a href="#9-构建-DOM-树" class="headerlink" title="9. 构建 DOM 树"></a>9. 构建 DOM 树</h2><p>浏览器会解析 HTML 文档，构建文档对象模型（DOM）树。DOM 是一个树形结构，其中每个节点代表文档中的一个元素或文本。构建 DOM 树的过程如下：</p><ul><li>解析每个 HTML 标签，创建对应的元素节点。</li><li>处理标签之间的关系，形成父子节点的层级结构。</li><li>处理文本节点，将文本内容与相应的元素节点关联。</li></ul><h2 id="10-DOM-的详细解析"><a href="#10-DOM-的详细解析" class="headerlink" title="10. DOM 的详细解析"></a>10. DOM 的详细解析</h2><p>DOM（文档对象模型）是浏览器用来表示和操作 HTML 和 XML 文档的编程接口。以下是对 DOM 的详细讲解：</p><h3 id="1-DOM-的结构"><a href="#1-DOM-的结构" class="headerlink" title="1. DOM 的结构"></a>1. DOM 的结构</h3><p>DOM 树的根节点是 <code>document</code>，它表示整个文档。树的每个节点都是一个对象，代表文档中的元素、属性或文本。DOM 树结构如下：</p><ul><li>document<ul><li>html<ul><li>head<ul><li>title</li><li>meta</li></ul></li><li>body<ul><li>h1</li><li>p</li><li>div<ul><li>span</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="2-DOM-节点类型"><a href="#2-DOM-节点类型" class="headerlink" title="2. DOM 节点类型"></a>2. DOM 节点类型</h3><p>DOM 中的节点可以分为几种类型：</p><ul><li><strong>元素节点</strong>：表示 HTML 标签，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等。</li><li><strong>文本节点</strong>：表示元素内部的文本内容。</li><li><strong>属性节点</strong>：表示元素的属性，如 <code>class</code>、<code>id</code> 等（现代浏览器 API 中，属性节点不再是单独的节点）。</li></ul><h3 id="3-DOM-操作"><a href="#3-DOM-操作" class="headerlink" title="3. DOM 操作"></a>3. DOM 操作</h3><p>JavaScript 可以通过 DOM API 访问和修改 DOM 树，包括：</p><ul><li><strong>访问节点</strong>：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：根据 ID 获取元素。</li><li><code>document.querySelector(&#39;.class&#39;)</code>：根据 CSS 选择器获取元素。</li></ul></li><li><strong>添加节点</strong>：<ul><li><code>element.appendChild(newNode)</code>：将新节点添加到指定元素的子节点列表中。</li><li><code>element.insertBefore(newNode, referenceNode)</code>：在指定节点前插入新节点。</li></ul></li><li><strong>修改节点</strong>：<ul><li><code>element.textContent = &#39;New Text&#39;</code>：更改节点的文本内容。</li><li><code>element.setAttribute(&#39;attribute&#39;, &#39;value&#39;)</code>：设置节点的属性。</li></ul></li><li><strong>删除节点</strong>：<ul><li><code>element.removeChild(childNode)</code>：从 DOM 中删除子节点。</li></ul></li></ul><h2 id="11-构建-CSSOM-树"><a href="#11-构建-CSSOM-树" class="headerlink" title="11. 构建 CSSOM 树"></a>11. 构建 CSSOM 树</h2><p>在解析 HTML 的同时，浏览器会处理页面中的 CSS（包括内联样式和外部样式表），构建 CSSOM（CSS 对象模型）树。CSSOM 表示页面的样式规则，包含每个 CSS 选择器和它所对应的样式。</p><h2 id="12-合并-DOM-和-CSSOM"><a href="#12-合并-DOM-和-CSSOM" class="headerlink" title="12. 合并 DOM 和 CSSOM"></a>12. 合并 DOM 和 CSSOM</h2><p>DOM 树和 CSSOM 树被合并成一棵“渲染树”，它只包含需要渲染的可见元素。渲染树中的每个节点都包含视觉信息，决定元素在页面上的呈现方式。</p><h2 id="13-布局计算（Reflow）"><a href="#13-布局计算（Reflow）" class="headerlink" title="13. 布局计算（Reflow）"></a>13. 布局计算（Reflow）</h2><p>浏览器根据渲染树计算每个元素的位置和大小，这个过程被称为布局（或重排，Reflow）。在此过程中，浏览器考虑样式、内容和屏幕大小等因素，决定每个元素在页面上的具体位置。</p><h2 id="14-绘制（Repaint）"><a href="#14-绘制（Repaint）" class="headerlink" title="14. 绘制（Repaint）"></a>14. 绘制（Repaint）</h2><p>在完成布局后，浏览器将元素绘制到屏幕上。绘制过程会将渲染树的每个节点转换为位图，最终形成用户在屏幕上看到的页面。</p><h2 id="15-执行-JavaScript"><a href="#15-执行-JavaScript" class="headerlink" title="15. 执行 JavaScript"></a>15. 执行 JavaScript</h2><p>页面中的 JavaScript 代码会被执行。JavaScript 可以直接操作 DOM 和 CSSOM，可能会导致页面更新。以下是执行 JavaScript 的几个重要点：</p><ul><li><strong>DOM 操作</strong>：通过 JavaScript，开发者可以动态地添加、删除或修改页面元素。</li><li><strong>事件处理</strong>：JavaScript 可以响应用户的操作，如点击、滚动、输入等，增加交互性。</li></ul><h2 id="16-事件循环"><a href="#16-事件循环" class="headerlink" title="16. 事件循环"></a>16. 事件循环</h2><p>JavaScript 是单线程的，事件循环机制使得 JavaScript 可以异步处理事件。浏览器将用户操作和定时器事件推入一个任务队列，JavaScript 引擎逐一执行这些任务，确保页面的响应性。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>浏览器是一个复杂而强大的工具，理解其工作原理有助于开发者更好地构建和优化网页应用。从用户输入 URL 到最终呈现内容，每一步都涉及到多个子步骤和技术细节。掌握这些知识将使开发者在进行前端开发时更为得心应手，也能帮助他们识别和解决性能问题和兼容性问题。</p><p>希望这篇深入的博客能够帮助你更好地理解浏览器的工作原理、DOM 的结构与操作以及相关机制！如果有任何疑问或想了解更多内容，欢迎随时交流。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器跨域问题详解及解决方案</title>
    <link href="/posts/3208/"/>
    <url>/posts/3208/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题详解及解决方案"><a href="#浏览器跨域问题详解及解决方案" class="headerlink" title="浏览器跨域问题详解及解决方案"></a>浏览器跨域问题详解及解决方案</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>在开发 Web 应用时，浏览器的跨域问题是前端开发者经常遇到的。浏览器的<strong>同源策略</strong>（Same-Origin Policy）是为了保证安全，限制了跨域请求的发起。然而，很多场景下，跨域请求是必须的，比如前端与不同域的后端服务器通信时。因此，理解浏览器跨域问题的原因及其解决方案是非常重要的。</p><p>本文将深入讲解跨域问题的产生原因，并提供常用的解决方案，帮助开发者高效解决跨域问题。</p><hr><h1 id="一、什么是跨域问题？"><a href="#一、什么是跨域问题？" class="headerlink" title="一、什么是跨域问题？"></a><strong>一、什么是跨域问题？</strong></h1><p><strong>跨域</strong>是指浏览器的安全策略，即同源策略（Same-Origin Policy）限制了 JavaScript 只能从与网页同源的服务器请求资源。所谓<strong>同源</strong>，是指协议、域名、端口号三者必须完全相同。</p><ul><li><p><strong>同源</strong>：指的是协议、域名、端口号三者必须一致。</p></li><li><p>跨域</p><p>：如果任意一个不同，都是跨域。例如：</p><ul><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="https://www.example.com'(协议不同)/">https://www.example.com&#39;（协议不同）</a></li><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="http://api.example.com'(域名不同)/">http://api.example.com&#39;（域名不同）</a></li><li>‘<a href="http://www.example.com:8080/">http://www.example.com:8080</a>‘ 与 ‘<a href="http://www.example.com:3000'（端口不同）">http://www.example.com:3000&#39;（端口不同）</a></li></ul></li></ul><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a><strong>浏览器的同源策略</strong></h2><p>同源策略是一种重要的安全策略，它用于阻止一个源（网页）中的脚本读取另一个源中的资源。它的主要目的是为了防止恶意网站通过跨站脚本攻击（XSS）来窃取用户数据。</p><h2 id="跨域请求带来的问题"><a href="#跨域请求带来的问题" class="headerlink" title="跨域请求带来的问题"></a><strong>跨域请求带来的问题</strong></h2><p>跨域问题常出现在通过 Ajax 或 Fetch 发起的 HTTP 请求中，浏览器会根据同源策略阻止跨域请求，导致前端无法拿到不同源的服务器数据。</p><hr><h1 id="二、跨域问题产生的原因"><a href="#二、跨域问题产生的原因" class="headerlink" title="二、跨域问题产生的原因"></a><strong>二、跨域问题产生的原因</strong></h1><p>跨域问题产生的核心原因是<strong>浏览器的同源策略</strong>，具体在以下情况下会产生跨域问题：</p><ol><li><strong>协议不同</strong>：比如 HTTP 和 HTTPS 协议不同，属于跨域。</li><li><strong>域名不同</strong>：比如 <code>example.com</code> 和 <code>sub.example.com</code> 属于跨域。</li><li><strong>端口不同</strong>：同样的域名和协议，但端口不同，比如 <code>example.com:8080</code> 和 <code>example.com:3000</code>。</li></ol><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子</strong>：</h2><ul><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com/api/data">http://example.com/api/data</a> ——<strong>同源</strong>，允许请求。</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="https://example.com/api/data">https://example.com/api/data</a> ——<strong>跨域</strong>，拒绝请求。（协议不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://api.example.com/data">http://api.example.com/data</a> ——<strong>跨域</strong>，拒绝请求。（域名不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com:3000/data">http://example.com:3000/data</a> ——<strong>跨域</strong>，拒绝请求。（端口不同）</li></ul><p>当发生跨域时，浏览器会抛出类似如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://api.example.com/data&#x27;</span> from origin <span class="hljs-string">&#x27;http://www.example.com&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.<br></code></pre></td></tr></table></figure><p>这种错误提示表明请求被浏览器阻止，原因是目标服务器没有配置允许跨域请求的响应头。</p><hr><h1 id="三、跨域问题的常见解决方案"><a href="#三、跨域问题的常见解决方案" class="headerlink" title="三、跨域问题的常见解决方案"></a><strong>三、跨域问题的常见解决方案</strong></h1><p>针对跨域问题，前端和后端都有不同的解决方法。常用的方案包括：</p><h2 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1. CORS（跨域资源共享）"></a><strong>1. CORS（跨域资源共享）</strong></h2><p>CORS（Cross-Origin Resource Sharing）是 W3C 标准，允许浏览器向跨源服务器，发起 XMLHttpRequest 或 Fetch 请求。只要服务器端配置了适当的 CORS 头信息，就可以允许跨域请求。</p><p><strong>服务器端解决方法：</strong></p><p>在后端服务器配置响应头来允许跨域访问。具体操作是设置 HTTP 响应头中的 <code>Access-Control-Allow-Origin</code>，这个头告诉浏览器，允许哪些域进行跨域请求。</p><ul><li><p><strong>基本 CORS 头配置</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br></code></pre></td></tr></table></figure><p>这意味着允许所有来源的跨域请求。如果要限制特定的域，可以将 <code>*</code> 替换为特定域名，比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://www.example.com<br></code></pre></td></tr></table></figure></li><li><p><strong>支持复杂请求</strong>：</p><p>如果是复杂的跨域请求（例如涉及 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等非简单方法，或者带有自定义头部），需要预检请求。此时需要后端配置更多的 CORS 头信息，例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>Content-Type, Authorization<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure><p>这些头信息分别表示允许的 HTTP 方法、允许的自定义头部、以及是否允许携带 Cookie 等认证信息。</p></li></ul><h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a><strong>2. JSONP</strong></h2><p>JSONP（JSON with Padding）是一种传统的跨域请求方案，利用 <code>&lt;script&gt;</code> 标签的跨域能力来请求资源。因为 <code>&lt;script&gt;</code> 标签不受同源策略的限制，可以加载任意来源的脚本，JSONP 通过动态插入 <code>&lt;script&gt;</code> 标签来实现跨域请求。</p><p><strong>实现步骤</strong>：</p><ul><li><p>前端发起请求时，在 URL 中添加一个回调函数参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理返回数据</span><br>&#125;<br><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li><p>后端返回的数据需要被包裹在回调函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleResponse</span>(&#123;<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: [...]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>虽然 JSONP 可以实现跨域请求，但它只支持 GET 请求，不支持其他 HTTP 方法。</p><h2 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a><strong>3. 反向代理</strong></h2><p>反向代理是一种通过代理服务器转发请求的方式。前端请求会先发到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将响应返回给前端。</p><p><strong>实现步骤</strong>：</p><ul><li><p>配置代理服务器（如 Nginx 或 Node.js 中的代理模块）来转发请求：</p><p>在 Nginx 中的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://api.example.com;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，前端只需要请求 <code>/api/</code>，Nginx 会将请求转发到 <code>http://api.example.com</code>，从而避免跨域问题。</p></li></ul><h2 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a><strong>4. WebSocket</strong></h2><p>WebSocket 协议不受同源策略的限制，可以实现跨域通信。如果项目中需要实时通信，WebSocket 是一种不错的选择。</p><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://example.com/socket&#x27;</span>);<br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from server &#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="四、前端解决方案"><a href="#四、前端解决方案" class="headerlink" title="四、前端解决方案"></a><strong>四、前端解决方案</strong></h1><ol><li><p><strong>CORS 前端控制</strong> 前端可以通过控制请求时的一些参数，避免复杂请求的跨域问题。例如使用简单请求方法（GET、POST）或避免自定义请求头等。</p></li><li><p><strong>使用代理开发服务器</strong> 在开发环境中，使用 Webpack DevServer 或 Vite 等开发工具时，可以通过设置代理解决跨域问题。比如在 <code>vue.config.js</code> 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="五、简单请求"><a href="#五、简单请求" class="headerlink" title="五、简单请求"></a>五、简单请求</h1><p>在浏览器的同源策略下，只有某些特定的请求不会触发跨域问题。浏览器针对不同的请求类型进行了区分，只有符合特定条件的请求才会被认为是安全的，属于<strong>简单请求（Simple Requests）</strong>，这些请求不会触发浏览器的<strong>CORS 预检（Preflight）请求</strong>，因此也不会被同源策略限制。</p><h2 id="1、不会触发跨域的请求类型（简单请求）"><a href="#1、不会触发跨域的请求类型（简单请求）" class="headerlink" title="1、不会触发跨域的请求类型（简单请求）"></a><strong>1、不会触发跨域的请求类型（简单请求）</strong></h2><p>根据<strong>CORS（跨域资源共享）</strong>的规范，以下请求被定义为“简单请求”：</p><h3 id="1-1-请求方法必须是以下三种之一："><a href="#1-1-请求方法必须是以下三种之一：" class="headerlink" title="1.1. 请求方法必须是以下三种之一："></a>1.1. <strong>请求方法必须是以下三种之一</strong>：</h3><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><p>这意味着浏览器只会认为这些方法是安全的，任何其他 HTTP 方法（如 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等）都会被视为复杂请求，从而触发跨域检查。</p><h3 id="1-2-请求头必须是以下几种之一："><a href="#1-2-请求头必须是以下几种之一：" class="headerlink" title="1.2. 请求头必须是以下几种之一："></a>1.2. <strong>请求头必须是以下几种之一</strong>：</h3><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（有特定限制，见下一条）</li><li><code>DPR</code>（Device Pixel Ratio）</li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><p>浏览器默认允许这些请求头传递。如果请求中包含了其他自定义头字段，则会被认为是复杂请求，会触发跨域预检。</p><h3 id="1-3-Content-Type-必须是以下三种之一："><a href="#1-3-Content-Type-必须是以下三种之一：" class="headerlink" title="1.3. Content-Type 必须是以下三种之一："></a>1.3. <strong><code>Content-Type</code> 必须是以下三种之一</strong>：</h3><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>这些 <code>Content-Type</code> 类型是最常用的，特别是 <code>application/x-www-form-urlencoded</code>，它是表单提交的默认编码格式。如果使用了其他 <code>Content-Type</code>（例如 <code>application/json</code>），请求会被认为是复杂请求，触发跨域预检。</p><h3 id="1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性："><a href="#1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性：" class="headerlink" title="1.4. 请求不包含任何自定义的 XMLHttpRequest 对象属性："></a>1.4. <strong>请求不包含任何自定义的 <code>XMLHttpRequest</code> 对象属性</strong>：</h3><p>例如 <code>request.withCredentials = true</code> 会导致请求包含用户凭证（cookies、HTTP authentication 等），这将使请求成为复杂请求，触发 CORS 检查。</p><p><strong>简单请求的示例</strong>：</p><ul><li><p><strong>GET 请求</strong>：向目标 API 发起 GET 请求并获取数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>POST 请求</strong>：发送表单数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、简单请求不会触发跨域预检的原因"><a href="#2、简单请求不会触发跨域预检的原因" class="headerlink" title="2、简单请求不会触发跨域预检的原因"></a><strong>2、简单请求不会触发跨域预检的原因</strong></h2><p>浏览器的安全模型假定，简单请求不会带来高风险，因为它们遵循了 HTTP 协议中广泛使用的标准行为。预检请求的目的是检查目标服务器是否允许跨域访问，确保请求不会有潜在的安全问题。</p><p>而简单请求（如上述 <code>GET</code> 和 <code>POST</code>）通常是安全的，因为它们不使用自定义头字段或不发送敏感的内容类型。浏览器认为这些请求不需要额外的安全检查，所以不会触发跨域预检。</p><h2 id="3、哪些请求会触发跨域？"><a href="#3、哪些请求会触发跨域？" class="headerlink" title="3、哪些请求会触发跨域？"></a><strong>3、哪些请求会触发跨域？</strong></h2><p>如果不符合上面简单请求的条件，以下情况会导致请求被认为是复杂请求，从而触发跨域检查：</p><ul><li>使用了 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>、<code>OPTIONS</code> 等不属于简单请求的方法。</li><li>请求中包含了自定义头，如 <code>Authorization</code>、<code>X-Custom-Header</code> 等。</li><li>使用了 <code>Content-Type</code> 头的其他类型（如 <code>application/json</code>、<code>application/xml</code>）。</li><li>使用了带有 <code>withCredentials: true</code> 的请求，表示请求携带用户凭证（如 Cookies）。</li></ul><h2 id="4、复杂请求和预检请求"><a href="#4、复杂请求和预检请求" class="headerlink" title="4、复杂请求和预检请求"></a><strong>4、复杂请求和预检请求</strong></h2><p>复杂请求会触发浏览器发起一个 <code>OPTIONS</code> 请求，称为<strong>预检请求（Preflight Request）</strong>，服务器需要在这个请求中返回允许跨域访问的 CORS 头信息。只有当预检请求通过后，浏览器才会真正发起复杂请求。</p><hr><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、<strong>总结</strong></h2><p>不会触发跨域的基础请求，遵循了简单请求的规则：</p><ol><li><strong>HTTP 方法</strong>：仅限 <code>GET</code>、<code>POST</code>、<code>HEAD</code>。</li><li><strong>请求头</strong>：仅使用特定的标准头字段，如 <code>Accept</code>、<code>Content-Type</code>，且 <code>Content-Type</code> 必须是 <code>text/plain</code>、<code>multipart/form-data</code> 或 <code>application/x-www-form-urlencoded</code>。</li><li><strong>不使用自定义请求头</strong>，例如 <code>Authorization</code> 等。</li><li><strong>不带凭证</strong>，即不使用 <code>withCredentials: true</code>。</li></ol><p>理解这些规则可以帮助你在开发中规避跨域问题，或者正确配置 CORS 来处理复杂请求。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h1><p>跨域问题是浏览器为了安全性引入的，同源策略的限制避免了跨站点攻击（XSS、CSRF），但同时也带来了开发中的诸多不便。解决跨域问题的方案多种多样，前后端可以根据项目的需求选择合适的方式来处理。</p><ol><li><strong>CORS</strong> 是最常用、最标准的跨域解决方案，推荐使用。</li><li><strong>JSONP</strong> 适用于简单的 GET 请求，但随着 CORS 的普及使用较少。</li><li><strong>反向代理</strong> 在开发环境或生产环境中都非常实用，尤其是在分布式系统中。</li><li><strong>WebSocket</strong> 则适用于需要双向实时通信的场景。</li></ol><p>选择合适的跨域解决方案可以极大提高开发效率，也能让系统更安全地进行数据交互。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6新特性详解</title>
    <link href="/posts/34057/"/>
    <url>/posts/34057/</url>
    
    <content type="html"><![CDATA[<p>ES6（ECMAScript 6，也称为ECMAScript 2015）是JavaScript语言的一个重大更新，引入了许多新特性，旨在使代码更简洁、更易读，同时提供更强大的功能。以下是ES6中引入的主要新特性及其详细解释：</p><hr><h1 id="1-let-和-const-关键字"><a href="#1-let-和-const-关键字" class="headerlink" title="1. let 和 const 关键字"></a>1. <strong><code>let</code> 和 <code>const</code> 关键字</strong></h1><h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a><strong><code>let</code> 声明</strong></h4><ul><li><strong>块级作用域</strong>：<code>let</code> 声明的变量具有块级作用域，即变量只在其所在的代码块 <code>&#123;&#125;</code> 内有效。</li><li><strong>不允许重复声明</strong>：在同一作用域内，不能使用 <code>let</code> 重复声明同一个变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出 10</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 未定义</span><br></code></pre></td></tr></table></figure><h4 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a><strong><code>const</code> 声明</strong></h4><ul><li><strong>常量声明</strong>：<code>const</code> 用于声明常量，变量的值一旦赋值就不能再改变。</li><li><strong>块级作用域</strong>：<code>const</code> 也具有块级作用域。</li><li><strong>必须初始化</strong>：使用 <code>const</code> 声明时，必须同时进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.1415</span>; <span class="hljs-comment">// 报错，无法重新赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-箭头函数（Arrow-Functions）"><a href="#2-箭头函数（Arrow-Functions）" class="headerlink" title="2. 箭头函数（Arrow Functions）"></a>2. <strong>箭头函数（Arrow Functions）</strong></h1><p>箭头函数（Arrow Functions）是 JavaScript 中一种简洁的函数书写方式，它不仅使代码更简洁，而且在一些语法和行为上与普通函数不同。箭头函数自 ES6 引入以来，广泛应用于 JavaScript 开发中。</p><h2 id="2-1-箭头函数的基本语法"><a href="#2-1-箭头函数的基本语法" class="headerlink" title="2.1. 箭头函数的基本语法"></a>2.1. <strong>箭头函数的基本语法</strong></h2><p>箭头函数的基本语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">functionName</span> = (<span class="hljs-params">parameter1, parameter2, ...</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>const functionName</code> 是常规的变量声明方式，可以替换为 <code>let</code> 或 <code>var</code>。</li><li><code>(parameter1, parameter2, ...)</code> 是函数的参数，可以是零个或多个。</li><li><code>=&gt;</code> 是箭头函数的关键字，表示函数的开始。</li><li><code>&#123;&#125;</code> 包围着函数体，表示函数执行的操作。如果只有一行语句，可以省略花括号和 <code>return</code>。</li></ul><h2 id="2-2-最简单的箭头函数"><a href="#2-2-最简单的箭头函数" class="headerlink" title="2.2. 最简单的箭头函数"></a>2.2. <strong>最简单的箭头函数</strong></h2><p>一个简单的箭头函数，它没有参数，返回一个固定值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sayHello</span>());  <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><p>在这里，<code>sayHello</code> 是一个没有参数的箭头函数，直接返回 <code>&#39;Hello, World!&#39;</code> 字符串。</p><h2 id="2-3-有参数的箭头函数"><a href="#2-3-有参数的箭头函数" class="headerlink" title="2.3. 有参数的箭头函数"></a>2.3. 有参数的箭头函数</h2><p>箭头函数可以有一个或多个参数。对于一个参数时，可以省略圆括号；多个参数时，圆括号是必须的。</p><p><strong>单个参数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x * x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">square</span>(<span class="hljs-number">5</span>));  <span class="hljs-comment">// 输出: 25</span><br></code></pre></td></tr></table></figure><p><strong>多个参数：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出: 7</span><br></code></pre></td></tr></table></figure><h2 id="2-4-有返回值的箭头函数"><a href="#2-4-有返回值的箭头函数" class="headerlink" title="2.4. 有返回值的箭头函数"></a>2.4. <strong>有返回值的箭头函数</strong></h2><p>当箭头函数的函数体中只有一个表达式时，<code>return</code> 语句可以省略，表达式的结果会自动作为返回值返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">x, y</span>) =&gt; x * y;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出: 6</span><br></code></pre></td></tr></table></figure><p>对于多个表达式的箭头函数，必须使用花括号 <code>&#123;&#125;</code> 包裹函数体，并显式写出 <code>return</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addAndMultiply</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> sum = a + b;<br>  <span class="hljs-keyword">return</span> sum * <span class="hljs-number">2</span>;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addAndMultiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));  <span class="hljs-comment">// 输出: 14</span><br></code></pre></td></tr></table></figure><h2 id="2-5-箭头函数与-this"><a href="#2-5-箭头函数与-this" class="headerlink" title="2.5. 箭头函数与 this"></a>2.5. <strong>箭头函数与 <code>this</code></strong></h2><p>箭头函数与普通函数最大的区别之一是它不会创建自己的 <code>this</code> 值，而是继承（”绑定”）外部上下文中的 <code>this</code> 值。这意味着，在箭头函数中，<code>this</code> 的指向由外部作用域决定，通常是它被定义时的 <code>this</code>。</p><p><strong>普通函数中的 <code>this</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// undefined，因为普通函数的 `this` 指向 `setTimeout` 的作用域</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数中的 <code>this</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// John，因为箭头函数继承了外部作用域的 `this`</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上面的例子中，普通函数中的 <code>this</code> 指向 <code>setTimeout</code> 的上下文，而箭头函数中的 <code>this</code> 指向外部的 <code>Person</code> 对象，继承了外部的 <code>this</code>。</p><h2 id="2-6-箭头函数与-arguments-对象"><a href="#2-6-箭头函数与-arguments-对象" class="headerlink" title="2.6. 箭头函数与 arguments 对象"></a><strong>2.6. 箭头函数与 <code>arguments</code> 对象</strong></h2><p>箭头函数没有自己的 <code>arguments</code> 对象。它会继承外部函数的 <code>arguments</code> 对象。如果你需要使用 <code>arguments</code>，可以选择使用普通函数。</p><p><strong>普通函数的 <code>arguments</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-comment">// &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;</span><br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数无法使用 <code>arguments</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-comment">// 报错: arguments is not defined</span><br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h2 id="2-7-箭头函数在回调中的应用"><a href="#2-7-箭头函数在回调中的应用" class="headerlink" title="2.7. 箭头函数在回调中的应用"></a>2.7. <strong>箭头函数在回调中的应用</strong></h2><p>箭头函数通常用于回调函数，因为它的简洁性和继承外部 <code>this</code> 的特性，使得它在事件处理、数组方法（如 <code>map</code>、<code>filter</code>）等回调场景中非常有用。</p><p><strong>例子：使用 <code>map</code> 和箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> doubled = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled);  <span class="hljs-comment">// 输出: [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><p><strong>例子：在事件监听器中使用箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-8-箭头函数的限制"><a href="#2-8-箭头函数的限制" class="headerlink" title="2.8. 箭头函数的限制"></a>2.8. <strong>箭头函数的限制</strong></h2><p>虽然箭头函数有许多优点，但它也有一些限制和特性：</p><ol><li><p><strong>不能用作构造函数</strong>：箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();  <span class="hljs-comment">// 报错：Foo is not a constructor</span><br></code></pre></td></tr></table></figure></li><li><p>**没有 <code>prototype</code>**：箭头函数没有 <code>prototype</code> 属性，因此不能用作类的构造函数。</p></li><li><p>**不能改变 <code>this</code>**：箭头函数的 <code>this</code> 是继承自外部作用域的，而不是动态绑定的。如果你希望在调用时动态绑定 <code>this</code>，需要使用普通函数。</p></li></ol><h2 id="2-9-箭头函数与函数表达式"><a href="#2-9-箭头函数与函数表达式" class="headerlink" title="2.9. 箭头函数与函数表达式"></a>2.9. <strong>箭头函数与函数表达式</strong></h2><p>箭头函数通常与函数表达式一起使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure><h2 id="2-10-箭头函数的书写规范"><a href="#2-10-箭头函数的书写规范" class="headerlink" title="2.10. 箭头函数的书写规范"></a>2.10. <strong>箭头函数的书写规范</strong></h2><ul><li>如果箭头函数有多个参数，必须使用圆括号。</li><li>如果箭头函数只有一个参数且没有类型约束，可以省略圆括号。</li><li>如果箭头函数的主体只有一个表达式，可以省略花括号和 <code>return</code> 关键字。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>箭头函数是 JavaScript 中非常强大和简洁的特性，它在简化代码的同时，也带来了新的行为特性，特别是在 <code>this</code> 和 <code>arguments</code> 的处理上。箭头函数适用于需要短小、简洁的回调函数，尤其在处理数组、事件监听等场景时非常常见。尽管如此，在某些需要动态 <code>this</code> 或构造函数的场景中，普通函数依然是更合适的选择。</p><hr><h1 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3. 模板字符串（Template Literals）"></a>3. <strong>模板字符串（Template Literals）</strong></h1><ul><li><strong>多行字符串</strong>：使用反引号 &#96;&#96;&#96; 包裹，可以直接编写多行字符串。</li><li><strong>字符串插值</strong>：使用 <code>$&#123;表达式&#125;</code> 在字符串中嵌入变量或表达式的值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!</span><br><span class="hljs-string">Welcome to ES6 features.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Hello, Alice!</span><br><span class="hljs-comment">// Welcome to ES6 features.</span><br></code></pre></td></tr></table></figure><hr><h1 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. <strong>默认参数（Default Parameters）</strong></h1><ul><li><strong>函数参数默认值</strong>：在函数定义时，可以为参数指定默认值，当调用函数时未传入该参数时，使用默认值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;Guest&#x27;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// 输出 Hello, Bob!</span><br><span class="hljs-title function_">greet</span>();      <span class="hljs-comment">// 输出 Hello, Guest!</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-剩余参数和展开运算符（Rest-and-Spread-Operators）"><a href="#5-剩余参数和展开运算符（Rest-and-Spread-Operators）" class="headerlink" title="5. 剩余参数和展开运算符（Rest and Spread Operators）"></a>5. <strong>剩余参数和展开运算符（Rest and Spread Operators）</strong></h1><h4 id="剩余参数（Rest-Parameter）"><a href="#剩余参数（Rest-Parameter）" class="headerlink" title="剩余参数（Rest Parameter）"></a><strong>剩余参数（Rest Parameter）</strong></h4><ul><li><strong>函数参数</strong>：使用 <code>...</code> 收集函数的剩余参数，形成一个数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =&gt;</span> total + num, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h4 id="展开运算符（Spread-Operator）"><a href="#展开运算符（Spread-Operator）" class="headerlink" title="展开运算符（Spread Operator）"></a><strong>展开运算符（Spread Operator）</strong></h4><ul><li><strong>数组和对象展开</strong>：使用 <code>...</code> 将数组或对象展开。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组展开</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// 输出 [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// 对象展开</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// 输出 &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-解构赋值（Destructuring-Assignment）"><a href="#6-解构赋值（Destructuring-Assignment）" class="headerlink" title="6. 解构赋值（Destructuring Assignment）"></a>6. <strong>解构赋值（Destructuring Assignment）</strong></h1><ul><li><strong>数组解构</strong>：从数组中提取值，按照对应位置赋值给变量。</li><li><strong>对象解构</strong>：从对象中提取属性，赋值给与属性同名的变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构</span><br><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y); <span class="hljs-comment">// 输出 1 2</span><br><br><span class="hljs-comment">// 对象解构</span><br><span class="hljs-keyword">const</span> &#123; name, age &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// 输出 Alice 25</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-增强的对象字面量（Enhanced-Object-Literals）"><a href="#7-增强的对象字面量（Enhanced-Object-Literals）" class="headerlink" title="7. 增强的对象字面量（Enhanced Object Literals）"></a>7. <strong>增强的对象字面量（Enhanced Object Literals）</strong></h1><h3 id="1-属性简写（Property-Shorthand）"><a href="#1-属性简写（Property-Shorthand）" class="headerlink" title="1. 属性简写（Property Shorthand）"></a>1. 属性简写（Property Shorthand）</h3><p>在 ES6 之前，如果我们要在对象中设置属性，属性名通常与变量名相同，这时需要重复编写属性和变量名。但通过增强的对象字面量，可以直接使用简写语法。</p><h4 id="传统语法："><a href="#传统语法：" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: name,<br>  <span class="hljs-attr">age</span>: age<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-增强对象字面量的属性简写："><a href="#ES6-增强对象字面量的属性简写：" class="headerlink" title="ES6 增强对象字面量的属性简写："></a>ES6 增强对象字面量的属性简写：</h4><p>如果属性名和变量名相同，可以省略重复的部分，简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  name, <span class="hljs-comment">// 相当于 name: name</span><br>  age   <span class="hljs-comment">// 相当于 age: age</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：减少代码冗余，特别是在需要设置多个属性时，代码更简洁明了。</li></ul><h3 id="2-方法简写（Method-Shorthand）"><a href="#2-方法简写（Method-Shorthand）" class="headerlink" title="2. 方法简写（Method Shorthand）"></a>2. 方法简写（Method Shorthand）</h3><p>在对象中定义方法时，传统的写法需要显式使用 <code>function</code> 关键字。在增强的对象字面量中，可以使用更简洁的语法直接定义对象的方法。</p><h4 id="传统语法：-1"><a href="#传统语法：-1" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><h4 id="ES6-方法简写："><a href="#ES6-方法简写：" class="headerlink" title="ES6 方法简写："></a>ES6 方法简写：</h4><p>我们可以省略 <code>function</code> 关键字，直接用简写的形式来定义方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 简写方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：方法简写使得对象中的函数声明更简洁，代码也更容易阅读。</li></ul><h3 id="3-计算属性名（Computed-Property-Names）"><a href="#3-计算属性名（Computed-Property-Names）" class="headerlink" title="3. 计算属性名（Computed Property Names）"></a>3. 计算属性名（Computed Property Names）</h3><p>在增强的对象字面量中，允许动态地为对象的属性名赋值。你可以在对象定义时，通过方括号 <code>[]</code> 包裹表达式，使用计算出的值作为属性名。</p><h4 id="传统语法（ES5-没有计算属性名的支持）："><a href="#传统语法（ES5-没有计算属性名的支持）：" class="headerlink" title="传统语法（ES5 没有计算属性名的支持）："></a>传统语法（ES5 没有计算属性名的支持）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> person = &#123;&#125;;<br><br>person[key] = <span class="hljs-number">25</span>;  <span class="hljs-comment">// 动态添加属性</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-计算属性名："><a href="#ES6-计算属性名：" class="headerlink" title="ES6 计算属性名："></a>ES6 计算属性名：</h4><p>通过计算属性名的方式，可以直接在对象定义时动态设置属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  [key]: <span class="hljs-number">25</span>  <span class="hljs-comment">// 计算属性名</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性名不仅仅可以是变量，还可以是更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&#x27;user&#x27;</span>;<br><span class="hljs-keyword">const</span> id = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>_<span class="hljs-subst">$&#123;id&#125;</span>`</span>]: <span class="hljs-string">&#x27;Alice&#x27;</span>  <span class="hljs-comment">// 动态生成属性名 user_42</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// &#123; user_42: &#x27;Alice&#x27; &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：在需要动态生成属性名的场景下，计算属性名提供了灵活的解决方案。</li></ul><h1 id="8-类（Classes）"><a href="#8-类（Classes）" class="headerlink" title="8. 类（Classes）"></a>8. <strong>类（Classes）</strong></h1><ul><li><strong>类的定义</strong>：使用 <code>class</code> 关键字定义类。</li><li><strong>构造函数</strong>：使用 <code>constructor</code> 方法。</li><li><strong>继承</strong>：使用 <code>extends</code> 关键字实现继承，使用 <code>super</code> 调用父类方法。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">speak</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br>dog.<span class="hljs-title function_">speak</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Buddy makes a sound.</span><br><span class="hljs-comment">// Buddy barks.</span><br></code></pre></td></tr></table></figure><hr><h1 id="9-模块（Modules）"><a href="#9-模块（Modules）" class="headerlink" title="9. 模块（Modules）"></a>9. <strong>模块（Modules）</strong></h1><p>在 ES6（ECMAScript 2015）中，<strong>模块（Modules）</strong>是 JavaScript 中引入的一个重要特性，它为开发者提供了更好地组织代码的方式，使得代码更加模块化、可维护。模块系统允许我们将代码分隔成独立的模块，每个模块可以包含自己的变量、函数、类，并且这些模块之间可以通过 <code>export</code> 和 <code>import</code> 进行共享和使用。</p><p>接下来我们详细讲解模块的基本概念、用法以及如何在现代 JavaScript 项目中使用它们。</p><hr><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>在 ES6 之前，JavaScript 并没有原生的模块系统。开发者通常通过一些全局变量来共享数据，或者使用 IIFE（立即执行函数表达式）来模拟模块封装。这种做法容易导致命名冲突、全局污染，以及代码难以维护、复用性差的问题。</p><p>ES6 引入的模块系统解决了这些问题，它允许我们：</p><ul><li>将代码组织成多个独立的文件或模块；</li><li>在不同模块之间导入或导出功能；</li><li>避免全局命名冲突；</li><li>提高代码的可维护性和复用性。</li></ul><h2 id="ES6-模块基础概念"><a href="#ES6-模块基础概念" class="headerlink" title="ES6 模块基础概念"></a>ES6 模块基础概念</h2><p>ES6 模块主要依赖两个关键字：</p><ul><li>**<code>export</code>**：用来从模块中导出变量、函数、类等内容。</li><li>**<code>import</code>**：用来从其他模块中导入内容。</li></ul><h2 id="1-导出（Export）"><a href="#1-导出（Export）" class="headerlink" title="1. 导出（Export）"></a>1. 导出（Export）</h2><p><code>export</code> 用于将模块中的变量、函数、类等导出，供其他模块使用。</p><h3 id="1-1-命名导出（Named-Export）"><a href="#1-1-命名导出（Named-Export）" class="headerlink" title="1.1. 命名导出（Named Export）"></a>1.1. 命名导出（Named Export）</h3><p>命名导出允许你导出多个内容，并且每个导出都有自己明确的名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>  <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们导出了一个常量 <code>pi</code>，一个函数 <code>add</code>，以及一个类 <code>Calculator</code>。这些内容都可以通过名字从其他模块中导入。</p><h3 id="1-2-默认导出（Default-Export）"><a href="#1-2-默认导出（Default-Export）" class="headerlink" title="1.2. 默认导出（Default Export）"></a>1.2. 默认导出（Default Export）</h3><p>默认导出是指模块中可以有一个默认导出的值，导入时可以不需要用花括号。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// greeting.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们导出了一个默认的函数 <code>greet</code>，默认导出在每个模块中只能有一个。</p><h2 id="2-导入（Import）"><a href="#2-导入（Import）" class="headerlink" title="2. 导入（Import）"></a>2. 导入（Import）</h2><p><code>import</code> 用于从其他模块中导入导出的内容。导入可以是命名导出或默认导出。</p><h3 id="2-1-导入命名导出"><a href="#2-1-导入命名导出" class="headerlink" title="2.1. 导入命名导出"></a>2.1. 导入命名导出</h3><p>当从其他模块导入命名导出时，需要使用花括号 <code>&#123;&#125;</code>，并且变量名必须与导出的名称一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; pi, add, <span class="hljs-title class_">Calculator</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们从 <code>math.js</code> 中导入了 <code>pi</code>、<code>add</code> 函数和 <code>Calculator</code> 类，并在 <code>main.js</code> 中使用。</p><h3 id="2-2-导入默认导出"><a href="#2-2-导入默认导出" class="headerlink" title="2.2. 导入默认导出"></a>2.2. 导入默认导出</h3><p>导入默认导出时不需要使用花括号 <code>&#123;&#125;</code>，并且导入时可以任意命名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeting.js&#x27;</span>;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这里，我们导入了 <code>greeting.js</code> 中的默认导出 <code>greet</code> 函数，并直接使用它。</p><h3 id="2-3-导入别名"><a href="#2-3-导入别名" class="headerlink" title="2.3. 导入别名"></a>2.3. 导入别名</h3><p>有时你可能需要对导入的模块重命名，可以使用 <code>as</code> 来设置别名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>使用 <code>as</code> 可以避免命名冲突或让代码语义更加清晰。</p><h3 id="2-4-导入所有导出（import-as）"><a href="#2-4-导入所有导出（import-as）" class="headerlink" title="2.4. 导入所有导出（import * as）"></a>2.4. 导入所有导出（<code>import * as</code>）</h3><p>你也可以将整个模块的所有导出内容作为一个对象导入。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-property">pi</span>);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们将 <code>math.js</code> 中的所有导出作为一个 <code>math</code> 对象导入，然后通过 <code>math</code> 对象访问导出的内容。</p><h2 id="3-重新导出（Re-export）"><a href="#3-重新导出（Re-export）" class="headerlink" title="3. 重新导出（Re-export）"></a>3. 重新导出（Re-export）</h2><p>有时我们需要从一个模块导入一些内容后再导出给其他模块，这时可以使用 <code>export ... from</code> 语法。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> &#123; pi, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里，<code>moduleA.js</code> 重新导出了 <code>math.js</code> 中的 <code>pi</code> 和 <code>add</code>，其他模块可以直接从 <code>moduleA.js</code> 导入这些内容。</p><h2 id="4-动态导入（Dynamic-Import）"><a href="#4-动态导入（Dynamic-Import）" class="headerlink" title="4. 动态导入（Dynamic Import）"></a>4. 动态导入（Dynamic Import）</h2><p>ES6 模块中的 <code>import</code> 通常是静态的，即在编译时已经决定好导入的内容。然而，ES2020 引入了 <strong>动态导入（Dynamic Import）</strong>，它允许我们在运行时动态加载模块。</p><p>动态导入返回一个 <code>Promise</code>，当模块加载完成后会执行后续的操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error loading module:&#x27;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>动态导入特别适合按需加载模块或实现代码拆分（code splitting）。</p><hr><h2 id="ES6-模块的优势"><a href="#ES6-模块的优势" class="headerlink" title="ES6 模块的优势"></a>ES6 模块的优势</h2><ol><li><strong>默认严格模式</strong>：ES6 模块默认采用严格模式（<code>strict mode</code>），这意味着你可以避免一些常见的错误，比如全局变量的隐式声明。</li><li><strong>模块作用域</strong>：每个模块都有自己的作用域，模块内部的变量不会污染全局作用域，减少了命名冲突的可能性。</li><li><strong>按需导入</strong>：通过导入需要的内容，避免加载多余的代码，有助于提升性能。</li><li><strong>提升代码的可维护性和复用性</strong>：通过将功能分散到不同模块中，代码更容易维护，且可以重复使用不同模块中的功能。</li><li><strong>与现代构建工具集成</strong>：许多现代前端工具（如 Webpack、Parcel）和后端框架（如 Node.js）都支持 ES6 模块，可以方便地将模块化代码与构建工具结合使用。</li></ol><hr><h2 id="ES6-模块-vs-CommonJS"><a href="#ES6-模块-vs-CommonJS" class="headerlink" title="ES6 模块 vs CommonJS"></a>ES6 模块 vs CommonJS</h2><p>在 Node.js 中，最常见的模块系统是 <strong>CommonJS</strong>，通过 <code>require</code> 和 <code>module.exports</code> 来实现模块化。但 ES6 模块的出现提供了更标准化、现代化的解决方案。主要区别如下：</p><ul><li><strong>ES6 模块</strong>：通过 <code>import</code> 和 <code>export</code>，是编译时静态加载，支持浏览器原生模块化。</li><li><strong>CommonJS 模块</strong>：通过 <code>require</code> 和 <code>module.exports</code>，是运行时动态加载，最常见于 Node.js 环境中。</li></ul><p>随着 Node.js 开始原生支持 ES6 模块（通过文件扩展名 <code>.mjs</code> 或设置 <code>&quot;type&quot;: &quot;module&quot;</code>），开发者可以逐渐过渡到使用 ES6 模块系统。</p><hr><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. <strong>Promise 对象</strong></h1><p><strong>Promise</strong> 对象是 ES6 引入的一种用于处理异步操作的解决方案，避免了“回调地狱”的问题，使得异步代码的结构更加清晰、可读。<code>Promise</code> 允许你将异步操作的结果（成功或失败）封装成一个对象，并提供链式调用来处理异步操作的结果。</p><hr><h2 id="1-什么是-Promise？"><a href="#1-什么是-Promise？" class="headerlink" title="1. 什么是 Promise？"></a>1. 什么是 Promise？</h2><p><code>Promise</code> 是一个代表未来某个异步操作的结果的对象，它有三种状态：</p><ul><li><strong>Pending（进行中）</strong>：初始状态，异步操作尚未完成。</li><li><strong>Fulfilled（已完成）</strong>：异步操作成功完成，结果已返回。</li><li><strong>Rejected（已失败）</strong>：异步操作失败，返回了失败原因（通常是一个错误对象）。</li></ul><p>每个 <code>Promise</code> 实例一旦状态从 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变，也就是说 Promise 一旦 resolved 或 rejected 之后，结果是不可修改的。</p><h2 id="2-创建-Promise-对象"><a href="#2-创建-Promise-对象" class="headerlink" title="2. 创建 Promise 对象"></a>2. 创建 Promise 对象</h2><p>我们可以通过 <code>new Promise()</code> 构造函数来创建一个 Promise 对象。它接收一个函数作为参数，该函数包含两个参数：<code>resolve</code> 和 <code>reject</code>。</p><ul><li><code>resolve(value)</code>：当异步操作成功时调用，表示完成并将结果传递给下一个链式操作。</li><li><code>reject(error)</code>：当异步操作失败时调用，表示操作失败并将错误传递给错误处理器。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟异步操作的结果</span><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;操作成功！&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-Promise-状态变化"><a href="#3-Promise-状态变化" class="headerlink" title="3. Promise 状态变化"></a>3. Promise 状态变化</h2><p><code>Promise</code> 对象的状态只能从 <code>Pending</code> 转为 <code>Fulfilled</code> 或 <code>Rejected</code>，一旦状态改变，就不能再修改。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功了！&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 输出：Pending</span><br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：成功了！</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 最初状态为 Pending，2秒后会变为 Fulfilled</span><br></code></pre></td></tr></table></figure><h2 id="4-Promise-的使用"><a href="#4-Promise-的使用" class="headerlink" title="4. Promise 的使用"></a>4. Promise 的使用</h2><p>Promise 主要通过 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 进行链式调用来处理异步操作。</p><h3 id="4-1-then-：处理成功结果"><a href="#4-1-then-：处理成功结果" class="headerlink" title="4.1 .then()：处理成功结果"></a>4.1 <code>.then()</code>：处理成功结果</h3><p><code>then()</code> 方法用于处理 Promise 成功的结果。它接收两个回调函数，分别是成功回调和失败回调。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);  <span class="hljs-comment">// 成功的回调</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);  <span class="hljs-comment">// 失败的回调</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-catch-：处理失败结果"><a href="#4-2-catch-：处理失败结果" class="headerlink" title="4.2 .catch()：处理失败结果"></a>4.2 <code>.catch()</code>：处理失败结果</h3><p><code>catch()</code> 方法用于处理 Promise 中的错误或拒绝操作。它相当于 <code>.then()</code> 的第二个参数，但更适用于单独处理错误的场景。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);  <span class="hljs-comment">// 输出：错误：出错了</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-finally-：无论成功或失败都执行"><a href="#4-3-finally-：无论成功或失败都执行" class="headerlink" title="4.3 .finally()：无论成功或失败都执行"></a>4.3 <code>.finally()</code>：无论成功或失败都执行</h3><p><code>finally()</code> 方法无论 Promise 最终是成功还是失败，都会执行一次操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作结束&#x27;</span>);  <span class="hljs-comment">// 无论成功还是失败，都会执行</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="5-Promise-的链式调用"><a href="#5-Promise-的链式调用" class="headerlink" title="5. Promise 的链式调用"></a>5. Promise 的链式调用</h2><p>Promise 的强大之处在于它允许通过链式调用来处理多个异步操作。每个 <code>then()</code> 调用返回一个新的 <code>Promise</code> 对象，从而可以链式调用下一个异步操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：1</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：2</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：4</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，每个 <code>then()</code> 会返回一个新的 Promise，它可以继续链式调用。最终可以通过多个 <code>then()</code> 处理一系列的异步任务。</p><h2 id="6-Promise-静态方法"><a href="#6-Promise-静态方法" class="headerlink" title="6. Promise 静态方法"></a>6. Promise 静态方法</h2><h3 id="6-1-Promise-resolve"><a href="#6-1-Promise-resolve" class="headerlink" title="6.1 Promise.resolve()"></a>6.1 <code>Promise.resolve()</code></h3><p><code>Promise.resolve()</code> 方法返回一个已被 <code>resolve</code> 的 Promise，可以用来快速封装同步值。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：成功</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-2-Promise-reject"><a href="#6-2-Promise-reject" class="headerlink" title="6.2 Promise.reject()"></a>6.2 <code>Promise.reject()</code></h3><p><code>Promise.reject()</code> 方法返回一个已被 <code>reject</code> 的 Promise，用来封装错误或失败的结果。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 输出：失败</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-3-Promise-all"><a href="#6-3-Promise-all" class="headerlink" title="6.3 Promise.all()"></a>6.3 <code>Promise.all()</code></h3><p><code>Promise.all()</code> 方法接受一个包含多个 Promise 的数组，只有当所有 Promise 都成功时，才会执行 <code>then()</code> 回调；如果任何一个 Promise 失败，它就会立即进入 <code>catch()</code>。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);  <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-4-Promise-race"><a href="#6-4-Promise-race" class="headerlink" title="6.4 Promise.race()"></a>6.4 <code>Promise.race()</code></h3><p><code>Promise.race()</code> 方法接受一个包含多个 Promise 的数组，<strong>只要有一个 Promise 完成</strong>，就会进入 <code>then()</code> 回调，无论是成功还是失败。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;p1&#x27;</span>));<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;p2&#x27;</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：p2</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-Promise-实现异步操作"><a href="#7-Promise-实现异步操作" class="headerlink" title="7. Promise 实现异步操作"></a>7. Promise 实现异步操作</h2><p>Promise 的主要用途是处理异步操作，常见的如网络请求、文件读取等。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模拟异步网络请求</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 模拟请求成功</span><br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;请求的数据&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 输出：请求的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="11-Symbol-类型"><a href="#11-Symbol-类型" class="headerlink" title="11. Symbol 类型"></a>11. <strong>Symbol 类型</strong></h1><p><code>Symbol</code> 是 ECMAScript 6（ES6）引入的一种<strong>原始数据类型</strong>，它表示独一无二的值。与其他 JavaScript 数据类型（如字符串、数字、布尔值等）不同，<code>Symbol</code> 的主要作用是创建一个唯一的标识符，用于避免对象属性命名的冲突。</p><h2 id="1-Symbol-基础概念"><a href="#1-Symbol-基础概念" class="headerlink" title="1. Symbol 基础概念"></a>1. <strong>Symbol 基础概念</strong></h2><p><code>Symbol</code> 是通过 <code>Symbol()</code> 函数调用创建的。与其他原始数据类型不同，<code>Symbol</code> 的每个实例都是唯一的，即使两个 <code>Symbol()</code> 的参数相同，它们也是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbol1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-keyword">const</span> symbol2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbol1 === symbol2);  <span class="hljs-comment">// 输出：false</span><br></code></pre></td></tr></table></figure><ul><li>这里，<code>Symbol()</code> 中的参数 <code>&#39;description&#39;</code> 仅用于调试时的描述（可以理解为符号的标签），它不会影响 <code>Symbol</code> 的唯一性。</li></ul><h2 id="2-Symbol-的特性"><a href="#2-Symbol-的特性" class="headerlink" title="2. Symbol 的特性"></a>2. <strong>Symbol 的特性</strong></h2><ul><li><strong>唯一性</strong>：每个 <code>Symbol</code> 都是独一无二的，即使它们的描述相同，创建出来的 <code>Symbol</code> 也不会相等。</li><li><strong>不可改变</strong>：<code>Symbol</code> 是一种不可变的原始值，类似于 <code>string</code> 或 <code>number</code> 类型，它的值不能被修改。</li><li><strong>不可枚举</strong>：使用 <code>for...in</code>、<code>for...of</code> 或 <code>Object.keys()</code> 等方法遍历对象属性时，<code>Symbol</code> 类型的属性不会被枚举出来。</li></ul><h2 id="3-Symbol-作为对象属性的键"><a href="#3-Symbol-作为对象属性的键" class="headerlink" title="3. Symbol 作为对象属性的键"></a>3. <strong>Symbol 作为对象属性的键</strong></h2><p>通常，JavaScript 对象的键是字符串类型，但 <code>Symbol</code> 可以用作对象的键（属性名）。由于 <code>Symbol</code> 是唯一的，可以避免对象中使用相同的属性名导致的冲突。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [mySymbol]: <span class="hljs-string">&#x27;Symbol 属性值&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;普通属性值&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol]);  <span class="hljs-comment">// 输出：Symbol 属性值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);       <span class="hljs-comment">// 输出：普通属性值</span><br></code></pre></td></tr></table></figure><ul><li>注意，这里使用了 <strong>方括号语法</strong> <code>[mySymbol]</code> 来动态地定义对象的 <code>Symbol</code> 属性。</li></ul><h2 id="4-遍历-Symbol-属性"><a href="#4-遍历-Symbol-属性" class="headerlink" title="4. 遍历 Symbol 属性"></a>4. <strong>遍历 Symbol 属性</strong></h2><p>如前所述，<code>Symbol</code> 属性不会被 <code>for...in</code>、<code>Object.keys()</code> 等遍历方法枚举出来，但你可以通过以下几种方法获取对象的 <code>Symbol</code> 属性：</p><ul><li>**<code>Object.getOwnPropertySymbols()</code>**：返回一个包含对象所有 <code>Symbol</code> 属性的数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [sym1]: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  [sym2]: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> symbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbols);  <span class="hljs-comment">// 输出：[Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><ul><li>**<code>Reflect.ownKeys()</code>**：返回对象所有的键，包括字符串和 <code>Symbol</code> 类型。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj));  <span class="hljs-comment">// 输出：[&quot;name&quot;, Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><h2 id="5-全局-Symbol"><a href="#5-全局-Symbol" class="headerlink" title="5. 全局 Symbol"></a>5. <strong>全局 Symbol</strong></h2><p>JavaScript 还提供了 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 两个方法，用于创建和使用<strong>全局 Symbol</strong>。全局 Symbol 是共享的，即通过相同的 key 创建的全局 Symbol 总是相同的。</p><h3 id="5-1-Symbol-for"><a href="#5-1-Symbol-for" class="headerlink" title="5.1 Symbol.for()"></a>5.1 <strong><code>Symbol.for()</code></strong></h3><p><code>Symbol.for()</code> 方法接收一个字符串作为参数，检查全局注册表中是否存在该字符串对应的 Symbol，如果存在则返回该 Symbol，否则新建一个。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><span class="hljs-keyword">const</span> globalSym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalSym1 === globalSym2);  <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><ul><li><code>Symbol.for()</code> 使得相同 key 的 Symbol 是共享的，因此多个地方可以通过相同的 key 来引用同一个 Symbol。</li></ul><h3 id="5-2-Symbol-keyFor"><a href="#5-2-Symbol-keyFor" class="headerlink" title="5.2 Symbol.keyFor()"></a>5.2 <strong><code>Symbol.keyFor()</code></strong></h3><p><code>Symbol.keyFor()</code> 方法用于获取某个全局 Symbol 的 key。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym));  <span class="hljs-comment">// 输出：myKey</span><br></code></pre></td></tr></table></figure><ul><li>注意：<code>Symbol.keyFor()</code> 只能用于全局 <code>Symbol</code>，而不能用于普通的 <code>Symbol</code>。</li></ul><h2 id="6-内置的-Symbol"><a href="#6-内置的-Symbol" class="headerlink" title="6. 内置的 Symbol"></a>6. <strong>内置的 Symbol</strong></h2><p>ES6 还定义了一些内置的 <code>Symbol</code>，这些内置 <code>Symbol</code> 具有特殊的用途，通常用于定义一些 JavaScript 内部行为的自定义实现。</p><ul><li>**<code>Symbol.iterator</code>**：用于定义对象的默认迭代器，允许对象参与 <code>for...of</code> 循环。</li><li>**<code>Symbol.toStringTag</code>**：用于自定义 <code>Object.prototype.toString</code> 的返回值。</li><li>**<code>Symbol.hasInstance</code>**：用于判断对象是否是某个构造函数的实例。</li></ul><h3 id="6-1-Symbol-iterator"><a href="#6-1-Symbol-iterator" class="headerlink" title="6.1 Symbol.iterator"></a>6.1 <code>Symbol.iterator</code></h3><p><code>Symbol.iterator</code> 是一个内置的 <code>Symbol</code>，允许你为对象定义迭代行为，从而使对象可以被 <code>for...of</code> 循环使用。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterableObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">3</span> ? &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> iterableObj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Symbol-toStringTag"><a href="#6-2-Symbol-toStringTag" class="headerlink" title="6.2 Symbol.toStringTag"></a>6.2 <code>Symbol.toStringTag</code></h3><p><code>Symbol.toStringTag</code> 允许你自定义对象在 <code>Object.prototype.toString()</code> 中显示的标签。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;MyCustomObject&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(myObj));  <span class="hljs-comment">// 输出：[object MyCustomObject]</span><br></code></pre></td></tr></table></figure><h2 id="7-Symbol-的应用场景"><a href="#7-Symbol-的应用场景" class="headerlink" title="7. Symbol 的应用场景"></a>7. <strong>Symbol 的应用场景</strong></h2><ul><li><strong>避免对象属性名冲突</strong>：使用 <code>Symbol</code> 作为对象属性的键，保证属性名是唯一的，防止重写或冲突，特别是在大型代码库或第三方库中。</li><li><strong>为对象定义私有属性</strong>：由于 <code>Symbol</code> 属性不可枚举，通常可以用于实现“伪私有”属性，不会被 <code>for...in</code> 遍历到。</li><li><strong>扩展原生对象的行为</strong>：通过使用内置 <code>Symbol</code>，可以扩展 JavaScript 原生对象的行为，比如为对象自定义迭代器。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. <strong>总结</strong></h2><ul><li><strong><code>Symbol</code> 是一种唯一的标识符</strong>，用于避免对象属性名的冲突。</li><li><strong><code>Symbol</code> 属性不可枚举</strong>，不能通过常规的对象遍历方法访问，但可以通过 <code>Object.getOwnPropertySymbols()</code> 或 <code>Reflect.ownKeys()</code> 获取。</li><li><strong>全局 <code>Symbol</code></strong> 可以通过 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 共享并访问。</li><li>ES6 提供了一些**内置的 <code>Symbol</code>**，用于修改 JavaScript 原生行为，如 <code>Symbol.iterator</code>、<code>Symbol.toStringTag</code> 等。</li></ul><p><code>Symbol</code> 是 JavaScript 中一种非常有用的工具，它为我们提供了更多灵活性和控制力，特别是在大型项目中，使用 <code>Symbol</code> 可以有效地避免属性名冲突和确保代码的稳定性。</p><hr><h1 id="12-迭代器（Iterators）和-for-of-循环"><a href="#12-迭代器（Iterators）和-for-of-循环" class="headerlink" title="12. 迭代器（Iterators）和 for...of 循环"></a>12. <strong>迭代器（Iterators）和 <code>for...of</code> 循环</strong></h1><h2 id="1-迭代器（Iterators）"><a href="#1-迭代器（Iterators）" class="headerlink" title="1. 迭代器（Iterators）"></a>1. 迭代器（Iterators）</h2><p><strong>迭代器</strong>是一种用于访问集合中元素的对象，它提供了一种标准化的方法来遍历各种数据结构（如数组、对象、集合等）。迭代器遵循一定的协议，使得各种对象可以被一致地遍历。</p><h3 id="1-1-迭代器协议"><a href="#1-1-迭代器协议" class="headerlink" title="1.1 迭代器协议"></a>1.1 迭代器协议</h3><p>迭代器协议是一组规则，定义了一个对象如何提供遍历操作。任何实现了这些规则的对象都可以称为迭代器。</p><ul><li><p>迭代器对象</p><p>：必须实现 <strong>next</strong> 方法，该方法返回一个对象，这个对象包含两个属性：</p><ul><li><code>value</code>：当前遍历的值。</li><li><code>done</code>：一个布尔值，指示是否已遍历完所有值（<code>true</code> 表示遍历完成，<code>false</code> 表示还有剩余值）。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterator = &#123;<br>  <span class="hljs-attr">current</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">last</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 3, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-可迭代对象（Iterable-Objects）"><a href="#1-2-可迭代对象（Iterable-Objects）" class="headerlink" title="1.2 可迭代对象（Iterable Objects）"></a>1.2 可迭代对象（Iterable Objects）</h3><p>可迭代对象是具有 <code>Symbol.iterator</code> 属性的对象，<code>Symbol.iterator</code> 属性的值是一个函数，这个函数返回一个迭代器。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterable = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-for-of-循环"><a href="#2-for-of-循环" class="headerlink" title="2. for...of 循环"></a>2. <code>for...of</code> 循环</h2><p><code>for...of</code> 循环是 ES6 引入的用于遍历可迭代对象（包括数组、字符串、Map、Set 等）的一种语法。与传统的 <code>for</code> 循环不同，<code>for...of</code> 循环更简洁、易于理解，并且可以直接访问到每个元素。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><strong>基本语法：</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> iterable) &#123;<br>  <span class="hljs-comment">// 处理 element</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-遍历数组"><a href="#2-1-遍历数组" class="headerlink" title="2.1 遍历数组"></a>2.1 遍历数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><h3 id="2-2-遍历字符串"><a href="#2-2-遍历字符串" class="headerlink" title="2.2 遍历字符串"></a>2.2 遍历字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(char);<br>&#125;<br><span class="hljs-comment">// 输出：h, e, l, l, o</span><br></code></pre></td></tr></table></figure><h3 id="2-3-遍历-Set"><a href="#2-3-遍历-Set" class="headerlink" title="2.3 遍历 Set"></a>2.3 遍历 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> mySet) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h3 id="2-4-遍历-Map"><a href="#2-4-遍历-Map" class="headerlink" title="2.4 遍历 Map"></a>2.4 遍历 Map</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：key1: value1, key2: value2</span><br></code></pre></td></tr></table></figure><h2 id="3-自定义可迭代对象"><a href="#3-自定义可迭代对象" class="headerlink" title="3. 自定义可迭代对象"></a>3. 自定义可迭代对象</h2><p>你可以通过实现 <code>Symbol.iterator</code> 方法来自定义一个可迭代对象，并使用 <code>for...of</code> 循环进行遍历。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> customIterable = &#123;<br>  <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; data.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: data[index++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> customIterable) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li><strong>迭代器</strong> 是遵循特定协议的对象，它包含 <code>next</code> 方法来逐步访问集合中的元素。</li><li><strong>可迭代对象</strong> 是实现了 <code>Symbol.iterator</code> 方法的对象，可以被 <code>for...of</code> 循环遍历。</li><li><strong><code>for...of</code> 循环</strong> 使得遍历可迭代对象变得更加简洁直观，可以直接访问每个元素，而无需手动管理迭代器对象。</li></ul><p>通过理解和掌握这些概念，你可以更有效地处理各种数据结构，编写更加清晰和可维护的代码。</p><hr><h1 id="13-生成器（Generators）"><a href="#13-生成器（Generators）" class="headerlink" title="13. 生成器（Generators）"></a>13. <strong>生成器（Generators）</strong></h1><p>生成器是 ECMAScript 6 (ES6) 引入的一种特殊类型的函数，允许函数在执行时被暂停和恢复。生成器在处理需要多次迭代的任务时非常有用，比如遍历数据集、异步操作等。生成器函数可以简化代码逻辑，并提供了一种优雅的方式来管理异步操作。</p><h2 id="1-生成器的基本概念"><a href="#1-生成器的基本概念" class="headerlink" title="1. 生成器的基本概念"></a>1. <strong>生成器的基本概念</strong></h2><p>生成器是能够暂停执行并在之后的时间点恢复执行的函数。生成器函数通过 <code>function*</code> 关键字定义，并且返回一个生成器对象。生成器对象具有 <code>next()</code> 方法，可以用来控制生成器的执行过程。</p><h2 id="2-生成器函数的定义"><a href="#2-生成器函数的定义" class="headerlink" title="2. 生成器函数的定义"></a>2. <strong>生成器函数的定义</strong></h2><p>生成器函数通过 <code>function*</code> 语法定义。生成器函数内部使用 <code>yield</code> 关键字来暂停函数的执行，并返回一个值。每次调用 <code>next()</code> 方法时，生成器会从上次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 语句。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: World</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: !</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="3-生成器对象"><a href="#3-生成器对象" class="headerlink" title="3. 生成器对象"></a>3. <strong>生成器对象</strong></h2><p>生成器函数返回一个生成器对象，该对象具有以下方法：</p><ul><li>**<code>next([value])</code>**：恢复生成器函数的执行，直到下一个 <code>yield</code> 表达式。可以传递一个参数 <code>value</code>，作为 <code>yield</code> 表达式的返回值。返回的对象包含两个属性：<ul><li><code>value</code>：<code>yield</code> 表达式返回的值。</li><li><code>done</code>：布尔值，表示生成器是否已经完成执行。</li></ul></li><li>**<code>return([value])</code>**：结束生成器的执行，返回一个包含 <code>value</code> 的对象。<code>done</code> 属性将被设置为 <code>true</code>。</li><li>**<code>throw(exception)</code>**：在生成器中抛出异常，生成器会捕获这个异常并将其作为 <code>throw</code> 表达式的结果。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)); <span class="hljs-comment">// 输出: Error: Something went wrong</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-生成器的实际应用"><a href="#4-生成器的实际应用" class="headerlink" title="4. 生成器的实际应用"></a>4. <strong>生成器的实际应用</strong></h2><p>生成器在许多实际场景中都非常有用：</p><ul><li><p><strong>迭代器</strong>：生成器提供了一种简洁的方式来实现自定义的迭代器，使得遍历自定义数据结构变得容易。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">range</span>(<span class="hljs-params">start, end</span>) &#123;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    <span class="hljs-keyword">yield</span> start++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>异步编程</strong>：生成器与 Promise 结合可以简化异步编程。通过使用 <code>yield</code> 可以逐步处理异步操作，代码看起来更加同步。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">fetchData</span>();<br>generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(response).<span class="hljs-property">value</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>状态机</strong>：生成器可以用来实现状态机，通过 <code>yield</code> 和 <code>next()</code> 控制状态的转换。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">stateMachine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;start&#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is start&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;middle&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is middle&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;end&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;State is end&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> machine = <span class="hljs-title function_">stateMachine</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is start</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;middle&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is middle</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;end&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is end</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>生成器是 ES6 中一个强大的特性，它提供了一种简单而灵活的方式来控制函数的执行流。通过 <code>function*</code> 语法定义生成器函数，并使用 <code>yield</code> 来暂停和恢复执行。生成器可以用于实现自定义迭代器、简化异步编程、实现状态机等。它们的使用可以使代码更加优雅和易于维护。</p><p>如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="14-Map-和-Set-数据结构"><a href="#14-Map-和-Set-数据结构" class="headerlink" title="14. Map 和 Set 数据结构"></a>14. <strong><code>Map</code> 和 <code>Set</code> 数据结构</strong></h1><p>在 ECMAScript 6 (ES6) 中，<code>Map</code> 和 <code>Set</code> 是两个新的数据结构，它们提供了比传统的对象和数组更强大的功能，特别是在处理键值对和唯一值时。下面是对这两个数据结构的详细解释。</p><hr><h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a><strong><code>Map</code> 数据结构</strong></h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Map</code> 是一个有序的键值对集合，其中的键和值都可以是任何类型的值。与普通的对象不同，<code>Map</code> 的键值对是按插入顺序保持的，并且键的类型不受限制。</p><h3 id="2-创建-Map"><a href="#2-创建-Map" class="headerlink" title="2. 创建 Map"></a>2. <strong>创建 <code>Map</code></strong></h3><p>你可以使用 <code>new Map()</code> 来创建一个新的 <code>Map</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Map</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Map 实例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Map</span><br><span class="hljs-keyword">const</span> mapWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>],<br>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>set(key, value)</code>**：添加或更新键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>get(key)</code>**：根据键获取值。如果键不存在，返回 <code>undefined</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>has(key)</code>**：检查是否存在指定的键。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(key)</code>**：删除指定的键及其对应的值。如果删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Map</code> 中的所有键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Map</code> 中键值对的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li>**<code>keys()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键。</li><li>**<code>values()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的值。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键值对。</li><li>**<code>forEach(callback)</code>**：对 <code>Map</code> 中的每个键值对执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong><code>Set</code> 数据结构</strong></h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Set</code> 是一个值的集合，其中的值是唯一的，不允许重复。<code>Set</code> 的值是按照插入顺序排列的。</p><h3 id="2-创建-Set"><a href="#2-创建-Set" class="headerlink" title="2. 创建 Set"></a>2. <strong>创建 <code>Set</code></strong></h3><p>你可以使用 <code>new Set()</code> 来创建一个新的 <code>Set</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Set</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Set 实例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Set</span><br><span class="hljs-keyword">const</span> setWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>add(value)</code>**：向 <code>Set</code> 中添加一个值。如果值已经存在，则不会重复添加。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;apple&#x27;</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>has(value)</code>**：检查 <code>Set</code> 中是否存在指定的值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;apple&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(value)</code>**：删除 <code>Set</code> 中的指定值。如果值存在并且删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Set</code> 中的所有值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Set</code> 中的值的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li><strong><code>keys()</code></strong> 和 **<code>values()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有值（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有键值对（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>forEach(callback)</code>**：对 <code>Set</code> 中的每个值执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**<code>Map</code>**：适用于需要键值对并且键可以是任意类型的情况。提供了有序的键值对，并且具有丰富的方法来操作数据。</li><li>**<code>Set</code>**：适用于需要唯一值的情况。提供了无重复的值集合，并且具有方便的方法来检查和操作这些值。</li></ul><p>这两个数据结构在 ES6 中提供了比传统的对象和数组更高效和灵活的操作方式。如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="15-WeakMap-和-WeakSet"><a href="#15-WeakMap-和-WeakSet" class="headerlink" title="15. WeakMap 和 WeakSet"></a>15. <strong><code>WeakMap</code> 和 <code>WeakSet</code></strong></h1><ul><li><strong>弱引用</strong>：<code>WeakMap</code> 和 <code>WeakSet</code> 中的键（对于 <code>WeakMap</code>）和值（对于 <code>WeakSet</code>）是弱引用，不会阻止垃圾回收。</li><li><strong>用途</strong>：常用于存储关联到对象的元数据，不会干扰对象的垃圾回收。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some value&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 被垃圾回收，weakMap 中的键值对也会被自动移除</span><br></code></pre></td></tr></table></figure><hr><h1 id="16-新增的字符串、数字、数组方法"><a href="#16-新增的字符串、数字、数组方法" class="headerlink" title="16. 新增的字符串、数字、数组方法"></a>16. <strong>新增的字符串、数字、数组方法</strong></h1><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a><strong>字符串方法</strong></h4><ul><li>**<code>includes()</code>**：判断字符串是否包含指定子串。</li><li>**<code>startsWith()</code>**：判断字符串是否以指定子串开头。</li><li>**<code>endsWith()</code>**：判断字符串是否以指定子串结尾。</li><li>**<code>repeat()</code>**：将字符串重复指定次数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// 输出 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ha&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 HaHaHa</span><br></code></pre></td></tr></table></figure><h4 id="数字方法"><a href="#数字方法" class="headerlink" title="数字方法"></a><strong>数字方法</strong></h4><ul><li>**<code>Number.isNaN()</code>**：判断值是否为 <code>NaN</code>。</li><li>**<code>Number.isFinite()</code>**：判断值是否为有限数。</li><li>**<code>Number.isInteger()</code>**：判断值是否为整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">4.5</span>)); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h4><ul><li>**<code>Array.from()</code>**：将类数组或可迭代对象转换为数组。</li><li>**<code>Array.of()</code>**：创建一个由参数组成的新数组。</li><li>**<code>find()</code> 和 <code>findIndex()</code>**：找到符合条件的第一个元素或其索引。</li><li>**<code>fill()</code>**：用指定值填充数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 2</span><br><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 输出 [1, 0, 0, 4]</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-Proxy-对象"><a href="#17-Proxy-对象" class="headerlink" title="17. Proxy 对象"></a>17. <strong><code>Proxy</code> 对象</strong></h1><p><code>Proxy</code> 是 ECMAScript 6（ES6）引入的一个新特性，它允许你创建一个对象的代理（Proxy），通过该代理可以定义基本操作的自定义行为，比如属性查找、赋值、枚举、函数调用等。<code>Proxy</code> 提供了一种灵活的机制，用于拦截并修改对目标对象的操作。</p><h2 id="1-创建-Proxy"><a href="#1-创建-Proxy" class="headerlink" title="1. 创建 Proxy"></a>1. <strong>创建 Proxy</strong></h2><p><code>Proxy</code> 构造函数接收两个参数：</p><ul><li>**<code>target</code>**：要创建代理的目标对象，可以是任何对象（包括原始值）。</li><li>**<code>handler</code>**：一个对象，其中定义了代理的行为（即拦截操作）。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><h2 id="2-Handler-对象"><a href="#2-Handler-对象" class="headerlink" title="2. Handler 对象"></a>2. <strong>Handler 对象</strong></h2><p><code>handler</code> 对象包含多个陷阱（trap）方法，这些方法定义了代理如何处理不同的操作。每个陷阱方法对应一个基本操作，如读取属性、设置属性等。</p><p><strong>常见陷阱方法包括：</strong></p><ul><li>**<code>get</code>**：拦截对象属性的读取操作。</li><li>**<code>set</code>**：拦截对象属性的写入操作。</li><li>**<code>has</code>**：拦截 <code>in</code> 操作符。</li><li>**<code>deleteProperty</code>**：拦截 <code>delete</code> 操作符。</li><li>**<code>apply</code>**：拦截函数调用。</li><li>**<code>construct</code>**：拦截构造函数调用。</li><li>**<code>ownKeys</code>**：拦截 <code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.keys()</code>。</li><li>**<code>getPrototypeOf</code>**：拦截 <code>Object.getPrototypeOf()</code>。</li><li>**<code>setPrototypeOf</code>**：拦截 <code>Object.setPrototypeOf()</code>。</li></ul><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h2><p>以下是一些使用 <code>Proxy</code> 对象的示例，展示了如何通过代理对象来拦截和修改对目标对象的操作。</p><h3 id="3-1-属性读取和设置"><a href="#3-1-属性读取和设置" class="headerlink" title="3.1 属性读取和设置"></a>3.1 属性读取和设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>;  <span class="hljs-comment">// 控制台输出: Setting name to John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 控制台输出: Getting name, 输出: John</span><br></code></pre></td></tr></table></figure><ul><li><code>get</code> 陷阱拦截对属性的读取。</li><li><code>set</code> 陷阱拦截对属性的写入。</li></ul><h3 id="3-2-属性存在检查"><a href="#3-2-属性存在检查" class="headerlink" title="3.2 属性存在检查"></a>3.2 属性存在检查</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Checking existence of <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, property);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// 控制台输出: Checking existence of name, 输出: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> proxy);   <span class="hljs-comment">// 控制台输出: Checking existence of age, 输出: false</span><br></code></pre></td></tr></table></figure><ul><li><code>has</code> 陷阱拦截 <code>in</code> 操作符。</li></ul><h3 id="3-3-函数调用"><a href="#3-3-函数调用" class="headerlink" title="3.3 函数调用"></a>3.3 函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling function with arguments <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 控制台输出: Calling function with arguments 1,2, 输出: 3</span><br></code></pre></td></tr></table></figure><ul><li><code>apply</code> 陷阱拦截函数调用。</li></ul><h3 id="3-4-构造函数调用"><a href="#3-4-构造函数调用" class="headerlink" title="3.4 构造函数调用"></a>3.4 构造函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Constructing with arguments <span class="hljs-subst">$&#123;args&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 控制台输出: Constructing with arguments 1,2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);  <span class="hljs-comment">// 输出: target &#123; x: 1, y: 2 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>construct</code> 陷阱拦截构造函数调用。</li></ul><h2 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4. 常见用法"></a>4. <strong>常见用法</strong></h2><ul><li><strong>数据验证</strong>：可以使用 <code>Proxy</code> 对象来验证对目标对象的属性值进行检查，例如确保属性值在某个范围内。</li><li><strong>日志记录</strong>：可以在 <code>Proxy</code> 的陷阱方法中记录对目标对象的所有操作，用于调试和分析。</li><li><strong>防御性编程</strong>：可以通过 <code>Proxy</code> 保护目标对象，防止非法的属性操作。</li><li><strong>虚拟化</strong>：可以使用 <code>Proxy</code> 实现懒加载和其他性能优化技术，例如按需加载对象属性。</li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h2><ul><li><strong>性能</strong>：使用 <code>Proxy</code> 对象会引入额外的开销，因为每个操作都需要经过陷阱函数。对于性能敏感的应用，要慎重使用。</li><li><strong>无法代理的对象</strong>：一些对象（如内置对象、冻结的对象）不能被 <code>Proxy</code> 代理。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><p><code>Proxy</code> 对象是 ES6 引入的强大特性，允许你创建一个代理对象来拦截和自定义对目标对象的操作。通过使用 <code>Proxy</code>，可以实现许多高级功能，如数据验证、日志记录和虚拟化等。在实际应用中，合理使用 <code>Proxy</code> 可以大大提高代码的灵活性和可维护性。</p><hr><h1 id="18-Reflect-API"><a href="#18-Reflect-API" class="headerlink" title="18. Reflect API"></a>18. <strong><code>Reflect</code> API</strong></h1><p><code>Reflect</code> 是 ES6 引入的一个内置对象，它提供了一组方法，用于操作对象的原型和目标对象的内部状态。<code>Reflect</code> 对象主要用于与 <code>Proxy</code> 一起使用，它提供了一些与 <code>Proxy</code> 陷阱方法相对应的基本操作，这些方法可以用来在代理对象内部调用目标对象的原始操作。</p><h2 id="1-Reflect-的方法"><a href="#1-Reflect-的方法" class="headerlink" title="1.Reflect 的方法"></a>1.Reflect 的方法</h2><p><code>Reflect</code> 提供了一些与对象操作相关的静态方法，这些方法对应于对象操作的基本行为。主要的方法包括：</p><ul><li><p><strong><code>Reflect.apply(target, thisArg, argumentsList)</code></strong></p><ul><li><p>用于调用一个函数，类似于 <code>Function.prototype.apply</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：要调用的函数。</li><li><code>thisArg</code>：函数内部的 <code>this</code>。</li><li><code>argumentsList</code>：参数数组。</li></ul></li><li><p><strong>返回值</strong>：函数调用的结果。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(sum, <span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.construct(target, argumentsList, newTarget)</code></strong></p><ul><li><p>用于创建一个对象实例，类似于 <code>new</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：构造函数。</li><li><code>argumentsList</code>：构造函数的参数数组。</li><li><code>newTarget</code>：指定构造函数的原型链的对象。</li></ul></li><li><p><strong>返回值</strong>：构造函数创建的新对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: Alice</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.defineProperty(target, propertyKey, attributes)</code></strong></p><ul><li><p>用于定义目标对象的属性，类似于 <code>Object.defineProperty</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>attributes</code>：属性描述符。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功定义。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.deleteProperty(target, propertyKey)</code></strong></p><ul><li><p>用于删除目标对象的属性，类似于 <code>delete</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：要删除的属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.get(target, propertyKey, receiver)</code></strong></p><ul><li><p>用于获取目标对象的属性值，类似于 <code>target[propertyKey]</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：属性的值。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.getPrototypeOf(target)</code></strong></p><ul><li><p>用于获取目标对象的原型，类似于 <code>Object.getPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：目标对象的原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prototype === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.has(target, propertyKey)</code></strong></p><ul><li><p>用于检查目标对象是否具有指定的属性，类似于 <code>propertyKey in target</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否存在。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.isExtensible(target)</code></strong></p><ul><li><p>用于检查目标对象是否可扩展（即是否可以添加新属性），类似于 <code>Object.isExtensible</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示目标对象是否可扩展。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.ownKeys(target)</code></strong></p><ul><li><p>用于获取目标对象的所有属性名（包括符号属性），类似于 <code>Object.getOwnPropertyNames</code> 和 <code>Object.getOwnPropertySymbols</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：属性名数组。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// 输出: [&#x27;name&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.set(target, propertyKey, value, receiver)</code></strong></p><ul><li><p>用于设置目标对象的属性值，类似于 <code>target[propertyKey] = value</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>value</code>：属性值。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功设置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.setPrototypeOf(target, prototype)</code></strong></p><ul><li><p>用于设置目标对象的原型，类似于 <code>Object.setPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>prototype</code>：新的原型。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示是否成功设置原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> newProto = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, newProto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === newProto);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><ul><li><strong><code>Reflect</code></strong> 对象提供了一组静态方法，用于操作对象的基本行为。</li><li><strong><code>Reflect</code></strong> 方法主要用于与 <code>Proxy</code> 一起使用，以便在代理对象中执行目标对象的操作。</li><li><strong><code>Reflect</code></strong> 提供的方法与目标对象操作的方法一一对应，简化了对象操作的实现逻辑，使得代码更加一致和可维护。</li></ul><p><code>Reflect</code> 对象是一个强大的工具，用于更细粒度地控制对象的行为，并且是 ES6 提供的一个重要功能。</p><hr><h1 id="19-尾调用优化（Tail-Call-Optimization）"><a href="#19-尾调用优化（Tail-Call-Optimization）" class="headerlink" title="19. 尾调用优化（Tail Call Optimization）"></a>19. <strong>尾调用优化（Tail Call Optimization）</strong></h1><p>尾调用优化（TCO）是一种编程语言优化技术，旨在提高递归函数的效率，防止函数调用栈的增长，避免因递归深度过大而导致的栈溢出。尾调用优化的核心思想是将尾递归（即递归调用是函数的最后一步操作）转换为更高效的迭代形式，从而减少内存使用。</p><h2 id="1-尾调用（Tail-Call）"><a href="#1-尾调用（Tail-Call）" class="headerlink" title="1. 尾调用（Tail Call）"></a>1. <strong>尾调用（Tail Call）</strong></h2><p>尾调用是指在函数的最后一步调用另一个函数，而没有任何额外的计算。换句话说，尾调用是函数调用的最后操作，没有任何额外的工作要做。这种调用模式适合进行尾调用优化。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>factorial</code> 函数中的递归调用 <code>factorial(n - 1, n * result)</code> 是尾调用，因为它是函数 <code>factorial</code> 的最后一步操作。</p><h2 id="2-尾调用优化的原理"><a href="#2-尾调用优化的原理" class="headerlink" title="2. 尾调用优化的原理"></a>2. <strong>尾调用优化的原理</strong></h2><p>在尾调用优化中，当一个函数执行尾调用时，编译器或解释器会将当前函数的栈帧复用到被调用函数的栈帧中。这样，递归调用不会增加新的栈帧，从而避免了栈空间的消耗。</p><p><strong>过程：</strong></p><ol><li><strong>当前函数执行到尾调用位置</strong>。</li><li><strong>丢弃当前函数的栈帧</strong>，因为在尾调用时当前函数的执行已经完成。</li><li><strong>重用当前函数的栈帧</strong>，将控制权转移到被调用函数。</li></ol><p>通过这种方式，尾调用优化将递归调用转化为迭代，从而避免了递归深度带来的性能问题。</p><h2 id="3-支持尾调用优化的语言"><a href="#3-支持尾调用优化的语言" class="headerlink" title="3. 支持尾调用优化的语言"></a>3. <strong>支持尾调用优化的语言</strong></h2><p>一些编程语言支持尾调用优化，包括：</p><ul><li><strong>Scheme</strong>：作为 Lisp 家族的一员，Scheme 是一种支持尾调用优化的函数式编程语言。</li><li><strong>Racket</strong>：Racket 也是一种支持尾调用优化的语言，具有类似于 Scheme 的特性。</li><li><strong>Haskell</strong>：Haskell 是一种纯函数式编程语言，支持尾调用优化。</li></ul><h2 id="4-JavaScript-中的尾调用优化"><a href="#4-JavaScript-中的尾调用优化" class="headerlink" title="4. JavaScript 中的尾调用优化"></a>4. <strong>JavaScript 中的尾调用优化</strong></h2><p>虽然 JavaScript 语言规范（ECMAScript 2015）引入了尾调用优化的提案，但实际支持这一特性的浏览器和 JavaScript 引擎的实现仍然不统一。部分浏览器的 JavaScript 引擎可能并不完全支持尾调用优化，因此，在实际开发中不一定能保证尾调用优化的效果。</p><p><strong>ECMAScript 2015（ES6）提案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 规范中定义了尾调用优化的行为，但实际支持情况取决于 JavaScript 引擎的实现。</p><h2 id="5-非支持尾调用优化的情况下的解决方案"><a href="#5-非支持尾调用优化的情况下的解决方案" class="headerlink" title="5. 非支持尾调用优化的情况下的解决方案"></a>5. <strong>非支持尾调用优化的情况下的解决方案</strong></h2><p>如果运行环境不支持尾调用优化，递归深度过大可能会导致栈溢出。在这种情况下，可以使用迭代代替递归，以避免深度递归带来的问题。</p><p><strong>迭代替代尾递归示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    result *= n;<br>    n--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例使用了迭代来计算阶乘，而不是递归，从而避免了栈溢出的问题。</p><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul><li><strong>尾调用</strong> 是指在函数的最后一步调用另一个函数。</li><li><strong>尾调用优化（TCO）</strong> 通过重用栈帧来减少递归深度，避免栈溢出。</li><li>一些编程语言（如 Scheme、Haskell）支持尾调用优化，但 JavaScript 的支持情况不一致。</li><li>当尾调用优化不可用时，可以使用迭代代替递归来避免栈溢出。</li></ul><p>尾调用优化是函数式编程中的一个重要概念，通过优化递归调用，可以使代码更加高效、健壮。在实际开发中，要根据运行环境的特性来决定是否依赖于尾调用优化。</p><hr><h1 id="20-模块加载器（Module-Loader）"><a href="#20-模块加载器（Module-Loader）" class="headerlink" title="20. 模块加载器（Module Loader）"></a>20. <strong>模块加载器（Module Loader）</strong></h1><p>在 ECMAScript 2015（ES6）中，引入了原生的模块系统，这一系统为 JavaScript 提供了标准化的模块化支持，称为 ES6 模块（ESM）。ES6 模块系统具有内建的模块加载器，允许开发者通过 <code>import</code> 和 <code>export</code> 语法来进行模块化编程。</p><h2 id="1-ES6-模块的基本概念"><a href="#1-ES6-模块的基本概念" class="headerlink" title="1. ES6 模块的基本概念"></a>1. <strong>ES6 模块的基本概念</strong></h2><p>在 ES6 中，模块是 JavaScript 代码的基本组织单元。每个模块都有自己的作用域，模块之间的依赖关系通过显式的 <code>import</code> 和 <code>export</code> 语法来定义和管理。</p><p><strong>模块的基本特点</strong>：</p><ul><li><strong>静态加载</strong>：模块在编译时加载，这使得依赖关系可以在编译阶段进行静态分析和优化。</li><li><strong>严格模式</strong>：模块默认在严格模式下运行，这有助于避免一些常见的 JavaScript 错误。</li><li><strong>导入和导出</strong>：模块可以通过 <code>export</code> 导出变量、函数或类，并通过 <code>import</code> 导入其他模块的导出。</li></ul><h2 id="2-模块导出（Export）"><a href="#2-模块导出（Export）" class="headerlink" title="2. 模块导出（Export）"></a>2. <strong>模块导出（Export）</strong></h2><p>ES6 模块通过 <code>export</code> 语法导出模块的功能。导出的内容可以是变量、函数、类或对象。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateArea</span>(<span class="hljs-params">radius</span>) &#123; <span class="hljs-comment">// 导出函数</span><br>  <span class="hljs-keyword">return</span> pi * radius * radius;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123; <span class="hljs-comment">// 导出类</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">radius</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;<br>  &#125;<br>  <span class="hljs-title function_">getArea</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> pi * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-模块导入（Import）"><a href="#3-模块导入（Import）" class="headerlink" title="3. 模块导入（Import）"></a>3. <strong>模块导入（Import）</strong></h2><p>ES6 模块通过 <code>import</code> 语法导入其他模块的内容。可以导入整个模块的功能，也可以导入模块的部分功能。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; pi, calculateArea, <span class="hljs-title class_">Circle</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi); <span class="hljs-comment">// 输出: 3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateArea</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 78.5</span><br><br><span class="hljs-keyword">const</span> myCircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCircle.<span class="hljs-title function_">getArea</span>()); <span class="hljs-comment">// 输出: 78.5</span><br></code></pre></td></tr></table></figure><h2 id="4-默认导出（Default-Export）"><a href="#4-默认导出（Default-Export）" class="headerlink" title="4. 默认导出（Default Export）"></a>4. <strong>默认导出（Default Export）</strong></h2><p>ES6 模块允许每个模块有一个默认导出，这对于导出单一的功能或对象非常有用。默认导出可以是变量、函数或类。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>; <span class="hljs-comment">// 导入默认导出</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><h2 id="5-动态导入（Dynamic-Import）"><a href="#5-动态导入（Dynamic-Import）" class="headerlink" title="5. 动态导入（Dynamic Import）"></a>5. <strong>动态导入（Dynamic Import）</strong></h2><p>ES6 模块也支持动态导入，即在运行时加载模块。这是通过 <code>import()</code> 函数实现的，返回一个 Promise 对象，可以在异步操作中使用。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">pi</span>);<br>&#125;<br><br><span class="hljs-title function_">loadModule</span>();<br></code></pre></td></tr></table></figure><h2 id="6-模块加载器的工作原理"><a href="#6-模块加载器的工作原理" class="headerlink" title="6. 模块加载器的工作原理"></a>6. <strong>模块加载器的工作原理</strong></h2><p>ES6 模块加载器的工作原理包括以下几个步骤：</p><ol><li><strong>解析模块</strong>：当模块被加载时，加载器会解析模块的 <code>import</code> 和 <code>export</code> 语法，确定模块之间的依赖关系。</li><li><strong>加载模块</strong>：根据解析结果，加载器会从指定的路径或 URL 加载模块的代码。</li><li><strong>执行模块</strong>：加载器会执行模块的代码，并处理模块的 <code>export</code> 和 <code>import</code> 语句。</li><li><strong>缓存模块</strong>：已加载的模块会被缓存，以便后续的 <code>import</code> 语句可以复用缓存的模块，避免重复加载。</li><li><strong>导出模块</strong>：模块的功能会通过 <code>export</code> 语法对外提供，其他模块可以通过 <code>import</code> 语法引用这些功能。</li></ol><h2 id="7-模块加载器的特点"><a href="#7-模块加载器的特点" class="headerlink" title="7. 模块加载器的特点"></a>7. <strong>模块加载器的特点</strong></h2><ul><li><strong>静态分析</strong>：ES6 模块的静态结构使得模块系统能够在编译时进行依赖分析和优化。</li><li><strong>作用域隔离</strong>：每个模块都有自己的作用域，避免了全局命名冲突。</li><li><strong>延迟加载</strong>：使用动态导入可以按需加载模块，提高应用程序的性能。</li><li><strong>编译时错误检测</strong>：静态分析可以在编译阶段检测导入和导出语法错误，提升代码质量。</li></ul><h2 id="8-与其他模块系统的比较"><a href="#8-与其他模块系统的比较" class="headerlink" title="8. 与其他模块系统的比较"></a>8. <strong>与其他模块系统的比较</strong></h2><p>与 CommonJS、AMD 和 UMD 等其他模块系统相比，ES6 模块具有以下优势：</p><ul><li><strong>原生支持</strong>：ES6 模块是 JavaScript 的标准部分，所有现代 JavaScript 引擎都支持。</li><li><strong>静态分析</strong>：ES6 模块的静态结构使得编译器和工具能够进行优化。</li><li><strong>模块作用域</strong>：ES6 模块的作用域隔离提供了更好的代码组织和模块管理。</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. <strong>总结</strong></h2><p>ES6 模块系统通过 <code>import</code> 和 <code>export</code> 语法提供了一个标准化的模块化机制，支持静态加载和动态导入。它的引入使得 JavaScript 的模块化编程更加高效和一致，为开发大型应用程序提供了强大的工具。了解 ES6 模块系统的工作原理和使用方法，有助于更好地组织和管理代码，提高代码的可维护性和重用性。</p><hr><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>ES6 的引入使 JavaScript 语言更加完善，提供了更强大的功能和更简洁的语法，极大地提高了开发效率。这些新特性涵盖了变量声明、函数定义、对象和数组操作、类和继承、模块化、异步编程等各个方面。熟练掌握ES6的新特性，将有助于编写出更加高效、可读性更强的代码。</p>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript1-5新特性详解</title>
    <link href="/posts/64231/"/>
    <url>/posts/64231/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-1-到-ECMAScript-5-新特性详解"><a href="#ECMAScript-1-到-ECMAScript-5-新特性详解" class="headerlink" title="ECMAScript 1 到 ECMAScript 5 新特性详解"></a>ECMAScript 1 到 ECMAScript 5 新特性详解</h1><hr><h1 id="ECMAScript-1-ES1-1997"><a href="#ECMAScript-1-ES1-1997" class="headerlink" title="ECMAScript 1 (ES1) - 1997"></a>ECMAScript 1 (ES1) - 1997</h1><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-基本语法和控制结构"><a href="#1-基本语法和控制结构" class="headerlink" title="1. 基本语法和控制结构"></a><strong>1. 基本语法和控制结构</strong></h3><ul><li>ECMAScript 1 引入了变量声明、条件判断、循环等基础控制结构，JavaScript 程序从此可以实现基本的逻辑控制。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// if...else 语句</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成年人&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;未成年人&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  count++;<br>&#125;<br><br><span class="hljs-comment">// for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a><strong>2. 数据类型</strong></h3><p>ES1 定义了基本的数据类型，包括 <code>Number</code>、<code>String</code>、<code>Boolean</code> 和 <code>Object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数据类型</span><br><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>;         <span class="hljs-comment">// Number</span><br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello&quot;</span>;      <span class="hljs-comment">// String</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// Boolean</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;; <span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure><h3 id="3-全局函数"><a href="#3-全局函数" class="headerlink" title="3. 全局函数"></a><strong>3. 全局函数</strong></h3><p>ES1 提供了 <code>parseInt</code> 和 <code>parseFloat</code> 函数，用于将字符串解析为整数和浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;42&quot;</span>));     <span class="hljs-comment">// 42</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.14&quot;</span>)); <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><hr><h1 id="ECMAScript-2-ES2-1998"><a href="#ECMAScript-2-ES2-1998" class="headerlink" title="ECMAScript 2 (ES2) - 1998"></a>ECMAScript 2 (ES2) - 1998</h1><p>ES2 是对 ES1 的规范化和修订版本，没有新特性。主要目的是与 ISO 标准保持一致。</p><hr><h1 id="ECMAScript-3-ES3-1999"><a href="#ECMAScript-3-ES3-1999" class="headerlink" title="ECMAScript 3 (ES3) - 1999"></a>ECMAScript 3 (ES3) - 1999</h1><h2 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-正则表达式（RegExp）"><a href="#1-正则表达式（RegExp）" class="headerlink" title="1. 正则表达式（RegExp）"></a><strong>1. 正则表达式（RegExp）</strong></h3><ul><li><strong>解释</strong>：正则表达式用于字符串模式匹配和替换。</li><li><strong>用法</strong>：<code>/pattern/flags</code> 的形式或通过 <code>RegExp</code> 构造函数创建。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基本用法</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/hello/i</span>;       <span class="hljs-comment">// 不区分大小写匹配 &quot;hello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// RegExp 构造函数</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;HELLO&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 正则表达式匹配</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;The quick brown fox&quot;</span>;<br><span class="hljs-keyword">var</span> result = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b\w&#123;5&#125;\b/g</span>); <span class="hljs-comment">// 匹配所有5个字母的单词</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [&quot;quick&quot;, &quot;brown&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="2-异常处理-try-catch-finally"><a href="#2-异常处理-try-catch-finally" class="headerlink" title="2. 异常处理 (try-catch-finally)"></a><strong>2. 异常处理 (<code>try-catch-finally</code>)</strong></h3><ul><li><strong>解释</strong>：<code>try-catch-finally</code> 结构允许捕获错误并进行相应处理，<code>finally</code> 总是会执行。</li><li><strong>用法</strong>：在 <code>try</code> 块中编写可能引发异常的代码，<code>catch</code> 捕获异常信息，<code>finally</code> 执行必要的清理工作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;&#125;&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Parsing error:&quot;</span>, error.<span class="hljs-property">message</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Finished parsing JSON&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-数组方法"><a href="#3-数组方法" class="headerlink" title="3. 数组方法"></a><strong>3. 数组方法</strong></h3><ul><li><strong>解释</strong>：ES3 引入了 <code>push</code>、<code>pop</code>、<code>shift</code> 和 <code>unshift</code> 等数组操作方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// push 添加元素到数组末尾</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// pop 移除数组最后一个元素</span><br>arr.<span class="hljs-title function_">pop</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// unshift 添加元素到数组开头</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [0, 1, 2, 3]</span><br><br><span class="hljs-comment">// shift 移除数组第一个元素</span><br>arr.<span class="hljs-title function_">shift</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="4-for-in-循环"><a href="#4-for-in-循环" class="headerlink" title="4. for...in 循环"></a><strong>4. <code>for...in</code> 循环</strong></h3><ul><li><strong>解释</strong>：遍历对象的所有可枚举属性。</li><li><strong>用法</strong>：<code>for...in</code> 遍历对象键值对。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-keyword">if</span> (person.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + person[key]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Function-apply-和-Function-call"><a href="#5-Function-apply-和-Function-call" class="headerlink" title="5. Function.apply 和 Function.call"></a><strong>5. <code>Function.apply</code> 和 <code>Function.call</code></strong></h3><ul><li><strong>解释</strong>：<code>apply</code> 和 <code>call</code> 允许将不同的 <code>this</code> 值传递给函数，并立即调用函数。<code>apply</code> 使用数组传递参数，而 <code>call</code> 逐个传递参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + punctuation);<br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><br><span class="hljs-comment">// 使用 call 逐个传递参数</span><br>greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>); <span class="hljs-comment">// &quot;Hello, Alice!&quot;</span><br><br><span class="hljs-comment">// 使用 apply 以数组传递参数</span><br>greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>]); <span class="hljs-comment">// &quot;Hi, Alice?&quot;</span><br></code></pre></td></tr></table></figure><hr><h1 id="ECMAScript-5-ES5-2009"><a href="#ECMAScript-5-ES5-2009" class="headerlink" title="ECMAScript 5 (ES5) - 2009"></a>ECMAScript 5 (ES5) - 2009</h1><h2 id="主要特性-2"><a href="#主要特性-2" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="1-严格模式（Strict-Mode）"><a href="#1-严格模式（Strict-Mode）" class="headerlink" title="1. 严格模式（Strict Mode）"></a><strong>1. 严格模式（Strict Mode）</strong></h3><ul><li><strong>解释</strong>：严格模式通过 <code>&quot;use strict&quot;;</code> 指令启用，更严格地解析代码，禁止一些不安全的语法。</li><li><strong>用法</strong>：在文件或函数顶部添加 <code>&quot;use strict&quot;;</code>，启用严格模式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>  undeclaredVar = <span class="hljs-number">42</span>; <span class="hljs-comment">// Error: undeclaredVar is not defined</span><br>&#125;<br><span class="hljs-title function_">example</span>();<br></code></pre></td></tr></table></figure><h3 id="2-JSON-支持"><a href="#2-JSON-支持" class="headerlink" title="2. JSON 支持"></a><strong>2. JSON 支持</strong></h3><ul><li><strong>解释</strong>：<code>JSON.parse</code> 和 <code>JSON.stringify</code> 用于处理 JSON 数据格式。</li><li><strong>用法</strong>：<code>JSON.parse</code> 将 JSON 字符串转换为对象；<code>JSON.stringify</code> 将对象转换为 JSON 字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonString = <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonString);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br><br><span class="hljs-keyword">var</span> newJsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newJsonString); <span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-对象增强方法"><a href="#3-对象增强方法" class="headerlink" title="3. 对象增强方法"></a><strong>3. 对象增强方法</strong></h3><ul><li><strong>解释</strong>：<code>Object.create</code>、<code>Object.keys</code> 和 <code>Object.defineProperty</code> 等方法增强了对象操作的灵活性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Object.create</span><br><span class="hljs-keyword">var</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Parent&quot;</span><br><br><span class="hljs-comment">// Object.keys 获取对象的键</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// []</span><br><br><span class="hljs-comment">// Object.defineProperty 定义只读属性</span><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;);<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 无法修改</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br></code></pre></td></tr></table></figure><p><strong><code>Object.keys</code> 只返回对象自身的可枚举属性，而不会包括从原型链上继承的属性。在上述的示例中：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Parent&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><strong><code>child</code> 对象的 <code>name</code> 属性是从 <code>parent</code> 继承而来的，并不是 <code>child</code> 自身的属性，所以 <code>Object.keys(child)</code> 返回空数组。</strong></p><p>如果你想查看 <code>child</code> 包括继承属性在内的所有属性，可以用 <code>for...in</code> 循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> child) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// &quot;name&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何在 <code>child</code> 上定义自身属性</strong></p><p>如果你需要 <code>child</code> 自身拥有一个 <code>name</code> 属性而不是从 <code>parent</code> 继承，可以直接赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Child&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(child)); <span class="hljs-comment">// [&quot;name&quot;]</span><br></code></pre></td></tr></table></figure><p>这样，<code>name</code> 就会作为 <code>child</code> 自身的属性出现。</p><h3 id="4-数组新方法"><a href="#4-数组新方法" class="headerlink" title="4. 数组新方法"></a><strong>4. 数组新方法</strong></h3><h4 id="4-1-Array-isArray"><a href="#4-1-Array-isArray" class="headerlink" title="4.1. Array.isArray()"></a>4.1. <code>Array.isArray()</code></h4><p><code>Array.isArray(value)</code> 用于判断给定的值是否为数组。</p><ul><li><strong>参数</strong>:<ul><li><code>value</code>: 要检查的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果值是数组，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>())); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-2-Array-prototype-forEach"><a href="#4-2-Array-prototype-forEach" class="headerlink" title="4.2. Array.prototype.forEach()"></a>4.2. <code>Array.prototype.forEach()</code></h4><p><code>forEach(callback(currentValue [, index [, array]])[, thisArg])</code> 方法对数组中的每个元素执行一次提供的函数。</p><ul><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><br>    : 要执行的函数，接受以下参数：<br><br>    - `currentValue`: 当前处理的元素。<br>    - `<span class="hljs-keyword">index</span><span class="hljs-symbol">`（可选）: 当前处理元素的索引。</span><br><span class="hljs-symbol">    - `</span><span class="hljs-keyword">array</span><span class="hljs-symbol">`（可选）: 调用 `</span>forEach<span class="hljs-symbol">` 的数组。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  - `</span>thisArg<span class="hljs-symbol">`（可选）: 当执行 `</span>callback<span class="hljs-symbol">` 函数时，用作 `</span>this<span class="hljs-symbol">` 的值。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">- **返回值**:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  - 没有返回值（返回 `</span>undefined<span class="hljs-symbol">`）。</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">**示例**:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">`</span><span class="hljs-symbol">``</span>javascript<br>const <span class="hljs-keyword">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.forEach((element, <span class="hljs-keyword">index</span>, arr) =&gt; &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-symbol">`Element at index $&#123;index&#125;: $&#123;element&#125;`</span>);<br>&#125;);<br>// Output:<br>// Element at <span class="hljs-keyword">index</span> <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>// <span class="hljs-keyword">Element</span> at <span class="hljs-keyword">index</span> <span class="hljs-number">1</span>: <span class="hljs-number">2</span><br>// <span class="hljs-keyword">Element</span> at <span class="hljs-keyword">index</span> <span class="hljs-number">2</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-3-Array-prototype-map"><a href="#4-3-Array-prototype-map" class="headerlink" title="4.3. Array.prototype.map()"></a>4.3. <code>Array.prototype.map()</code></h4><p><code>map(callback(currentValue [, index [, array]])[, thisArg])</code> 方法返回一个新数组，其结果是通过对原数组的每个元素调用提供的函数得到的。</p><ul><li><p><strong>用于对数组中的每个元素进行转换或操作。</strong></p></li><li><p><strong>返回一个新数组，该数组的每个元素都是对原数组相应元素经过某种处理后的结果。</strong></p></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`currentValue`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`map`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`thisArg`</span>（可选）: 当执行 <span class="hljs-code">`callback`</span> 函数时，用作 <span class="hljs-code">`this`</span> 的值。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回一个新数组。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3];</span><br><span class="hljs-code">const doubled = numbers.map(num =&gt; num * 2);</span><br><span class="hljs-code">console.log(doubled); // [2, 4, 6]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-4-Array-prototype-filter"><a href="#4-4-Array-prototype-filter" class="headerlink" title="4.4. Array.prototype.filter()"></a>4.4. <code>Array.prototype.filter()</code></h4><p><code>filter(callback(element [, index [, array]])[, thisArg])</code> 方法创建一个新数组，包含所有通过测试的元素。</p><ul><li><p><strong>用于从数组中筛选出满足特定条件的元素。</strong></p></li><li><p><strong>返回一个新数组，该数组只包含满足条件的元素。</strong></p></li><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`element`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`filter`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`thisArg`</span>（可选）: 当执行 <span class="hljs-code">`callback`</span> 函数时，用作 <span class="hljs-code">`this`</span> 的值。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回一个新数组，包含通过测试的所有元素。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3, 4, 5];</span><br><span class="hljs-code">const evenNumbers = numbers.filter(num =&gt; num % 2 === 0);</span><br><span class="hljs-code">console.log(evenNumbers); // [2, 4]</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-5-Array-prototype-reduce"><a href="#4-5-Array-prototype-reduce" class="headerlink" title="4.5. Array.prototype.reduce()"></a>4.5. <code>Array.prototype.reduce()</code></h4><p><code>reduce(callback(accumulator, currentValue [, index [, array]])[, initialValue])</code> 方法对数组中的每个元素应用一个函数，将其归纳为单一的值。</p><ul><li><p><strong>参数</strong>:</p><ul><li><pre><code class="javascript">callback<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    : 要执行的函数，接受以下参数：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> <span class="hljs-code">`accumulator`</span>: 累加器，累积回调的返回值。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`currentValue`</span>: 当前处理的元素。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`index`</span>（可选）: 当前处理元素的索引。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`array`</span>（可选）: 调用 <span class="hljs-code">`reduce`</span> 的数组。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`initialValue`</span>（可选）: 作为第一次调用 <span class="hljs-code">`callback`</span> 函数时的第一个参数。如果没有提供初始值，则数组的第一个元素将被用作初始值，且不执行回调。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**返回值**</span>:<br><br><span class="hljs-bullet">  -</span> 返回最终的累加器值。<br><br><span class="hljs-strong">**示例**</span>:<br><br><span class="hljs-code">```javascript</span><br><span class="hljs-code">const numbers = [1, 2, 3, 4];</span><br><span class="hljs-code">const sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);</span><br><span class="hljs-code">console.log(sum); // 10</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>用法</strong></p><h5 id="1-求和"><a href="#1-求和" class="headerlink" title="1. 求和"></a>1. 求和</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 输出: 15</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法将数组中的所有数字相加。<code>initialValue</code> 设置为 <code>0</code>，作为累加器的初始值。</p><h5 id="2-求最大值"><a href="#2-求最大值" class="headerlink" title="2. 求最大值"></a>2. 求最大值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> max = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (currentValue &gt; accumulator) ? currentValue : accumulator;<br>&#125;, numbers[<span class="hljs-number">0</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max); <span class="hljs-comment">// 输出: 5</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法找出数组中的最大值。<code>initialValue</code> 设置为数组的第一个元素。</p><h5 id="3-计数出现次数"><a href="#3-计数出现次数" class="headerlink" title="3. 计数出现次数"></a>3. 计数出现次数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>];<br><span class="hljs-keyword">const</span> count = fruits.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> &#123;<br>  accumulator[currentValue] = (accumulator[currentValue] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;, &#123;&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 输出: &#123; apple: 3, banana: 2, orange: 1 &#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>reduce()</code> 方法统计每种水果出现的次数，并将结果存储在一个对象中。</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li><strong>累加器</strong>: 用于求和、计算平均值等。</li><li><strong>汇总数据</strong>: 将数组中的数据汇总为单个对象、字符串或其他数据结构。</li><li><strong>转换数据结构</strong>: 将数组转换为其他数据类型，如对象或另一个数组。</li></ul><h4 id="4-6-Array-prototype-reduceRight"><a href="#4-6-Array-prototype-reduceRight" class="headerlink" title="4.6. Array.prototype.reduceRight()"></a>4.6. <code>Array.prototype.reduceRight()</code></h4><p><code>reduceRight(callback(accumulator, currentValue [, index [, array]])[, initialValue])</code> 方法与 <code>reduce()</code> 类似，<strong>但它从数组的最后一个元素开始向前进行。</strong></p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>reduce</code> 相同。</li><li><code>initialValue</code>（可选）: 同上。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回最终的累加器值。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> concatenated = numbers.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;accumulator&#125;</span>-<span class="hljs-subst">$&#123;currentValue&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(concatenated); <span class="hljs-comment">// &quot;4-3-2-1&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-7-Array-prototype-some"><a href="#4-7-Array-prototype-some" class="headerlink" title="4.7. Array.prototype.some()"></a>4.7. <code>Array.prototype.some()</code></h4><p><code>some(callback(element [, index [, array]])[, thisArg])</code> 方法测试数组中是否至少有一个元素通过了提供的函数测试。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果数组中至少有一个元素通过测试，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> hasEven = numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasEven); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-8-Array-prototype-every"><a href="#4-8-Array-prototype-every" class="headerlink" title="4.8. Array.prototype.every()"></a>4.8. <code>Array.prototype.every()</code></h4><p><code>every(callback(element [, index [, array]])[, thisArg])</code> 方法测试数组中的所有元素是否都通过了提供的函数测试。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果所有元素都通过测试，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">const</span> allEven = numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allEven); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="4-9-Array-prototype-indexOf"><a href="#4-9-Array-prototype-indexOf" class="headerlink" title="4.9. Array.prototype.indexOf()"></a>4.9. <code>Array.prototype.indexOf()</code></h4><p><code>indexOf(searchElement[, fromIndex])</code> 方法返回数组中首次出现指定值的索引，如果未找到则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为 <code>0</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回指定元素的索引，如果未找到则返回 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h4 id="4-10-Array-prototype-lastIndexOf"><a href="#4-10-Array-prototype-lastIndexOf" class="headerlink" title="4.10. Array.prototype.lastIndexOf()"></a>4.10. <code>Array.prototype.lastIndexOf()</code></h4><p><code>lastIndexOf(searchElement[, fromIndex])</code> 方法返回数组中最后一次出现指定值的索引，如果未找到则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为数组长度减一，即从最后一个元素开始查找。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回指定元素的最后一次出现的索引，如果未找到则返回 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h4 id="4-11-Array-prototype-splice"><a href="#4-11-Array-prototype-splice" class="headerlink" title="4.11. Array.prototype.splice()"></a>4.11. <code>Array.prototype.splice()</code></h4><p><code>splice(start, deleteCount[, item1[, item2[, ...]]])</code> 方法可以添加、删除或替换数组中的元素。它会修改原数组，并返回被删除的元素（如果有）。</p><ul><li><strong>参数</strong>:<ul><li><code>start</code>: 从该索引开始修改数组。</li><li><code>deleteCount</code>: 要删除的元素数量。</li><li><code>item1, item2, ...</code>（可选）: 要添加到数组的新元素。(<strong>需要注意的是插入的位置是在删除的位置</strong>)</li></ul></li><li><strong>返回值</strong>:<ul><li>返回包含已删除元素的数组，如果没有删除元素，则返回空数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> removed = array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [1, 5, 6, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(removed); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="4-12-Array-prototype-slice"><a href="#4-12-Array-prototype-slice" class="headerlink" title="4.12. Array.prototype.slice()"></a>4.12. <code>Array.prototype.slice()</code></h4><p><code>slice(start, end)</code> 方法返回数组的一个浅拷贝（即包含原数组中所选元素的数组）。不修改原数组。</p><ul><li><strong>参数</strong>:<ul><li><code>start</code>: 提取的第一个元素的索引（包含）。</li><li><code>end</code>（可选）: 提取的最后一个元素的索引（不包含），默认为数组长度。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回包含指定元素的新数组。</li></ul></li></ul><p><strong>示例</strong></p><p>下面通过几个示例来说明 <code>slice()</code> 的浅拷贝特性。</p><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 提取索引 1 到 3 的元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>newArray</code> 是从 <code>originalArray</code> 中提取的元素，<code>originalArray</code> 保持不变。</p><h5 id="2-修改新数组中的基本类型"><a href="#2-修改新数组中的基本类型" class="headerlink" title="2. 修改新数组中的基本类型"></a>2. 修改新数组中的基本类型</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>();<br><br>newArray[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改新数组的第一个元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalArray); <span class="hljs-comment">// 输出: [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [10, 2, 3]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>originalArray</code> 的内容没有受到影响，因为这里是基本数据类型（数字），直接的值拷贝。</p><h5 id="3-修改新数组中的对象"><a href="#3-修改新数组中的对象" class="headerlink" title="3. 修改新数组中的对象"></a>3. 修改新数组中的对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> originalArray = [&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;];<br><span class="hljs-keyword">let</span> newArray = originalArray.<span class="hljs-title function_">slice</span>();<br><br>newArray[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改新数组中的对象的属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalArray); <span class="hljs-comment">// 输出: [&#123; value: 10 &#125;, &#123; value: 2 &#125;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// 输出: [&#123; value: 10 &#125;, &#123; value: 2 &#125;]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>originalArray</code> 的第一个元素的属性 <code>value</code> 被修改了，因为 <code>newArray</code> 和 <code>originalArray</code> 中的元素都是对同一个对象的引用。</p><p><strong>小结</strong></p><ul><li><strong><code>slice()</code> 创建的新数组是对原数组的浅拷贝。</strong></li><li><strong>如果原数组中的元素是基本类型，修改新数组不会影响原数组。</strong></li><li><strong>如果原数组中的元素是对象，修改新数组中的对象会影响到原数组，因为它们引用的是同一个对象。</strong></li></ul><h4 id="4-13-Array-prototype-concat"><a href="#4-13-Array-prototype-concat" class="headerlink" title="4.13. Array.prototype.concat()"></a>4.13. <code>Array.prototype.concat()</code></h4><p><code>concat(value1[, value2[, ...]])</code> 方法用于合并两个或多个数组，并返回一个新数组。</p><ul><li><strong>参数</strong>:<ul><li><code>value1, value2, ...</code>: 要合并的数组或值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回一个新数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> array2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> newArray = array1.<span class="hljs-title function_">concat</span>(array2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h4 id="4-14-Array-prototype-join"><a href="#4-14-Array-prototype-join" class="headerlink" title="4.14. Array.prototype.join()"></a>4.14. <code>Array.prototype.join()</code></h4><p><code>join(separator)</code> 方法将数组的所有元素连接成一个字符串。</p><ul><li><strong>参数</strong>:<ul><li><code>separator</code>（可选）: 用于分隔每个元素的字符串，默认为逗号 <code>,</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回由数组元素连接而成的字符串。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> joined = array.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(joined); <span class="hljs-comment">// &quot;1-2-3&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-15-Array-prototype-reverse"><a href="#4-15-Array-prototype-reverse" class="headerlink" title="4.15. Array.prototype.reverse()"></a>4.15. <code>Array.prototype.reverse()</code></h4><p><code>reverse()</code> 方法反转数组中的元素顺序。</p><ul><li><strong>参数</strong>:<ul><li>无。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回反转后的数组（是原数组的引用）。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">reverse</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><h4 id="4-16-Array-prototype-sort"><a href="#4-16-Array-prototype-sort" class="headerlink" title="4.16. Array.prototype.sort()"></a>4.16. <code>Array.prototype.sort()</code></h4><p><code>sort(compareFunction)</code> 方法是用于对数组中的元素进行排序的一个内置方法。它会改变原数组并返回引用相同的数组。默认情况下，<code>sort()</code> 方法将元素按字符串Unicode编码进行排序。要进行数值排序或自定义排序，可以提供一个比较函数。</p><ul><li><strong>参数</strong>:<ul><li><code>compareFunction</code>（可选）: 一个用于比较两个元素的函数。如果提供该函数，数组会根据其返回值进行排序。<ul><li>如果返回值小于 0，则 <code>a</code> 在 <code>b</code> 之前。</li><li>如果返回值大于 0，则 <code>a</code> 在 <code>b</code> 之后。</li><li>如果返回值等于 0，则 <code>a</code> 和 <code>b</code> 的相对位置保持不变。</li></ul></li></ul></li><li><strong>返回值</strong>:<ul><li>返回已排序的数组（是原数组的引用）。</li></ul></li></ul><h5 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1.默认行为"></a>1.默认行为</h5><p>当没有提供 <code>compareFunction</code> 时，<code>sort()</code> 方法将元素转换为字符串，然后按字符顺序进行排序。例如，数字会被转为字符串并按字典序排列。</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br>fruits.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span><br></code></pre></td></tr></table></figure><h5 id="2-数字排序的例子"><a href="#2-数字排序的例子" class="headerlink" title="2.数字排序的例子"></a>2.数字排序的例子</h5><p>由于默认的排序是按照字符串顺序进行的，对于数字排序可能会导致意想不到的结果。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>];<br>numbers.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [1, 10, 2, 21]</span><br></code></pre></td></tr></table></figure><p>为了进行数值排序，我们需要提供一个比较函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>];<br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 从小到大排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [1, 2, 10, 21]</span><br><br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a); <span class="hljs-comment">// 从大到小排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// 输出: [21, 10, 2, 1]</span><br></code></pre></td></tr></table></figure><h5 id="3-自定义排序"><a href="#3-自定义排序" class="headerlink" title="3.自定义排序"></a>3.自定义排序</h5><p>我们可以根据需要自定义比较函数，以实现不同的排序规则。例如，我们可以根据对象的属性进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> items = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Banana&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">5</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Cherry&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">15</span> &#125;<br>];<br><br><span class="hljs-comment">// 按价格从小到大排序</span><br>items.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">price</span> - b.<span class="hljs-property">price</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items);<br><span class="hljs-comment">// 输出: [&#123; name: &#x27;Banana&#x27;, price: 5 &#125;, &#123; name: &#x27;Apple&#x27;, price: 10 &#125;, &#123; name: &#x27;Cherry&#x27;, price: 15 &#125;]</span><br></code></pre></td></tr></table></figure><h5 id="4-排序的稳定性"><a href="#4-排序的稳定性" class="headerlink" title="4.排序的稳定性"></a>4.排序的稳定性</h5><p><strong>在 ECMAScript 2019（ES10）之前，<code>sort()</code> 方法的排序算法是不稳定的。这意味着如果两个元素相等，它们的相对顺序可能会被改变。从 ECMAScript 2019 开始，排序的稳定性得到了保证，但具体实现仍然依赖于 JavaScript 引擎。</strong></p><h5 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h5><ol><li><strong>原地排序</strong>: <code>sort()</code> 方法会改变原数组，而不是创建一个新数组。</li><li><strong>返回值</strong>: <code>sort()</code> 方法返回对原数组的引用。</li><li><strong>空数组</strong>: 对于空数组，<code>sort()</code> 方法不会有任何效果。</li></ol><h5 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h5><ul><li><code>Array.prototype.sort()</code> 是一个强大而灵活的方法，适用于多种排序需求。</li><li>使用自定义比较函数可以轻松实现数字、字符串和对象的排序。</li><li>理解默认排序行为非常重要，以避免在处理数字时产生意外结果。</li></ul><h4 id="4-17-Array-prototype-fill"><a href="#4-17-Array-prototype-fill" class="headerlink" title="4.17. Array.prototype.fill()"></a>4.17. <code>Array.prototype.fill()</code></h4><p><code>fill(value[, start[, end]])</code> 方法用指定的值填充数组的所有元素。</p><ul><li><strong>参数</strong>:<ul><li><code>value</code>: 用于填充数组的值。</li><li><code>start</code>（可选）: 开始填充的索引，默认为 <code>0</code>。</li><li><code>end</code>（可选）: 停止填充的索引，默认为数组长度。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回填充后的数组（是原数组的引用）。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [1, 0, 0]</span><br></code></pre></td></tr></table></figure><h4 id="4-18-Array-prototype-includes"><a href="#4-18-Array-prototype-includes" class="headerlink" title="4.18. Array.prototype.includes()"></a>4.18. <code>Array.prototype.includes()</code></h4><p><code>includes(searchElement[, fromIndex])</code> 方法确定数组是否包含指定值，返回 <code>true</code> 或 <code>false</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>searchElement</code>: 要查找的值。</li><li><code>fromIndex</code>（可选）: 开始查找的索引，默认为 <code>0</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>如果数组中包含指定值，返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="4-19-Array-prototype-flat"><a href="#4-19-Array-prototype-flat" class="headerlink" title="4.19. Array.prototype.flat()"></a>4.19. <code>Array.prototype.flat()</code></h4><p><code>flat(depth)</code> 方法用于将嵌套的数组展平。</p><ul><li><strong>参数</strong>:<ul><li><code>depth</code>（可选）: 要展平的层数，默认为 <code>1</code>。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回展平后的新数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]];<br><span class="hljs-keyword">const</span> flattened = array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flattened); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="4-20-Array-prototype-flatMap"><a href="#4-20-Array-prototype-flatMap" class="headerlink" title="4.20. Array.prototype.flatMap()"></a>4.20. <code>Array.prototype.flatMap()</code></h4><p><code>flatMap(callback(currentValue[, index[, array]])[, thisArg])</code> 方法先对每个元素应用映射函数，然后再将结果压平。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>map</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回新的数组。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> flatMapped = array.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> [num, num * <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flatMapped); <span class="hljs-comment">// [1, 2, 2, 4, 3, 6]</span><br></code></pre></td></tr></table></figure><h4 id="4-21-Array-prototype-find"><a href="#4-21-Array-prototype-find" class="headerlink" title="4.21. Array.prototype.find()"></a>4.21. <code>Array.prototype.find()</code></h4><p><code>find(callback(element[, index[, array]])[, thisArg])</code> 方法返回数组中满足提供测试函数的第一个元素的值，否则返回 <code>undefined</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回满足条件的第一个元素，或 <code>undefined</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> found = array.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(found); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="4-22-Array-prototype-findIndex"><a href="#4-22-Array-prototype-findIndex" class="headerlink" title="4.22. Array.prototype.findIndex()"></a>4.22. <code>Array.prototype.findIndex()</code></h4><p><code>findIndex(callback(element[, index[, array]])[, thisArg])</code> 方法返回数组中满足提供测试函数的第一个元素的索引，否则返回 <code>-1</code>。</p><ul><li><strong>参数</strong>:<ul><li><code>callback</code>: 要执行的函数，接受的参数与 <code>forEach</code> 相同。</li><li><code>thisArg</code>（可选）: 当执行 <code>callback</code> 函数时，用作 <code>this</code> 的值。</li></ul></li><li><strong>返回值</strong>:<ul><li>返回满足条件的第一个元素的索引，或 <code>-1</code>。</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> index = array.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript新特性总览</title>
    <link href="/posts/65387/"/>
    <url>/posts/65387/</url>
    
    <content type="html"><![CDATA[<h3 id="1-ECMAScript-1-ES1-1997"><a href="#1-ECMAScript-1-ES1-1997" class="headerlink" title="1. ECMAScript 1 (ES1) - 1997"></a>1. ECMAScript 1 (ES1) - 1997</h3><ul><li><strong>首个版本</strong>：定义了基本的 JavaScript 语法和功能，奠定了 JavaScript 标准的基础。</li></ul><h3 id="2-ECMAScript-2-ES2-1998"><a href="#2-ECMAScript-2-ES2-1998" class="headerlink" title="2. ECMAScript 2 (ES2) - 1998"></a>2. ECMAScript 2 (ES2) - 1998</h3><ul><li><strong>小幅更新</strong>：对 ES1 进行了一些格式化的调整，以匹配 ISO&#x2F;IEC 16262 国际标准，基本没有新功能。</li></ul><h3 id="3-ECMAScript-3-ES3-1999"><a href="#3-ECMAScript-3-ES3-1999" class="headerlink" title="3. ECMAScript 3 (ES3) - 1999"></a>3. ECMAScript 3 (ES3) - 1999</h3><ul><li><strong>扩展语言特性</strong>：添加了许多新功能，包括正则表达式支持、更好的错误处理机制、<code>try/catch</code> 异常处理、<code>Array</code> 和 <code>String</code> 方法（如 <code>map</code>、<code>filter</code> 和 <code>split</code>）。</li><li><strong>标志性的语言特性</strong>：如 <code>Object</code>、<code>Array</code> 等的标准化。</li></ul><h3 id="4-ECMAScript-4-ES4-未发布"><a href="#4-ECMAScript-4-ES4-未发布" class="headerlink" title="4. ECMAScript 4 (ES4) - 未发布"></a>4. ECMAScript 4 (ES4) - <strong>未发布</strong></h3><ul><li><strong>开发中止</strong>：ES4 原计划加入大量新特性，例如模块、类、接口和类型检查。但由于复杂度和各方意见不一致，最终未发布。</li></ul><h3 id="5-ECMAScript-5-ES5-2009"><a href="#5-ECMAScript-5-ES5-2009" class="headerlink" title="5. ECMAScript 5 (ES5) - 2009"></a>5. ECMAScript 5 (ES5) - 2009</h3><ul><li><p>关键性更新</p><ul><li><strong>严格模式</strong>：通过 <code>&quot;use strict&quot;</code> 引入严格模式，以增强代码的安全性和性能。</li><li><strong>原生 JSON 支持</strong>：加入 <code>JSON.parse</code> 和 <code>JSON.stringify</code>。</li><li><strong>增强对象和数组方法</strong>：如 <code>Object.create</code>、<code>Object.keys</code>、<code>Array.isArray</code>、<code>forEach</code>、<code>map</code>、<code>filter</code>、<code>reduce</code>。</li><li><strong>属性描述符</strong>：允许通过 <code>Object.defineProperty</code> 来控制对象属性的可写性、可枚举性等。</li><li><strong>增强数组的处理能力</strong>：扩展了数组的高阶函数。</li></ul></li></ul><h3 id="6-ECMAScript-6-ES6-ES2015-2015"><a href="#6-ECMAScript-6-ES6-ES2015-2015" class="headerlink" title="6. ECMAScript 6 (ES6&#x2F;ES2015) - 2015"></a>6. ECMAScript 6 (ES6&#x2F;ES2015) - 2015</h3><ul><li><p>重大更新</p><p>：引入了现代 JavaScript 的大部分关键特性。</p><ul><li>**<code>let</code> 和 <code>const</code>**：块级作用域变量声明。</li><li><strong>箭头函数</strong>：简化函数表达式的写法，同时绑定 <code>this</code>。</li><li><strong>模板字符串</strong>：通过反引号 &#96;&#96;&#96; 来进行多行字符串和嵌入变量。</li><li><strong>解构赋值</strong>：支持对象和数组的解构赋值。</li><li><strong>默认参数</strong>：为函数参数设置默认值。</li><li><strong>展开运算符（Spread Operator）</strong>：简化数组和对象的合并。</li><li><strong>Promise</strong>：处理异步操作的新方法。</li><li><strong>模块化</strong>：引入 <code>import</code> 和 <code>export</code>，标准化模块管理。</li><li><strong>类（Class）</strong>：支持基于原型的类语法。</li><li><strong>Symbol</strong>：新的原始数据类型，用于创建唯一的标识符。</li></ul></li></ul><h3 id="7-ECMAScript-2016-ES7-2016"><a href="#7-ECMAScript-2016-ES7-2016" class="headerlink" title="7. ECMAScript 2016 (ES7) - 2016"></a>7. ECMAScript 2016 (ES7) - 2016</h3><ul><li><p>少量新特性</p><ul><li><strong>指数运算符</strong>：使用 <code>**</code> 来代替 <code>Math.pow</code>。</li></ul></li><li><p><strong>Array.prototype.includes</strong>：检查数组是否包含某个元素，比 <code>indexOf</code> 更加直观。</p></li></ul><h3 id="8-ECMAScript-2017-ES8-2017"><a href="#8-ECMAScript-2017-ES8-2017" class="headerlink" title="8. ECMAScript 2017 (ES8) - 2017"></a>8. ECMAScript 2017 (ES8) - 2017</h3><ul><li><strong>异步函数</strong>：支持 <code>async/await</code>，使异步代码更接近同步写法。</li><li><strong>Object.entries 和 Object.values</strong>：提取对象的键值对和所有值。</li><li><strong>字符串填充方法</strong>：<code>padStart</code> 和 <code>padEnd</code>。</li><li><strong>共享内存和原子操作</strong>：增加 <code>SharedArrayBuffer</code> 和 <code>Atomics</code> 对象，允许更高效的并行编程。</li></ul><h3 id="9-ECMAScript-2018-ES9-2018"><a href="#9-ECMAScript-2018-ES9-2018" class="headerlink" title="9. ECMAScript 2018 (ES9) - 2018"></a>9. ECMAScript 2018 (ES9) - 2018</h3><ul><li><strong>Rest&#x2F;Spread 运算符扩展</strong>：支持在对象中的展开和剩余参数语法。</li><li><strong>异步迭代器</strong>：引入 <code>for await...of</code> 循环。</li><li><strong>Promise.finally</strong>：在 <code>Promise</code> 完成后执行指定代码。</li><li><strong>正则表达式增强</strong>：添加了命名捕获组、后行断言（lookbehind）、dotAll 模式等。</li></ul><h3 id="10-ECMAScript-2019-ES10-2019"><a href="#10-ECMAScript-2019-ES10-2019" class="headerlink" title="10. ECMAScript 2019 (ES10) - 2019"></a>10. ECMAScript 2019 (ES10) - 2019</h3><ul><li><strong>Array.prototype.flat 和 flatMap</strong>：将多维数组展平。</li><li><strong>Object.fromEntries</strong>：将键值对列表转换为对象。</li><li><strong>字符串修剪方法</strong>：<code>trimStart</code> 和 <code>trimEnd</code>。</li><li><strong>可选捕获绑定</strong>：<code>try/catch</code> 中可以省略 <code>catch</code> 的参数。</li><li><strong>Function.prototype.toString 修复</strong>：输出函数代码的完整实现。</li></ul><h3 id="11-ECMAScript-2020-ES11-2020"><a href="#11-ECMAScript-2020-ES11-2020" class="headerlink" title="11. ECMAScript 2020 (ES11) - 2020"></a>11. ECMAScript 2020 (ES11) - 2020</h3><ul><li><strong>可选链（Optional Chaining）</strong>：使用 <code>?.</code> 避免访问空值对象属性时报错。</li><li><strong>空值合并运算符（Nullish Coalescing）</strong>：<code>??</code> 在 <code>null</code> 或 <code>undefined</code> 时返回默认值。</li><li>**动态 <code>import()</code>**：允许动态加载模块，返回 Promise。</li><li><strong>BigInt 类型</strong>：处理超过 <code>Number</code> 的安全范围的大整数。</li><li><strong>Promise.allSettled</strong>：等待所有 <code>Promise</code> 完成，无论成功还是失败。</li></ul><h3 id="12-ECMAScript-2021-ES12-2021"><a href="#12-ECMAScript-2021-ES12-2021" class="headerlink" title="12. ECMAScript 2021 (ES12) - 2021"></a>12. ECMAScript 2021 (ES12) - 2021</h3><ul><li><strong>逻辑赋值运算符</strong>：<code>&amp;&amp;=</code>, <code>||=</code>, <code>??=</code> 等赋值简写形式。</li><li>**<code>String.prototype.replaceAll</code>**：允许替换所有匹配项。</li><li><strong>WeakRefs 和 FinalizationRegistry</strong>：对垃圾回收的支持，允许在对象被清理前执行回调。</li><li><strong>Promise.any</strong>：只要有一个 <code>Promise</code> 成功则返回。</li></ul><h3 id="13-ECMAScript-2022-ES13-2022"><a href="#13-ECMAScript-2022-ES13-2022" class="headerlink" title="13. ECMAScript 2022 (ES13) - 2022"></a>13. ECMAScript 2022 (ES13) - 2022</h3><ul><li><strong><code>at()</code> 方法</strong>：<code>Array</code> 和 <code>String</code> 的 <code>.at()</code> 方法支持负索引访问。</li><li>**<code>Object.hasOwn()</code>**：比 <code>Object.prototype.hasOwnProperty</code> 更简洁的对象属性判断。</li><li><strong>类字段与私有属性</strong>：类内直接定义字段，私有属性以 <code>#</code> 开头。</li><li><strong>正则表达式匹配索引</strong>：<code>matchAll</code> 中捕获匹配的起始和结束索引。</li></ul><h3 id="14-ECMAScript-2023-ES14-2023"><a href="#14-ECMAScript-2023-ES14-2023" class="headerlink" title="14. ECMAScript 2023 (ES14) - 2023"></a>14. ECMAScript 2023 (ES14) - 2023</h3><ul><li>**Array.prototype.toSorted()**：不修改原数组的情况下排序。</li><li>**Array.prototype.toReversed() 和 toSpliced()**：不修改原数组，返回翻转或删除后的副本。</li><li><strong>Symbol.symbols</strong>：一种新的内置 <code>Symbol</code>，允许标记不可修改的字段。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ECMAScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventEmitter</title>
    <link href="/posts/36600/"/>
    <url>/posts/36600/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">2</span> 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br><span class="hljs-number">1</span> 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-property">js</span>:<span class="hljs-number">201</span> <br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// process.nextTick error, or &#x27;error&#x27; event on first tick </span><br>^ <br><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Uncaught</span>, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">emit</span> (events.<span class="hljs-property">js</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span>) <br>at <span class="hljs-title class_">Object</span>.&lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>byvoid/error.<span class="hljs-property">js</span>:<span class="hljs-number">5</span>:<span class="hljs-number">9</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">_compile</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">441</span>:<span class="hljs-number">26</span>) <br>at <span class="hljs-title class_">Object</span>..<span class="hljs-property">js</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">459</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">348</span>:<span class="hljs-number">31</span>) <br>at <span class="hljs-title class_">Function</span>.<span class="hljs-property">_load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">308</span>:<span class="hljs-number">12</span>) <br>at <span class="hljs-title class_">Array</span><span class="hljs-number">.0</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">479</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">_tickCallback</span> (node.<span class="hljs-property">js</span>:<span class="hljs-number">192</span>:<span class="hljs-number">40</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Node.js的线程机制</title>
    <link href="/posts/22142/"/>
    <url>/posts/22142/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Node-js的线程机制、事件循环与高并发处理"><a href="#深入理解Node-js的线程机制、事件循环与高并发处理" class="headerlink" title="深入理解Node.js的线程机制、事件循环与高并发处理"></a>深入理解Node.js的线程机制、事件循环与高并发处理</h1><p>Node.js因其强大的高并发处理能力而备受青睐。这一能力得益于其事件驱动的非阻塞I&#x2F;O模型和高效的事件循环机制。在这篇博客中，我们将深入探讨Node.js的线程机制、事件循环的工作流程与优先级，以及如何避免阻塞主线程的最佳实践。通过这些内容，你将更好地理解Node.js的内部运行机制，并学会如何编写高效的Node.js应用程序。</p><hr><h2 id="1-Node-js-的线程机制"><a href="#1-Node-js-的线程机制" class="headerlink" title="1. Node.js 的线程机制"></a>1. Node.js 的线程机制</h2><p>Node.js 是单线程的，但它通过多线程的方式处理高并发。JavaScript代码运行在主线程中，而Node.js使用的<a href="https://libuv.org/">libuv</a>库则提供了一个基于事件循环的异步I&#x2F;O模型，使得主线程不会因为I&#x2F;O操作而被阻塞。</p><h3 id="主线程与-libuv-线程池"><a href="#主线程与-libuv-线程池" class="headerlink" title="主线程与 libuv 线程池"></a><strong>主线程与 <a href="https://libuv.org/">libuv</a> 线程池</strong></h3><ul><li><strong>主线程</strong>：Node.js中的JavaScript代码在一个单独的主线程中运行，该线程处理所有的同步代码。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：用于处理阻塞性任务，如文件I&#x2F;O、DNS查询等，工作线程池通常包含4个线程，可以根据需要配置更多。</li></ul><p>Node.js通过将耗时的I&#x2F;O操作交给<a href="https://libuv.org/">libuv</a>线程池中的工作线程来处理，从而避免主线程被阻塞。这种设计使得Node.js可以在单线程的主线程中处理大量并发请求，而不会因为阻塞I&#x2F;O操作而降低性能。</p><h3 id="重点知识："><a href="#重点知识：" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>主线程</strong>：负责执行所有同步任务。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：处理阻塞I&#x2F;O任务，防止主线程阻塞。</li></ul><hr><h2 id="2-Node-js-的高并发原理"><a href="#2-Node-js-的高并发原理" class="headerlink" title="2. Node.js 的高并发原理"></a>2. Node.js 的高并发原理</h2><p>Node.js的高并发处理能力主要源于其事件驱动的非阻塞I&#x2F;O模型。通过事件循环，Node.js可以在单线程环境中处理大量的并发请求。</p><h3 id="事件驱动的非阻塞I-O模型"><a href="#事件驱动的非阻塞I-O模型" class="headerlink" title="事件驱动的非阻塞I&#x2F;O模型"></a><strong>事件驱动的非阻塞I&#x2F;O模型</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：Node.js 的I&#x2F;O操作不会阻塞主线程，而是将I&#x2F;O操作委托给<a href="https://libuv.org/">libuv</a>线程池处理，主线程在I&#x2F;O操作完成之前可以继续执行其他任务。</li><li><strong>异步任务队列</strong>：异步操作的回调函数会被放入任务队列中，等待主线程空闲时由事件循环调度执行。</li></ul><p>通过这种非阻塞设计，Node.js能够高效地处理并发请求。</p><h5 id="代码示例：异步I-O操作"><a href="#代码示例：异步I-O操作" class="headerlink" title="代码示例：异步I&#x2F;O操作"></a><strong>代码示例：异步I&#x2F;O操作</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File content:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This log comes first!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>fs.readFile</code> 是一个异步操作，它会将回调函数放入任务队列中，而不会阻塞主线程。因此，<code>console.log(&#39;This log comes first!&#39;)</code> 会先于文件内容的输出执行。</p><h3 id="重点知识：-1"><a href="#重点知识：-1" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：避免主线程因I&#x2F;O操作而阻塞。</li><li><strong>异步任务队列</strong>：存储需要执行的异步操作回调。</li></ul><hr><h2 id="3-事件循环的工作机制与优先级"><a href="#3-事件循环的工作机制与优先级" class="headerlink" title="3. 事件循环的工作机制与优先级"></a>3. 事件循环的工作机制与优先级</h2><p>事件循环是Node.js运行的核心机制，它决定了程序中代码的执行顺序。我们将详细剖析事件循环的工作流程及其优先级，帮助你更好地理解Node.js的并发处理。</p><h3 id="事件循环的工作流程"><a href="#事件循环的工作流程" class="headerlink" title="事件循环的工作流程"></a><strong>事件循环的工作流程</strong></h3><ol><li><strong>执行同步代码</strong>：事件循环首先执行主线程中的同步代码，这些代码会被立即执行。</li><li><strong>进入事件循环</strong>：当同步代码执行完毕后，事件循环开始检查任务队列中是否有待处理的异步回调。</li><li><strong>处理异步回调</strong>：事件循环依次从任务队列中取出回调函数并执行。</li><li><strong>循环往复</strong>：事件循环不断检查并处理任务队列中的任务，直到队列为空。</li></ol><h3 id="事件循环的优先级"><a href="#事件循环的优先级" class="headerlink" title="事件循环的优先级"></a><strong>事件循环的优先级</strong></h3><p>事件循环在执行任务时遵循一定的优先级。常见的优先级顺序如下：</p><ul><li><strong>Microtasks（微任务）</strong>：包括 <code>process.nextTick</code> 和 <code>Promise</code> 的回调。这些任务优先级最高，通常会在当前操作结束后立即执行。</li><li><strong>Timers（计时器）</strong>：如 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>I&#x2F;O callbacks</strong>：处理来自I&#x2F;O操作的回调。</li><li><strong>Check</strong>：执行 <code>setImmediate</code> 的回调函数。</li><li><strong>Close callbacks</strong>：处理 <code>close</code> 事件的回调。</li></ul><h5 id="代码示例：事件循环的优先级"><a href="#代码示例：事件循环的优先级" class="headerlink" title="代码示例：事件循环的优先级"></a><strong>代码示例：事件循环的优先级</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Sync</span> code<br>nextTick<br><span class="hljs-title class_">Promise</span><br><span class="hljs-built_in">setTimeout</span><br>setImmediate<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;Sync code&#39;)</code> 立即执行，<code>process.nextTick</code> 和 <code>Promise</code> 回调作为微任务执行，其次是 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调。</p><h3 id="重点知识：-2"><a href="#重点知识：-2" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>事件循环阶段</strong>：不同类型的任务在事件循环中具有不同的优先级。</li><li><strong>Microtasks</strong>：优先级最高的任务，通常在当前事件循环阶段结束后立即执行。</li></ul><hr><h2 id="4-为什么先执行同步代码，再执行事件循环？"><a href="#4-为什么先执行同步代码，再执行事件循环？" class="headerlink" title="4. 为什么先执行同步代码，再执行事件循环？"></a>4. 为什么先执行同步代码，再执行事件循环？</h2><p>Node.js在执行代码时，首先会运行同步代码，这是因为同步代码通常包含程序的初始化、配置、变量定义等重要操作。如果不先执行同步代码，异步回调可能会在未准备好的上下文中被触发，导致程序行为不可预测。</p><h3 id="同步代码的定义"><a href="#同步代码的定义" class="headerlink" title="同步代码的定义"></a><strong>同步代码的定义</strong></h3><p>同步代码是指立即执行并返回结果的代码，不依赖于异步事件的完成。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is synchronous code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>同步代码执行完后，事件循环才会开始处理异步任务。</p><h5 id="代码示例：同步代码与异步代码"><a href="#代码示例：同步代码与异步代码" class="headerlink" title="代码示例：同步代码与异步代码"></a><strong>代码示例：同步代码与异步代码</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is asynchronous&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在此例中，<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 是同步代码，它们会立即执行，而 <code>setTimeout</code> 的回调则是异步代码，会在同步代码执行完毕后，由事件循环调度执行。</p><h3 id="避免将复杂任务放入主线程"><a href="#避免将复杂任务放入主线程" class="headerlink" title="避免将复杂任务放入主线程"></a><strong>避免将复杂任务放入主线程</strong></h3><p>在主线程中放入复杂的同步任务，会阻塞主线程，导致事件循环无法及时处理异步任务。为了解决这个问题，我们可以使用以下几种方法：</p><ol><li><strong>将任务拆分</strong>：将复杂的同步任务拆分为多个小任务，分批执行。</li><li>**使用 <code>setImmediate</code>**：将长时间执行的任务放入下一个事件循环阶段执行。</li><li>**使用 <code>Worker Threads</code>**：将复杂计算任务放入工作线程中执行，避免阻塞主线程。</li></ol><h5 id="代码示例：使用-setImmediate-避免阻塞"><a href="#代码示例：使用-setImmediate-避免阻塞" class="headerlink" title="代码示例：使用 setImmediate 避免阻塞"></a><strong>代码示例：使用 <code>setImmediate</code> 避免阻塞</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">complexTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task Done:&#x27;</span>, count);<br>&#125;<br><br><span class="hljs-title function_">setImmediate</span>(complexTask);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will log before complexTask finishes&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>complexTask</code> 是一个可能会阻塞主线程的复杂任务。通过使用 <code>setImmediate</code>，我们可以将其延迟到当前事件循环阶段结束后再执行，从而避免阻塞其他重要的任务。</p><h5 id="使用-Worker-Threads-进行并行计算"><a href="#使用-Worker-Threads-进行并行计算" class="headerlink" title="使用 Worker Threads 进行并行计算"></a><strong>使用 <code>Worker Threads</code> 进行并行计算</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from worker:&#x27;</span>, message));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  parentPort.<span class="hljs-title function_">postMessage</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，复杂的计算任务被移至工作线程中执行，不再阻塞主线程。这使得主线程可以继续处理其他任务，而不会受到复杂计算的影响。</p><h3 id="重点知识：-3"><a href="#重点知识：-3" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>避免主线程阻塞</strong>：将复杂任务分拆或延迟执行，避免阻塞事件循环。</li><li><strong>Worker Threads</strong>：用于处理计算密集型任务，减少主线程压力。</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对Node.js线程机制、事件循环与高并发处理的深入探讨，我们了解到如何编写高效的Node.js应用程序。理解事件循环的工作原理和优先级，可以帮助我们更好地管理异步任务的执行顺序，避免主线程被阻塞。同时，采用合理的技术，如 <code>Worker Threads</code> 和 <code>setImmediate</code>，能够有效地提升程序性能，确保高并发环境下的稳定性。</p><hr><p>这篇博客详细解释了Node.js的线程机制及事件循环，并提供了避免主线程阻塞的实际解决方案。希望这些内容对你理解和优化Node.js应用程序有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的回收机制</title>
    <link href="/posts/580/"/>
    <url>/posts/580/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-的垃圾回收机制"><a href="#一、JavaScript-的垃圾回收机制" class="headerlink" title="一、JavaScript 的垃圾回收机制"></a>一、JavaScript 的垃圾回收机制</h1><p>JavaScript 的垃圾回收机制主要依赖于一种称为 <strong>“标记-清除”（Mark-and-Sweep）</strong> 的算法。垃圾回收（Garbage Collection, GC）负责自动管理内存，回收不再使用的对象所占用的内存，以防止内存泄漏。</p><h3 id="垃圾回收的工作原理"><a href="#垃圾回收的工作原理" class="headerlink" title="垃圾回收的工作原理"></a>垃圾回收的工作原理</h3><ol><li><strong>标记阶段（Marking Phase）</strong>:<ul><li>垃圾回收器会在内存中“标记”所有活动的、可到达的对象。所谓“可到达”是指对象可以通过根（通常是全局变量或当前作用域中的变量）直接或间接访问到。</li><li>垃圾回收器从根开始，递归地遍历所有引用的对象，并标记这些对象为“活动的”。</li></ul></li><li><strong>清除阶段（Sweeping Phase）</strong>:<ul><li>在标记阶段结束后，垃圾回收器会遍历内存中的所有对象，清除没有被标记的对象（即那些不可到达的对象）。</li><li>清除后，这些对象所占用的内存将被回收并重新分配。</li></ul></li></ol><h3 id="触发垃圾回收的条件"><a href="#触发垃圾回收的条件" class="headerlink" title="触发垃圾回收的条件"></a>触发垃圾回收的条件</h3><ul><li>JavaScript 引擎的垃圾回收器在运行时会周期性地执行垃圾回收，以回收不再使用的内存。</li><li>垃圾回收器的执行是非确定性的，这意味着你不能确切知道何时会触发垃圾回收。通常是在内存分配请求达到一定阈值或空闲时执行。</li></ul><h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><ol><li><p><strong>内存泄漏</strong>: 当程序中不再需要的对象无法被垃圾回收器清除时，内存泄漏就会发生，导致内存使用量持续增长。</p><ul><li><p><strong>未解除的事件监听器</strong>: 如果在不再需要时没有手动移除事件监听器，监听器中对对象的引用将导致这些对象无法被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachEventListener</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element clicked!&#x27;</span>);<br>    &#125;<br><br>    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br><br>    <span class="hljs-comment">// 模拟在元素销毁时忘记移除监听器</span><br>    <span class="hljs-comment">// element.removeEventListener(&#x27;click&#x27;, handleClick);</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数后，element和handleClick函数依然存在引用，导致element不能被回收。</span><br><span class="hljs-title function_">attachEventListener</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p><strong>事件监听器的引用</strong>：</p><ul><li>当你调用 <code>element.addEventListener(&#39;click&#39;, handleClick)</code> 时，浏览器内部实际上在 <code>element</code> 对象的某个地方（通常是在它的事件监听器列表中）保存了对 <code>handleClick</code> 函数的引用。这意味着 <code>element</code> 本身还存活在内存中，因为它的事件监听器依然在引用它。</li></ul><p><strong>引用链的存在</strong>：</p><ul><li>尽管 <code>element</code> 是一个局部变量，函数 <code>attachEventListener</code> 执行完后不会直接持有对它的引用，但是因为事件监听器 (<code>handleClick</code>) 被添加到了 <code>element</code> 上，<code>element</code> 对象内部保存了对 <code>handleClick</code> 的引用。</li><li>反过来，因为 <code>handleClick</code> 函数是在 <code>attachEventListener</code> 内部定义的，它对定义该函数的外部作用域有引用链，因此，这种引用链会一直存在，直到 <code>element</code> 被手动移除事件监听器或者 <code>element</code> 本身被彻底销毁。</li></ul><p><strong>内存泄漏的来源</strong>：</p><ul><li>如果 <code>element</code> 被从 DOM 中移除（比如被 <code>document.removeChild</code>），但没有调用 <code>element.removeEventListener(&#39;click&#39;, handleClick)</code>，<code>element</code> 仍然不能被垃圾回收，因为它的事件监听器中仍然持有对 <code>handleClick</code> 的引用。</li><li>因为 <code>handleClick</code> 还在 <code>element</code> 的事件监听列表中，JavaScript 引擎会认为 <code>element</code> 还可能被使用，因此不会回收 <code>element</code> 或其关联的内存。</li></ul><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​在不再需要时调用 <code>removeEventListener</code> 来移除事件监听器。</p></li><li><p><strong>闭包导致的引用</strong>: 闭包中保存的变量会保持对外部作用域中对象的引用，可能导致无法回收这些对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 返回的 innerFunction 持有对 largeObject 的引用，即使 largeObject 在函数作用域外部已经不需要。</span><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// closure 的引用存在，导致 largeObject 无法被垃圾回收。</span><br><span class="hljs-title function_">closure</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h6><p>在 JavaScript 中，闭包中的引用指向其创建时的环境（即作用域链上的上级）。具体来说：</p><ul><li>当 <code>createClosure</code> 函数执行时，它创建了一个作用域，该作用域中包含 <code>largeObject</code>。</li><li><code>innerFunction</code> 被返回，并且它在其创建时保留了对 <code>largeObject</code> 的引用。</li><li><code>largeObject</code> 的引用存在于 <code>innerFunction</code> 的闭包环境中。</li></ul><p>因此，<code>innerFunction</code> 的作用域链包括 <code>largeObject</code> 所在的作用域。即使 <code>createClosure</code> 执行完毕并退出，<code>innerFunction</code> 仍然能访问 <code>largeObject</code>。</p><p><span style="color: red;"><em><strong>总的来说，如果closure没被销毁那么闭包中的数据会一直存在，所以尽量避免闭包被全局变量所持有，且尽量避免闭包引用大的数据结构，这样会比较消耗内存</strong></em></span></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​要释放 <code>largeObject</code> 的引用，可以在不再需要 <code>innerFunction</code> 时清除对 <code>largeObject</code> 的引用。在这种情况下，确保在 <code>innerFunction</code> 不再使用 <code>largeObject</code> 后，手动清理引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在此处进行逻辑处理</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// 使用完闭包后，手动设置 largeObject 为 null</span><br><span class="hljs-comment">// 这是实际清理引用的地方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 可以设置 closure 为 null 或 undefined</span><br>    closure = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用 releaseClosure 释放对 largeObject 的引用</span><br><span class="hljs-title function_">releaseClosure</span>();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>: 全局变量在整个程序生命周期中都存在，会阻止其被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVariable = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;I&#x27;m a global variable&quot;</span> &#125;;<br><br><span class="hljs-comment">// 全局变量在程序结束前一直存在，无法回收。</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>未清理的定时器</strong>: 忘记清除不再需要的 <code>setInterval</code> 或 <code>setTimeout</code>，可能导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 设置一个定时器，每秒执行一次</span><br>    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 模拟元素销毁时忘记清除定时器</span><br>    <span class="hljs-comment">// clearInterval(intervalId);</span><br>&#125;<br><br><span class="hljs-comment">// 调用后，即使 element 被移除，intervalId 依然存在，导致内存泄漏。</span><br><span class="hljs-title function_">startTimer</span>();<br><br></code></pre></td></tr></table></figure><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><p>​ 在不再需要定时器时调用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存管理不善</strong>: 虽然 JavaScript 有自动垃圾回收，但开发者仍需注意合理使用内存。例如，避免创建大量不必要的对象或保留不必要的引用。</p></li></ol><h3 id="现代-JavaScript-引擎的优化"><a href="#现代-JavaScript-引擎的优化" class="headerlink" title="现代 JavaScript 引擎的优化"></a>现代 JavaScript 引擎的优化</h3><p>除了基本的标记-清除算法，现代 JavaScript 引擎（如 V8）通常还使用一些优化技术，如：</p><ul><li><strong>增量标记（Incremental Marking）</strong>: 将标记阶段拆分为多个小步骤，避免长时间的卡顿。</li><li><strong>世代回收（Generational Garbage Collection）</strong>: 将内存划分为“新生代”和“老生代”两个区域，短命对象会快速回收，长命对象则被移至老生代以减少处理频率。</li><li><strong>惰性清理（Lazy Cleanup）</strong>: 仅在需要时才清理内存，以进一步减少不必要的垃圾回收操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据hexo创建个人博客</title>
    <link href="/posts/62544/"/>
    <url>/posts/62544/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h2><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p><h2 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h2><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p><h1 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="/posts/62544/1.png"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="/posts/62544/2.png"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="/posts/62544/3.png"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/posts/62544/4.png"></p><p>浏览器中访问，展示成功。</p><p><img src="/posts/62544/5.png"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面默认主图风格如下">http://localhost:4000&#39;，页面默认主图风格如下</a></p><p><img src="/posts/62544/6.png"></p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。个人比较喜欢<code>Fluid</code>。</p><h2 id="1-Fluid主题"><a href="#1-Fluid主题" class="headerlink" title="1.Fluid主题"></a>1.Fluid主题</h2><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 <strong>安装主题</strong></h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h3 id="1-2-指定主题"><a href="#1-2-指定主题" class="headerlink" title="1.2 指定主题"></a>1.2 <strong>指定主题</strong></h3><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="1-3-创建「关于页」"><a href="#1-3-创建「关于页」" class="headerlink" title="1.3 创建「关于页」"></a>1.3 <strong>创建「关于页」</strong></h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br><br></code></pre></td></tr></table></figure><h3 id="1-4-本地启动"><a href="#1-4-本地启动" class="headerlink" title="1.4 本地启动**"></a>1.4 本地启动**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，`Fluid`主题风格页面如下">http://localhost:4000&#39;，`Fluid`主题风格页面如下</a></p><p><img src="/posts/62544/7.png"></p><h1 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h1><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><h2 id="1-添加hexo-asset-image插件"><a href="#1-添加hexo-asset-image插件" class="headerlink" title="1.添加hexo-asset-image插件"></a>1.添加hexo-asset-image插件</h2><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p>hexo-asset-image插件的作用就是为图片资源默认追加上时间路径前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这里不要用</p><p><img src="/posts/62544/8.png"></p><h2 id="2-修改-Hexo-博客目录中的-config-yml"><a href="#2-修改-Hexo-博客目录中的-config-yml" class="headerlink" title="2.修改 Hexo 博客目录中的 _config.yml"></a>2.修改 Hexo 博客目录中的 <code>_config.yml</code></h2><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="/posts/62544/9.png"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="/posts/62544/10.png"></p><p>在测试文章.md中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在\source\images目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:<br><span class="hljs-bullet">-</span> 原创<br>categories:<br><span class="hljs-section">- Java</span><br><span class="hljs-section">---</span><br><br>这是一篇测试文章<br><br>![<span class="hljs-string">图片引用方一</span>](<span class="hljs-link">测试文章/test.png</span>)<br><br>![<span class="hljs-string">图片引用方法二</span>](<span class="hljs-link">test.png</span>)<br><br>![<span class="hljs-string">图片引用方法三</span>](<span class="hljs-link">/images/test.png</span>)<br><br></code></pre></td></tr></table></figure><h2 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.<strong>本地启动</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 ‘<a href="http://localhost:4000'，页面如下，文章添加成功">http://localhost:4000&#39;，页面如下，文章添加成功</a></p><p><img src="/posts/62544/11.png"></p><h1 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h1><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h2 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h2><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="/posts/62544/12.png"></p><h2 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2.博客标题"></a>2.博客标题</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="/posts/62544/13.png"></p><h2 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="/posts/62544/14.png"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="/posts/62544/15.png"></p><h1 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h1><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h2 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h2><h3 id="进入-官网-注册账号"><a href="#进入-官网-注册账号" class="headerlink" title="进入 官网 注册账号"></a>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</h3><p><img src="/posts/62544/16.png"></p><h3 id="需实名认证，完成后才能使用各项服务"><a href="#需实名认证，完成后才能使用各项服务" class="headerlink" title="需实名认证，完成后才能使用各项服务"></a>需实名认证，完成后才能使用各项服务</h3><p><img src="/posts/62544/17.png"></p><p>验证邮箱</p><p><img src="/posts/62544/18.png"></p><h3 id="创建应用，选择开发版即可，免费的"><a href="#创建应用，选择开发版即可，免费的" class="headerlink" title="创建应用，选择开发版即可，免费的"></a>创建应用，选择<code>开发版</code>即可，免费的</h3><p><img src="/posts/62544/19.png"></p><h3 id="进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用"><a href="#进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用" class="headerlink" title="进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用"></a>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</h3><p><img src="/posts/62544/20.png"></p><h2 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h2><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h3 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h3><p>打开统计开关</p><p><img src="/posts/62544/21.png"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="/posts/62544/22.png"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="/posts/62544/23.png"></p><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><img src="/posts/62544/24.png"></p><h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p><img src="/posts/62544/25.png"></p><p>页面效果</p><p><img src="/posts/62544/26.png"></p><h1 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h1><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h2 id="启用评论插件"><a href="#启用评论插件" class="headerlink" title="启用评论插件"></a>启用评论插件</h2><p><img src="/posts/62544/27.png"></p><h2 id="配置-LeanCloud-的-appId-和-appkey"><a href="#配置-LeanCloud-的-appId-和-appkey" class="headerlink" title="配置 LeanCloud 的 appId 和 appkey"></a>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></h2><p><img src="/posts/62544/28.png"></p><h2 id="重新部署后，查看页面效果，评论功能已开启"><a href="#重新部署后，查看页面效果，评论功能已开启" class="headerlink" title="重新部署后，查看页面效果，评论功能已开启"></a>重新部署后，查看页面效果，评论功能已开启</h2><p><img src="/posts/62544/29.png"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h1 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="1-1-安装hexo-deployer-git"><a href="#1-1-安装hexo-deployer-git" class="headerlink" title="1.1 安装hexo-deployer-git"></a>1.1 安装hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="1-2-修改根目录下的-config-yml，配置-GitHub-相关信息"><a href="#1-2-修改根目录下的-config-yml，配置-GitHub-相关信息" class="headerlink" title="1.2 修改根目录下的 _config.yml，配置 GitHub 相关信息"></a>1.2 修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><h3 id="1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图"><a href="#1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图" class="headerlink" title="1.3 其中 token 为 GitHub 的 Personal access tokens，获取方式如下图"></a>1.3 其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</h3><p><img src="/posts/62544/30.png"></p><h3 id="1-4-部署到GitHub"><a href="#1-4-部署到GitHub" class="headerlink" title="1.4 部署到GitHub"></a>1.4 部署到GitHub</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a></p><p><img src="/posts/62544/31.png"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="/posts/62544/32.png"></p><h1 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>代理</h1><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location &#x2F;blog 路径一致。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rkyao/fronted/hexo-blog<br></code></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/conf<br>vim nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">server节点下添加如下配置</span><br>location /blog &#123;<br>    alias  /opt/rkyao/fronted/hexo-blog;<br>    index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://47.96.106.173/blog/<br></code></pre></td></tr></table></figure><h1 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h1><p>可访问如下地址查看<br><a href="https://yonghengshikong.github.io/">https://yonghengshikong.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命名</title>
    <link href="/posts/16107/"/>
    <url>/posts/16107/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-创建新的博客"><a href="#1-创建新的博客" class="headerlink" title="1.创建新的博客"></a>1.创建新的博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="2-本地运行"><a href="#2-本地运行" class="headerlink" title="2.本地运行"></a>2.本地运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3.生成静态文件"></a>3.生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="4-部署到远程站点"><a href="#4-部署到远程站点" class="headerlink" title="4.部署到远程站点"></a>4.部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="5-清除本地缓存"><a href="#5-清除本地缓存" class="headerlink" title="5.清除本地缓存"></a>5.清除本地缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c<br></code></pre></td></tr></table></figure><h3 id="6-组合命令-生成且部署到远程"><a href="#6-组合命令-生成且部署到远程" class="headerlink" title="6.组合命令(生成且部署到远程)"></a>6.组合命令(生成且部署到远程)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
