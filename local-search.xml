<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器跨域问题详解及解决方案</title>
    <link href="/posts/3208/"/>
    <url>/posts/3208/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题详解及解决方案"><a href="#浏览器跨域问题详解及解决方案" class="headerlink" title="浏览器跨域问题详解及解决方案"></a>浏览器跨域问题详解及解决方案</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>在开发 Web 应用时，浏览器的跨域问题是前端开发者经常遇到的。浏览器的<strong>同源策略</strong>（Same-Origin Policy）是为了保证安全，限制了跨域请求的发起。然而，很多场景下，跨域请求是必须的，比如前端与不同域的后端服务器通信时。因此，理解浏览器跨域问题的原因及其解决方案是非常重要的。</p><p>本文将深入讲解跨域问题的产生原因，并提供常用的解决方案，帮助开发者高效解决跨域问题。</p><hr><h1 id="一、什么是跨域问题？"><a href="#一、什么是跨域问题？" class="headerlink" title="一、什么是跨域问题？"></a><strong>一、什么是跨域问题？</strong></h1><p><strong>跨域</strong>是指浏览器的安全策略，即同源策略（Same-Origin Policy）限制了 JavaScript 只能从与网页同源的服务器请求资源。所谓<strong>同源</strong>，是指协议、域名、端口号三者必须完全相同。</p><ul><li><p><strong>同源</strong>：指的是协议、域名、端口号三者必须一致。</p></li><li><p>跨域</p><p>：如果任意一个不同，都是跨域。例如：</p><ul><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="https://www.example.com'(协议不同)/">https://www.example.com&#39;（协议不同）</a></li><li>‘<a href="http://www.example.com/">http://www.example.com</a>‘ 与 ‘<a href="http://api.example.com'(域名不同)/">http://api.example.com&#39;（域名不同）</a></li><li>‘<a href="http://www.example.com:8080/">http://www.example.com:8080</a>‘ 与 ‘<a href="http://www.example.com:3000'（端口不同）">http://www.example.com:3000&#39;（端口不同）</a></li></ul></li></ul><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a><strong>浏览器的同源策略</strong></h2><p>同源策略是一种重要的安全策略，它用于阻止一个源（网页）中的脚本读取另一个源中的资源。它的主要目的是为了防止恶意网站通过跨站脚本攻击（XSS）来窃取用户数据。</p><h2 id="跨域请求带来的问题"><a href="#跨域请求带来的问题" class="headerlink" title="跨域请求带来的问题"></a><strong>跨域请求带来的问题</strong></h2><p>跨域问题常出现在通过 Ajax 或 Fetch 发起的 HTTP 请求中，浏览器会根据同源策略阻止跨域请求，导致前端无法拿到不同源的服务器数据。</p><hr><h1 id="二、跨域问题产生的原因"><a href="#二、跨域问题产生的原因" class="headerlink" title="二、跨域问题产生的原因"></a><strong>二、跨域问题产生的原因</strong></h1><p>跨域问题产生的核心原因是<strong>浏览器的同源策略</strong>，具体在以下情况下会产生跨域问题：</p><ol><li><strong>协议不同</strong>：比如 HTTP 和 HTTPS 协议不同，属于跨域。</li><li><strong>域名不同</strong>：比如 <code>example.com</code> 和 <code>sub.example.com</code> 属于跨域。</li><li><strong>端口不同</strong>：同样的域名和协议，但端口不同，比如 <code>example.com:8080</code> 和 <code>example.com:3000</code>。</li></ol><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子</strong>：</h2><ul><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com/api/data">http://example.com/api/data</a> ——<strong>同源</strong>，允许请求。</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="https://example.com/api/data">https://example.com/api/data</a> ——<strong>跨域</strong>，拒绝请求。（协议不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://api.example.com/data">http://api.example.com/data</a> ——<strong>跨域</strong>，拒绝请求。（域名不同）</li><li><a href="http://example.com/">http://example.com</a> 请求 <a href="http://example.com:3000/data">http://example.com:3000/data</a> ——<strong>跨域</strong>，拒绝请求。（端口不同）</li></ul><p>当发生跨域时，浏览器会抛出类似如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://api.example.com/data&#x27;</span> from origin <span class="hljs-string">&#x27;http://www.example.com&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.<br></code></pre></td></tr></table></figure><p>这种错误提示表明请求被浏览器阻止，原因是目标服务器没有配置允许跨域请求的响应头。</p><hr><h1 id="三、跨域问题的常见解决方案"><a href="#三、跨域问题的常见解决方案" class="headerlink" title="三、跨域问题的常见解决方案"></a><strong>三、跨域问题的常见解决方案</strong></h1><p>针对跨域问题，前端和后端都有不同的解决方法。常用的方案包括：</p><h2 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1. CORS（跨域资源共享）"></a><strong>1. CORS（跨域资源共享）</strong></h2><p>CORS（Cross-Origin Resource Sharing）是 W3C 标准，允许浏览器向跨源服务器，发起 XMLHttpRequest 或 Fetch 请求。只要服务器端配置了适当的 CORS 头信息，就可以允许跨域请求。</p><p><strong>服务器端解决方法：</strong></p><p>在后端服务器配置响应头来允许跨域访问。具体操作是设置 HTTP 响应头中的 <code>Access-Control-Allow-Origin</code>，这个头告诉浏览器，允许哪些域进行跨域请求。</p><ul><li><p><strong>基本 CORS 头配置</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br></code></pre></td></tr></table></figure><p>这意味着允许所有来源的跨域请求。如果要限制特定的域，可以将 <code>*</code> 替换为特定域名，比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://www.example.com<br></code></pre></td></tr></table></figure></li><li><p><strong>支持复杂请求</strong>：</p><p>如果是复杂的跨域请求（例如涉及 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等非简单方法，或者带有自定义头部），需要预检请求。此时需要后端配置更多的 CORS 头信息，例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>Content-Type, Authorization<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure><p>这些头信息分别表示允许的 HTTP 方法、允许的自定义头部、以及是否允许携带 Cookie 等认证信息。</p></li></ul><h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a><strong>2. JSONP</strong></h2><p>JSONP（JSON with Padding）是一种传统的跨域请求方案，利用 <code>&lt;script&gt;</code> 标签的跨域能力来请求资源。因为 <code>&lt;script&gt;</code> 标签不受同源策略的限制，可以加载任意来源的脚本，JSONP 通过动态插入 <code>&lt;script&gt;</code> 标签来实现跨域请求。</p><p><strong>实现步骤</strong>：</p><ul><li><p>前端发起请求时，在 URL 中添加一个回调函数参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理返回数据</span><br>&#125;<br><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li><p>后端返回的数据需要被包裹在回调函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleResponse</span>(&#123;<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: [...]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>虽然 JSONP 可以实现跨域请求，但它只支持 GET 请求，不支持其他 HTTP 方法。</p><h2 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a><strong>3. 反向代理</strong></h2><p>反向代理是一种通过代理服务器转发请求的方式。前端请求会先发到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将响应返回给前端。</p><p><strong>实现步骤</strong>：</p><ul><li><p>配置代理服务器（如 Nginx 或 Node.js 中的代理模块）来转发请求：</p><p>在 Nginx 中的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://api.example.com;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，前端只需要请求 <code>/api/</code>，Nginx 会将请求转发到 <code>http://api.example.com</code>，从而避免跨域问题。</p></li></ul><h2 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a><strong>4. WebSocket</strong></h2><p>WebSocket 协议不受同源策略的限制，可以实现跨域通信。如果项目中需要实时通信，WebSocket 是一种不错的选择。</p><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://example.com/socket&#x27;</span>);<br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from server &#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="四、前端解决方案"><a href="#四、前端解决方案" class="headerlink" title="四、前端解决方案"></a><strong>四、前端解决方案</strong></h1><ol><li><p><strong>CORS 前端控制</strong> 前端可以通过控制请求时的一些参数，避免复杂请求的跨域问题。例如使用简单请求方法（GET、POST）或避免自定义请求头等。</p></li><li><p><strong>使用代理开发服务器</strong> 在开发环境中，使用 Webpack DevServer 或 Vite 等开发工具时，可以通过设置代理解决跨域问题。比如在 <code>vue.config.js</code> 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="五、简单请求"><a href="#五、简单请求" class="headerlink" title="五、简单请求"></a>五、简单请求</h1><p>在浏览器的同源策略下，只有某些特定的请求不会触发跨域问题。浏览器针对不同的请求类型进行了区分，只有符合特定条件的请求才会被认为是安全的，属于<strong>简单请求（Simple Requests）</strong>，这些请求不会触发浏览器的<strong>CORS 预检（Preflight）请求</strong>，因此也不会被同源策略限制。</p><h2 id="1、不会触发跨域的请求类型（简单请求）"><a href="#1、不会触发跨域的请求类型（简单请求）" class="headerlink" title="1、不会触发跨域的请求类型（简单请求）"></a><strong>1、不会触发跨域的请求类型（简单请求）</strong></h2><p>根据<strong>CORS（跨域资源共享）</strong>的规范，以下请求被定义为“简单请求”：</p><h3 id="1-1-请求方法必须是以下三种之一："><a href="#1-1-请求方法必须是以下三种之一：" class="headerlink" title="1.1. 请求方法必须是以下三种之一："></a>1.1. <strong>请求方法必须是以下三种之一</strong>：</h3><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><p>这意味着浏览器只会认为这些方法是安全的，任何其他 HTTP 方法（如 <code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 等）都会被视为复杂请求，从而触发跨域检查。</p><h3 id="1-2-请求头必须是以下几种之一："><a href="#1-2-请求头必须是以下几种之一：" class="headerlink" title="1.2. 请求头必须是以下几种之一："></a>1.2. <strong>请求头必须是以下几种之一</strong>：</h3><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（有特定限制，见下一条）</li><li><code>DPR</code>（Device Pixel Ratio）</li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><p>浏览器默认允许这些请求头传递。如果请求中包含了其他自定义头字段，则会被认为是复杂请求，会触发跨域预检。</p><h3 id="1-3-Content-Type-必须是以下三种之一："><a href="#1-3-Content-Type-必须是以下三种之一：" class="headerlink" title="1.3. Content-Type 必须是以下三种之一："></a>1.3. <strong><code>Content-Type</code> 必须是以下三种之一</strong>：</h3><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>这些 <code>Content-Type</code> 类型是最常用的，特别是 <code>application/x-www-form-urlencoded</code>，它是表单提交的默认编码格式。如果使用了其他 <code>Content-Type</code>（例如 <code>application/json</code>），请求会被认为是复杂请求，触发跨域预检。</p><h3 id="1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性："><a href="#1-4-请求不包含任何自定义的-XMLHttpRequest-对象属性：" class="headerlink" title="1.4. 请求不包含任何自定义的 XMLHttpRequest 对象属性："></a>1.4. <strong>请求不包含任何自定义的 <code>XMLHttpRequest</code> 对象属性</strong>：</h3><p>例如 <code>request.withCredentials = true</code> 会导致请求包含用户凭证（cookies、HTTP authentication 等），这将使请求成为复杂请求，触发 CORS 检查。</p><p><strong>简单请求的示例</strong>：</p><ul><li><p><strong>GET 请求</strong>：向目标 API 发起 GET 请求并获取数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>POST 请求</strong>：发送表单数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、简单请求不会触发跨域预检的原因"><a href="#2、简单请求不会触发跨域预检的原因" class="headerlink" title="2、简单请求不会触发跨域预检的原因"></a><strong>2、简单请求不会触发跨域预检的原因</strong></h2><p>浏览器的安全模型假定，简单请求不会带来高风险，因为它们遵循了 HTTP 协议中广泛使用的标准行为。预检请求的目的是检查目标服务器是否允许跨域访问，确保请求不会有潜在的安全问题。</p><p>而简单请求（如上述 <code>GET</code> 和 <code>POST</code>）通常是安全的，因为它们不使用自定义头字段或不发送敏感的内容类型。浏览器认为这些请求不需要额外的安全检查，所以不会触发跨域预检。</p><h2 id="3、哪些请求会触发跨域？"><a href="#3、哪些请求会触发跨域？" class="headerlink" title="3、哪些请求会触发跨域？"></a><strong>3、哪些请求会触发跨域？</strong></h2><p>如果不符合上面简单请求的条件，以下情况会导致请求被认为是复杂请求，从而触发跨域检查：</p><ul><li>使用了 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>、<code>OPTIONS</code> 等不属于简单请求的方法。</li><li>请求中包含了自定义头，如 <code>Authorization</code>、<code>X-Custom-Header</code> 等。</li><li>使用了 <code>Content-Type</code> 头的其他类型（如 <code>application/json</code>、<code>application/xml</code>）。</li><li>使用了带有 <code>withCredentials: true</code> 的请求，表示请求携带用户凭证（如 Cookies）。</li></ul><h2 id="4、复杂请求和预检请求"><a href="#4、复杂请求和预检请求" class="headerlink" title="4、复杂请求和预检请求"></a><strong>4、复杂请求和预检请求</strong></h2><p>复杂请求会触发浏览器发起一个 <code>OPTIONS</code> 请求，称为<strong>预检请求（Preflight Request）</strong>，服务器需要在这个请求中返回允许跨域访问的 CORS 头信息。只有当预检请求通过后，浏览器才会真正发起复杂请求。</p><hr><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、<strong>总结</strong></h2><p>不会触发跨域的基础请求，遵循了简单请求的规则：</p><ol><li><strong>HTTP 方法</strong>：仅限 <code>GET</code>、<code>POST</code>、<code>HEAD</code>。</li><li><strong>请求头</strong>：仅使用特定的标准头字段，如 <code>Accept</code>、<code>Content-Type</code>，且 <code>Content-Type</code> 必须是 <code>text/plain</code>、<code>multipart/form-data</code> 或 <code>application/x-www-form-urlencoded</code>。</li><li><strong>不使用自定义请求头</strong>，例如 <code>Authorization</code> 等。</li><li><strong>不带凭证</strong>，即不使用 <code>withCredentials: true</code>。</li></ol><p>理解这些规则可以帮助你在开发中规避跨域问题，或者正确配置 CORS 来处理复杂请求。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h1><p>跨域问题是浏览器为了安全性引入的，同源策略的限制避免了跨站点攻击（XSS、CSRF），但同时也带来了开发中的诸多不便。解决跨域问题的方案多种多样，前后端可以根据项目的需求选择合适的方式来处理。</p><ol><li><strong>CORS</strong> 是最常用、最标准的跨域解决方案，推荐使用。</li><li><strong>JSONP</strong> 适用于简单的 GET 请求，但随着 CORS 的普及使用较少。</li><li><strong>反向代理</strong> 在开发环境或生产环境中都非常实用，尤其是在分布式系统中。</li><li><strong>WebSocket</strong> 则适用于需要双向实时通信的场景。</li></ol><p>选择合适的跨域解决方案可以极大提高开发效率，也能让系统更安全地进行数据交互。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6新特性详解</title>
    <link href="/posts/34057/"/>
    <url>/posts/34057/</url>
    
    <content type="html"><![CDATA[<p>ES6（ECMAScript 6，也称为ECMAScript 2015）是JavaScript语言的一个重大更新，引入了许多新特性，旨在使代码更简洁、更易读，同时提供更强大的功能。以下是ES6中引入的主要新特性及其详细解释：</p><hr><h1 id="1-let-和-const-关键字"><a href="#1-let-和-const-关键字" class="headerlink" title="1. let 和 const 关键字"></a>1. <strong><code>let</code> 和 <code>const</code> 关键字</strong></h1><h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a><strong><code>let</code> 声明</strong></h4><ul><li><strong>块级作用域</strong>：<code>let</code> 声明的变量具有块级作用域，即变量只在其所在的代码块 <code>&#123;&#125;</code> 内有效。</li><li><strong>不允许重复声明</strong>：在同一作用域内，不能使用 <code>let</code> 重复声明同一个变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出 10</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 未定义</span><br></code></pre></td></tr></table></figure><h4 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a><strong><code>const</code> 声明</strong></h4><ul><li><strong>常量声明</strong>：<code>const</code> 用于声明常量，变量的值一旦赋值就不能再改变。</li><li><strong>块级作用域</strong>：<code>const</code> 也具有块级作用域。</li><li><strong>必须初始化</strong>：使用 <code>const</code> 声明时，必须同时进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.1415</span>; <span class="hljs-comment">// 报错，无法重新赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-箭头函数（Arrow-Functions）"><a href="#2-箭头函数（Arrow-Functions）" class="headerlink" title="2. 箭头函数（Arrow Functions）"></a>2. <strong>箭头函数（Arrow Functions）</strong></h1><ul><li><strong>简化函数定义</strong>：使用 <code>=&gt;</code> 符号定义函数，语法更简洁。</li><li>**不绑定 <code>this</code>**：箭头函数不创建自己的 <code>this</code>，它会捕获上下文的 <code>this</code> 值。</li><li><strong>不能用作构造函数</strong>：箭头函数不能使用 <code>new</code> 关键字调用。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 5</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3. 模板字符串（Template Literals）"></a>3. <strong>模板字符串（Template Literals）</strong></h1><ul><li><strong>多行字符串</strong>：使用反引号 &#96;&#96;&#96; 包裹，可以直接编写多行字符串。</li><li><strong>字符串插值</strong>：使用 <code>$&#123;表达式&#125;</code> 在字符串中嵌入变量或表达式的值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!</span><br><span class="hljs-string">Welcome to ES6 features.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Hello, Alice!</span><br><span class="hljs-comment">// Welcome to ES6 features.</span><br></code></pre></td></tr></table></figure><hr><h1 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. <strong>默认参数（Default Parameters）</strong></h1><ul><li><strong>函数参数默认值</strong>：在函数定义时，可以为参数指定默认值，当调用函数时未传入该参数时，使用默认值。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;Guest&#x27;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// 输出 Hello, Bob!</span><br><span class="hljs-title function_">greet</span>();      <span class="hljs-comment">// 输出 Hello, Guest!</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-剩余参数和展开运算符（Rest-and-Spread-Operators）"><a href="#5-剩余参数和展开运算符（Rest-and-Spread-Operators）" class="headerlink" title="5. 剩余参数和展开运算符（Rest and Spread Operators）"></a>5. <strong>剩余参数和展开运算符（Rest and Spread Operators）</strong></h1><h4 id="剩余参数（Rest-Parameter）"><a href="#剩余参数（Rest-Parameter）" class="headerlink" title="剩余参数（Rest Parameter）"></a><strong>剩余参数（Rest Parameter）</strong></h4><ul><li><strong>函数参数</strong>：使用 <code>...</code> 收集函数的剩余参数，形成一个数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =&gt;</span> total + num, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><h4 id="展开运算符（Spread-Operator）"><a href="#展开运算符（Spread-Operator）" class="headerlink" title="展开运算符（Spread Operator）"></a><strong>展开运算符（Spread Operator）</strong></h4><ul><li><strong>数组和对象展开</strong>：使用 <code>...</code> 将数组或对象展开。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组展开</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// 输出 [1, 2, 3, 4]</span><br><br><span class="hljs-comment">// 对象展开</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// 输出 &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-解构赋值（Destructuring-Assignment）"><a href="#6-解构赋值（Destructuring-Assignment）" class="headerlink" title="6. 解构赋值（Destructuring Assignment）"></a>6. <strong>解构赋值（Destructuring Assignment）</strong></h1><ul><li><strong>数组解构</strong>：从数组中提取值，按照对应位置赋值给变量。</li><li><strong>对象解构</strong>：从对象中提取属性，赋值给与属性同名的变量。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构</span><br><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y); <span class="hljs-comment">// 输出 1 2</span><br><br><span class="hljs-comment">// 对象解构</span><br><span class="hljs-keyword">const</span> &#123; name, age &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// 输出 Alice 25</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-增强的对象字面量（Enhanced-Object-Literals）"><a href="#7-增强的对象字面量（Enhanced-Object-Literals）" class="headerlink" title="7. 增强的对象字面量（Enhanced Object Literals）"></a>7. <strong>增强的对象字面量（Enhanced Object Literals）</strong></h1><h3 id="1-属性简写（Property-Shorthand）"><a href="#1-属性简写（Property-Shorthand）" class="headerlink" title="1. 属性简写（Property Shorthand）"></a>1. 属性简写（Property Shorthand）</h3><p>在 ES6 之前，如果我们要在对象中设置属性，属性名通常与变量名相同，这时需要重复编写属性和变量名。但通过增强的对象字面量，可以直接使用简写语法。</p><h4 id="传统语法："><a href="#传统语法：" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: name,<br>  <span class="hljs-attr">age</span>: age<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-增强对象字面量的属性简写："><a href="#ES6-增强对象字面量的属性简写：" class="headerlink" title="ES6 增强对象字面量的属性简写："></a>ES6 增强对象字面量的属性简写：</h4><p>如果属性名和变量名相同，可以省略重复的部分，简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  name, <span class="hljs-comment">// 相当于 name: name</span><br>  age   <span class="hljs-comment">// 相当于 age: age</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：减少代码冗余，特别是在需要设置多个属性时，代码更简洁明了。</li></ul><h3 id="2-方法简写（Method-Shorthand）"><a href="#2-方法简写（Method-Shorthand）" class="headerlink" title="2. 方法简写（Method Shorthand）"></a>2. 方法简写（Method Shorthand）</h3><p>在对象中定义方法时，传统的写法需要显式使用 <code>function</code> 关键字。在增强的对象字面量中，可以使用更简洁的语法直接定义对象的方法。</p><h4 id="传统语法：-1"><a href="#传统语法：-1" class="headerlink" title="传统语法："></a>传统语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><h4 id="ES6-方法简写："><a href="#ES6-方法简写：" class="headerlink" title="ES6 方法简写："></a>ES6 方法简写：</h4><p>我们可以省略 <code>function</code> 关键字，直接用简写的形式来定义方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 简写方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：方法简写使得对象中的函数声明更简洁，代码也更容易阅读。</li></ul><h3 id="3-计算属性名（Computed-Property-Names）"><a href="#3-计算属性名（Computed-Property-Names）" class="headerlink" title="3. 计算属性名（Computed Property Names）"></a>3. 计算属性名（Computed Property Names）</h3><p>在增强的对象字面量中，允许动态地为对象的属性名赋值。你可以在对象定义时，通过方括号 <code>[]</code> 包裹表达式，使用计算出的值作为属性名。</p><h4 id="传统语法（ES5-没有计算属性名的支持）："><a href="#传统语法（ES5-没有计算属性名的支持）：" class="headerlink" title="传统语法（ES5 没有计算属性名的支持）："></a>传统语法（ES5 没有计算属性名的支持）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> person = &#123;&#125;;<br><br>person[key] = <span class="hljs-number">25</span>;  <span class="hljs-comment">// 动态添加属性</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; age: 25 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="ES6-计算属性名："><a href="#ES6-计算属性名：" class="headerlink" title="ES6 计算属性名："></a>ES6 计算属性名：</h4><p>通过计算属性名的方式，可以直接在对象定义时动态设置属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;age&#x27;</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  [key]: <span class="hljs-number">25</span>  <span class="hljs-comment">// 计算属性名</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// &#123; name: &#x27;Alice&#x27;, age: 25 &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性名不仅仅可以是变量，还可以是更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&#x27;user&#x27;</span>;<br><span class="hljs-keyword">const</span> id = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>_<span class="hljs-subst">$&#123;id&#125;</span>`</span>]: <span class="hljs-string">&#x27;Alice&#x27;</span>  <span class="hljs-comment">// 动态生成属性名 user_42</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// &#123; user_42: &#x27;Alice&#x27; &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>优势</strong>：在需要动态生成属性名的场景下，计算属性名提供了灵活的解决方案。</li></ul><h1 id="8-类（Classes）"><a href="#8-类（Classes）" class="headerlink" title="8. 类（Classes）"></a>8. <strong>类（Classes）</strong></h1><ul><li><strong>类的定义</strong>：使用 <code>class</code> 关键字定义类。</li><li><strong>构造函数</strong>：使用 <code>constructor</code> 方法。</li><li><strong>继承</strong>：使用 <code>extends</code> 关键字实现继承，使用 <code>super</code> 调用父类方法。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a sound.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">speak</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> barks.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br>dog.<span class="hljs-title function_">speak</span>();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Buddy makes a sound.</span><br><span class="hljs-comment">// Buddy barks.</span><br></code></pre></td></tr></table></figure><hr><h1 id="9-模块（Modules）"><a href="#9-模块（Modules）" class="headerlink" title="9. 模块（Modules）"></a>9. <strong>模块（Modules）</strong></h1><p>在 ES6（ECMAScript 2015）中，<strong>模块（Modules）</strong>是 JavaScript 中引入的一个重要特性，它为开发者提供了更好地组织代码的方式，使得代码更加模块化、可维护。模块系统允许我们将代码分隔成独立的模块，每个模块可以包含自己的变量、函数、类，并且这些模块之间可以通过 <code>export</code> 和 <code>import</code> 进行共享和使用。</p><p>接下来我们详细讲解模块的基本概念、用法以及如何在现代 JavaScript 项目中使用它们。</p><hr><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>在 ES6 之前，JavaScript 并没有原生的模块系统。开发者通常通过一些全局变量来共享数据，或者使用 IIFE（立即执行函数表达式）来模拟模块封装。这种做法容易导致命名冲突、全局污染，以及代码难以维护、复用性差的问题。</p><p>ES6 引入的模块系统解决了这些问题，它允许我们：</p><ul><li>将代码组织成多个独立的文件或模块；</li><li>在不同模块之间导入或导出功能；</li><li>避免全局命名冲突；</li><li>提高代码的可维护性和复用性。</li></ul><h2 id="ES6-模块基础概念"><a href="#ES6-模块基础概念" class="headerlink" title="ES6 模块基础概念"></a>ES6 模块基础概念</h2><p>ES6 模块主要依赖两个关键字：</p><ul><li>**<code>export</code>**：用来从模块中导出变量、函数、类等内容。</li><li>**<code>import</code>**：用来从其他模块中导入内容。</li></ul><h2 id="1-导出（Export）"><a href="#1-导出（Export）" class="headerlink" title="1. 导出（Export）"></a>1. 导出（Export）</h2><p><code>export</code> 用于将模块中的变量、函数、类等导出，供其他模块使用。</p><h3 id="1-1-命名导出（Named-Export）"><a href="#1-1-命名导出（Named-Export）" class="headerlink" title="1.1. 命名导出（Named Export）"></a>1.1. 命名导出（Named Export）</h3><p>命名导出允许你导出多个内容，并且每个导出都有自己明确的名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>  <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们导出了一个常量 <code>pi</code>，一个函数 <code>add</code>，以及一个类 <code>Calculator</code>。这些内容都可以通过名字从其他模块中导入。</p><h3 id="1-2-默认导出（Default-Export）"><a href="#1-2-默认导出（Default-Export）" class="headerlink" title="1.2. 默认导出（Default Export）"></a>1.2. 默认导出（Default Export）</h3><p>默认导出是指模块中可以有一个默认导出的值，导入时可以不需要用花括号。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// greeting.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们导出了一个默认的函数 <code>greet</code>，默认导出在每个模块中只能有一个。</p><h2 id="2-导入（Import）"><a href="#2-导入（Import）" class="headerlink" title="2. 导入（Import）"></a>2. 导入（Import）</h2><p><code>import</code> 用于从其他模块中导入导出的内容。导入可以是命名导出或默认导出。</p><h3 id="2-1-导入命名导出"><a href="#2-1-导入命名导出" class="headerlink" title="2.1. 导入命名导出"></a>2.1. 导入命名导出</h3><p>当从其他模块导入命名导出时，需要使用花括号 <code>&#123;&#125;</code>，并且变量名必须与导出的名称一致。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; pi, add, <span class="hljs-title class_">Calculator</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们从 <code>math.js</code> 中导入了 <code>pi</code>、<code>add</code> 函数和 <code>Calculator</code> 类，并在 <code>main.js</code> 中使用。</p><h3 id="2-2-导入默认导出"><a href="#2-2-导入默认导出" class="headerlink" title="2.2. 导入默认导出"></a>2.2. 导入默认导出</h3><p>导入默认导出时不需要使用花括号 <code>&#123;&#125;</code>，并且导入时可以任意命名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeting.js&#x27;</span>;<br><br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);  <span class="hljs-comment">// Hello, Alice!</span><br></code></pre></td></tr></table></figure><p>在这里，我们导入了 <code>greeting.js</code> 中的默认导出 <code>greet</code> 函数，并直接使用它。</p><h3 id="2-3-导入别名"><a href="#2-3-导入别名" class="headerlink" title="2.3. 导入别名"></a>2.3. 导入别名</h3><p>有时你可能需要对导入的模块重命名，可以使用 <code>as</code> 来设置别名。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>使用 <code>as</code> 可以避免命名冲突或让代码语义更加清晰。</p><h3 id="2-4-导入所有导出（import-as）"><a href="#2-4-导入所有导出（import-as）" class="headerlink" title="2.4. 导入所有导出（import * as）"></a>2.4. 导入所有导出（<code>import * as</code>）</h3><p>你也可以将整个模块的所有导出内容作为一个对象导入。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-property">pi</span>);  <span class="hljs-comment">// 3.14159</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们将 <code>math.js</code> 中的所有导出作为一个 <code>math</code> 对象导入，然后通过 <code>math</code> 对象访问导出的内容。</p><h2 id="3-重新导出（Re-export）"><a href="#3-重新导出（Re-export）" class="headerlink" title="3. 重新导出（Re-export）"></a>3. 重新导出（Re-export）</h2><p>有时我们需要从一个模块导入一些内容后再导出给其他模块，这时可以使用 <code>export ... from</code> 语法。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> &#123; pi, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里，<code>moduleA.js</code> 重新导出了 <code>math.js</code> 中的 <code>pi</code> 和 <code>add</code>，其他模块可以直接从 <code>moduleA.js</code> 导入这些内容。</p><h2 id="4-动态导入（Dynamic-Import）"><a href="#4-动态导入（Dynamic-Import）" class="headerlink" title="4. 动态导入（Dynamic Import）"></a>4. 动态导入（Dynamic Import）</h2><p>ES6 模块中的 <code>import</code> 通常是静态的，即在编译时已经决定好导入的内容。然而，ES2020 引入了 <strong>动态导入（Dynamic Import）</strong>，它允许我们在运行时动态加载模块。</p><p>动态导入返回一个 <code>Promise</code>，当模块加载完成后会执行后续的操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error loading module:&#x27;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>动态导入特别适合按需加载模块或实现代码拆分（code splitting）。</p><hr><h2 id="ES6-模块的优势"><a href="#ES6-模块的优势" class="headerlink" title="ES6 模块的优势"></a>ES6 模块的优势</h2><ol><li><strong>默认严格模式</strong>：ES6 模块默认采用严格模式（<code>strict mode</code>），这意味着你可以避免一些常见的错误，比如全局变量的隐式声明。</li><li><strong>模块作用域</strong>：每个模块都有自己的作用域，模块内部的变量不会污染全局作用域，减少了命名冲突的可能性。</li><li><strong>按需导入</strong>：通过导入需要的内容，避免加载多余的代码，有助于提升性能。</li><li><strong>提升代码的可维护性和复用性</strong>：通过将功能分散到不同模块中，代码更容易维护，且可以重复使用不同模块中的功能。</li><li><strong>与现代构建工具集成</strong>：许多现代前端工具（如 Webpack、Parcel）和后端框架（如 Node.js）都支持 ES6 模块，可以方便地将模块化代码与构建工具结合使用。</li></ol><hr><h2 id="ES6-模块-vs-CommonJS"><a href="#ES6-模块-vs-CommonJS" class="headerlink" title="ES6 模块 vs CommonJS"></a>ES6 模块 vs CommonJS</h2><p>在 Node.js 中，最常见的模块系统是 <strong>CommonJS</strong>，通过 <code>require</code> 和 <code>module.exports</code> 来实现模块化。但 ES6 模块的出现提供了更标准化、现代化的解决方案。主要区别如下：</p><ul><li><strong>ES6 模块</strong>：通过 <code>import</code> 和 <code>export</code>，是编译时静态加载，支持浏览器原生模块化。</li><li><strong>CommonJS 模块</strong>：通过 <code>require</code> 和 <code>module.exports</code>，是运行时动态加载，最常见于 Node.js 环境中。</li></ul><p>随着 Node.js 开始原生支持 ES6 模块（通过文件扩展名 <code>.mjs</code> 或设置 <code>&quot;type&quot;: &quot;module&quot;</code>），开发者可以逐渐过渡到使用 ES6 模块系统。</p><hr><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. <strong>Promise 对象</strong></h1><p><strong>Promise</strong> 对象是 ES6 引入的一种用于处理异步操作的解决方案，避免了“回调地狱”的问题，使得异步代码的结构更加清晰、可读。<code>Promise</code> 允许你将异步操作的结果（成功或失败）封装成一个对象，并提供链式调用来处理异步操作的结果。</p><hr><h2 id="1-什么是-Promise？"><a href="#1-什么是-Promise？" class="headerlink" title="1. 什么是 Promise？"></a>1. 什么是 Promise？</h2><p><code>Promise</code> 是一个代表未来某个异步操作的结果的对象，它有三种状态：</p><ul><li><strong>Pending（进行中）</strong>：初始状态，异步操作尚未完成。</li><li><strong>Fulfilled（已完成）</strong>：异步操作成功完成，结果已返回。</li><li><strong>Rejected（已失败）</strong>：异步操作失败，返回了失败原因（通常是一个错误对象）。</li></ul><p>每个 <code>Promise</code> 实例一旦状态从 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变，也就是说 Promise 一旦 resolved 或 rejected 之后，结果是不可修改的。</p><h2 id="2-创建-Promise-对象"><a href="#2-创建-Promise-对象" class="headerlink" title="2. 创建 Promise 对象"></a>2. 创建 Promise 对象</h2><p>我们可以通过 <code>new Promise()</code> 构造函数来创建一个 Promise 对象。它接收一个函数作为参数，该函数包含两个参数：<code>resolve</code> 和 <code>reject</code>。</p><ul><li><code>resolve(value)</code>：当异步操作成功时调用，表示完成并将结果传递给下一个链式操作。</li><li><code>reject(error)</code>：当异步操作失败时调用，表示操作失败并将错误传递给错误处理器。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟异步操作的结果</span><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;操作成功！&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-Promise-状态变化"><a href="#3-Promise-状态变化" class="headerlink" title="3. Promise 状态变化"></a>3. Promise 状态变化</h2><p><code>Promise</code> 对象的状态只能从 <code>Pending</code> 转为 <code>Fulfilled</code> 或 <code>Rejected</code>，一旦状态改变，就不能再修改。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功了！&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 输出：Pending</span><br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：成功了！</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise);  <span class="hljs-comment">// 最初状态为 Pending，2秒后会变为 Fulfilled</span><br></code></pre></td></tr></table></figure><h2 id="4-Promise-的使用"><a href="#4-Promise-的使用" class="headerlink" title="4. Promise 的使用"></a>4. Promise 的使用</h2><p>Promise 主要通过 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 进行链式调用来处理异步操作。</p><h3 id="4-1-then-：处理成功结果"><a href="#4-1-then-：处理成功结果" class="headerlink" title="4.1 .then()：处理成功结果"></a>4.1 <code>.then()</code>：处理成功结果</h3><p><code>then()</code> 方法用于处理 Promise 成功的结果。它接收两个回调函数，分别是成功回调和失败回调。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);  <span class="hljs-comment">// 成功的回调</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);  <span class="hljs-comment">// 失败的回调</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-catch-：处理失败结果"><a href="#4-2-catch-：处理失败结果" class="headerlink" title="4.2 .catch()：处理失败结果"></a>4.2 <code>.catch()</code>：处理失败结果</h3><p><code>catch()</code> 方法用于处理 Promise 中的错误或拒绝操作。它相当于 <code>.then()</code> 的第二个参数，但更适用于单独处理错误的场景。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);  <span class="hljs-comment">// 输出：错误：出错了</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-finally-：无论成功或失败都执行"><a href="#4-3-finally-：无论成功或失败都执行" class="headerlink" title="4.3 .finally()：无论成功或失败都执行"></a>4.3 <code>.finally()</code>：无论成功或失败都执行</h3><p><code>finally()</code> 方法无论 Promise 最终是成功还是失败，都会执行一次操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;操作结束&#x27;</span>);  <span class="hljs-comment">// 无论成功还是失败，都会执行</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="5-Promise-的链式调用"><a href="#5-Promise-的链式调用" class="headerlink" title="5. Promise 的链式调用"></a>5. Promise 的链式调用</h2><p>Promise 的强大之处在于它允许通过链式调用来处理多个异步操作。每个 <code>then()</code> 调用返回一个新的 <code>Promise</code> 对象，从而可以链式调用下一个异步操作。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：1</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：2</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出：4</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，每个 <code>then()</code> 会返回一个新的 Promise，它可以继续链式调用。最终可以通过多个 <code>then()</code> 处理一系列的异步任务。</p><h2 id="6-Promise-静态方法"><a href="#6-Promise-静态方法" class="headerlink" title="6. Promise 静态方法"></a>6. Promise 静态方法</h2><h3 id="6-1-Promise-resolve"><a href="#6-1-Promise-resolve" class="headerlink" title="6.1 Promise.resolve()"></a>6.1 <code>Promise.resolve()</code></h3><p><code>Promise.resolve()</code> 方法返回一个已被 <code>resolve</code> 的 Promise，可以用来快速封装同步值。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：成功</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-2-Promise-reject"><a href="#6-2-Promise-reject" class="headerlink" title="6.2 Promise.reject()"></a>6.2 <code>Promise.reject()</code></h3><p><code>Promise.reject()</code> 方法返回一个已被 <code>reject</code> 的 Promise，用来封装错误或失败的结果。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 输出：失败</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-3-Promise-all"><a href="#6-3-Promise-all" class="headerlink" title="6.3 Promise.all()"></a>6.3 <code>Promise.all()</code></h3><p><code>Promise.all()</code> 方法接受一个包含多个 Promise 的数组，只有当所有 Promise 都成功时，才会执行 <code>then()</code> 回调；如果任何一个 Promise 失败，它就会立即进入 <code>catch()</code>。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);  <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-4-Promise-race"><a href="#6-4-Promise-race" class="headerlink" title="6.4 Promise.race()"></a>6.4 <code>Promise.race()</code></h3><p><code>Promise.race()</code> 方法接受一个包含多个 Promise 的数组，<strong>只要有一个 Promise 完成</strong>，就会进入 <code>then()</code> 回调，无论是成功还是失败。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;p1&#x27;</span>));<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;p2&#x27;</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：p2</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-Promise-实现异步操作"><a href="#7-Promise-实现异步操作" class="headerlink" title="7. Promise 实现异步操作"></a>7. Promise 实现异步操作</h2><p>Promise 的主要用途是处理异步操作，常见的如网络请求、文件读取等。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模拟异步网络请求</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 模拟请求成功</span><br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;请求的数据&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 输出：请求的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误：&#x27;</span> + error);<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="11-Symbol-类型"><a href="#11-Symbol-类型" class="headerlink" title="11. Symbol 类型"></a>11. <strong>Symbol 类型</strong></h1><p><code>Symbol</code> 是 ECMAScript 6（ES6）引入的一种<strong>原始数据类型</strong>，它表示独一无二的值。与其他 JavaScript 数据类型（如字符串、数字、布尔值等）不同，<code>Symbol</code> 的主要作用是创建一个唯一的标识符，用于避免对象属性命名的冲突。</p><h2 id="1-Symbol-基础概念"><a href="#1-Symbol-基础概念" class="headerlink" title="1. Symbol 基础概念"></a>1. <strong>Symbol 基础概念</strong></h2><p><code>Symbol</code> 是通过 <code>Symbol()</code> 函数调用创建的。与其他原始数据类型不同，<code>Symbol</code> 的每个实例都是唯一的，即使两个 <code>Symbol()</code> 的参数相同，它们也是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbol1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-keyword">const</span> symbol2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbol1 === symbol2);  <span class="hljs-comment">// 输出：false</span><br></code></pre></td></tr></table></figure><ul><li>这里，<code>Symbol()</code> 中的参数 <code>&#39;description&#39;</code> 仅用于调试时的描述（可以理解为符号的标签），它不会影响 <code>Symbol</code> 的唯一性。</li></ul><h2 id="2-Symbol-的特性"><a href="#2-Symbol-的特性" class="headerlink" title="2. Symbol 的特性"></a>2. <strong>Symbol 的特性</strong></h2><ul><li><strong>唯一性</strong>：每个 <code>Symbol</code> 都是独一无二的，即使它们的描述相同，创建出来的 <code>Symbol</code> 也不会相等。</li><li><strong>不可改变</strong>：<code>Symbol</code> 是一种不可变的原始值，类似于 <code>string</code> 或 <code>number</code> 类型，它的值不能被修改。</li><li><strong>不可枚举</strong>：使用 <code>for...in</code>、<code>for...of</code> 或 <code>Object.keys()</code> 等方法遍历对象属性时，<code>Symbol</code> 类型的属性不会被枚举出来。</li></ul><h2 id="3-Symbol-作为对象属性的键"><a href="#3-Symbol-作为对象属性的键" class="headerlink" title="3. Symbol 作为对象属性的键"></a>3. <strong>Symbol 作为对象属性的键</strong></h2><p>通常，JavaScript 对象的键是字符串类型，但 <code>Symbol</code> 可以用作对象的键（属性名）。由于 <code>Symbol</code> 是唯一的，可以避免对象中使用相同的属性名导致的冲突。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [mySymbol]: <span class="hljs-string">&#x27;Symbol 属性值&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;普通属性值&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol]);  <span class="hljs-comment">// 输出：Symbol 属性值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);       <span class="hljs-comment">// 输出：普通属性值</span><br></code></pre></td></tr></table></figure><ul><li>注意，这里使用了 <strong>方括号语法</strong> <code>[mySymbol]</code> 来动态地定义对象的 <code>Symbol</code> 属性。</li></ul><h2 id="4-遍历-Symbol-属性"><a href="#4-遍历-Symbol-属性" class="headerlink" title="4. 遍历 Symbol 属性"></a>4. <strong>遍历 Symbol 属性</strong></h2><p>如前所述，<code>Symbol</code> 属性不会被 <code>for...in</code>、<code>Object.keys()</code> 等遍历方法枚举出来，但你可以通过以下几种方法获取对象的 <code>Symbol</code> 属性：</p><ul><li>**<code>Object.getOwnPropertySymbols()</code>**：返回一个包含对象所有 <code>Symbol</code> 属性的数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;<br>  [sym1]: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  [sym2]: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> symbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbols);  <span class="hljs-comment">// 输出：[Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><ul><li>**<code>Reflect.ownKeys()</code>**：返回对象所有的键，包括字符串和 <code>Symbol</code> 类型。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj));  <span class="hljs-comment">// 输出：[&quot;name&quot;, Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><h2 id="5-全局-Symbol"><a href="#5-全局-Symbol" class="headerlink" title="5. 全局 Symbol"></a>5. <strong>全局 Symbol</strong></h2><p>JavaScript 还提供了 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 两个方法，用于创建和使用<strong>全局 Symbol</strong>。全局 Symbol 是共享的，即通过相同的 key 创建的全局 Symbol 总是相同的。</p><h3 id="5-1-Symbol-for"><a href="#5-1-Symbol-for" class="headerlink" title="5.1 Symbol.for()"></a>5.1 <strong><code>Symbol.for()</code></strong></h3><p><code>Symbol.for()</code> 方法接收一个字符串作为参数，检查全局注册表中是否存在该字符串对应的 Symbol，如果存在则返回该 Symbol，否则新建一个。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><span class="hljs-keyword">const</span> globalSym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;globalKey&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalSym1 === globalSym2);  <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><ul><li><code>Symbol.for()</code> 使得相同 key 的 Symbol 是共享的，因此多个地方可以通过相同的 key 来引用同一个 Symbol。</li></ul><h3 id="5-2-Symbol-keyFor"><a href="#5-2-Symbol-keyFor" class="headerlink" title="5.2 Symbol.keyFor()"></a>5.2 <strong><code>Symbol.keyFor()</code></strong></h3><p><code>Symbol.keyFor()</code> 方法用于获取某个全局 Symbol 的 key。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;myKey&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym));  <span class="hljs-comment">// 输出：myKey</span><br></code></pre></td></tr></table></figure><ul><li>注意：<code>Symbol.keyFor()</code> 只能用于全局 <code>Symbol</code>，而不能用于普通的 <code>Symbol</code>。</li></ul><h2 id="6-内置的-Symbol"><a href="#6-内置的-Symbol" class="headerlink" title="6. 内置的 Symbol"></a>6. <strong>内置的 Symbol</strong></h2><p>ES6 还定义了一些内置的 <code>Symbol</code>，这些内置 <code>Symbol</code> 具有特殊的用途，通常用于定义一些 JavaScript 内部行为的自定义实现。</p><ul><li>**<code>Symbol.iterator</code>**：用于定义对象的默认迭代器，允许对象参与 <code>for...of</code> 循环。</li><li>**<code>Symbol.toStringTag</code>**：用于自定义 <code>Object.prototype.toString</code> 的返回值。</li><li>**<code>Symbol.hasInstance</code>**：用于判断对象是否是某个构造函数的实例。</li></ul><h3 id="6-1-Symbol-iterator"><a href="#6-1-Symbol-iterator" class="headerlink" title="6.1 Symbol.iterator"></a>6.1 <code>Symbol.iterator</code></h3><p><code>Symbol.iterator</code> 是一个内置的 <code>Symbol</code>，允许你为对象定义迭代行为，从而使对象可以被 <code>for...of</code> 循环使用。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterableObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">3</span> ? &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> iterableObj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 输出：0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Symbol-toStringTag"><a href="#6-2-Symbol-toStringTag" class="headerlink" title="6.2 Symbol.toStringTag"></a>6.2 <code>Symbol.toStringTag</code></h3><p><code>Symbol.toStringTag</code> 允许你自定义对象在 <code>Object.prototype.toString()</code> 中显示的标签。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;MyCustomObject&#x27;</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(myObj));  <span class="hljs-comment">// 输出：[object MyCustomObject]</span><br></code></pre></td></tr></table></figure><h2 id="7-Symbol-的应用场景"><a href="#7-Symbol-的应用场景" class="headerlink" title="7. Symbol 的应用场景"></a>7. <strong>Symbol 的应用场景</strong></h2><ul><li><strong>避免对象属性名冲突</strong>：使用 <code>Symbol</code> 作为对象属性的键，保证属性名是唯一的，防止重写或冲突，特别是在大型代码库或第三方库中。</li><li><strong>为对象定义私有属性</strong>：由于 <code>Symbol</code> 属性不可枚举，通常可以用于实现“伪私有”属性，不会被 <code>for...in</code> 遍历到。</li><li><strong>扩展原生对象的行为</strong>：通过使用内置 <code>Symbol</code>，可以扩展 JavaScript 原生对象的行为，比如为对象自定义迭代器。</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. <strong>总结</strong></h2><ul><li><strong><code>Symbol</code> 是一种唯一的标识符</strong>，用于避免对象属性名的冲突。</li><li><strong><code>Symbol</code> 属性不可枚举</strong>，不能通过常规的对象遍历方法访问，但可以通过 <code>Object.getOwnPropertySymbols()</code> 或 <code>Reflect.ownKeys()</code> 获取。</li><li><strong>全局 <code>Symbol</code></strong> 可以通过 <code>Symbol.for()</code> 和 <code>Symbol.keyFor()</code> 共享并访问。</li><li>ES6 提供了一些**内置的 <code>Symbol</code>**，用于修改 JavaScript 原生行为，如 <code>Symbol.iterator</code>、<code>Symbol.toStringTag</code> 等。</li></ul><p><code>Symbol</code> 是 JavaScript 中一种非常有用的工具，它为我们提供了更多灵活性和控制力，特别是在大型项目中，使用 <code>Symbol</code> 可以有效地避免属性名冲突和确保代码的稳定性。</p><hr><h1 id="12-迭代器（Iterators）和-for-of-循环"><a href="#12-迭代器（Iterators）和-for-of-循环" class="headerlink" title="12. 迭代器（Iterators）和 for...of 循环"></a>12. <strong>迭代器（Iterators）和 <code>for...of</code> 循环</strong></h1><h2 id="1-迭代器（Iterators）"><a href="#1-迭代器（Iterators）" class="headerlink" title="1. 迭代器（Iterators）"></a>1. 迭代器（Iterators）</h2><p><strong>迭代器</strong>是一种用于访问集合中元素的对象，它提供了一种标准化的方法来遍历各种数据结构（如数组、对象、集合等）。迭代器遵循一定的协议，使得各种对象可以被一致地遍历。</p><h3 id="1-1-迭代器协议"><a href="#1-1-迭代器协议" class="headerlink" title="1.1 迭代器协议"></a>1.1 迭代器协议</h3><p>迭代器协议是一组规则，定义了一个对象如何提供遍历操作。任何实现了这些规则的对象都可以称为迭代器。</p><ul><li><p>迭代器对象</p><p>：必须实现 <strong>next</strong> 方法，该方法返回一个对象，这个对象包含两个属性：</p><ul><li><code>value</code>：当前遍历的值。</li><li><code>done</code>：一个布尔值，指示是否已遍历完所有值（<code>true</code> 表示遍历完成，<code>false</code> 表示还有剩余值）。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterator = &#123;<br>  <span class="hljs-attr">current</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">last</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 3, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-可迭代对象（Iterable-Objects）"><a href="#1-2-可迭代对象（Iterable-Objects）" class="headerlink" title="1.2 可迭代对象（Iterable Objects）"></a>1.2 可迭代对象（Iterable Objects）</h3><p>可迭代对象是具有 <code>Symbol.iterator</code> 属性的对象，<code>Symbol.iterator</code> 属性的值是一个函数，这个函数返回一个迭代器。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iterable = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: i++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 0, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">// 输出：&#123; done: true &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-for-of-循环"><a href="#2-for-of-循环" class="headerlink" title="2. for...of 循环"></a>2. <code>for...of</code> 循环</h2><p><code>for...of</code> 循环是 ES6 引入的用于遍历可迭代对象（包括数组、字符串、Map、Set 等）的一种语法。与传统的 <code>for</code> 循环不同，<code>for...of</code> 循环更简洁、易于理解，并且可以直接访问到每个元素。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><strong>基本语法：</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> iterable) &#123;<br>  <span class="hljs-comment">// 处理 element</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-遍历数组"><a href="#2-1-遍历数组" class="headerlink" title="2.1 遍历数组"></a>2.1 遍历数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><h3 id="2-2-遍历字符串"><a href="#2-2-遍历字符串" class="headerlink" title="2.2 遍历字符串"></a>2.2 遍历字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(char);<br>&#125;<br><span class="hljs-comment">// 输出：h, e, l, l, o</span><br></code></pre></td></tr></table></figure><h3 id="2-3-遍历-Set"><a href="#2-3-遍历-Set" class="headerlink" title="2.3 遍历 Set"></a>2.3 遍历 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> mySet) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h3 id="2-4-遍历-Map"><a href="#2-4-遍历-Map" class="headerlink" title="2.4 遍历 Map"></a>2.4 遍历 Map</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出：key1: value1, key2: value2</span><br></code></pre></td></tr></table></figure><h2 id="3-自定义可迭代对象"><a href="#3-自定义可迭代对象" class="headerlink" title="3. 自定义可迭代对象"></a>3. 自定义可迭代对象</h2><p>你可以通过实现 <code>Symbol.iterator</code> 方法来自定义一个可迭代对象，并使用 <code>for...of</code> 循环进行遍历。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> customIterable = &#123;<br>  <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; data.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: data[index++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> customIterable) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 输出：1, 2, 3</span><br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li><strong>迭代器</strong> 是遵循特定协议的对象，它包含 <code>next</code> 方法来逐步访问集合中的元素。</li><li><strong>可迭代对象</strong> 是实现了 <code>Symbol.iterator</code> 方法的对象，可以被 <code>for...of</code> 循环遍历。</li><li><strong><code>for...of</code> 循环</strong> 使得遍历可迭代对象变得更加简洁直观，可以直接访问每个元素，而无需手动管理迭代器对象。</li></ul><p>通过理解和掌握这些概念，你可以更有效地处理各种数据结构，编写更加清晰和可维护的代码。</p><hr><h1 id="13-生成器（Generators）"><a href="#13-生成器（Generators）" class="headerlink" title="13. 生成器（Generators）"></a>13. <strong>生成器（Generators）</strong></h1><p>生成器是 ECMAScript 6 (ES6) 引入的一种特殊类型的函数，允许函数在执行时被暂停和恢复。生成器在处理需要多次迭代的任务时非常有用，比如遍历数据集、异步操作等。生成器函数可以简化代码逻辑，并提供了一种优雅的方式来管理异步操作。</p><h2 id="1-生成器的基本概念"><a href="#1-生成器的基本概念" class="headerlink" title="1. 生成器的基本概念"></a>1. <strong>生成器的基本概念</strong></h2><p>生成器是能够暂停执行并在之后的时间点恢复执行的函数。生成器函数通过 <code>function*</code> 关键字定义，并且返回一个生成器对象。生成器对象具有 <code>next()</code> 方法，可以用来控制生成器的执行过程。</p><h2 id="2-生成器函数的定义"><a href="#2-生成器函数的定义" class="headerlink" title="2. 生成器函数的定义"></a>2. <strong>生成器函数的定义</strong></h2><p>生成器函数通过 <code>function*</code> 语法定义。生成器函数内部使用 <code>yield</code> 关键字来暂停函数的执行，并返回一个值。每次调用 <code>next()</code> 方法时，生成器会从上次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 语句。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: World</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: !</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="3-生成器对象"><a href="#3-生成器对象" class="headerlink" title="3. 生成器对象"></a>3. <strong>生成器对象</strong></h2><p>生成器函数返回一个生成器对象，该对象具有以下方法：</p><ul><li>**<code>next([value])</code>**：恢复生成器函数的执行，直到下一个 <code>yield</code> 表达式。可以传递一个参数 <code>value</code>，作为 <code>yield</code> 表达式的返回值。返回的对象包含两个属性：<ul><li><code>value</code>：<code>yield</code> 表达式返回的值。</li><li><code>done</code>：布尔值，表示生成器是否已经完成执行。</li></ul></li><li>**<code>return([value])</code>**：结束生成器的执行，返回一个包含 <code>value</code> 的对象。<code>done</code> 属性将被设置为 <code>true</code>。</li><li>**<code>throw(exception)</code>**：在生成器中抛出异常，生成器会捕获这个异常并将其作为 <code>throw</code> 表达式的结果。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: Hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)); <span class="hljs-comment">// 输出: Error: Something went wrong</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-生成器的实际应用"><a href="#4-生成器的实际应用" class="headerlink" title="4. 生成器的实际应用"></a>4. <strong>生成器的实际应用</strong></h2><p>生成器在许多实际场景中都非常有用：</p><ul><li><p><strong>迭代器</strong>：生成器提供了一种简洁的方式来实现自定义的迭代器，使得遍历自定义数据结构变得容易。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">range</span>(<span class="hljs-params">start, end</span>) &#123;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    <span class="hljs-keyword">yield</span> start++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>异步编程</strong>：生成器与 Promise 结合可以简化异步编程。通过使用 <code>yield</code> 可以逐步处理异步操作，代码看起来更加同步。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">fetchData</span>();<br>generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(response).<span class="hljs-property">value</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> generator.<span class="hljs-title function_">next</span>(data));<br></code></pre></td></tr></table></figure></li><li><p><strong>状态机</strong>：生成器可以用来实现状态机，通过 <code>yield</code> 和 <code>next()</code> 控制状态的转换。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">stateMachine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;start&#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is start&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;middle&#x27;</span>:<br>        state = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;State is middle&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;end&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;State is end&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> machine = <span class="hljs-title function_">stateMachine</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is start</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;middle&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is middle</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(machine.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;end&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: State is end</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>生成器是 ES6 中一个强大的特性，它提供了一种简单而灵活的方式来控制函数的执行流。通过 <code>function*</code> 语法定义生成器函数，并使用 <code>yield</code> 来暂停和恢复执行。生成器可以用于实现自定义迭代器、简化异步编程、实现状态机等。它们的使用可以使代码更加优雅和易于维护。</p><p>如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="14-Map-和-Set-数据结构"><a href="#14-Map-和-Set-数据结构" class="headerlink" title="14. Map 和 Set 数据结构"></a>14. <strong><code>Map</code> 和 <code>Set</code> 数据结构</strong></h1><p>在 ECMAScript 6 (ES6) 中，<code>Map</code> 和 <code>Set</code> 是两个新的数据结构，它们提供了比传统的对象和数组更强大的功能，特别是在处理键值对和唯一值时。下面是对这两个数据结构的详细解释。</p><hr><h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a><strong><code>Map</code> 数据结构</strong></h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Map</code> 是一个有序的键值对集合，其中的键和值都可以是任何类型的值。与普通的对象不同，<code>Map</code> 的键值对是按插入顺序保持的，并且键的类型不受限制。</p><h3 id="2-创建-Map"><a href="#2-创建-Map" class="headerlink" title="2. 创建 Map"></a>2. <strong>创建 <code>Map</code></strong></h3><p>你可以使用 <code>new Map()</code> 来创建一个新的 <code>Map</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Map</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Map 实例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Map</span><br><span class="hljs-keyword">const</span> mapWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>],<br>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>set(key, value)</code>**：添加或更新键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>get(key)</code>**：根据键获取值。如果键不存在，返回 <code>undefined</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>has(key)</code>**：检查是否存在指定的键。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(key)</code>**：删除指定的键及其对应的值。如果删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Map</code> 中的所有键值对。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Map</code> 中键值对的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li>**<code>keys()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键。</li><li>**<code>values()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的值。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Map</code> 中所有的键值对。</li><li>**<code>forEach(callback)</code>**：对 <code>Map</code> 中的每个键值对执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong><code>Set</code> 数据结构</strong></h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>Set</code> 是一个值的集合，其中的值是唯一的，不允许重复。<code>Set</code> 的值是按照插入顺序排列的。</p><h3 id="2-创建-Set"><a href="#2-创建-Set" class="headerlink" title="2. 创建 Set"></a>2. <strong>创建 <code>Set</code></strong></h3><p>你可以使用 <code>new Set()</code> 来创建一个新的 <code>Set</code> 实例。可以选择传递一个可迭代对象（如数组）来初始化 <code>Set</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空的 Set 实例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 使用数组初始化 Set</span><br><span class="hljs-keyword">const</span> setWithValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><ul><li><p>**<code>add(value)</code>**：向 <code>Set</code> 中添加一个值。如果值已经存在，则不会重复添加。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;apple&#x27;</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>has(value)</code>**：检查 <code>Set</code> 中是否存在指定的值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;apple&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>delete(value)</code>**：删除 <code>Set</code> 中的指定值。如果值存在并且删除成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code>**：删除 <code>Set</code> 中的所有值。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p>**<code>size</code>**：获取 <code>Set</code> 中的值的数量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代方法</strong>：</p><ul><li><strong><code>keys()</code></strong> 和 **<code>values()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有值（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>entries()</code>**：返回一个迭代器对象，包含 <code>Set</code> 中的所有键值对（在 <code>Set</code> 中，键和值是一样的）。</li><li>**<code>forEach(callback)</code>**：对 <code>Set</code> 中的每个值执行回调函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**<code>Map</code>**：适用于需要键值对并且键可以是任意类型的情况。提供了有序的键值对，并且具有丰富的方法来操作数据。</li><li>**<code>Set</code>**：适用于需要唯一值的情况。提供了无重复的值集合，并且具有方便的方法来检查和操作这些值。</li></ul><p>这两个数据结构在 ES6 中提供了比传统的对象和数组更高效和灵活的操作方式。如果你有任何其他问题或需要进一步的帮助，请随时告诉我！</p><hr><h1 id="15-WeakMap-和-WeakSet"><a href="#15-WeakMap-和-WeakSet" class="headerlink" title="15. WeakMap 和 WeakSet"></a>15. <strong><code>WeakMap</code> 和 <code>WeakSet</code></strong></h1><ul><li><strong>弱引用</strong>：<code>WeakMap</code> 和 <code>WeakSet</code> 中的键（对于 <code>WeakMap</code>）和值（对于 <code>WeakSet</code>）是弱引用，不会阻止垃圾回收。</li><li><strong>用途</strong>：常用于存储关联到对象的元数据，不会干扰对象的垃圾回收。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some value&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 被垃圾回收，weakMap 中的键值对也会被自动移除</span><br></code></pre></td></tr></table></figure><hr><h1 id="16-新增的字符串、数字、数组方法"><a href="#16-新增的字符串、数字、数组方法" class="headerlink" title="16. 新增的字符串、数字、数组方法"></a>16. <strong>新增的字符串、数字、数组方法</strong></h1><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a><strong>字符串方法</strong></h4><ul><li>**<code>includes()</code>**：判断字符串是否包含指定子串。</li><li>**<code>startsWith()</code>**：判断字符串是否以指定子串开头。</li><li>**<code>endsWith()</code>**：判断字符串是否以指定子串结尾。</li><li>**<code>repeat()</code>**：将字符串重复指定次数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// 输出 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ha&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 HaHaHa</span><br></code></pre></td></tr></table></figure><h4 id="数字方法"><a href="#数字方法" class="headerlink" title="数字方法"></a><strong>数字方法</strong></h4><ul><li>**<code>Number.isNaN()</code>**：判断值是否为 <code>NaN</code>。</li><li>**<code>Number.isFinite()</code>**：判断值是否为有限数。</li><li>**<code>Number.isInteger()</code>**：判断值是否为整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">4.5</span>)); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h4><ul><li>**<code>Array.from()</code>**：将类数组或可迭代对象转换为数组。</li><li>**<code>Array.of()</code>**：创建一个由参数组成的新数组。</li><li>**<code>find()</code> 和 <code>findIndex()</code>**：找到符合条件的第一个元素或其索引。</li><li>**<code>fill()</code>**：用指定值填充数组。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// 输出 [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 2</span><br><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 输出 [1, 0, 0, 4]</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-Proxy-对象"><a href="#17-Proxy-对象" class="headerlink" title="17. Proxy 对象"></a>17. <strong><code>Proxy</code> 对象</strong></h1><p><code>Proxy</code> 是 ECMAScript 6（ES6）引入的一个新特性，它允许你创建一个对象的代理（Proxy），通过该代理可以定义基本操作的自定义行为，比如属性查找、赋值、枚举、函数调用等。<code>Proxy</code> 提供了一种灵活的机制，用于拦截并修改对目标对象的操作。</p><h2 id="1-创建-Proxy"><a href="#1-创建-Proxy" class="headerlink" title="1. 创建 Proxy"></a>1. <strong>创建 Proxy</strong></h2><p><code>Proxy</code> 构造函数接收两个参数：</p><ul><li>**<code>target</code>**：要创建代理的目标对象，可以是任何对象（包括原始值）。</li><li>**<code>handler</code>**：一个对象，其中定义了代理的行为（即拦截操作）。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><h2 id="2-Handler-对象"><a href="#2-Handler-对象" class="headerlink" title="2. Handler 对象"></a>2. <strong>Handler 对象</strong></h2><p><code>handler</code> 对象包含多个陷阱（trap）方法，这些方法定义了代理如何处理不同的操作。每个陷阱方法对应一个基本操作，如读取属性、设置属性等。</p><p><strong>常见陷阱方法包括：</strong></p><ul><li>**<code>get</code>**：拦截对象属性的读取操作。</li><li>**<code>set</code>**：拦截对象属性的写入操作。</li><li>**<code>has</code>**：拦截 <code>in</code> 操作符。</li><li>**<code>deleteProperty</code>**：拦截 <code>delete</code> 操作符。</li><li>**<code>apply</code>**：拦截函数调用。</li><li>**<code>construct</code>**：拦截构造函数调用。</li><li>**<code>ownKeys</code>**：拦截 <code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.keys()</code>。</li><li>**<code>getPrototypeOf</code>**：拦截 <code>Object.getPrototypeOf()</code>。</li><li>**<code>setPrototypeOf</code>**：拦截 <code>Object.setPrototypeOf()</code>。</li></ul><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h2><p>以下是一些使用 <code>Proxy</code> 对象的示例，展示了如何通过代理对象来拦截和修改对目标对象的操作。</p><h3 id="3-1-属性读取和设置"><a href="#3-1-属性读取和设置" class="headerlink" title="3.1 属性读取和设置"></a>3.1 属性读取和设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>;  <span class="hljs-comment">// 控制台输出: Setting name to John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 控制台输出: Getting name, 输出: John</span><br></code></pre></td></tr></table></figure><ul><li><code>get</code> 陷阱拦截对属性的读取。</li><li><code>set</code> 陷阱拦截对属性的写入。</li></ul><h3 id="3-2-属性存在检查"><a href="#3-2-属性存在检查" class="headerlink" title="3.2 属性存在检查"></a>3.2 属性存在检查</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Checking existence of <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, property);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// 控制台输出: Checking existence of name, 输出: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> proxy);   <span class="hljs-comment">// 控制台输出: Checking existence of age, 输出: false</span><br></code></pre></td></tr></table></figure><ul><li><code>has</code> 陷阱拦截 <code>in</code> 操作符。</li></ul><h3 id="3-3-函数调用"><a href="#3-3-函数调用" class="headerlink" title="3.3 函数调用"></a>3.3 函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling function with arguments <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 控制台输出: Calling function with arguments 1,2, 输出: 3</span><br></code></pre></td></tr></table></figure><ul><li><code>apply</code> 陷阱拦截函数调用。</li></ul><h3 id="3-4-构造函数调用"><a href="#3-4-构造函数调用" class="headerlink" title="3.4 构造函数调用"></a>3.4 构造函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Constructing with arguments <span class="hljs-subst">$&#123;args&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 控制台输出: Constructing with arguments 1,2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);  <span class="hljs-comment">// 输出: target &#123; x: 1, y: 2 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>construct</code> 陷阱拦截构造函数调用。</li></ul><h2 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4. 常见用法"></a>4. <strong>常见用法</strong></h2><ul><li><strong>数据验证</strong>：可以使用 <code>Proxy</code> 对象来验证对目标对象的属性值进行检查，例如确保属性值在某个范围内。</li><li><strong>日志记录</strong>：可以在 <code>Proxy</code> 的陷阱方法中记录对目标对象的所有操作，用于调试和分析。</li><li><strong>防御性编程</strong>：可以通过 <code>Proxy</code> 保护目标对象，防止非法的属性操作。</li><li><strong>虚拟化</strong>：可以使用 <code>Proxy</code> 实现懒加载和其他性能优化技术，例如按需加载对象属性。</li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h2><ul><li><strong>性能</strong>：使用 <code>Proxy</code> 对象会引入额外的开销，因为每个操作都需要经过陷阱函数。对于性能敏感的应用，要慎重使用。</li><li><strong>无法代理的对象</strong>：一些对象（如内置对象、冻结的对象）不能被 <code>Proxy</code> 代理。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><p><code>Proxy</code> 对象是 ES6 引入的强大特性，允许你创建一个代理对象来拦截和自定义对目标对象的操作。通过使用 <code>Proxy</code>，可以实现许多高级功能，如数据验证、日志记录和虚拟化等。在实际应用中，合理使用 <code>Proxy</code> 可以大大提高代码的灵活性和可维护性。</p><hr><h1 id="18-Reflect-API"><a href="#18-Reflect-API" class="headerlink" title="18. Reflect API"></a>18. <strong><code>Reflect</code> API</strong></h1><p><code>Reflect</code> 是 ES6 引入的一个内置对象，它提供了一组方法，用于操作对象的原型和目标对象的内部状态。<code>Reflect</code> 对象主要用于与 <code>Proxy</code> 一起使用，它提供了一些与 <code>Proxy</code> 陷阱方法相对应的基本操作，这些方法可以用来在代理对象内部调用目标对象的原始操作。</p><h2 id="1-Reflect-的方法"><a href="#1-Reflect-的方法" class="headerlink" title="1.Reflect 的方法"></a>1.Reflect 的方法</h2><p><code>Reflect</code> 提供了一些与对象操作相关的静态方法，这些方法对应于对象操作的基本行为。主要的方法包括：</p><ul><li><p><strong><code>Reflect.apply(target, thisArg, argumentsList)</code></strong></p><ul><li><p>用于调用一个函数，类似于 <code>Function.prototype.apply</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：要调用的函数。</li><li><code>thisArg</code>：函数内部的 <code>this</code>。</li><li><code>argumentsList</code>：参数数组。</li></ul></li><li><p><strong>返回值</strong>：函数调用的结果。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(sum, <span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.construct(target, argumentsList, newTarget)</code></strong></p><ul><li><p>用于创建一个对象实例，类似于 <code>new</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：构造函数。</li><li><code>argumentsList</code>：构造函数的参数数组。</li><li><code>newTarget</code>：指定构造函数的原型链的对象。</li></ul></li><li><p><strong>返回值</strong>：构造函数创建的新对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: Alice</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.defineProperty(target, propertyKey, attributes)</code></strong></p><ul><li><p>用于定义目标对象的属性，类似于 <code>Object.defineProperty</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>attributes</code>：属性描述符。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功定义。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.deleteProperty(target, propertyKey)</code></strong></p><ul><li><p>用于删除目标对象的属性，类似于 <code>delete</code> 操作符。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：要删除的属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: undefined</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.get(target, propertyKey, receiver)</code></strong></p><ul><li><p>用于获取目标对象的属性值，类似于 <code>target[propertyKey]</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：属性的值。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.getPrototypeOf(target)</code></strong></p><ul><li><p>用于获取目标对象的原型，类似于 <code>Object.getPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：目标对象的原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prototype === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.has(target, propertyKey)</code></strong></p><ul><li><p>用于检查目标对象是否具有指定的属性，类似于 <code>propertyKey in target</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否存在。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.isExtensible(target)</code></strong></p><ul><li><p>用于检查目标对象是否可扩展（即是否可以添加新属性），类似于 <code>Object.isExtensible</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示目标对象是否可扩展。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj));  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.ownKeys(target)</code></strong></p><ul><li><p>用于获取目标对象的所有属性名（包括符号属性），类似于 <code>Object.getOwnPropertyNames</code> 和 <code>Object.getOwnPropertySymbols</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li></ul></li><li><p><strong>返回值</strong>：属性名数组。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// 输出: [&#x27;name&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.set(target, propertyKey, value, receiver)</code></strong></p><ul><li><p>用于设置目标对象的属性值，类似于 <code>target[propertyKey] = value</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>propertyKey</code>：属性名。</li><li><code>value</code>：属性值。</li><li><code>receiver</code>：当 <code>Proxy</code> 代理被使用时，<code>receiver</code> 是代理对象。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示属性是否成功设置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出: John</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Reflect.setPrototypeOf(target, prototype)</code></strong></p><ul><li><p>用于设置目标对象的原型，类似于 <code>Object.setPrototypeOf</code>。</p></li><li><p>参数：</p><ul><li><code>target</code>：目标对象。</li><li><code>prototype</code>：新的原型。</li></ul></li><li><p><strong>返回值</strong>：布尔值，指示是否成功设置原型。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> newProto = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, newProto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === newProto);  <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><ul><li><strong><code>Reflect</code></strong> 对象提供了一组静态方法，用于操作对象的基本行为。</li><li><strong><code>Reflect</code></strong> 方法主要用于与 <code>Proxy</code> 一起使用，以便在代理对象中执行目标对象的操作。</li><li><strong><code>Reflect</code></strong> 提供的方法与目标对象操作的方法一一对应，简化了对象操作的实现逻辑，使得代码更加一致和可维护。</li></ul><p><code>Reflect</code> 对象是一个强大的工具，用于更细粒度地控制对象的行为，并且是 ES6 提供的一个重要功能。</p><hr><h1 id="19-尾调用优化（Tail-Call-Optimization）"><a href="#19-尾调用优化（Tail-Call-Optimization）" class="headerlink" title="19. 尾调用优化（Tail Call Optimization）"></a>19. <strong>尾调用优化（Tail Call Optimization）</strong></h1><p>尾调用优化（TCO）是一种编程语言优化技术，旨在提高递归函数的效率，防止函数调用栈的增长，避免因递归深度过大而导致的栈溢出。尾调用优化的核心思想是将尾递归（即递归调用是函数的最后一步操作）转换为更高效的迭代形式，从而减少内存使用。</p><h2 id="1-尾调用（Tail-Call）"><a href="#1-尾调用（Tail-Call）" class="headerlink" title="1. 尾调用（Tail Call）"></a>1. <strong>尾调用（Tail Call）</strong></h2><p>尾调用是指在函数的最后一步调用另一个函数，而没有任何额外的计算。换句话说，尾调用是函数调用的最后操作，没有任何额外的工作要做。这种调用模式适合进行尾调用优化。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>factorial</code> 函数中的递归调用 <code>factorial(n - 1, n * result)</code> 是尾调用，因为它是函数 <code>factorial</code> 的最后一步操作。</p><h2 id="2-尾调用优化的原理"><a href="#2-尾调用优化的原理" class="headerlink" title="2. 尾调用优化的原理"></a>2. <strong>尾调用优化的原理</strong></h2><p>在尾调用优化中，当一个函数执行尾调用时，编译器或解释器会将当前函数的栈帧复用到被调用函数的栈帧中。这样，递归调用不会增加新的栈帧，从而避免了栈空间的消耗。</p><p><strong>过程：</strong></p><ol><li><strong>当前函数执行到尾调用位置</strong>。</li><li><strong>丢弃当前函数的栈帧</strong>，因为在尾调用时当前函数的执行已经完成。</li><li><strong>重用当前函数的栈帧</strong>，将控制权转移到被调用函数。</li></ol><p>通过这种方式，尾调用优化将递归调用转化为迭代，从而避免了递归深度带来的性能问题。</p><h2 id="3-支持尾调用优化的语言"><a href="#3-支持尾调用优化的语言" class="headerlink" title="3. 支持尾调用优化的语言"></a>3. <strong>支持尾调用优化的语言</strong></h2><p>一些编程语言支持尾调用优化，包括：</p><ul><li><strong>Scheme</strong>：作为 Lisp 家族的一员，Scheme 是一种支持尾调用优化的函数式编程语言。</li><li><strong>Racket</strong>：Racket 也是一种支持尾调用优化的语言，具有类似于 Scheme 的特性。</li><li><strong>Haskell</strong>：Haskell 是一种纯函数式编程语言，支持尾调用优化。</li></ul><h2 id="4-JavaScript-中的尾调用优化"><a href="#4-JavaScript-中的尾调用优化" class="headerlink" title="4. JavaScript 中的尾调用优化"></a>4. <strong>JavaScript 中的尾调用优化</strong></h2><p>虽然 JavaScript 语言规范（ECMAScript 2015）引入了尾调用优化的提案，但实际支持这一特性的浏览器和 JavaScript 引擎的实现仍然不统一。部分浏览器的 JavaScript 引擎可能并不完全支持尾调用优化，因此，在实际开发中不一定能保证尾调用优化的效果。</p><p><strong>ECMAScript 2015（ES6）提案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, result = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * result);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 规范中定义了尾调用优化的行为，但实际支持情况取决于 JavaScript 引擎的实现。</p><h2 id="5-非支持尾调用优化的情况下的解决方案"><a href="#5-非支持尾调用优化的情况下的解决方案" class="headerlink" title="5. 非支持尾调用优化的情况下的解决方案"></a>5. <strong>非支持尾调用优化的情况下的解决方案</strong></h2><p>如果运行环境不支持尾调用优化，递归深度过大可能会导致栈溢出。在这种情况下，可以使用迭代代替递归，以避免深度递归带来的问题。</p><p><strong>迭代替代尾递归示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    result *= n;<br>    n--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例使用了迭代来计算阶乘，而不是递归，从而避免了栈溢出的问题。</p><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul><li><strong>尾调用</strong> 是指在函数的最后一步调用另一个函数。</li><li><strong>尾调用优化（TCO）</strong> 通过重用栈帧来减少递归深度，避免栈溢出。</li><li>一些编程语言（如 Scheme、Haskell）支持尾调用优化，但 JavaScript 的支持情况不一致。</li><li>当尾调用优化不可用时，可以使用迭代代替递归来避免栈溢出。</li></ul><p>尾调用优化是函数式编程中的一个重要概念，通过优化递归调用，可以使代码更加高效、健壮。在实际开发中，要根据运行环境的特性来决定是否依赖于尾调用优化。</p><hr><h1 id="20-模块加载器（Module-Loader）"><a href="#20-模块加载器（Module-Loader）" class="headerlink" title="20. 模块加载器（Module Loader）"></a>20. <strong>模块加载器（Module Loader）</strong></h1><p>在 ECMAScript 2015（ES6）中，引入了原生的模块系统，这一系统为 JavaScript 提供了标准化的模块化支持，称为 ES6 模块（ESM）。ES6 模块系统具有内建的模块加载器，允许开发者通过 <code>import</code> 和 <code>export</code> 语法来进行模块化编程。</p><h2 id="1-ES6-模块的基本概念"><a href="#1-ES6-模块的基本概念" class="headerlink" title="1. ES6 模块的基本概念"></a>1. <strong>ES6 模块的基本概念</strong></h2><p>在 ES6 中，模块是 JavaScript 代码的基本组织单元。每个模块都有自己的作用域，模块之间的依赖关系通过显式的 <code>import</code> 和 <code>export</code> 语法来定义和管理。</p><p><strong>模块的基本特点</strong>：</p><ul><li><strong>静态加载</strong>：模块在编译时加载，这使得依赖关系可以在编译阶段进行静态分析和优化。</li><li><strong>严格模式</strong>：模块默认在严格模式下运行，这有助于避免一些常见的 JavaScript 错误。</li><li><strong>导入和导出</strong>：模块可以通过 <code>export</code> 导出变量、函数或类，并通过 <code>import</code> 导入其他模块的导出。</li></ul><h2 id="2-模块导出（Export）"><a href="#2-模块导出（Export）" class="headerlink" title="2. 模块导出（Export）"></a>2. <strong>模块导出（Export）</strong></h2><p>ES6 模块通过 <code>export</code> 语法导出模块的功能。导出的内容可以是变量、函数、类或对象。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateArea</span>(<span class="hljs-params">radius</span>) &#123; <span class="hljs-comment">// 导出函数</span><br>  <span class="hljs-keyword">return</span> pi * radius * radius;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123; <span class="hljs-comment">// 导出类</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">radius</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;<br>  &#125;<br>  <span class="hljs-title function_">getArea</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> pi * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-模块导入（Import）"><a href="#3-模块导入（Import）" class="headerlink" title="3. 模块导入（Import）"></a>3. <strong>模块导入（Import）</strong></h2><p>ES6 模块通过 <code>import</code> 语法导入其他模块的内容。可以导入整个模块的功能，也可以导入模块的部分功能。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; pi, calculateArea, <span class="hljs-title class_">Circle</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pi); <span class="hljs-comment">// 输出: 3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateArea</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 78.5</span><br><br><span class="hljs-keyword">const</span> myCircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCircle.<span class="hljs-title function_">getArea</span>()); <span class="hljs-comment">// 输出: 78.5</span><br></code></pre></td></tr></table></figure><h2 id="4-默认导出（Default-Export）"><a href="#4-默认导出（Default-Export）" class="headerlink" title="4. 默认导出（Default Export）"></a>4. <strong>默认导出（Default Export）</strong></h2><p>ES6 模块允许每个模块有一个默认导出，这对于导出单一的功能或对象非常有用。默认导出可以是变量、函数或类。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>; <span class="hljs-comment">// 导入默认导出</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;World&#x27;</span>)); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><h2 id="5-动态导入（Dynamic-Import）"><a href="#5-动态导入（Dynamic-Import）" class="headerlink" title="5. 动态导入（Dynamic Import）"></a>5. <strong>动态导入（Dynamic Import）</strong></h2><p>ES6 模块也支持动态导入，即在运行时加载模块。这是通过 <code>import()</code> 函数实现的，返回一个 Promise 对象，可以在异步操作中使用。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">pi</span>);<br>&#125;<br><br><span class="hljs-title function_">loadModule</span>();<br></code></pre></td></tr></table></figure><h2 id="6-模块加载器的工作原理"><a href="#6-模块加载器的工作原理" class="headerlink" title="6. 模块加载器的工作原理"></a>6. <strong>模块加载器的工作原理</strong></h2><p>ES6 模块加载器的工作原理包括以下几个步骤：</p><ol><li><strong>解析模块</strong>：当模块被加载时，加载器会解析模块的 <code>import</code> 和 <code>export</code> 语法，确定模块之间的依赖关系。</li><li><strong>加载模块</strong>：根据解析结果，加载器会从指定的路径或 URL 加载模块的代码。</li><li><strong>执行模块</strong>：加载器会执行模块的代码，并处理模块的 <code>export</code> 和 <code>import</code> 语句。</li><li><strong>缓存模块</strong>：已加载的模块会被缓存，以便后续的 <code>import</code> 语句可以复用缓存的模块，避免重复加载。</li><li><strong>导出模块</strong>：模块的功能会通过 <code>export</code> 语法对外提供，其他模块可以通过 <code>import</code> 语法引用这些功能。</li></ol><h2 id="7-模块加载器的特点"><a href="#7-模块加载器的特点" class="headerlink" title="7. 模块加载器的特点"></a>7. <strong>模块加载器的特点</strong></h2><ul><li><strong>静态分析</strong>：ES6 模块的静态结构使得模块系统能够在编译时进行依赖分析和优化。</li><li><strong>作用域隔离</strong>：每个模块都有自己的作用域，避免了全局命名冲突。</li><li><strong>延迟加载</strong>：使用动态导入可以按需加载模块，提高应用程序的性能。</li><li><strong>编译时错误检测</strong>：静态分析可以在编译阶段检测导入和导出语法错误，提升代码质量。</li></ul><h2 id="8-与其他模块系统的比较"><a href="#8-与其他模块系统的比较" class="headerlink" title="8. 与其他模块系统的比较"></a>8. <strong>与其他模块系统的比较</strong></h2><p>与 CommonJS、AMD 和 UMD 等其他模块系统相比，ES6 模块具有以下优势：</p><ul><li><strong>原生支持</strong>：ES6 模块是 JavaScript 的标准部分，所有现代 JavaScript 引擎都支持。</li><li><strong>静态分析</strong>：ES6 模块的静态结构使得编译器和工具能够进行优化。</li><li><strong>模块作用域</strong>：ES6 模块的作用域隔离提供了更好的代码组织和模块管理。</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. <strong>总结</strong></h2><p>ES6 模块系统通过 <code>import</code> 和 <code>export</code> 语法提供了一个标准化的模块化机制，支持静态加载和动态导入。它的引入使得 JavaScript 的模块化编程更加高效和一致，为开发大型应用程序提供了强大的工具。了解 ES6 模块系统的工作原理和使用方法，有助于更好地组织和管理代码，提高代码的可维护性和重用性。</p><hr><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>ES6 的引入使 JavaScript 语言更加完善，提供了更强大的功能和更简洁的语法，极大地提高了开发效率。这些新特性涵盖了变量声明、函数定义、对象和数组操作、类和继承、模块化、异步编程等各个方面。熟练掌握ES6的新特性，将有助于编写出更加高效、可读性更强的代码。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventEmitter</title>
    <link href="/posts/36600/"/>
    <url>/posts/36600/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">2</span> 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br><span class="hljs-number">1</span> 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-property">js</span>:<span class="hljs-number">201</span> <br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// process.nextTick error, or &#x27;error&#x27; event on first tick </span><br>^ <br><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Uncaught</span>, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">emit</span> (events.<span class="hljs-property">js</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span>) <br>at <span class="hljs-title class_">Object</span>.&lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>byvoid/error.<span class="hljs-property">js</span>:<span class="hljs-number">5</span>:<span class="hljs-number">9</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">_compile</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">441</span>:<span class="hljs-number">26</span>) <br>at <span class="hljs-title class_">Object</span>..<span class="hljs-property">js</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">459</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">348</span>:<span class="hljs-number">31</span>) <br>at <span class="hljs-title class_">Function</span>.<span class="hljs-property">_load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">308</span>:<span class="hljs-number">12</span>) <br>at <span class="hljs-title class_">Array</span><span class="hljs-number">.0</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">479</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">_tickCallback</span> (node.<span class="hljs-property">js</span>:<span class="hljs-number">192</span>:<span class="hljs-number">40</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Node.js的线程机制</title>
    <link href="/posts/22142/"/>
    <url>/posts/22142/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Node-js的线程机制、事件循环与高并发处理"><a href="#深入理解Node-js的线程机制、事件循环与高并发处理" class="headerlink" title="深入理解Node.js的线程机制、事件循环与高并发处理"></a>深入理解Node.js的线程机制、事件循环与高并发处理</h1><p>Node.js因其强大的高并发处理能力而备受青睐。这一能力得益于其事件驱动的非阻塞I&#x2F;O模型和高效的事件循环机制。在这篇博客中，我们将深入探讨Node.js的线程机制、事件循环的工作流程与优先级，以及如何避免阻塞主线程的最佳实践。通过这些内容，你将更好地理解Node.js的内部运行机制，并学会如何编写高效的Node.js应用程序。</p><hr><h2 id="1-Node-js-的线程机制"><a href="#1-Node-js-的线程机制" class="headerlink" title="1. Node.js 的线程机制"></a>1. Node.js 的线程机制</h2><p>Node.js 是单线程的，但它通过多线程的方式处理高并发。JavaScript代码运行在主线程中，而Node.js使用的<a href="https://libuv.org/">libuv</a>库则提供了一个基于事件循环的异步I&#x2F;O模型，使得主线程不会因为I&#x2F;O操作而被阻塞。</p><h3 id="主线程与-libuv-线程池"><a href="#主线程与-libuv-线程池" class="headerlink" title="主线程与 libuv 线程池"></a><strong>主线程与 <a href="https://libuv.org/">libuv</a> 线程池</strong></h3><ul><li><strong>主线程</strong>：Node.js中的JavaScript代码在一个单独的主线程中运行，该线程处理所有的同步代码。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：用于处理阻塞性任务，如文件I&#x2F;O、DNS查询等，工作线程池通常包含4个线程，可以根据需要配置更多。</li></ul><p>Node.js通过将耗时的I&#x2F;O操作交给<a href="https://libuv.org/">libuv</a>线程池中的工作线程来处理，从而避免主线程被阻塞。这种设计使得Node.js可以在单线程的主线程中处理大量并发请求，而不会因为阻塞I&#x2F;O操作而降低性能。</p><h3 id="重点知识："><a href="#重点知识：" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>主线程</strong>：负责执行所有同步任务。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：处理阻塞I&#x2F;O任务，防止主线程阻塞。</li></ul><hr><h2 id="2-Node-js-的高并发原理"><a href="#2-Node-js-的高并发原理" class="headerlink" title="2. Node.js 的高并发原理"></a>2. Node.js 的高并发原理</h2><p>Node.js的高并发处理能力主要源于其事件驱动的非阻塞I&#x2F;O模型。通过事件循环，Node.js可以在单线程环境中处理大量的并发请求。</p><h3 id="事件驱动的非阻塞I-O模型"><a href="#事件驱动的非阻塞I-O模型" class="headerlink" title="事件驱动的非阻塞I&#x2F;O模型"></a><strong>事件驱动的非阻塞I&#x2F;O模型</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：Node.js 的I&#x2F;O操作不会阻塞主线程，而是将I&#x2F;O操作委托给<a href="https://libuv.org/">libuv</a>线程池处理，主线程在I&#x2F;O操作完成之前可以继续执行其他任务。</li><li><strong>异步任务队列</strong>：异步操作的回调函数会被放入任务队列中，等待主线程空闲时由事件循环调度执行。</li></ul><p>通过这种非阻塞设计，Node.js能够高效地处理并发请求。</p><h5 id="代码示例：异步I-O操作"><a href="#代码示例：异步I-O操作" class="headerlink" title="代码示例：异步I&#x2F;O操作"></a><strong>代码示例：异步I&#x2F;O操作</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File content:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This log comes first!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>fs.readFile</code> 是一个异步操作，它会将回调函数放入任务队列中，而不会阻塞主线程。因此，<code>console.log(&#39;This log comes first!&#39;)</code> 会先于文件内容的输出执行。</p><h3 id="重点知识：-1"><a href="#重点知识：-1" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：避免主线程因I&#x2F;O操作而阻塞。</li><li><strong>异步任务队列</strong>：存储需要执行的异步操作回调。</li></ul><hr><h2 id="3-事件循环的工作机制与优先级"><a href="#3-事件循环的工作机制与优先级" class="headerlink" title="3. 事件循环的工作机制与优先级"></a>3. 事件循环的工作机制与优先级</h2><p>事件循环是Node.js运行的核心机制，它决定了程序中代码的执行顺序。我们将详细剖析事件循环的工作流程及其优先级，帮助你更好地理解Node.js的并发处理。</p><h3 id="事件循环的工作流程"><a href="#事件循环的工作流程" class="headerlink" title="事件循环的工作流程"></a><strong>事件循环的工作流程</strong></h3><ol><li><strong>执行同步代码</strong>：事件循环首先执行主线程中的同步代码，这些代码会被立即执行。</li><li><strong>进入事件循环</strong>：当同步代码执行完毕后，事件循环开始检查任务队列中是否有待处理的异步回调。</li><li><strong>处理异步回调</strong>：事件循环依次从任务队列中取出回调函数并执行。</li><li><strong>循环往复</strong>：事件循环不断检查并处理任务队列中的任务，直到队列为空。</li></ol><h3 id="事件循环的优先级"><a href="#事件循环的优先级" class="headerlink" title="事件循环的优先级"></a><strong>事件循环的优先级</strong></h3><p>事件循环在执行任务时遵循一定的优先级。常见的优先级顺序如下：</p><ul><li><strong>Microtasks（微任务）</strong>：包括 <code>process.nextTick</code> 和 <code>Promise</code> 的回调。这些任务优先级最高，通常会在当前操作结束后立即执行。</li><li><strong>Timers（计时器）</strong>：如 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>I&#x2F;O callbacks</strong>：处理来自I&#x2F;O操作的回调。</li><li><strong>Check</strong>：执行 <code>setImmediate</code> 的回调函数。</li><li><strong>Close callbacks</strong>：处理 <code>close</code> 事件的回调。</li></ul><h5 id="代码示例：事件循环的优先级"><a href="#代码示例：事件循环的优先级" class="headerlink" title="代码示例：事件循环的优先级"></a><strong>代码示例：事件循环的优先级</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Sync</span> code<br>nextTick<br><span class="hljs-title class_">Promise</span><br><span class="hljs-built_in">setTimeout</span><br>setImmediate<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;Sync code&#39;)</code> 立即执行，<code>process.nextTick</code> 和 <code>Promise</code> 回调作为微任务执行，其次是 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调。</p><h3 id="重点知识：-2"><a href="#重点知识：-2" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>事件循环阶段</strong>：不同类型的任务在事件循环中具有不同的优先级。</li><li><strong>Microtasks</strong>：优先级最高的任务，通常在当前事件循环阶段结束后立即执行。</li></ul><hr><h2 id="4-为什么先执行同步代码，再执行事件循环？"><a href="#4-为什么先执行同步代码，再执行事件循环？" class="headerlink" title="4. 为什么先执行同步代码，再执行事件循环？"></a>4. 为什么先执行同步代码，再执行事件循环？</h2><p>Node.js在执行代码时，首先会运行同步代码，这是因为同步代码通常包含程序的初始化、配置、变量定义等重要操作。如果不先执行同步代码，异步回调可能会在未准备好的上下文中被触发，导致程序行为不可预测。</p><h3 id="同步代码的定义"><a href="#同步代码的定义" class="headerlink" title="同步代码的定义"></a><strong>同步代码的定义</strong></h3><p>同步代码是指立即执行并返回结果的代码，不依赖于异步事件的完成。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is synchronous code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>同步代码执行完后，事件循环才会开始处理异步任务。</p><h5 id="代码示例：同步代码与异步代码"><a href="#代码示例：同步代码与异步代码" class="headerlink" title="代码示例：同步代码与异步代码"></a><strong>代码示例：同步代码与异步代码</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is asynchronous&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在此例中，<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 是同步代码，它们会立即执行，而 <code>setTimeout</code> 的回调则是异步代码，会在同步代码执行完毕后，由事件循环调度执行。</p><h3 id="避免将复杂任务放入主线程"><a href="#避免将复杂任务放入主线程" class="headerlink" title="避免将复杂任务放入主线程"></a><strong>避免将复杂任务放入主线程</strong></h3><p>在主线程中放入复杂的同步任务，会阻塞主线程，导致事件循环无法及时处理异步任务。为了解决这个问题，我们可以使用以下几种方法：</p><ol><li><strong>将任务拆分</strong>：将复杂的同步任务拆分为多个小任务，分批执行。</li><li>**使用 <code>setImmediate</code>**：将长时间执行的任务放入下一个事件循环阶段执行。</li><li>**使用 <code>Worker Threads</code>**：将复杂计算任务放入工作线程中执行，避免阻塞主线程。</li></ol><h5 id="代码示例：使用-setImmediate-避免阻塞"><a href="#代码示例：使用-setImmediate-避免阻塞" class="headerlink" title="代码示例：使用 setImmediate 避免阻塞"></a><strong>代码示例：使用 <code>setImmediate</code> 避免阻塞</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">complexTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task Done:&#x27;</span>, count);<br>&#125;<br><br><span class="hljs-title function_">setImmediate</span>(complexTask);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will log before complexTask finishes&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>complexTask</code> 是一个可能会阻塞主线程的复杂任务。通过使用 <code>setImmediate</code>，我们可以将其延迟到当前事件循环阶段结束后再执行，从而避免阻塞其他重要的任务。</p><h5 id="使用-Worker-Threads-进行并行计算"><a href="#使用-Worker-Threads-进行并行计算" class="headerlink" title="使用 Worker Threads 进行并行计算"></a><strong>使用 <code>Worker Threads</code> 进行并行计算</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from worker:&#x27;</span>, message));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  parentPort.<span class="hljs-title function_">postMessage</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，复杂的计算任务被移至工作线程中执行，不再阻塞主线程。这使得主线程可以继续处理其他任务，而不会受到复杂计算的影响。</p><h3 id="重点知识：-3"><a href="#重点知识：-3" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>避免主线程阻塞</strong>：将复杂任务分拆或延迟执行，避免阻塞事件循环。</li><li><strong>Worker Threads</strong>：用于处理计算密集型任务，减少主线程压力。</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对Node.js线程机制、事件循环与高并发处理的深入探讨，我们了解到如何编写高效的Node.js应用程序。理解事件循环的工作原理和优先级，可以帮助我们更好地管理异步任务的执行顺序，避免主线程被阻塞。同时，采用合理的技术，如 <code>Worker Threads</code> 和 <code>setImmediate</code>，能够有效地提升程序性能，确保高并发环境下的稳定性。</p><hr><p>这篇博客详细解释了Node.js的线程机制及事件循环，并提供了避免主线程阻塞的实际解决方案。希望这些内容对你理解和优化Node.js应用程序有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的回收机制</title>
    <link href="/posts/580/"/>
    <url>/posts/580/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-的垃圾回收机制"><a href="#一、JavaScript-的垃圾回收机制" class="headerlink" title="一、JavaScript 的垃圾回收机制"></a>一、JavaScript 的垃圾回收机制</h1><p>JavaScript 的垃圾回收机制主要依赖于一种称为 <strong>“标记-清除”（Mark-and-Sweep）</strong> 的算法。垃圾回收（Garbage Collection, GC）负责自动管理内存，回收不再使用的对象所占用的内存，以防止内存泄漏。</p><h3 id="垃圾回收的工作原理"><a href="#垃圾回收的工作原理" class="headerlink" title="垃圾回收的工作原理"></a>垃圾回收的工作原理</h3><ol><li><strong>标记阶段（Marking Phase）</strong>:<ul><li>垃圾回收器会在内存中“标记”所有活动的、可到达的对象。所谓“可到达”是指对象可以通过根（通常是全局变量或当前作用域中的变量）直接或间接访问到。</li><li>垃圾回收器从根开始，递归地遍历所有引用的对象，并标记这些对象为“活动的”。</li></ul></li><li><strong>清除阶段（Sweeping Phase）</strong>:<ul><li>在标记阶段结束后，垃圾回收器会遍历内存中的所有对象，清除没有被标记的对象（即那些不可到达的对象）。</li><li>清除后，这些对象所占用的内存将被回收并重新分配。</li></ul></li></ol><h3 id="触发垃圾回收的条件"><a href="#触发垃圾回收的条件" class="headerlink" title="触发垃圾回收的条件"></a>触发垃圾回收的条件</h3><ul><li>JavaScript 引擎的垃圾回收器在运行时会周期性地执行垃圾回收，以回收不再使用的内存。</li><li>垃圾回收器的执行是非确定性的，这意味着你不能确切知道何时会触发垃圾回收。通常是在内存分配请求达到一定阈值或空闲时执行。</li></ul><h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><ol><li><p><strong>内存泄漏</strong>: 当程序中不再需要的对象无法被垃圾回收器清除时，内存泄漏就会发生，导致内存使用量持续增长。</p><ul><li><p><strong>未解除的事件监听器</strong>: 如果在不再需要时没有手动移除事件监听器，监听器中对对象的引用将导致这些对象无法被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachEventListener</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element clicked!&#x27;</span>);<br>    &#125;<br><br>    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br><br>    <span class="hljs-comment">// 模拟在元素销毁时忘记移除监听器</span><br>    <span class="hljs-comment">// element.removeEventListener(&#x27;click&#x27;, handleClick);</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数后，element和handleClick函数依然存在引用，导致element不能被回收。</span><br><span class="hljs-title function_">attachEventListener</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p><strong>事件监听器的引用</strong>：</p><ul><li>当你调用 <code>element.addEventListener(&#39;click&#39;, handleClick)</code> 时，浏览器内部实际上在 <code>element</code> 对象的某个地方（通常是在它的事件监听器列表中）保存了对 <code>handleClick</code> 函数的引用。这意味着 <code>element</code> 本身还存活在内存中，因为它的事件监听器依然在引用它。</li></ul><p><strong>引用链的存在</strong>：</p><ul><li>尽管 <code>element</code> 是一个局部变量，函数 <code>attachEventListener</code> 执行完后不会直接持有对它的引用，但是因为事件监听器 (<code>handleClick</code>) 被添加到了 <code>element</code> 上，<code>element</code> 对象内部保存了对 <code>handleClick</code> 的引用。</li><li>反过来，因为 <code>handleClick</code> 函数是在 <code>attachEventListener</code> 内部定义的，它对定义该函数的外部作用域有引用链，因此，这种引用链会一直存在，直到 <code>element</code> 被手动移除事件监听器或者 <code>element</code> 本身被彻底销毁。</li></ul><p><strong>内存泄漏的来源</strong>：</p><ul><li>如果 <code>element</code> 被从 DOM 中移除（比如被 <code>document.removeChild</code>），但没有调用 <code>element.removeEventListener(&#39;click&#39;, handleClick)</code>，<code>element</code> 仍然不能被垃圾回收，因为它的事件监听器中仍然持有对 <code>handleClick</code> 的引用。</li><li>因为 <code>handleClick</code> 还在 <code>element</code> 的事件监听列表中，JavaScript 引擎会认为 <code>element</code> 还可能被使用，因此不会回收 <code>element</code> 或其关联的内存。</li></ul><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​在不再需要时调用 <code>removeEventListener</code> 来移除事件监听器。</p></li><li><p><strong>闭包导致的引用</strong>: 闭包中保存的变量会保持对外部作用域中对象的引用，可能导致无法回收这些对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 返回的 innerFunction 持有对 largeObject 的引用，即使 largeObject 在函数作用域外部已经不需要。</span><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// closure 的引用存在，导致 largeObject 无法被垃圾回收。</span><br><span class="hljs-title function_">closure</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h6><p>在 JavaScript 中，闭包中的引用指向其创建时的环境（即作用域链上的上级）。具体来说：</p><ul><li>当 <code>createClosure</code> 函数执行时，它创建了一个作用域，该作用域中包含 <code>largeObject</code>。</li><li><code>innerFunction</code> 被返回，并且它在其创建时保留了对 <code>largeObject</code> 的引用。</li><li><code>largeObject</code> 的引用存在于 <code>innerFunction</code> 的闭包环境中。</li></ul><p>因此，<code>innerFunction</code> 的作用域链包括 <code>largeObject</code> 所在的作用域。即使 <code>createClosure</code> 执行完毕并退出，<code>innerFunction</code> 仍然能访问 <code>largeObject</code>。</p><p><span style="color: red;"><em><strong>总的来说，如果closure没被销毁那么闭包中的数据会一直存在，所以尽量避免闭包被全局变量所持有，且尽量避免闭包引用大的数据结构，这样会比较消耗内存</strong></em></span></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​要释放 <code>largeObject</code> 的引用，可以在不再需要 <code>innerFunction</code> 时清除对 <code>largeObject</code> 的引用。在这种情况下，确保在 <code>innerFunction</code> 不再使用 <code>largeObject</code> 后，手动清理引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在此处进行逻辑处理</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// 使用完闭包后，手动设置 largeObject 为 null</span><br><span class="hljs-comment">// 这是实际清理引用的地方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 可以设置 closure 为 null 或 undefined</span><br>    closure = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用 releaseClosure 释放对 largeObject 的引用</span><br><span class="hljs-title function_">releaseClosure</span>();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>: 全局变量在整个程序生命周期中都存在，会阻止其被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVariable = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;I&#x27;m a global variable&quot;</span> &#125;;<br><br><span class="hljs-comment">// 全局变量在程序结束前一直存在，无法回收。</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>未清理的定时器</strong>: 忘记清除不再需要的 <code>setInterval</code> 或 <code>setTimeout</code>，可能导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 设置一个定时器，每秒执行一次</span><br>    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 模拟元素销毁时忘记清除定时器</span><br>    <span class="hljs-comment">// clearInterval(intervalId);</span><br>&#125;<br><br><span class="hljs-comment">// 调用后，即使 element 被移除，intervalId 依然存在，导致内存泄漏。</span><br><span class="hljs-title function_">startTimer</span>();<br><br></code></pre></td></tr></table></figure><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><p>​ 在不再需要定时器时调用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存管理不善</strong>: 虽然 JavaScript 有自动垃圾回收，但开发者仍需注意合理使用内存。例如，避免创建大量不必要的对象或保留不必要的引用。</p></li></ol><h3 id="现代-JavaScript-引擎的优化"><a href="#现代-JavaScript-引擎的优化" class="headerlink" title="现代 JavaScript 引擎的优化"></a>现代 JavaScript 引擎的优化</h3><p>除了基本的标记-清除算法，现代 JavaScript 引擎（如 V8）通常还使用一些优化技术，如：</p><ul><li><strong>增量标记（Incremental Marking）</strong>: 将标记阶段拆分为多个小步骤，避免长时间的卡顿。</li><li><strong>世代回收（Generational Garbage Collection）</strong>: 将内存划分为“新生代”和“老生代”两个区域，短命对象会快速回收，长命对象则被移至老生代以减少处理频率。</li><li><strong>惰性清理（Lazy Cleanup）</strong>: 仅在需要时才清理内存，以进一步减少不必要的垃圾回收操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据hexo创建个人博客</title>
    <link href="/posts/62544/"/>
    <url>/posts/62544/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h2><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p><h2 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h2><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p><h1 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="/posts/62544/1.png"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="/posts/62544/2.png"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="/posts/62544/3.png"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/posts/62544/4.png"></p><p>浏览器中访问，展示成功。</p><p><img src="/posts/62544/5.png"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="/posts/62544/6.png"></p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。个人比较喜欢<code>Fluid</code>。</p><h2 id="1-Fluid主题"><a href="#1-Fluid主题" class="headerlink" title="1.Fluid主题"></a>1.Fluid主题</h2><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 <strong>安装主题</strong></h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h3 id="1-2-指定主题"><a href="#1-2-指定主题" class="headerlink" title="1.2 指定主题"></a>1.2 <strong>指定主题</strong></h3><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="1-3-创建「关于页」"><a href="#1-3-创建「关于页」" class="headerlink" title="1.3 创建「关于页」"></a>1.3 <strong>创建「关于页」</strong></h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br><br></code></pre></td></tr></table></figure><h3 id="1-4-本地启动"><a href="#1-4-本地启动" class="headerlink" title="1.4 本地启动**"></a>1.4 本地启动**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下">http://localhost:4000，`Fluid`主题风格页面如下</a></p><p><img src="/posts/62544/7.png"></p><h1 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h1><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><h2 id="1-添加hexo-asset-image插件"><a href="#1-添加hexo-asset-image插件" class="headerlink" title="1.添加hexo-asset-image插件"></a>1.添加hexo-asset-image插件</h2><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p>hexo-asset-image插件的作用就是为图片资源默认追加上时间路径前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这里不要用</p><p><img src="/posts/62544/8.png"></p><h2 id="2-修改-Hexo-博客目录中的-config-yml"><a href="#2-修改-Hexo-博客目录中的-config-yml" class="headerlink" title="2.修改 Hexo 博客目录中的 _config.yml"></a>2.修改 Hexo 博客目录中的 <code>_config.yml</code></h2><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="/posts/62544/9.png"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="/posts/62544/10.png"></p><p>在测试文章.md中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在\source\images目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:<br><span class="hljs-bullet">-</span> 原创<br>categories:<br><span class="hljs-section">- Java</span><br><span class="hljs-section">---</span><br><br>这是一篇测试文章<br><br>![<span class="hljs-string">图片引用方一</span>](<span class="hljs-link">测试文章/test.png</span>)<br><br>![<span class="hljs-string">图片引用方法二</span>](<span class="hljs-link">test.png</span>)<br><br>![<span class="hljs-string">图片引用方法三</span>](<span class="hljs-link">/images/test.png</span>)<br><br></code></pre></td></tr></table></figure><h2 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.<strong>本地启动</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面如下，文章添加成功">http://localhost:4000，页面如下，文章添加成功</a></p><p><img src="/posts/62544/11.png"></p><h1 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h1><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h2 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h2><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="/posts/62544/12.png"></p><h2 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2.博客标题"></a>2.博客标题</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="/posts/62544/13.png"></p><h2 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="/posts/62544/14.png"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="/posts/62544/15.png"></p><h1 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h1><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h2 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h2><h3 id="进入-官网-注册账号"><a href="#进入-官网-注册账号" class="headerlink" title="进入 官网 注册账号"></a>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</h3><p><img src="/posts/62544/16.png"></p><h3 id="需实名认证，完成后才能使用各项服务"><a href="#需实名认证，完成后才能使用各项服务" class="headerlink" title="需实名认证，完成后才能使用各项服务"></a>需实名认证，完成后才能使用各项服务</h3><p><img src="/posts/62544/17.png"></p><p>验证邮箱</p><p><img src="/posts/62544/18.png"></p><h3 id="创建应用，选择开发版即可，免费的"><a href="#创建应用，选择开发版即可，免费的" class="headerlink" title="创建应用，选择开发版即可，免费的"></a>创建应用，选择<code>开发版</code>即可，免费的</h3><p><img src="/posts/62544/19.png"></p><h3 id="进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用"><a href="#进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用" class="headerlink" title="进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用"></a>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</h3><p><img src="/posts/62544/20.png"></p><h2 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h2><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h3 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h3><p>打开统计开关</p><p><img src="/posts/62544/21.png"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="/posts/62544/22.png"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="/posts/62544/23.png"></p><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><img src="/posts/62544/24.png"></p><h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p><img src="/posts/62544/25.png"></p><p>页面效果</p><p><img src="/posts/62544/26.png"></p><h1 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h1><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h2 id="启用评论插件"><a href="#启用评论插件" class="headerlink" title="启用评论插件"></a>启用评论插件</h2><p><img src="/posts/62544/27.png"></p><h2 id="配置-LeanCloud-的-appId-和-appkey"><a href="#配置-LeanCloud-的-appId-和-appkey" class="headerlink" title="配置 LeanCloud 的 appId 和 appkey"></a>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></h2><p><img src="/posts/62544/28.png"></p><h2 id="重新部署后，查看页面效果，评论功能已开启"><a href="#重新部署后，查看页面效果，评论功能已开启" class="headerlink" title="重新部署后，查看页面效果，评论功能已开启"></a>重新部署后，查看页面效果，评论功能已开启</h2><p><img src="/posts/62544/29.png"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h1 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="1-1-安装hexo-deployer-git"><a href="#1-1-安装hexo-deployer-git" class="headerlink" title="1.1 安装hexo-deployer-git"></a>1.1 安装hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="1-2-修改根目录下的-config-yml，配置-GitHub-相关信息"><a href="#1-2-修改根目录下的-config-yml，配置-GitHub-相关信息" class="headerlink" title="1.2 修改根目录下的 _config.yml，配置 GitHub 相关信息"></a>1.2 修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><h3 id="1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图"><a href="#1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图" class="headerlink" title="1.3 其中 token 为 GitHub 的 Personal access tokens，获取方式如下图"></a>1.3 其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</h3><p><img src="/posts/62544/30.png"></p><h3 id="1-4-部署到GitHub"><a href="#1-4-部署到GitHub" class="headerlink" title="1.4 部署到GitHub"></a>1.4 部署到GitHub</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a></p><p><img src="/posts/62544/31.png"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="/posts/62544/32.png"></p><h1 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>代理</h1><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location &#x2F;blog 路径一致。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rkyao/fronted/hexo-blog<br></code></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/conf<br>vim nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">server节点下添加如下配置</span><br>location /blog &#123;<br>    alias  /opt/rkyao/fronted/hexo-blog;<br>    index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://47.96.106.173/blog/<br></code></pre></td></tr></table></figure><h1 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h1><p>可访问如下地址查看<br><a href="https://yonghengshikong.github.io/">https://yonghengshikong.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命名</title>
    <link href="/posts/16107/"/>
    <url>/posts/16107/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-创建新的博客"><a href="#1-创建新的博客" class="headerlink" title="1.创建新的博客"></a>1.创建新的博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="2-本地运行"><a href="#2-本地运行" class="headerlink" title="2.本地运行"></a>2.本地运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3.生成静态文件"></a>3.生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="4-部署到远程站点"><a href="#4-部署到远程站点" class="headerlink" title="4.部署到远程站点"></a>4.部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="5-清除本地缓存"><a href="#5-清除本地缓存" class="headerlink" title="5.清除本地缓存"></a>5.清除本地缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c<br></code></pre></td></tr></table></figure><h3 id="6-组合命令-生成且部署到远程"><a href="#6-组合命令-生成且部署到远程" class="headerlink" title="6.组合命令(生成且部署到远程)"></a>6.组合命令(生成且部署到远程)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
