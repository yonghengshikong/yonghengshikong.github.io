<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>EventEmitter</title>
    <link href="/posts/36600/"/>
    <url>/posts/36600/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><hr><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><p>你可以通过require(“events”);来访问该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 events 模块</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-comment">// 创建 eventEmitter 对象</span><br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;some_event 事件触发&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;some_event&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//event.js 文件</span><br><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener1&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listener2&#x27;</span>, arg1, arg2); <br>&#125;); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;someEvent&#x27;</span>, <span class="hljs-string">&#x27;arg1 参数&#x27;</span>, <span class="hljs-string">&#x27;arg2 参数&#x27;</span>); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node event.<span class="hljs-property">js</span> <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td align="left">2</td><td align="left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;);</code></td></tr><tr><td align="left">3</td><td align="left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once(&#39;connection&#39;, function (stream) &#123;  console.log(&#39;Ah, we have our first user!&#39;); &#125;);</code></td></tr><tr><td align="left">4</td><td align="left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log(&#39;someone connected!&#39;); &#125;; server.on(&#39;connection&#39;, callback); // ... server.removeListener(&#39;connection&#39;, callback);</code></td></tr><tr><td align="left">5</td><td align="left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td align="left">6</td><td align="left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td></tr><tr><td align="left">7</td><td align="left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td></tr><tr><td align="left">8</td><td align="left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-property">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(emitter, eventName) <span class="hljs-comment">//已废弃，不推荐</span><br>events.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(eventName) <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th align="left">序号</th><th align="left">事件 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td></tr><tr><td align="left">2</td><td align="left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><p>创建 main.js 文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 监听器 #1</span><br><span class="hljs-keyword">var</span> listener1 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener1</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener1 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 监听器 #2</span><br><span class="hljs-keyword">var</span> listener2 = <span class="hljs-keyword">function</span> <span class="hljs-title function_">listener2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听器 listener2 执行。&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener1 </span><br>eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><br><span class="hljs-comment">// 绑定 connection 事件，处理函数为 listener2</span><br>eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener2);<br><br><span class="hljs-keyword">var</span> eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-comment">// 处理 connection 事件 </span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br><span class="hljs-comment">// 移除监绑定的 listener1 函数</span><br>eventEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, listener1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;listener1 不再受监听。&quot;</span>);<br><br><span class="hljs-comment">// 触发连接事件</span><br>eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><br>eventListeners = eventEmitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;connection&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventListeners + <span class="hljs-string">&quot; 个监听器监听连接事件。&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;程序执行完毕。&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，执行结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">2</span> 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br><span class="hljs-number">1</span> 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>); <br><span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.<span class="hljs-title class_">EventEmitter</span>(); <br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-property">js</span>:<span class="hljs-number">201</span> <br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// process.nextTick error, or &#x27;error&#x27; event on first tick </span><br>^ <br><span class="hljs-title class_">Error</span>: <span class="hljs-title class_">Uncaught</span>, unspecified <span class="hljs-string">&#x27;error&#x27;</span> event. <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">emit</span> (events.<span class="hljs-property">js</span>:<span class="hljs-number">50</span>:<span class="hljs-number">15</span>) <br>at <span class="hljs-title class_">Object</span>.&lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>byvoid/error.<span class="hljs-property">js</span>:<span class="hljs-number">5</span>:<span class="hljs-number">9</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">_compile</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">441</span>:<span class="hljs-number">26</span>) <br>at <span class="hljs-title class_">Object</span>..<span class="hljs-property">js</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">459</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">Module</span>.<span class="hljs-property">load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">348</span>:<span class="hljs-number">31</span>) <br>at <span class="hljs-title class_">Function</span>.<span class="hljs-property">_load</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">308</span>:<span class="hljs-number">12</span>) <br>at <span class="hljs-title class_">Array</span><span class="hljs-number">.0</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">js</span>:<span class="hljs-number">479</span>:<span class="hljs-number">10</span>) <br>at <span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">_tickCallback</span> (node.<span class="hljs-property">js</span>:<span class="hljs-number">192</span>:<span class="hljs-number">40</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><p>为什么要这样做呢？原因有两点：</p><p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Node.js的线程机制</title>
    <link href="/posts/22142/"/>
    <url>/posts/22142/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Node-js的线程机制、事件循环与高并发处理"><a href="#深入理解Node-js的线程机制、事件循环与高并发处理" class="headerlink" title="深入理解Node.js的线程机制、事件循环与高并发处理"></a>深入理解Node.js的线程机制、事件循环与高并发处理</h1><p>Node.js因其强大的高并发处理能力而备受青睐。这一能力得益于其事件驱动的非阻塞I&#x2F;O模型和高效的事件循环机制。在这篇博客中，我们将深入探讨Node.js的线程机制、事件循环的工作流程与优先级，以及如何避免阻塞主线程的最佳实践。通过这些内容，你将更好地理解Node.js的内部运行机制，并学会如何编写高效的Node.js应用程序。</p><hr><h2 id="1-Node-js-的线程机制"><a href="#1-Node-js-的线程机制" class="headerlink" title="1. Node.js 的线程机制"></a>1. Node.js 的线程机制</h2><p>Node.js 是单线程的，但它通过多线程的方式处理高并发。JavaScript代码运行在主线程中，而Node.js使用的<a href="https://libuv.org/">libuv</a>库则提供了一个基于事件循环的异步I&#x2F;O模型，使得主线程不会因为I&#x2F;O操作而被阻塞。</p><h3 id="主线程与-libuv-线程池"><a href="#主线程与-libuv-线程池" class="headerlink" title="主线程与 libuv 线程池"></a><strong>主线程与 <a href="https://libuv.org/">libuv</a> 线程池</strong></h3><ul><li><strong>主线程</strong>：Node.js中的JavaScript代码在一个单独的主线程中运行，该线程处理所有的同步代码。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：用于处理阻塞性任务，如文件I&#x2F;O、DNS查询等，工作线程池通常包含4个线程，可以根据需要配置更多。</li></ul><p>Node.js通过将耗时的I&#x2F;O操作交给<a href="https://libuv.org/">libuv</a>线程池中的工作线程来处理，从而避免主线程被阻塞。这种设计使得Node.js可以在单线程的主线程中处理大量并发请求，而不会因为阻塞I&#x2F;O操作而降低性能。</p><h3 id="重点知识："><a href="#重点知识：" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>主线程</strong>：负责执行所有同步任务。</li><li><strong><a href="https://libuv.org/">libuv</a> 线程池</strong>：处理阻塞I&#x2F;O任务，防止主线程阻塞。</li></ul><hr><h2 id="2-Node-js-的高并发原理"><a href="#2-Node-js-的高并发原理" class="headerlink" title="2. Node.js 的高并发原理"></a>2. Node.js 的高并发原理</h2><p>Node.js的高并发处理能力主要源于其事件驱动的非阻塞I&#x2F;O模型。通过事件循环，Node.js可以在单线程环境中处理大量的并发请求。</p><h3 id="事件驱动的非阻塞I-O模型"><a href="#事件驱动的非阻塞I-O模型" class="headerlink" title="事件驱动的非阻塞I&#x2F;O模型"></a><strong>事件驱动的非阻塞I&#x2F;O模型</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：Node.js 的I&#x2F;O操作不会阻塞主线程，而是将I&#x2F;O操作委托给<a href="https://libuv.org/">libuv</a>线程池处理，主线程在I&#x2F;O操作完成之前可以继续执行其他任务。</li><li><strong>异步任务队列</strong>：异步操作的回调函数会被放入任务队列中，等待主线程空闲时由事件循环调度执行。</li></ul><p>通过这种非阻塞设计，Node.js能够高效地处理并发请求。</p><h5 id="代码示例：异步I-O操作"><a href="#代码示例：异步I-O操作" class="headerlink" title="代码示例：异步I&#x2F;O操作"></a><strong>代码示例：异步I&#x2F;O操作</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File content:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This log comes first!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>fs.readFile</code> 是一个异步操作，它会将回调函数放入任务队列中，而不会阻塞主线程。因此，<code>console.log(&#39;This log comes first!&#39;)</code> 会先于文件内容的输出执行。</p><h3 id="重点知识：-1"><a href="#重点知识：-1" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>非阻塞 I&#x2F;O</strong>：避免主线程因I&#x2F;O操作而阻塞。</li><li><strong>异步任务队列</strong>：存储需要执行的异步操作回调。</li></ul><hr><h2 id="3-事件循环的工作机制与优先级"><a href="#3-事件循环的工作机制与优先级" class="headerlink" title="3. 事件循环的工作机制与优先级"></a>3. 事件循环的工作机制与优先级</h2><p>事件循环是Node.js运行的核心机制，它决定了程序中代码的执行顺序。我们将详细剖析事件循环的工作流程及其优先级，帮助你更好地理解Node.js的并发处理。</p><h3 id="事件循环的工作流程"><a href="#事件循环的工作流程" class="headerlink" title="事件循环的工作流程"></a><strong>事件循环的工作流程</strong></h3><ol><li><strong>执行同步代码</strong>：事件循环首先执行主线程中的同步代码，这些代码会被立即执行。</li><li><strong>进入事件循环</strong>：当同步代码执行完毕后，事件循环开始检查任务队列中是否有待处理的异步回调。</li><li><strong>处理异步回调</strong>：事件循环依次从任务队列中取出回调函数并执行。</li><li><strong>循环往复</strong>：事件循环不断检查并处理任务队列中的任务，直到队列为空。</li></ol><h3 id="事件循环的优先级"><a href="#事件循环的优先级" class="headerlink" title="事件循环的优先级"></a><strong>事件循环的优先级</strong></h3><p>事件循环在执行任务时遵循一定的优先级。常见的优先级顺序如下：</p><ul><li><strong>Microtasks（微任务）</strong>：包括 <code>process.nextTick</code> 和 <code>Promise</code> 的回调。这些任务优先级最高，通常会在当前操作结束后立即执行。</li><li><strong>Timers（计时器）</strong>：如 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>I&#x2F;O callbacks</strong>：处理来自I&#x2F;O操作的回调。</li><li><strong>Check</strong>：执行 <code>setImmediate</code> 的回调函数。</li><li><strong>Close callbacks</strong>：处理 <code>close</code> 事件的回调。</li></ul><h5 id="代码示例：事件循环的优先级"><a href="#代码示例：事件循环的优先级" class="headerlink" title="代码示例：事件循环的优先级"></a><strong>代码示例：事件循环的优先级</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果可能为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Sync</span> code<br>nextTick<br><span class="hljs-title class_">Promise</span><br><span class="hljs-built_in">setTimeout</span><br>setImmediate<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;Sync code&#39;)</code> 立即执行，<code>process.nextTick</code> 和 <code>Promise</code> 回调作为微任务执行，其次是 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调。</p><h3 id="重点知识：-2"><a href="#重点知识：-2" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>事件循环阶段</strong>：不同类型的任务在事件循环中具有不同的优先级。</li><li><strong>Microtasks</strong>：优先级最高的任务，通常在当前事件循环阶段结束后立即执行。</li></ul><hr><h2 id="4-为什么先执行同步代码，再执行事件循环？"><a href="#4-为什么先执行同步代码，再执行事件循环？" class="headerlink" title="4. 为什么先执行同步代码，再执行事件循环？"></a>4. 为什么先执行同步代码，再执行事件循环？</h2><p>Node.js在执行代码时，首先会运行同步代码，这是因为同步代码通常包含程序的初始化、配置、变量定义等重要操作。如果不先执行同步代码，异步回调可能会在未准备好的上下文中被触发，导致程序行为不可预测。</p><h3 id="同步代码的定义"><a href="#同步代码的定义" class="headerlink" title="同步代码的定义"></a><strong>同步代码的定义</strong></h3><p>同步代码是指立即执行并返回结果的代码，不依赖于异步事件的完成。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is synchronous code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>同步代码执行完后，事件循环才会开始处理异步任务。</p><h5 id="代码示例：同步代码与异步代码"><a href="#代码示例：同步代码与异步代码" class="headerlink" title="代码示例：同步代码与异步代码"></a><strong>代码示例：同步代码与异步代码</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is asynchronous&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在此例中，<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 是同步代码，它们会立即执行，而 <code>setTimeout</code> 的回调则是异步代码，会在同步代码执行完毕后，由事件循环调度执行。</p><h3 id="避免将复杂任务放入主线程"><a href="#避免将复杂任务放入主线程" class="headerlink" title="避免将复杂任务放入主线程"></a><strong>避免将复杂任务放入主线程</strong></h3><p>在主线程中放入复杂的同步任务，会阻塞主线程，导致事件循环无法及时处理异步任务。为了解决这个问题，我们可以使用以下几种方法：</p><ol><li><strong>将任务拆分</strong>：将复杂的同步任务拆分为多个小任务，分批执行。</li><li>**使用 <code>setImmediate</code>**：将长时间执行的任务放入下一个事件循环阶段执行。</li><li>**使用 <code>Worker Threads</code>**：将复杂计算任务放入工作线程中执行，避免阻塞主线程。</li></ol><h5 id="代码示例：使用-setImmediate-避免阻塞"><a href="#代码示例：使用-setImmediate-避免阻塞" class="headerlink" title="代码示例：使用 setImmediate 避免阻塞"></a><strong>代码示例：使用 <code>setImmediate</code> 避免阻塞</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">complexTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task Done:&#x27;</span>, count);<br>&#125;<br><br><span class="hljs-title function_">setImmediate</span>(complexTask);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will log before complexTask finishes&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>complexTask</code> 是一个可能会阻塞主线程的复杂任务。通过使用 <code>setImmediate</code>，我们可以将其延迟到当前事件循环阶段结束后再执行，从而避免阻塞其他重要的任务。</p><h5 id="使用-Worker-Threads-进行并行计算"><a href="#使用-Worker-Threads-进行并行计算" class="headerlink" title="使用 Worker Threads 进行并行计算"></a><strong>使用 <code>Worker Threads</code> 进行并行计算</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from worker:&#x27;</span>, message));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>    count += i;<br>  &#125;<br>  parentPort.<span class="hljs-title function_">postMessage</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，复杂的计算任务被移至工作线程中执行，不再阻塞主线程。这使得主线程可以继续处理其他任务，而不会受到复杂计算的影响。</p><h3 id="重点知识：-3"><a href="#重点知识：-3" class="headerlink" title="重点知识："></a><strong>重点知识：</strong></h3><ul><li><strong>避免主线程阻塞</strong>：将复杂任务分拆或延迟执行，避免阻塞事件循环。</li><li><strong>Worker Threads</strong>：用于处理计算密集型任务，减少主线程压力。</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对Node.js线程机制、事件循环与高并发处理的深入探讨，我们了解到如何编写高效的Node.js应用程序。理解事件循环的工作原理和优先级，可以帮助我们更好地管理异步任务的执行顺序，避免主线程被阻塞。同时，采用合理的技术，如 <code>Worker Threads</code> 和 <code>setImmediate</code>，能够有效地提升程序性能，确保高并发环境下的稳定性。</p><hr><p>这篇博客详细解释了Node.js的线程机制及事件循环，并提供了避免主线程阻塞的实际解决方案。希望这些内容对你理解和优化Node.js应用程序有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>NodeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的回收机制</title>
    <link href="/posts/580/"/>
    <url>/posts/580/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-的垃圾回收机制"><a href="#一、JavaScript-的垃圾回收机制" class="headerlink" title="一、JavaScript 的垃圾回收机制"></a>一、JavaScript 的垃圾回收机制</h1><p>JavaScript 的垃圾回收机制主要依赖于一种称为 <strong>“标记-清除”（Mark-and-Sweep）</strong> 的算法。垃圾回收（Garbage Collection, GC）负责自动管理内存，回收不再使用的对象所占用的内存，以防止内存泄漏。</p><h3 id="垃圾回收的工作原理"><a href="#垃圾回收的工作原理" class="headerlink" title="垃圾回收的工作原理"></a>垃圾回收的工作原理</h3><ol><li><strong>标记阶段（Marking Phase）</strong>:<ul><li>垃圾回收器会在内存中“标记”所有活动的、可到达的对象。所谓“可到达”是指对象可以通过根（通常是全局变量或当前作用域中的变量）直接或间接访问到。</li><li>垃圾回收器从根开始，递归地遍历所有引用的对象，并标记这些对象为“活动的”。</li></ul></li><li><strong>清除阶段（Sweeping Phase）</strong>:<ul><li>在标记阶段结束后，垃圾回收器会遍历内存中的所有对象，清除没有被标记的对象（即那些不可到达的对象）。</li><li>清除后，这些对象所占用的内存将被回收并重新分配。</li></ul></li></ol><h3 id="触发垃圾回收的条件"><a href="#触发垃圾回收的条件" class="headerlink" title="触发垃圾回收的条件"></a>触发垃圾回收的条件</h3><ul><li>JavaScript 引擎的垃圾回收器在运行时会周期性地执行垃圾回收，以回收不再使用的内存。</li><li>垃圾回收器的执行是非确定性的，这意味着你不能确切知道何时会触发垃圾回收。通常是在内存分配请求达到一定阈值或空闲时执行。</li></ul><h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><ol><li><p><strong>内存泄漏</strong>: 当程序中不再需要的对象无法被垃圾回收器清除时，内存泄漏就会发生，导致内存使用量持续增长。</p><ul><li><p><strong>未解除的事件监听器</strong>: 如果在不再需要时没有手动移除事件监听器，监听器中对对象的引用将导致这些对象无法被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachEventListener</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element clicked!&#x27;</span>);<br>    &#125;<br><br>    element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br><br>    <span class="hljs-comment">// 模拟在元素销毁时忘记移除监听器</span><br>    <span class="hljs-comment">// element.removeEventListener(&#x27;click&#x27;, handleClick);</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数后，element和handleClick函数依然存在引用，导致element不能被回收。</span><br><span class="hljs-title function_">attachEventListener</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p><strong>事件监听器的引用</strong>：</p><ul><li>当你调用 <code>element.addEventListener(&#39;click&#39;, handleClick)</code> 时，浏览器内部实际上在 <code>element</code> 对象的某个地方（通常是在它的事件监听器列表中）保存了对 <code>handleClick</code> 函数的引用。这意味着 <code>element</code> 本身还存活在内存中，因为它的事件监听器依然在引用它。</li></ul><p><strong>引用链的存在</strong>：</p><ul><li>尽管 <code>element</code> 是一个局部变量，函数 <code>attachEventListener</code> 执行完后不会直接持有对它的引用，但是因为事件监听器 (<code>handleClick</code>) 被添加到了 <code>element</code> 上，<code>element</code> 对象内部保存了对 <code>handleClick</code> 的引用。</li><li>反过来，因为 <code>handleClick</code> 函数是在 <code>attachEventListener</code> 内部定义的，它对定义该函数的外部作用域有引用链，因此，这种引用链会一直存在，直到 <code>element</code> 被手动移除事件监听器或者 <code>element</code> 本身被彻底销毁。</li></ul><p><strong>内存泄漏的来源</strong>：</p><ul><li>如果 <code>element</code> 被从 DOM 中移除（比如被 <code>document.removeChild</code>），但没有调用 <code>element.removeEventListener(&#39;click&#39;, handleClick)</code>，<code>element</code> 仍然不能被垃圾回收，因为它的事件监听器中仍然持有对 <code>handleClick</code> 的引用。</li><li>因为 <code>handleClick</code> 还在 <code>element</code> 的事件监听列表中，JavaScript 引擎会认为 <code>element</code> 还可能被使用，因此不会回收 <code>element</code> 或其关联的内存。</li></ul><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​在不再需要时调用 <code>removeEventListener</code> 来移除事件监听器。</p></li><li><p><strong>闭包导致的引用</strong>: 闭包中保存的变量会保持对外部作用域中对象的引用，可能导致无法回收这些对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 返回的 innerFunction 持有对 largeObject 的引用，即使 largeObject 在函数作用域外部已经不需要。</span><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// closure 的引用存在，导致 largeObject 无法被垃圾回收。</span><br><span class="hljs-title function_">closure</span>();<br><br></code></pre></td></tr></table></figure><h6 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h6><p>在 JavaScript 中，闭包中的引用指向其创建时的环境（即作用域链上的上级）。具体来说：</p><ul><li>当 <code>createClosure</code> 函数执行时，它创建了一个作用域，该作用域中包含 <code>largeObject</code>。</li><li><code>innerFunction</code> 被返回，并且它在其创建时保留了对 <code>largeObject</code> 的引用。</li><li><code>largeObject</code> 的引用存在于 <code>innerFunction</code> 的闭包环境中。</li></ul><p>因此，<code>innerFunction</code> 的作用域链包括 <code>largeObject</code> 所在的作用域。即使 <code>createClosure</code> 执行完毕并退出，<code>innerFunction</code> 仍然能访问 <code>largeObject</code>。</p><p><span style="color: red;"><em><strong>总的来说，如果closure没被销毁那么闭包中的数据会一直存在，所以尽量避免闭包被全局变量所持有，且尽量避免闭包引用大的数据结构，这样会比较消耗内存</strong></em></span></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​要释放 <code>largeObject</code> 的引用，可以在不再需要 <code>innerFunction</code> 时清除对 <code>largeObject</code> 的引用。在这种情况下，确保在 <code>innerFunction</code> 不再使用 <code>largeObject</code> 后，手动清理引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> largeObject = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;some large data&#x27;</span>) &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(largeObject.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在此处进行逻辑处理</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();<br><br><span class="hljs-comment">// 使用完闭包后，手动设置 largeObject 为 null</span><br><span class="hljs-comment">// 这是实际清理引用的地方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 可以设置 closure 为 null 或 undefined</span><br>    closure = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用 releaseClosure 释放对 largeObject 的引用</span><br><span class="hljs-title function_">releaseClosure</span>();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>: 全局变量在整个程序生命周期中都存在，会阻止其被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVariable = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;I&#x27;m a global variable&quot;</span> &#125;;<br><br><span class="hljs-comment">// 全局变量在程序结束前一直存在，无法回收。</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>未清理的定时器</strong>: 忘记清除不再需要的 <code>setInterval</code> 或 <code>setTimeout</code>，可能导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 设置一个定时器，每秒执行一次</span><br>    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 模拟元素销毁时忘记清除定时器</span><br>    <span class="hljs-comment">// clearInterval(intervalId);</span><br>&#125;<br><br><span class="hljs-comment">// 调用后，即使 element 被移除，intervalId 依然存在，导致内存泄漏。</span><br><span class="hljs-title function_">startTimer</span>();<br><br></code></pre></td></tr></table></figure><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><p>​ 在不再需要定时器时调用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存管理不善</strong>: 虽然 JavaScript 有自动垃圾回收，但开发者仍需注意合理使用内存。例如，避免创建大量不必要的对象或保留不必要的引用。</p></li></ol><h3 id="现代-JavaScript-引擎的优化"><a href="#现代-JavaScript-引擎的优化" class="headerlink" title="现代 JavaScript 引擎的优化"></a>现代 JavaScript 引擎的优化</h3><p>除了基本的标记-清除算法，现代 JavaScript 引擎（如 V8）通常还使用一些优化技术，如：</p><ul><li><strong>增量标记（Incremental Marking）</strong>: 将标记阶段拆分为多个小步骤，避免长时间的卡顿。</li><li><strong>世代回收（Generational Garbage Collection）</strong>: 将内存划分为“新生代”和“老生代”两个区域，短命对象会快速回收，长命对象则被移至老生代以减少处理频率。</li><li><strong>惰性清理（Lazy Cleanup）</strong>: 仅在需要时才清理内存，以进一步减少不必要的垃圾回收操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据hexo创建个人博客</title>
    <link href="/posts/62544/"/>
    <url>/posts/62544/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h2><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p><h2 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h2><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p><h1 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="/posts/62544/1.png"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="/posts/62544/2.png"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="/posts/62544/3.png"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/posts/62544/4.png"></p><p>浏览器中访问，展示成功。</p><p><img src="/posts/62544/5.png"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="/posts/62544/6.png"></p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。个人比较喜欢<code>Fluid</code>。</p><h2 id="1-Fluid主题"><a href="#1-Fluid主题" class="headerlink" title="1.Fluid主题"></a>1.Fluid主题</h2><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 <strong>安装主题</strong></h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h3 id="1-2-指定主题"><a href="#1-2-指定主题" class="headerlink" title="1.2 指定主题"></a>1.2 <strong>指定主题</strong></h3><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="1-3-创建「关于页」"><a href="#1-3-创建「关于页」" class="headerlink" title="1.3 创建「关于页」"></a>1.3 <strong>创建「关于页」</strong></h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br><br></code></pre></td></tr></table></figure><h3 id="1-4-本地启动"><a href="#1-4-本地启动" class="headerlink" title="1.4 本地启动**"></a>1.4 本地启动**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下">http://localhost:4000，`Fluid`主题风格页面如下</a></p><p><img src="/posts/62544/7.png"></p><h1 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h1><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><h2 id="1-添加hexo-asset-image插件"><a href="#1-添加hexo-asset-image插件" class="headerlink" title="1.添加hexo-asset-image插件"></a>1.添加hexo-asset-image插件</h2><p>为什么需要这么插件呢？</p><p>因为我们虽然在source_posts文件夹下写了md文件，也有了图片资源文件夹存了图片，但实际上md文件中的图片路径都是相对路径（.&#x2F;${filename}）。而实际网上看到的博文显然不是md文件，而是html文件，从md到html的转变就是hexo帮我们做的，还记得hexo g命令吗？就是干这个的。转换后的html文件在public目录下，路径是通过日期指示的。</p><p>hexo-asset-image插件的作用就是为图片资源默认追加上时间路径前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这里不要用</p><p><img src="/posts/62544/8.png"></p><h2 id="2-修改-Hexo-博客目录中的-config-yml"><a href="#2-修改-Hexo-博客目录中的-config-yml" class="headerlink" title="2.修改 Hexo 博客目录中的 _config.yml"></a>2.修改 Hexo 博客目录中的 <code>_config.yml</code></h2><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="/posts/62544/9.png"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="/posts/62544/10.png"></p><p>在测试文章.md中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在\source\images目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 测试文章<br>date: 2021-06-10 16:35:20<br>tags:<br><span class="hljs-bullet">-</span> 原创<br>categories:<br><span class="hljs-section">- Java</span><br><span class="hljs-section">---</span><br><br>这是一篇测试文章<br><br>![<span class="hljs-string">图片引用方一</span>](<span class="hljs-link">测试文章/test.png</span>)<br><br>![<span class="hljs-string">图片引用方法二</span>](<span class="hljs-link">test.png</span>)<br><br>![<span class="hljs-string">图片引用方法三</span>](<span class="hljs-link">/images/test.png</span>)<br><br></code></pre></td></tr></table></figure><h2 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3.本地启动"></a>3.<strong>本地启动</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面如下，文章添加成功">http://localhost:4000，页面如下，文章添加成功</a></p><p><img src="/posts/62544/11.png"></p><h1 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h1><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h2 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h2><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="/posts/62544/12.png"></p><h2 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2.博客标题"></a>2.博客标题</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="/posts/62544/13.png"></p><h2 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h2><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="/posts/62544/14.png"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="/posts/62544/15.png"></p><h1 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h1><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h2 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h2><h3 id="进入-官网-注册账号"><a href="#进入-官网-注册账号" class="headerlink" title="进入 官网 注册账号"></a>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</h3><p><img src="/posts/62544/16.png"></p><h3 id="需实名认证，完成后才能使用各项服务"><a href="#需实名认证，完成后才能使用各项服务" class="headerlink" title="需实名认证，完成后才能使用各项服务"></a>需实名认证，完成后才能使用各项服务</h3><p><img src="/posts/62544/17.png"></p><p>验证邮箱</p><p><img src="/posts/62544/18.png"></p><h3 id="创建应用，选择开发版即可，免费的"><a href="#创建应用，选择开发版即可，免费的" class="headerlink" title="创建应用，选择开发版即可，免费的"></a>创建应用，选择<code>开发版</code>即可，免费的</h3><p><img src="/posts/62544/19.png"></p><h3 id="进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用"><a href="#进入该应用的-设置-应用凭证，找到-AppID-和-AppKey，记录下来后面配置要用" class="headerlink" title="进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用"></a>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</h3><p><img src="/posts/62544/20.png"></p><h2 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h2><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h3 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h3><p>打开统计开关</p><p><img src="/posts/62544/21.png"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="/posts/62544/22.png"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="/posts/62544/23.png"></p><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><img src="/posts/62544/24.png"></p><h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p><img src="/posts/62544/25.png"></p><p>页面效果</p><p><img src="/posts/62544/26.png"></p><h1 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h1><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h2 id="启用评论插件"><a href="#启用评论插件" class="headerlink" title="启用评论插件"></a>启用评论插件</h2><p><img src="/posts/62544/27.png"></p><h2 id="配置-LeanCloud-的-appId-和-appkey"><a href="#配置-LeanCloud-的-appId-和-appkey" class="headerlink" title="配置 LeanCloud 的 appId 和 appkey"></a>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></h2><p><img src="/posts/62544/28.png"></p><h2 id="重新部署后，查看页面效果，评论功能已开启"><a href="#重新部署后，查看页面效果，评论功能已开启" class="headerlink" title="重新部署后，查看页面效果，评论功能已开启"></a>重新部署后，查看页面效果，评论功能已开启</h2><p><img src="/posts/62544/29.png"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h1 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="1-1-安装hexo-deployer-git"><a href="#1-1-安装hexo-deployer-git" class="headerlink" title="1.1 安装hexo-deployer-git"></a>1.1 安装hexo-deployer-git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="1-2-修改根目录下的-config-yml，配置-GitHub-相关信息"><a href="#1-2-修改根目录下的-config-yml，配置-GitHub-相关信息" class="headerlink" title="1.2 修改根目录下的 _config.yml，配置 GitHub 相关信息"></a>1.2 修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><h3 id="1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图"><a href="#1-3-其中-token-为-GitHub-的-Personal-access-tokens，获取方式如下图" class="headerlink" title="1.3 其中 token 为 GitHub 的 Personal access tokens，获取方式如下图"></a>1.3 其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</h3><p><img src="/posts/62544/30.png"></p><h3 id="1-4-部署到GitHub"><a href="#1-4-部署到GitHub" class="headerlink" title="1.4 部署到GitHub"></a>1.4 部署到GitHub</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a></p><p><img src="/posts/62544/31.png"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="/posts/62544/32.png"></p><h1 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>代理</h1><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location &#x2F;blog 路径一致。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rkyao/fronted/hexo-blog<br></code></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/conf<br>vim nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">server节点下添加如下配置</span><br>location /blog &#123;<br>    alias  /opt/rkyao/fronted/hexo-blog;<br>    index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://47.96.106.173/blog/<br></code></pre></td></tr></table></figure><h1 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h1><p>可访问如下地址查看<br><a href="https://yonghengshikong.github.io/">https://yonghengshikong.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/16107/"/>
    <url>/posts/16107/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
